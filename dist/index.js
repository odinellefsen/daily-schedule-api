// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// node_modules/zod/dist/esm/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var init_util = __esm(() => {
  (function(util2) {
    util2.assertEqual = (_) => {};
    function assertIs(_arg) {}
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error;
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
      };
    };
  })(objectUtil || (objectUtil = {}));
  ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
});

// node_modules/zod/dist/esm/v3/ZodError.js
var ZodIssueCode, quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
}, ZodError;
var init_ZodError = __esm(() => {
  init_util();
  ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  ZodError = class ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
});

// node_modules/zod/dist/esm/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
}, en_default;
var init_en = __esm(() => {
  init_ZodError();
  init_util();
  en_default = errorMap;
});

// node_modules/zod/dist/esm/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm(() => {
  init_en();
  overrideErrorMap = en_default;
});

// node_modules/zod/dist/esm/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
}, EMPTY_PATH, INVALID, DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var init_parseUtil = __esm(() => {
  init_errors();
  init_en();
  EMPTY_PATH = [];
  INVALID = Object.freeze({
    status: "aborted"
  });
});

// node_modules/zod/dist/esm/v3/helpers/typeAliases.js
var init_typeAliases = () => {};

// node_modules/zod/dist/esm/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm(() => {
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));
});

// node_modules/zod/dist/esm/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
}, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
}, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params), stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce, NEVER;
var init_types = __esm(() => {
  init_ZodError();
  init_errors();
  init_errorUtil();
  init_parseUtil();
  init_util();
  cuidRegex = /^c[^\s-]{8,}$/i;
  cuid2Regex = /^[0-9a-z]+$/;
  ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  nanoidRegex = /^[a-z0-9_-]{21}$/i;
  jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  dateRegex = new RegExp(`^${dateRegexSource}$`);
  ZodString = class ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodNumber = class ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodBigInt = class ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = undefined;
      const status = new ParseStatus;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  ZodBoolean = class ZodBoolean extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  ZodDate = class ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus;
      let ctx = undefined;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  ZodSymbol = class ZodSymbol extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  ZodUndefined = class ZodUndefined extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  ZodNull = class ZodNull extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  ZodAny = class ZodAny extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  ZodUnknown = class ZodUnknown extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  ZodNever = class ZodNever extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  ZodVoid = class ZodVoid extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  ZodArray = class ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : undefined,
            maximum: tooBig ? def.exactLength.value : undefined,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  ZodObject = class ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {} else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== undefined ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    extend(augmentation) {
      return new ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    merge(merging) {
      const merged = new ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    catchall(index) {
      return new ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodUnion = class ZodUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = undefined;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  ZodDiscriminatedUnion = class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    static create(discriminator, options, params) {
      const optionsMap = new Map;
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  ZodIntersection = class ZodIntersection extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  ZodTuple = class ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  ZodRecord = class ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  ZodMap = class ZodMap extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = new Map;
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = new Map;
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  ZodSet = class ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = new Set;
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  ZodFunction = class ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  ZodLazy = class ZodLazy extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  ZodLiteral = class ZodLiteral extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  ZodEnum = class ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  ZodNativeEnum = class ZodNativeEnum extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  ZodPromise = class ZodPromise extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  ZodEffects = class ZodEffects extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  ZodOptional = class ZodOptional extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(undefined);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  ZodNullable = class ZodNullable extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  ZodDefault = class ZodDefault extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  ZodCatch = class ZodCatch extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  ZodNaN = class ZodNaN extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  BRAND = Symbol("zod_brand");
  ZodBranded = class ZodBranded extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  ZodPipeline = class ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  ZodReadonly = class ZodReadonly extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  late = {
    object: ZodObject.lazycreate
  };
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  stringType = ZodString.create;
  numberType = ZodNumber.create;
  nanType = ZodNaN.create;
  bigIntType = ZodBigInt.create;
  booleanType = ZodBoolean.create;
  dateType = ZodDate.create;
  symbolType = ZodSymbol.create;
  undefinedType = ZodUndefined.create;
  nullType = ZodNull.create;
  anyType = ZodAny.create;
  unknownType = ZodUnknown.create;
  neverType = ZodNever.create;
  voidType = ZodVoid.create;
  arrayType = ZodArray.create;
  objectType = ZodObject.create;
  strictObjectType = ZodObject.strictCreate;
  unionType = ZodUnion.create;
  discriminatedUnionType = ZodDiscriminatedUnion.create;
  intersectionType = ZodIntersection.create;
  tupleType = ZodTuple.create;
  recordType = ZodRecord.create;
  mapType = ZodMap.create;
  setType = ZodSet.create;
  functionType = ZodFunction.create;
  lazyType = ZodLazy.create;
  literalType = ZodLiteral.create;
  enumType = ZodEnum.create;
  nativeEnumType = ZodNativeEnum.create;
  promiseType = ZodPromise.create;
  effectsType = ZodEffects.create;
  optionalType = ZodOptional.create;
  nullableType = ZodNullable.create;
  preprocessType = ZodEffects.createWithPreprocess;
  pipelineType = ZodPipeline.create;
  coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  NEVER = INVALID;
});

// node_modules/zod/dist/esm/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});
var init_external = __esm(() => {
  init_errors();
  init_parseUtil();
  init_typeAliases();
  init_util();
  init_types();
  init_ZodError();
});

// node_modules/zod/dist/esm/v3/index.js
var init_v3 = __esm(() => {
  init_external();
  init_external();
});

// node_modules/zod/dist/esm/index.js
var init_esm = __esm(() => {
  init_v3();
});

// node_modules/cookie/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse3;
  exports.serialize = serialize2;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
  })();
  function parse3(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize2(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform) {
    return new ArrayParser(source, transform).parse();
  };

  class ArrayParser {
    constructor(source, transform) {
      this.source = source;
      this.transform = transform || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char2 = this.nextCharacter();
          if (char2.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array = require_postgres_array();
  module.exports = {
    create: function(source, transform) {
      return {
        parse: function() {
          return array.parse(source, transform);
        }
      };
    }
  };
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date2;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date2 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date2.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date2.setTime(date2.getTime() - offset);
      }
    } else {
      date2 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date2.setFullYear(year);
      }
    }
    return date2;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date2 = new Date(year, month, day);
    if (is0To99(year)) {
      date2.setFullYear(year);
    }
    return date2;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw2) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw2);
    }
    extend(this, parse4(raw2));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse4(interval2) {
    if (!interval2)
      return {};
    var matches = INTERVAL.exec(interval2);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point2 = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value.length - 1; i++) {
      if (!pointParsed) {
        point2 += value[i];
      }
      if (value[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i] === ",") {
        continue;
      }
      radius += value[i];
    }
    var result = parsePoint(point2);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse4 = function(dimension, elementType2) {
      var array = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array[i2] = parse4(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array[i2] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse4(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var defaults = require_defaults();
  var util3 = __require("util");
  var { isDate } = util3.types || util3;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date2) {
    let offset = -date2.getTimezoneOffset();
    let year = date2.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date2.getMonth() + 1).padStart(2, "0") + "-" + String(date2.getDate()).padStart(2, "0") + "T" + String(date2.getHours()).padStart(2, "0") + ":" + String(date2.getMinutes()).padStart(2, "0") + ":" + String(date2.getSeconds()).padStart(2, "0") + "." + String(date2.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date2) {
    let year = date2.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date2.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date2.getUTCDate()).padStart(2, "0") + "T" + String(date2.getUTCHours()).padStart(2, "0") + ":" + String(date2.getUTCMinutes()).padStart(2, "0") + ":" + String(date2.getUTCSeconds()).padStart(2, "0") + "." + String(date2.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values) {
      if (typeof values === "function") {
        config.callback = values;
      } else {
        config.values = values;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha2562(text2) {
    return nodeCrypto.createHash("sha256").update(text2).digest();
  }
  function hashByName(hashName, text2) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text2).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256: sha2562,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha2562(text2) {
    return await subtleCrypto.digest("SHA-256", text2);
  }
  async function hashByName(hashName, text2) {
    return await subtleCrypto.digest(hashName, text2);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto2 = require_utils2();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto2.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto2.sha256(clientKey);
    const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text2.split("").map((_, i) => text2.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text2);
  }
  function parseAttributePairs(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text2.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types2 = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types2;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse4(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err) {
      err.input && (err.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config.sslrootcert) {
            config.ssl.checkServerIdentity = function() {};
          } else {
            config.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse4(str));
  }
  module.exports = parse4;
  parse4.parse = parse4;
  parse4.toClientConfig = toClientConfig;
  parse4.parseIntoClientConfig = parseIntoClientConfig;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults();
  var parse4 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    const value = config[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse4(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse4(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types2 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types3) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types3;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match2;
      if (msg.text) {
        match2 = matchRegexp.exec(msg.text);
      } else {
        match2 = matchRegexp.exec(msg.command);
      }
      if (match2) {
        this.command = match2[1];
        if (match2[3]) {
          this.oid = parseInt(match2[2], 10);
          this.rowCount = parseInt(match2[3], 10);
        } else if (match2[2]) {
          this.rowCount = parseInt(match2[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc2 = fieldDescriptions[i];
        row[desc2.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        } else {
          this._parsers[i] = types2.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events");
  var Result = require_result();
  var utils = require_utils();

  class Query extends EventEmitter {
    constructor(config, values, callback) {
      super();
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text2) {
      this.length = length;
      this.text = text2;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text2) => {
    return writer.addCString(text2).flush(81);
  };
  var emptyArray = [];
  var parse4 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types2 = query2.types || emptyArray;
    const len = types2.length;
    const buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types2[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text2 = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text2);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize2 = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse4,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize2;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text2 = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text2);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse4(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  }
  exports.parse = parse4;
});

// node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var { parse: parse4, serialize: serialize2 } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize2.flush();
  var syncBuffer = serialize2.sync();
  var endBuffer = serialize2.end();

  class Connection extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self._keepAlive) {
          self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
        }
        self.emit("connect");
      });
      const reportStreamError = function(error2) {
        if (self._ending && (error2.code === "ECONNRESET" || error2.code === "EPIPE")) {
          return;
        }
        self.emit("error", error2);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self.stream.end();
            return self.emit("error", new Error("The server does not support SSL connections"));
          default:
            self.stream.end();
            return self.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self.stream
        };
        if (self.ssl !== true) {
          Object.assign(options, self.ssl);
          if ("key" in self.ssl) {
            options.key = self.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self.stream = getSecureStream(options);
        } catch (err) {
          return self.emit("error", err);
        }
        self.attachListeners(self.stream);
        self.stream.on("error", reportStreamError);
        self.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse4(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize2.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize2.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize2.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize2.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text2) {
      this._send(serialize2.query(text2));
    }
    parse(query) {
      this._send(serialize2.parse(query));
    }
    bind(config) {
      this._send(serialize2.bind(config));
    }
    execute(config) {
      this._send(serialize2.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize2.close(msg));
    }
    describe(msg) {
      this._send(serialize2.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize2.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize2.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize2.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error2) {
        return cb(error2);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error2) {
        return cb(error2);
      }
    }
    cb();
  }
  function push(self, val) {
    if (val !== undefined) {
      self.push(val);
    }
  }
  function noop(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  }
  module.exports = split;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util3 = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util3.format.apply(util3, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env = rawEnv || process.env;
    var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line2) {
      var entry = parseLine(line2);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line2) {
    if (line2.length < 11 || line2.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line2.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line2.length - 1; i += 1) {
      curChar = line2.charAt(i + 1);
      prevChar = line2.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var utils = require_utils();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils2();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self.ssl) {
          con.requestSsl();
        } else {
          con.startup(self.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error2);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error2);
            } else {
              this._handleErrorEvent(error2);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error2);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error2) => {
          if (error2) {
            reject(error2);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error2 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error2, this.connection);
          });
          queryCallback(error2);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise2(function(resolve, reject) {
      res = resolve;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text2, values, cb) {
      if (typeof text2 === "function") {
        const response2 = promisify(this.Promise, text2);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text2, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events").EventEmitter;
  var util3 = __require("util");
  var utils = require_utils();
  var NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter.call(this);
    config = utils.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util3.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject) {
      this._once("end", resolve);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self.emit("_done");
      });
      if (err) {
        return self.handleError(err);
      }
      if (self._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self.emit("row", row, results);
          });
        }
      }
      self.state = "end";
      self.emit("end", results);
      if (self.callback) {
        self.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self.name] = self.text;
        return self.native.execute(self.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = __require("events").EventEmitter;
  var util3 = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util3.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self.connectionParameters.nativeConnectionString)
        conString = self.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self.native.connect(conString, function(err2) {
        if (err2) {
          self.native.end();
          return cb(err2);
        }
        self._connected = true;
        self.native.on("error", function(err3) {
          self._queryable = false;
          self._errorAllQueries(err3);
          self.emit("error", err3);
        });
        self.native.on("notification", function(msg) {
          self.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self.emit("connect");
        self._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject) => {
      this._connect((error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query = config;
      if (typeof values === "function") {
        config.callback = values;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject) => {
          resolveOut = resolve;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error2 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error2, this.connection);
        });
        queryCallback(error2);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject) {
        cb = (err) => err ? reject(err) : resolve();
      });
    }
    this.native.end(function() {
      self._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self = this;
    query.once("_done", function() {
      self._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/@flowcore/pathways/esm/common/flowcore.type.js
var init_flowcore_type = () => {};

// node_modules/@flowcore/pathways/esm/common/index.js
var init_common = __esm(() => {
  init_flowcore_type();
});

// node_modules/@flowcore/pathways/esm/contracts/event.js
var init_event = () => {};

// node_modules/@flowcore/pathways/esm/contracts/index.js
var init_contracts = __esm(() => {
  init_event();
});

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});
// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    writeChunk(target, chunk) {
      const written = Math.min(chunk.length, target.length);
      target.set(chunk.subarray(0, written));
      if (written < chunk.length) {
        this.buffer = chunk.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    async readFromStream(buffer, mayBeLess) {
      if (buffer.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer, this.buffer);
      }
      while (totalBytesRead < buffer.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error2) {
    if (error2 instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error2;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length) {
      const bufSize = Math.min(maxBufferSize, length);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length) {
        const remaining = length - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}

class StringType {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
    this.textDecoder = new TextDecoder(encoding);
  }
  get(uint8Array, offset) {
    return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib2 = __esm(() => {
  init_ieee754();
  UINT8 = {
    len: 1,
    get(array, offset) {
      return dv(array).getUint8(offset);
    },
    put(array, offset, value) {
      dv(array).setUint8(offset, value);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array, offset) {
      return dv(array).getUint16(offset);
    },
    put(array, offset, value) {
      dv(array).setUint16(offset, value);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset, true);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getUint32(offset);
    },
    put(array, offset, value) {
      dv(array).setUint32(offset, value);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array, offset) {
      return dv(array).getInt32(offset);
    },
    put(array, offset, value) {
      dv(array).setInt32(offset, value);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array, offset) {
      return dv(array).getBigUint64(offset, true);
    },
    put(array, offset, value) {
      dv(array).setBigUint64(offset, value, true);
      return offset + 8;
    }
  };
});

// node_modules/fflate/esm/index.mjs
import { createRequire } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max2 = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max2(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt2 = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max2(lt2);
        dbt = max2(dt);
        lm = hMap(lt2, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm2 = __esm(() => {
  require2 = createRequire("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {}
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {}
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
          if (match2 === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match2 = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error2) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var os = __require("os");
  var tty = __require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty");
  var util3 = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util3.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
    }
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib2();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        compressedSize: UINT32_LE.get(array, 8),
        uncompressedSize: UINT32_LE.get(array, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array) {
      const flags = UINT16_LE.get(array, 6);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 8),
        compressedSize: UINT32_LE.get(array, 18),
        uncompressedSize: UINT32_LE.get(array, 22),
        filenameLength: UINT16_LE.get(array, 26),
        extraFieldLength: UINT16_LE.get(array, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array) {
      return {
        signature: UINT32_LE.get(array, 0),
        nrOfThisDisk: UINT16_LE.get(array, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array, 10),
        sizeOfCd: UINT32_LE.get(array, 12),
        offsetOfStartOfCd: UINT32_LE.get(array, 16),
        zipFileCommentLength: UINT16_LE.get(array, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array) {
      const flags = UINT16_LE.get(array, 8);
      return {
        signature: UINT32_LE.get(array, 0),
        minVersion: UINT16_LE.get(array, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array, 10),
        compressedSize: UINT32_LE.get(array, 20),
        uncompressedSize: UINT32_LE.get(array, 24),
        filenameLength: UINT16_LE.get(array, 28),
        extraFieldLength: UINT16_LE.get(array, 30),
        fileCommentLength: UINT16_LE.get(array, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i2 = buffer.length - 4;i2 >= 0; i2--) {
      if (buffer[i2] === eocdSignatureBytes[0] && buffer[i2 + 1] === eocdSignatureBytes[1] && buffer[i2 + 2] === eocdSignatureBytes[2] && buffer[i2 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i2;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i2 = 0;i2 <= bufferLength - portionLength; i2++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i2 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i2;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib3 = __esm(() => {
  init_lib2();
  init_esm2();
  init_ZipToken();
  import_debug = __toESM(require_src(), 1);
  debug = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util2 = __esm(() => {
  init_lib2();
  uint32SyncSafeToken = {
    get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error2) {
          if (!(error2 instanceof EndOfStreamError)) {
            throw error2;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version2 = new StringType(4, "latin1").get(this.buffer, 2);
      if (version2.match("^d*") && version2 >= 1000 && version2 <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json2 = JSON.parse(header);
          if (json2.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {}
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version2 === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version2 === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib2();
  init_core();
  init_lib3();
  init_uint8array_extras();
  init_util2();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isFunction = undefined;
  function isFunction(value) {
    return typeof value === "function";
  }
  exports.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createErrorClass = undefined;
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  exports.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors2) {
      _super(this);
      this.message = errors2 ? errors2.length + ` errors occurred during unsubscription:
` + errors2.map(function(err2, i2) {
        return i2 + 1 + ") " + err2.toString();
      }).join(`
  `) : "";
      this.name = "UnsubscriptionError";
      this.errors = errors2;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.arrRemove = undefined;
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  exports.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = undefined;
  var isFunction_1 = require_isFunction();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a2, e_2, _b2;
      var errors2;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                  _a2.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors2 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err2) {
                errors2 = errors2 !== null && errors2 !== undefined ? errors2 : [];
                if (err2 instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err2.errors));
                } else {
                  errors2.push(err2);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return))
                _b2.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors2);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a2;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== undefined ? _a2 : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports.Subscription = Subscription;
  exports.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  }
  exports.isSubscription = isSubscription;
  function execFinalizer(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.config = undefined;
  exports.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutProvider = undefined;
  exports.timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  function reportUnhandledError(err2) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err2);
      } else {
        throw err2;
      }
    });
  }
  exports.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = undefined;
  function noop() {}
  exports.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = undefined;
  exports.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  function errorNotification(error2) {
    return createNotification("E", undefined, error2);
  }
  exports.errorNotification = errorNotification;
  function nextNotification(value) {
    return createNotification("N", value, undefined);
  }
  exports.nextNotification = nextNotification;
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }
  exports.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.captureError = exports.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  function errorContext(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a2 = context, errorThrown = _a2.errorThrown, error2 = _a2.error;
        context = null;
        if (errorThrown) {
          throw error2;
        }
      }
    } else {
      cb();
    }
  }
  exports.errorContext = errorContext;
  function captureError(err2) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err2;
    }
  }
  exports.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = undefined;
  var isFunction_1 = require_isFunction();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error2, complete) {
      return new SafeSubscriber(next, error2, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err2) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err2), this);
      } else {
        this.isStopped = true;
        this._error(err2);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err2) {
      try {
        this.destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err2) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err2);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      } else {
        handleUnhandledError(err2);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error2, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error2 !== null && error2 !== undefined ? error2 : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports.SafeSubscriber = SafeSubscriber;
  function handleUnhandledError(error2) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error2);
    } else {
      reportUnhandledError_1.reportUnhandledError(error2);
    }
  }
  function defaultErrorHandler(err2) {
    throw err2;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observable = undefined;
  exports.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.identity = undefined;
  function identity(x2) {
    return x2;
  }
  exports.identity = identity;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pipeFromArray = exports.pipe = undefined;
  var identity_1 = require_identity();
  function pipe() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  exports.pipe = pipe;
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  exports.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
      errorContext_1.errorContext(function() {
        var _a2 = _this, operator = _a2.operator, source = _a2.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err2) {
        sink.error(err2);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err2) {
              reject(err2);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a2;
      return (_a2 = this.source) === null || _a2 === undefined ? undefined : _a2.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x2) {
          return value = x2;
        }, function(err2) {
          return reject(err2);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports.Observable = Observable;
  function getPromiseCtor(promiseCtor) {
    var _a2;
    return (_a2 = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a2 !== undefined ? _a2 : Promise;
  }
  function isObserver(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.operate = exports.hasLift = undefined;
  var isFunction_1 = require_isFunction();
  function hasLift(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  }
  exports.hasLift = hasLift;
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err2) {
            this.error(err2);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  exports.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OperatorSubscriber = exports.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  exports.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err2) {
          destination.error(err2);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err2) {
        try {
          onError(err2);
        } catch (err3) {
          destination.error(err3);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a2;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === undefined || _a2.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function refCount() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  }
  exports.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err2) {
          _this._teardown();
          subject_1.error(err2);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.performanceTimestampProvider = undefined;
  exports.performanceTimestampProvider = {
    now: function() {
      return (exports.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp2) {
        cancel = undefined;
        callback(timestamp2);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  function animationFrames(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  }
  exports.animationFrames = animationFrames;
  function animationFramesFactory(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp2) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp2,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  }
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnonymousSubject = exports.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a2;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b2 = __values(_this.currentObservers), _c = _b2.next();!_c.done; _c = _b2.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b2.return))
                _a2.call(_b2);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err2) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err2;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err2);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === undefined ? undefined : _a2.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.next) === null || _b2 === undefined || _b2.call(_a2, value);
    };
    AnonymousSubject2.prototype.error = function(err2) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.error) === null || _b2 === undefined || _b2.call(_a2, err2);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.complete) === null || _b2 === undefined || _b2.call(_a2);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a2, _b2;
      return (_b2 = (_a2 = this.source) === null || _a2 === undefined ? undefined : _a2.subscribe(subscriber)) !== null && _b2 !== undefined ? _b2 : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dateTimestampProvider = undefined;
  exports.dateTimestampProvider = {
    now: function() {
      return (exports.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a2 = this, isStopped = _a2.isStopped, _buffer2 = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
      if (!isStopped) {
        _buffer2.push(value);
        !_infiniteTimeWindow && _buffer2.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer2 = _a2._buffer;
      var copy = _buffer2.slice();
      for (var i2 = 0;i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i2]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer2 = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer2.length && _buffer2.splice(0, _buffer2.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i2 = 1;i2 < _buffer2.length && _buffer2[i2] <= now; i2 += 2) {
          last = i2;
        }
        last && _buffer2.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intervalProvider = undefined;
  exports.intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncAction = undefined;
  var Action_1 = require_Action();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a2 = this.id) !== null && _a2 !== undefined ? _a2 : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error2 = this._execute(state, delay);
      if (error2) {
        return error2;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a2 = this, id = _a2.id, scheduler = _a2.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TestTools = exports.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  exports.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate2 = Immediate_1.Immediate.clearImmediate;
  exports.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate2)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === undefined ? undefined : _a2.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error2;
      this._active = true;
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.asap = exports.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports.asap = exports.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.async = exports.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports.async = exports.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queue = exports.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports.queue = exports.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && id === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === undefined ? undefined : _a2.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId;
      if (action) {
        flushId = action.id;
      } else {
        flushId = this._scheduled;
        this._scheduled = undefined;
      }
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animationFrame = exports.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports.animationFrame = exports.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VirtualAction = exports.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
      var error2;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.empty = exports.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
  }
  exports.empty = empty;
  function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isScheduler = undefined;
  var isFunction_1 = require_isFunction();
  function isScheduler(value) {
    return value && isFunction_1.isFunction(value.schedule);
  }
  exports.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.popNumber = exports.popScheduler = exports.popResultSelector = undefined;
  var isFunction_1 = require_isFunction();
  var isScheduler_1 = require_isScheduler();
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  }
  exports.popResultSelector = popResultSelector;
  function popScheduler(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  }
  exports.popScheduler = popScheduler;
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  exports.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArrayLike = undefined;
  exports.isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isPromise = undefined;
  var isFunction_1 = require_isFunction();
  function isPromise(value) {
    return isFunction_1.isFunction(value === null || value === undefined ? undefined : value.then);
  }
  exports.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction();
  function isInteropObservable(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  }
  exports.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction();
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  }
  exports.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createInvalidObservableTypeError = undefined;
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iterator = exports.getSymbolIterator = undefined;
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  exports.getSymbolIterator = getSymbolIterator;
  exports.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  function isIterable(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  }
  exports.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports && exports.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g[n])
        i2[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction();
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a2, value, done;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            reader = readableStream.getReader();
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, , 9, 10]);
            _b2.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b2.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b2.sent()];
          case 7:
            _b2.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  function isReadableStreamLike(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  }
  exports.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports && exports.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  function innerFrom(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports.innerFrom = innerFrom;
  function fromInteropObservable(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  exports.fromInteropObservable = fromInteropObservable;
  function fromArrayLike(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i2 = 0;i2 < array.length && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    });
  }
  exports.fromArrayLike = fromArrayLike;
  function fromPromise(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err2) {
        return subscriber.error(err2);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  }
  exports.fromPromise = fromPromise;
  function fromIterable(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a2;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
            _a2.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  exports.fromIterable = fromIterable;
  function fromAsyncIterable(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err2) {
        return subscriber.error(err2);
      });
    });
  }
  exports.fromAsyncIterable = fromAsyncIterable;
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  }
  exports.fromReadableStreamLike = fromReadableStreamLike;
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a2;
    return __awaiter(this, undefined, undefined, function() {
      var value, e_2_1;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b2.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b2.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b2.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b2.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a2.call(asyncIterable_1)];
          case 7:
            _b2.sent();
            _b2.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeSchedule = undefined;
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  exports.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function observeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err2) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err2);
        }, delay);
      }));
    });
  }
  exports.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.subscribeOn = undefined;
  var lift_1 = require_lift();
  function subscribeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }
  exports.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function scheduleObservable(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function schedulePromise(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  exports.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleIterable(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a2;
          var value;
          var done;
          try {
            _a2 = iterator.next(), value = _a2.value, done = _a2.done;
          } catch (err2) {
            subscriber.error(err2);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  }
  exports.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  exports.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  function from(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  }
  exports.from = from;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  function of() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  }
  exports.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init, 0, subscriber);
    } : init);
  }
  exports.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.observeNotification = exports.Notification = exports.NotificationKind = undefined;
  var empty_1 = require_empty2();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value, error2) {
      this.kind = kind;
      this.value = value;
      this.error = error2;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler2, completeHandler) {
      var _a2 = this, kind = _a2.kind, value = _a2.value, error2 = _a2.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value) : kind === "E" ? errorHandler2 === null || errorHandler2 === undefined ? undefined : errorHandler2(error2) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
      var _a2;
      return isFunction_1.isFunction((_a2 = nextOrObserver) === null || _a2 === undefined ? undefined : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a2 = this, kind = _a2.kind, value = _a2.value, error2 = _a2.error;
      var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error2;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value) {
      return new Notification2("N", value);
    };
    Notification2.createError = function(err2) {
      return new Notification2("E", undefined, err2);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports.Notification = Notification;
  function observeNotification(notification, observer) {
    var _a2, _b2, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a2 = observer.next) === null || _a2 === undefined || _a2.call(observer, value) : kind === "E" ? (_b2 = observer.error) === null || _b2 === undefined || _b2.call(observer, error2) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  }
  exports.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  }
  exports.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  function lastValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  }
  exports.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  function firstValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  }
  exports.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isValidDate = undefined;
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  exports.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeout = exports.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout(config, schedulerArg) {
    var _a2 = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a2.first, each = _a2.each, _b2 = _a2.with, _with = _b2 === undefined ? timeoutErrorFactory : _b2, _c = _a2.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a2.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err2) {
            subscriber.error(err2);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  }
  exports.timeout = timeout;
  function timeoutErrorFactory(info) {
    throw new exports.TimeoutError(info);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function map(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  exports.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  }
  exports.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err2 = results.shift();
                if (err2 != null) {
                  subject.error(err2);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  }
  exports.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  }
  exports.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  }
  exports.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  exports.argsArgArrayOrObject = argsArgArrayOrObject;
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createObject = undefined;
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i2) {
      return result[key] = values[i2], result;
    }, {});
  }
  exports.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestInit = exports.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports.combineLatest = combineLatest;
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i3) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i3], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values[i3] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i2 = 0;i2 < length; i2++) {
          _loop_1(i2);
        }
      }, subscriber);
    };
  }
  exports.combineLatestInit = combineLatestInit;
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err2) {
            subscriber.error(err2);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  }
  exports.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction();
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i2) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        })(innerFrom_1.innerFrom(project(a, i2)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  }
  exports.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  function mergeAll(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  }
  exports.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  function concatAll() {
    return mergeAll_1.mergeAll(1);
  }
  exports.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  }
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  function defer(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  exports.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  function connectable(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a2 } = config, resetOnDisconnect = _a2 === undefined ? true : _a2;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  }
  exports.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  function forkJoin() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a2.args, keys = _a2.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a2[0], remove = _a2[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  exports.fromEvent = fromEvent;
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  }
  exports.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports) => {
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a2, _b2;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a2 = initialStateOrOptions, initialState = _a2.initialState, condition = _a2.condition, iterate = _a2.iterate, _b2 = _a2.resultSelector, resultSelector = _b2 === undefined ? identity_1.identity : _b2, scheduler = _a2.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            state = initialState;
            _a3.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a3.sent();
            _a3.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  }
  exports.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.iif = undefined;
  var defer_1 = require_defer();
  function iif(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  exports.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  exports.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  function interval2(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  }
  exports.interval = interval2;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty2();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  }
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.never = exports.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop();
  exports.NEVER = new Observable_1.Observable(noop_1.noop);
  function never() {
    return exports.NEVER;
  }
  exports.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  }
  exports.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err2) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  }
  exports.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairs = undefined;
  var from_1 = require_from();
  function pairs(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  }
  exports.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.not = undefined;
  function not2(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  }
  exports.not = not2;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function filter(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  exports.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  function partition(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  }
  exports.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceInit = exports.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function race() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  }
  exports.race = race;
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i3) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0;s < subscriptions.length; s++) {
              s !== i3 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i2 = 0;subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
        _loop_1(i2);
      }
    };
  }
  exports.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty2();
  function range(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  }
  exports.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty2();
  function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  exports.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty2();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  function zip() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function(buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer, i2) {
              return !buffer.length && completed[i2];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  }
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function audit(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }
  exports.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  function auditTime(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  }
  exports.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function buffer(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  }
  exports.buffer = buffer;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2, e_2, _b2;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
            if (bufferSize <= buffer.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return))
              _a2.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b2 = toEmit_1.return))
                _b2.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a2;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer = buffers_2_1.value;
            subscriber.next(buffer);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a2 = buffers_2.return))
              _a2.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  }
  exports.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function bufferTime(bufferTimeSpan) {
    var _a2, _b2;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== undefined ? _a2 : async_1.asyncScheduler;
    var bufferCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== undefined ? _b2 : null;
    var maxBufferSize2 = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer = [];
          var record_1 = {
            buffer,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a3;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer = record.buffer;
            buffer.push(value);
            maxBufferSize2 <= buffer.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a3 = recordsCopy_1.return))
              _a3.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }
  exports.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function bufferToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer = [];
        buffers.push(buffer);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer);
          subscriber.next(buffer);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return))
              _a2.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  }
  exports.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function bufferWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b = buffer;
        buffer = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer === null || buffer === undefined ? undefined : buffer.push(value);
      }, function() {
        buffer && subscriber.next(buffer);
        subscriber.complete();
      }, undefined, function() {
        return buffer = closingSubscriber = null;
      }));
    });
  }
  exports.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  function catchError(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err2) {
        handledResult = innerFrom_1.innerFrom(selector(err2, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  exports.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i2 = index++;
        state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }
  exports.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  function reduce(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  exports.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  function toArray() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  }
  exports.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  function joinAllInternals(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  }
  exports.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  function combineLatestAll(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  }
  exports.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  }
  exports.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  function combineLatestWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function concatMap(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  }
  exports.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction();
  function concatMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  }
  exports.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.concatWith = undefined;
  var concat_1 = require_concat2();
  function concatWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  function fromSubscribable(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  }
  exports.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  function connect(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  }
  exports.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.count = undefined;
  var reduce_1 = require_reduce();
  function count(predicate) {
    return reduce_1.reduce(function(total, value, i2) {
      return !predicate || predicate(value, i2) ? total + 1 : total;
    }, 0);
  }
  exports.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function debounce(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  exports.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function debounceTime(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  exports.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function defaultIfEmpty(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  exports.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.take = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function take(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  exports.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  function ignoreElements() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  }
  exports.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapTo = undefined;
  var map_1 = require_map();
  function mapTo(value) {
    return map_1.map(function() {
      return value;
    });
  }
  exports.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  }
  exports.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  function delay(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  }
  exports.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function dematerialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  }
  exports.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function distinct(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  }
  exports.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  exports.distinctUntilChanged = distinctUntilChanged;
  function defaultCompare(a, b) {
    return a === b;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x2, y) {
      return compare ? compare(x2[key], y[key]) : x2[key] === y[key];
    });
  }
  exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function throwIfEmpty(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  exports.throwIfEmpty = throwIfEmpty;
  function defaultErrorFactory() {
    return new EmptyError_1.EmptyError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  function elementAt(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i2) {
        return i2 === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  }
  exports.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  function endWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  }
  exports.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function every(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function exhaustMap(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i2) {
          return innerFrom_1.innerFrom(project(a, i2)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  exports.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  function exhaustAll() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  }
  exports.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function expand(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  }
  exports.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.finalize = undefined;
  var lift_1 = require_lift();
  function finalize(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }
  exports.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createFind = exports.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function find(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  }
  exports.find = find;
  function createFind(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i2 = index++;
        if (predicate.call(thisArg, value, i2, source)) {
          subscriber.next(findIndex ? i2 : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  }
  exports.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  function findIndex(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  }
  exports.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function groupBy(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err2) {
        return notify(function(consumer) {
          return consumer.error(err2);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err2) {
          handleError(err2);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  }
  exports.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function isEmpty() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeLast = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeLast(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a2;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a2 = buffer_1.return))
              _a2.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer = null;
      }));
    });
  }
  exports.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function materialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err2) {
        subscriber.next(Notification_1.Notification.createError(err2));
        subscriber.complete();
      }));
    });
  }
  exports.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function max3(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
      return comparer(x2, y) > 0 ? x2 : y;
    } : function(x2, y) {
      return x2 > y ? x2 : y;
    });
  }
  exports.max = max3;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  exports.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, undefined, function() {
        return state = null;
      });
    });
  }
  exports.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.merge = undefined;
  var lift_1 = require_lift();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mergeWith = undefined;
  var merge_1 = require_merge2();
  function mergeWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function min(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
      return comparer(x2, y) < 0 ? x2 : y;
    } : function(x2, y) {
      return x2 < y ? x2 : y;
    });
  }
  exports.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction();
  var connect_1 = require_connect();
  function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  }
  exports.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.onErrorResumeNext = exports.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  function onErrorResumeNextWith() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  }
  exports.onErrorResumeNextWith = onErrorResumeNextWith;
  exports.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function pairwise() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  exports.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.pluck = undefined;
  var map_1 = require_map();
  function pluck() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x2) {
      var currentProp = x2;
      for (var i2 = 0;i2 < length; i2++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i2]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  }
  exports.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect();
  function publish(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  }
  exports.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishBehavior(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishLast() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction();
  function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  }
  exports.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  function raceWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  }
  exports.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeat = undefined;
  var empty_1 = require_empty2();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  function repeat(countOrConfig) {
    var _a2;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a2 = countOrConfig.count, count = _a2 === undefined ? Infinity : _a2, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }
  exports.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function repeatWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  }
  exports.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  function retry2(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a2 = config.count, count = _a2 === undefined ? Infinity : _a2, delay = config.delay, _b2 = config.resetOnSuccess, resetOnSuccess = _b2 === undefined ? false : _b2;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, undefined, function(err2) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err2, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err2);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  exports.retry = retry2;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function retryWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err2) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err2);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  }
  exports.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function sample(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  }
  exports.sample = sample;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  function sampleTime(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  }
  exports.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  function scan(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  exports.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function sequenceEqual(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual2) {
        subscriber.next(isEqual2);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer, complete } = otherState;
          if (buffer.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer } = otherState;
          complete && emit(buffer.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  }
  exports.sequenceEqual = sequenceEqual;
  function createState() {
    return {
      buffer: [],
      complete: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  function share(options) {
    if (options === undefined) {
      options = {};
    }
    var _a2 = options.connector, connector = _a2 === undefined ? function() {
      return new Subject_1.Subject;
    } : _a2, _b2 = options.resetOnError, resetOnError = _b2 === undefined ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err2) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err2);
              dest.error(err2);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  exports.share = share;
  function handleReset(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a2, _b2, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === undefined ? Infinity : _a2, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === undefined ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  }
  exports.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function single(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  }
  exports.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skip = undefined;
  var filter_1 = require_filter();
  function skip(count) {
    return filter_1.filter(function(_, index) {
      return count <= index;
    });
  }
  exports.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipLast(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  }
  exports.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function skipUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }
  exports.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipWhile(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  }
  exports.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  function startWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  }
  exports.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function switchMap(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  exports.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
  }
  exports.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction();
  function switchMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  }
  exports.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  function switchScan(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state, value, index);
      }, function(_, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  }
  exports.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function takeUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  exports.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeWhile(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }
  exports.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tap = undefined;
  var isFunction_1 = require_isFunction();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  function tap(observerOrNext, error2, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a2;
      (_a2 = tapObserver.subscribe) === null || _a2 === undefined || _a2.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a3;
        (_a3 = tapObserver.next) === null || _a3 === undefined || _a3.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.complete) === null || _a3 === undefined || _a3.call(tapObserver);
        subscriber.complete();
      }, function(err2) {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.error) === null || _a3 === undefined || _a3.call(tapObserver, err2);
        subscriber.error(err2);
      }, function() {
        var _a3, _b2;
        if (isUnsub) {
          (_a3 = tapObserver.unsubscribe) === null || _a3 === undefined || _a3.call(tapObserver);
        }
        (_b2 = tapObserver.finalize) === null || _b2 === undefined || _b2.call(tapObserver);
      }));
    }) : identity_1.identity;
  }
  exports.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function throttle(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a2 = config !== null && config !== undefined ? config : {}, _b2 = _a2.leading, leading = _b2 === undefined ? true : _b2, _c = _a2.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }
  exports.throttle = throttle;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  function throttleTime(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  }
  exports.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TimeInterval = exports.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function timeInterval(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler.now();
        var interval2 = now - last;
        last = now;
        subscriber.next(new TimeInterval(value, interval2));
      }));
    });
  }
  exports.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value, interval2) {
      this.value = value;
      this.interval = interval2;
    }
    return TimeInterval2;
  }();
  exports.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  function timeoutWith(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  }
  exports.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  function timestamp2(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }
  exports.timestamp = timestamp2;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function window2(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler2 = function(err2) {
        windowSubject.error(err2);
        subscriber.error(err2);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler2));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler2));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  }
  exports.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a2 = windows_1.return))
              _a2.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c = count - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err2) {
        while (windows.length > 0) {
          windows.shift().error(err2);
        }
        subscriber.error(err2);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  }
  exports.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function windowTime(windowTimeSpan) {
    var _a2, _b2;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== undefined ? _a2 : async_1.asyncScheduler;
    var windowCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== undefined ? _b2 : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a3) {
          var window2 = _a3.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err2) {
        return terminate(function(consumer) {
          return consumer.error(err2);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  }
  exports.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports) => {
  var __values = exports && exports.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function windowToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err2) {
        while (0 < windows.length) {
          windows.shift().error(err2);
        }
        subscriber.error(err2);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err2) {
          handleError(err2);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a2 = windowsCopy_1.return))
              _a2.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  }
  exports.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function windowWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err2) {
        window2.error(err2);
        subscriber.error(err2);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err2) {
          handleError(err2);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  }
  exports.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop();
  var args_1 = require_args();
  function withLatestFrom() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i3) {
        innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i3] = value;
          if (!ready && !hasValue[i3]) {
            hasValue[i3] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i2 = 0;i2 < len; i2++) {
        _loop_1(i2);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  }
  exports.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  function zipAll(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  }
  exports.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  function zip() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  }
  exports.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports) => {
  var __read = exports && exports.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.zipWith = undefined;
  var zip_1 = require_zip2();
  function zipWith() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  }
  exports.zipWith = zipWith;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = undefined;
  exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = undefined;
  exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = undefined;
  exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop();
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty2();
  Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty2();
  Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types(), exports);
  var config_1 = require_config();
  Object.defineProperty(exports, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer();
  Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect();
  Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/@flowcore/sdk-transformer-core/dist/contracts/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "TIME_BUCKET_FORMAT", {
    enumerable: true,
    get: function() {
      return TIME_BUCKET_FORMAT;
    }
  });
  var TIME_BUCKET_FORMAT = "YYYYMMDDHHmmss";
});

// node_modules/@flowcore/sdk-transformer-core/dist/contracts/index.js
var require_contracts = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_constants(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/exceptions.js
var require_exceptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "TransformerError", {
    enumerable: true,
    get: function() {
      return TransformerError;
    }
  });
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class TransformerError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception.message})` : message;
      super(errorMessage);
      _define_property(this, "name", "TransformerError");
      _define_property(this, "exception", undefined);
      _define_property(this, "errors", undefined);
      this.exception = options?.exception;
      this.errors = options?.errors;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsIterator = IsIterator;
  exports.IsStandardObject = IsStandardObject;
  exports.IsInstanceObject = IsInstanceObject;
  exports.IsPromise = IsPromise;
  exports.IsDate = IsDate;
  exports.IsMap = IsMap;
  exports.IsSet = IsSet;
  exports.IsRegExp = IsRegExp;
  exports.IsTypedArray = IsTypedArray;
  exports.IsInt8Array = IsInt8Array;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUint8ClampedArray = IsUint8ClampedArray;
  exports.IsInt16Array = IsInt16Array;
  exports.IsUint16Array = IsUint16Array;
  exports.IsInt32Array = IsInt32Array;
  exports.IsUint32Array = IsUint32Array;
  exports.IsFloat32Array = IsFloat32Array;
  exports.IsFloat64Array = IsFloat64Array;
  exports.IsBigInt64Array = IsBigInt64Array;
  exports.IsBigUint64Array = IsBigUint64Array;
  exports.HasPropertyKey = HasPropertyKey;
  exports.IsObject = IsObject;
  exports.IsArray = IsArray;
  exports.IsUndefined = IsUndefined;
  exports.IsNull = IsNull;
  exports.IsBoolean = IsBoolean;
  exports.IsNumber = IsNumber;
  exports.IsInteger = IsInteger;
  exports.IsBigInt = IsBigInt;
  exports.IsString = IsString;
  exports.IsFunction = IsFunction;
  exports.IsSymbol = IsSymbol;
  exports.IsValueType = IsValueType;
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  function IsStandardObject(value) {
    return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
  }
  function IsInstanceObject(value) {
    return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== "Object";
  }
  function IsPromise(value) {
    return value instanceof Promise;
  }
  function IsDate(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  }
  function IsMap(value) {
    return value instanceof globalThis.Map;
  }
  function IsSet(value) {
    return value instanceof globalThis.Set;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  function IsInt8Array(value) {
    return value instanceof globalThis.Int8Array;
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUint8ClampedArray(value) {
    return value instanceof globalThis.Uint8ClampedArray;
  }
  function IsInt16Array(value) {
    return value instanceof globalThis.Int16Array;
  }
  function IsUint16Array(value) {
    return value instanceof globalThis.Uint16Array;
  }
  function IsInt32Array(value) {
    return value instanceof globalThis.Int32Array;
  }
  function IsUint32Array(value) {
    return value instanceof globalThis.Uint32Array;
  }
  function IsFloat32Array(value) {
    return value instanceof globalThis.Float32Array;
  }
  function IsFloat64Array(value) {
    return value instanceof globalThis.Float64Array;
  }
  function IsBigInt64Array(value) {
    return value instanceof globalThis.BigInt64Array;
  }
  function IsBigUint64Array(value) {
    return value instanceof globalThis.BigUint64Array;
  }
  function HasPropertyKey(value, key) {
    return key in value;
  }
  function IsObject(value) {
    return value !== null && typeof value === "object";
  }
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  function IsUndefined(value) {
    return value === undefined;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsInteger(value) {
    return Number.isInteger(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_guard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystemPolicy = undefined;
  var index_1 = require_guard2();
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject = (0, index_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, index_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return TypeSystemPolicy2.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined2 = (0, index_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value === null : isUndefined2;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries;
  exports.Clear = Clear;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Set = Set2;
  exports.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(format) {
    return map.delete(format);
  }
  function Has(format) {
    return map.has(format);
  }
  function Set2(format, func) {
    map.set(format, func);
  }
  function Get(format) {
    return map.get(format);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries;
  exports.Clear = Clear;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Set = Set2;
  exports.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(kind) {
    return map.delete(kind);
  }
  function Has(kind) {
    return map.has(kind);
  }
  function Set2(kind, func) {
    map.set(kind, func);
  }
  function Get(kind) {
    return map.get(kind);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeRegistry = exports.FormatRegistry = undefined;
  exports.FormatRegistry = require_format();
  exports.TypeRegistry = require_type();
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = undefined;
  exports.TransformKind = Symbol.for("TypeBox.Transform");
  exports.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  exports.OptionalKind = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbols(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unsafe = Unsafe;
  var index_1 = require_symbols2();
  function Unsafe(options = {}) {
    return {
      ...options,
      [index_1.Kind]: options[index_1.Kind] ?? "Unsafe"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unsafe(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeBoxError = undefined;

  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError;
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_error(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var index_1 = require_registry();
  var index_2 = require_unsafe2();
  var index_3 = require_symbols2();
  var index_4 = require_error2();

  class TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;

  class TypeSystemDuplicateFormat extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (index_1.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      index_1.TypeRegistry.Set(kind, check);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check) {
      if (index_1.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      index_1.FormatRegistry.Set(format, check);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_policy(), exports);
  __exportStar(require_system(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedKey = MappedKey;
  var index_1 = require_symbols2();
  function MappedKey(T) {
    return {
      [index_1.Kind]: "MappedKey",
      keys: T
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedResult = MappedResult;
  var index_1 = require_symbols2();
  function MappedResult(properties) {
    return {
      [index_1.Kind]: "MappedResult",
      properties
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsArray = IsArray;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsIterator = IsIterator;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUndefined = IsUndefined;
  function IsAsyncIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
  }
  function IsArray(value) {
    return Array.isArray(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsDate(value) {
    return value instanceof globalThis.Date;
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsObject(value) {
    return typeof value === "object" && value !== null;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUndefined(value) {
    return value === undefined;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone;
  var ValueGuard = require_value();
  function ArrayType(value) {
    return value.map((value2) => Visit(value2));
  }
  function DateType(value) {
    return new Date(value.getTime());
  }
  function Uint8ArrayType(value) {
    return new Uint8Array(value);
  }
  function RegExpType(value) {
    return new RegExp(value.source, value.flags);
  }
  function ObjectType(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      result[key] = Visit(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      result[key] = Visit(value[key]);
    }
    return result;
  }
  function Visit(value) {
    return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsRegExp(value) ? RegExpType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
  }
  function Clone(value) {
    return Visit(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CloneRest = CloneRest;
  exports.CloneType = CloneType;
  var value_1 = require_value2();
  function CloneRest(schemas) {
    return schemas.map((schema) => CloneType(schema));
  }
  function CloneType(schema, options = {}) {
    return { ...(0, value_1.Clone)(schema), ...options };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Discard = Discard;
  function DiscardKey(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
  }
  function Discard(value, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_discard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Array = Array2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Array2(schema, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Array",
      type: "array",
      items: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncIterator = AsyncIterator;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  function AsyncIterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "AsyncIterator",
      type: "AsyncIterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_async_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Constructor = Constructor;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Constructor(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Constructor",
      type: "Constructor",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Function = Function2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Function2(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Function",
      type: "Function",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_function(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Never = Never;
  var index_1 = require_symbols2();
  function Never(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Never",
      not: {}
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_never2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsReadonly = IsReadonly;
  exports.IsOptional = IsOptional;
  exports.IsAny = IsAny;
  exports.IsArray = IsArray;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsConstructor = IsConstructor;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsInteger = IsInteger;
  exports.IsProperties = IsProperties;
  exports.IsIntersect = IsIntersect;
  exports.IsIterator = IsIterator;
  exports.IsKindOf = IsKindOf;
  exports.IsLiteralString = IsLiteralString;
  exports.IsLiteralNumber = IsLiteralNumber;
  exports.IsLiteralBoolean = IsLiteralBoolean;
  exports.IsLiteral = IsLiteral;
  exports.IsMappedKey = IsMappedKey;
  exports.IsMappedResult = IsMappedResult;
  exports.IsNever = IsNever;
  exports.IsNot = IsNot;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsPromise = IsPromise;
  exports.IsRecord = IsRecord;
  exports.IsRecursive = IsRecursive;
  exports.IsRef = IsRef;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsTemplateLiteral = IsTemplateLiteral;
  exports.IsThis = IsThis;
  exports.IsTransform = IsTransform;
  exports.IsTuple = IsTuple;
  exports.IsUndefined = IsUndefined;
  exports.IsUnion = IsUnion;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUnknown = IsUnknown;
  exports.IsUnsafe = IsUnsafe;
  exports.IsVoid = IsVoid;
  exports.IsKind = IsKind;
  exports.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any");
  }
  function IsArray(value) {
    return IsKindOf(value, "Array");
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator");
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt");
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean");
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor");
  }
  function IsDate(value) {
    return IsKindOf(value, "Date");
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function");
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer");
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value);
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect");
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator");
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal");
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey");
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult");
  }
  function IsNever(value) {
    return IsKindOf(value, "Never");
  }
  function IsNot(value) {
    return IsKindOf(value, "Not");
  }
  function IsNull(value) {
    return IsKindOf(value, "Null");
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number");
  }
  function IsObject(value) {
    return IsKindOf(value, "Object");
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise");
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record");
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref");
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp");
  }
  function IsString(value) {
    return IsKindOf(value, "String");
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol");
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral");
  }
  function IsThis(value) {
    return IsKindOf(value, "This");
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple");
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined");
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union");
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array");
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown");
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void");
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Optional = Optional;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var optional_from_mapped_result_1 = require_optional_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveOptional(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.OptionalKind]);
  }
  function AddOptional(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.OptionalKind]: "Optional" };
  }
  function OptionalWithFlag(schema, F) {
    return F === false ? RemoveOptional(schema) : AddOptional(schema);
  }
  function Optional(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionalFromMappedResult = OptionalFromMappedResult;
  var index_1 = require_mapped2();
  var optional_1 = require_optional();
  function FromProperties(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_optional_from_mapped_result(), exports);
  __exportStar(require_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectCreate = IntersectCreate;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function IntersectCreate(T, options) {
    const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: (0, type_1.CloneType)(options.unevaluatedProperties) } : {};
    return options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: (0, type_1.CloneRest)(T) } : { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectEvaluated = IntersectEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never3();
  var index_4 = require_optional2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function IsIntersectOptional(T) {
    return T.every((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function ResolveIntersect(T, options) {
    return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);
  }
  function IntersectEvaluated(T, options = {}) {
    if (T.length === 0)
      return (0, index_3.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intersect = Intersect;
  var type_1 = require_type2();
  var index_1 = require_never3();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function Intersect(T, options = {}) {
    if (T.length === 0)
      return (0, index_1.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_intersect_evaluated(), exports);
  __exportStar(require_intersect_type(), exports);
  __exportStar(require_intersect(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionCreate = UnionCreate;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function UnionCreate(T, options) {
    return { ...options, [index_1.Kind]: "Union", anyOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionEvaluated = UnionEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never3();
  var index_4 = require_optional2();
  var union_create_1 = require_union_create();
  var kind_1 = require_kind();
  function IsUnionOptional(T) {
    return T.some((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function ResolveUnion(T, options) {
    return IsUnionOptional(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options);
  }
  function UnionEvaluated(T, options = {}) {
    return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : ResolveUnion(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Union = Union;
  var index_1 = require_never3();
  var type_1 = require_type2();
  var union_create_1 = require_union_create();
  function Union(T, options = {}) {
    return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_union_evaluated(), exports);
  __exportStar(require_union_type(), exports);
  __exportStar(require_union(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralParserError = undefined;
  exports.TemplateLiteralParse = TemplateLiteralParse;
  exports.TemplateLiteralParseExact = TemplateLiteralParseExact;
  var index_1 = require_error2();

  class TemplateLiteralParserError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  function Unescape(pattern) {
    return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }
  function IsNonEscaped(pattern, index, char2) {
    return pattern[index] === char2 && pattern.charCodeAt(index - 1) !== 92;
  }
  function IsOpenParen(pattern, index) {
    return IsNonEscaped(pattern, index, "(");
  }
  function IsCloseParen(pattern, index) {
    return IsNonEscaped(pattern, index, ")");
  }
  function IsSeparator(pattern, index) {
    return IsNonEscaped(pattern, index, "|");
  }
  function IsGroup(pattern) {
    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
      return false;
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (count === 0 && index !== pattern.length - 1)
        return false;
    }
    return true;
  }
  function InGroup(pattern) {
    return pattern.slice(1, pattern.length - 1);
  }
  function IsPrecedenceOr(pattern) {
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0)
        return true;
    }
    return false;
  }
  function IsPrecedenceAnd(pattern) {
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        return true;
    }
    return false;
  }
  function Or(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0) {
        const range2 = pattern.slice(start, index);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse(range2));
        start = index + 1;
      }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  }
  function And(pattern) {
    function Group(value, index) {
      if (!IsOpenParen(value, index))
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index;scan < value.length; scan++) {
        if (IsOpenParen(value, scan))
          count += 1;
        if (IsCloseParen(value, scan))
          count -= 1;
        if (count === 0)
          return [index, scan];
      }
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern2, index) {
      for (let scan = index;scan < pattern2.length; scan++) {
        if (IsOpenParen(pattern2, scan))
          return [index, scan];
      }
      return [index, pattern2.length];
    }
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index)) {
        const [start, end] = Group(pattern, index);
        const range = pattern.slice(start, end + 1);
        expressions.push(TemplateLiteralParse(range));
        index = end;
      } else {
        const [start, end] = Range(pattern, index);
        const range = pattern.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse(range));
        index = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  }
  function TemplateLiteralParse(pattern) {
    return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
  }
  function TemplateLiteralParseExact(pattern) {
    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralFiniteError = undefined;
  exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
  exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralFiniteError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  function IsNumberExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  }
  function IsBooleanExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  }
  function IsStringExpression(expression) {
    return expression.type === "const" && expression.const === ".*";
  }
  function IsTemplateLiteralExpressionFinite(expression) {
    return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError(`Unknown expression type`);
    })();
  }
  function IsTemplateLiteralFinite(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralGenerateError = undefined;
  exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
  exports.TemplateLiteralGenerate = TemplateLiteralGenerate;
  var finite_1 = require_finite();
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralGenerateError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
  function* GenerateReduce(buffer) {
    if (buffer.length === 1)
      return yield* buffer[0];
    for (const left of buffer[0]) {
      for (const right of GenerateReduce(buffer.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
  }
  function* GenerateOr(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate(expr);
  }
  function* GenerateConst(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
      throw new TemplateLiteralGenerateError("Unknown expression");
    })();
  }
  function TemplateLiteralGenerate(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Literal = Literal;
  var index_1 = require_symbols2();
  function Literal(value, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Literal",
      const: value,
      type: typeof value
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Boolean = Boolean2;
  var index_1 = require_symbols2();
  function Boolean2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Boolean",
      type: "boolean"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_boolean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BigInt = BigInt2;
  var index_1 = require_symbols2();
  function BigInt2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "BigInt",
      type: "bigint"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_bigint(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Number = Number2;
  var index_1 = require_symbols2();
  function Number2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Number",
      type: "number"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_number(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.String = String2;
  var index_1 = require_symbols2();
  function String2(options = {}) {
    return { ...options, [index_1.Kind]: "String", type: "string" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_string(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralSyntax = TemplateLiteralSyntax;
  var index_1 = require_literal2();
  var index_2 = require_boolean2();
  var index_3 = require_bigint2();
  var index_4 = require_number2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_never3();
  function* FromUnion(syntax) {
    const trim = syntax.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal(syntax) {
    if (syntax[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax(syntax.slice(1));
      return yield* [L, ...R];
    }
    for (let i2 = 2;i2 < syntax.length; i2++) {
      if (syntax[i2] === "}") {
        const L = FromUnion(syntax.slice(2, i2));
        const R = FromSyntax(syntax.slice(i2 + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function* FromSyntax(syntax) {
    for (let i2 = 0;i2 < syntax.length; i2++) {
      if (syntax[i2] === "$") {
        const L = (0, index_1.Literal)(syntax.slice(0, i2));
        const R = FromTerminal(syntax.slice(i2));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function TemplateLiteralSyntax(syntax) {
    return [...FromSyntax(syntax)];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PatternNeverExact = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternNever = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = undefined;
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternNever = "(?!.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}$`;
  exports.PatternStringExact = `^${exports.PatternString}$`;
  exports.PatternNeverExact = `^${exports.PatternNever}$`;
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_patterns(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralPatternError = undefined;
  exports.TemplateLiteralPattern = TemplateLiteralPattern;
  var index_1 = require_patterns2();
  var index_2 = require_symbols2();
  var index_3 = require_error2();
  var kind_1 = require_kind();

  class TemplateLiteralPatternError extends index_3.TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  function Escape(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Visit(schema, acc) {
    return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[index_2.Kind]}'`);
    })();
  }
  function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralToUnion = TemplateLiteralToUnion;
  var index_1 = require_union2();
  var index_2 = require_literal2();
  var generate_1 = require_generate2();
  function TemplateLiteralToUnion(schema) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteral = TemplateLiteral;
  var syntax_1 = require_syntax();
  var pattern_1 = require_pattern();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function TemplateLiteral(unresolved, options = {}) {
    const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return { ...options, [index_1.Kind]: "TemplateLiteral", type: "string", pattern };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_finite(), exports);
  __exportStar(require_generate2(), exports);
  __exportStar(require_syntax(), exports);
  __exportStar(require_parse(), exports);
  __exportStar(require_pattern(), exports);
  __exportStar(require_union3(), exports);
  __exportStar(require_template_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexPropertyKeys = IndexPropertyKeys;
  var index_1 = require_template_literal2();
  var kind_1 = require_kind();
  function FromTemplateLiteral(T) {
    const R = (0, index_1.TemplateLiteralGenerate)(T);
    return R.map((S) => S.toString());
  }
  function FromUnion(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...IndexPropertyKeys(L));
    return Acc;
  }
  function FromLiteral(T) {
    return [T.toString()];
  }
  function IndexPropertyKeys(T) {
    return [...new Set((0, kind_1.IsTemplateLiteral)(T) ? FromTemplateLiteral(T) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsLiteral)(T) ? FromLiteral(T.const) : (0, kind_1.IsNumber)(T) ? ["[number]"] : (0, kind_1.IsInteger)(T) ? ["[number]"] : [])];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedResult = IndexFromMappedResult;
  var index_1 = require_mapped2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var index_2 = require_indexed2();
  function FromProperties(T, P, options) {
    const Acc = {};
    for (const K2 of Object.getOwnPropertyNames(P)) {
      Acc[K2] = (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options);
    }
    return Acc;
  }
  function FromMappedResult(T, R, options) {
    return FromProperties(T, R.properties, options);
  }
  function IndexFromMappedResult(T, R, options) {
    const P = FromMappedResult(T, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromPropertyKey = IndexFromPropertyKey;
  exports.IndexFromPropertyKeys = IndexFromPropertyKeys;
  exports.Index = Index;
  var index_1 = require_never3();
  var index_2 = require_intersect2();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
  var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T, K) {
    return T.map((L) => IndexFromPropertyKey(L, K));
  }
  function FromIntersectRest(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function FromIntersect(T, K) {
    return (0, index_2.IntersectEvaluated)(FromIntersectRest(FromRest(T, K)));
  }
  function FromUnionRest(T) {
    return T.some((L) => (0, kind_1.IsNever)(L)) ? [] : T;
  }
  function FromUnion(T, K) {
    return (0, index_3.UnionEvaluated)(FromUnionRest(FromRest(T, K)));
  }
  function FromTuple(T, K) {
    return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
  }
  function FromArray(T, K) {
    return K === "[number]" ? T : (0, index_1.Never)();
  }
  function FromProperty(T, K) {
    return K in T ? T[K] : (0, index_1.Never)();
  }
  function IndexFromPropertyKey(T, K) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf, K) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf, K) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? [], K) : (0, kind_1.IsArray)(T) ? FromArray(T.items, K) : (0, kind_1.IsObject)(T) ? FromProperty(T.properties, K) : (0, index_1.Never)();
  }
  function IndexFromPropertyKeys(T, K) {
    return K.map((L) => IndexFromPropertyKey(T, L));
  }
  function FromSchema(T, K) {
    return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys(T, K));
  }
  function Index(T, K, options = {}) {
    return (0, kind_1.IsMappedResult)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options)) : (0, kind_1.IsMappedKey)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options)) : (0, kind_1.IsSchema)(K) ? (0, type_1.CloneType)(FromSchema(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)), options) : (0, type_1.CloneType)(FromSchema(T, K), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedKey = IndexFromMappedKey;
  var indexed_1 = require_indexed();
  var index_1 = require_mapped2();
  function MappedIndexPropertyKey(T, K, options) {
    return { [K]: (0, indexed_1.Index)(T, [K], options) };
  }
  function MappedIndexPropertyKeys(T, K, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
    }, {});
  }
  function MappedIndexProperties(T, K, options) {
    return MappedIndexPropertyKeys(T, K.keys, options);
  }
  function IndexFromMappedKey(T, K, options) {
    const P = MappedIndexProperties(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_indexed_from_mapped_key(), exports);
  __exportStar(require_indexed_from_mapped_result(), exports);
  __exportStar(require_indexed_property_keys(), exports);
  __exportStar(require_indexed(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Iterator = Iterator;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Iterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Iterator",
      type: "Iterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_iterator2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Object = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var kind_1 = require_kind();
  function _Object(properties, options = {}) {
    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
    const optionalKeys = propertyKeys.filter((key) => (0, kind_1.IsOptional)(properties[key]));
    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
    const clonedAdditionalProperties = (0, kind_1.IsSchema)(options.additionalProperties) ? { additionalProperties: (0, type_1.CloneType)(options.additionalProperties) } : {};
    const clonedProperties = {};
    for (const key of propertyKeys)
      clonedProperties[key] = (0, type_1.CloneType)(properties[key]);
    return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties };
  }
  exports.Object = _Object;
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_object(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Promise = Promise2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Promise2(item, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Promise",
      type: "Promise",
      item: (0, type_1.CloneType)(item)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_promise(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Readonly = Readonly;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveReadonly(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.ReadonlyKind]);
  }
  function AddReadonly(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.ReadonlyKind]: "Readonly" };
  }
  function ReadonlyWithFlag(schema, F) {
    return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
  }
  function Readonly(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
  var index_1 = require_mapped2();
  var readonly_1 = require_readonly();
  function FromProperties(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_from_mapped_result(), exports);
  __exportStar(require_readonly(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tuple = Tuple;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Tuple(items, options = {}) {
    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
    return items.length > 0 ? { ...options, [index_1.Kind]: "Tuple", type: "array", items: (0, type_1.CloneRest)(items), additionalItems, minItems, maxItems } : { ...options, [index_1.Kind]: "Tuple", type: "array", minItems, maxItems };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_tuple(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetIncludes = SetIncludes;
  exports.SetIsSubset = SetIsSubset;
  exports.SetDistinct = SetDistinct;
  exports.SetIntersect = SetIntersect;
  exports.SetUnion = SetUnion;
  exports.SetComplement = SetComplement;
  exports.SetIntersectMany = SetIntersectMany;
  exports.SetUnionMany = SetUnionMany;
  function SetIncludes(T, S) {
    return T.includes(S);
  }
  function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes(S, L));
  }
  function SetDistinct(T) {
    return [...new Set(T)];
  }
  function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
  }
  function SetUnion(T, S) {
    return [...T, ...S];
  }
  function SetComplement(T, S) {
    return T.filter((L) => !S.includes(L));
  }
  function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect(Acc, L);
    }, Init);
  }
  function SetIntersectMany(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
  }
  function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...L);
    return Acc;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_set(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedFunctionReturnType = MappedFunctionReturnType;
  exports.Mapped = Mapped;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_array2();
  var index_4 = require_async_iterator2();
  var index_5 = require_constructor2();
  var index_6 = require_function2();
  var index_7 = require_indexed2();
  var index_8 = require_intersect2();
  var index_9 = require_iterator3();
  var index_10 = require_literal2();
  var index_11 = require_object2();
  var index_12 = require_optional2();
  var index_13 = require_promise2();
  var index_14 = require_readonly2();
  var index_15 = require_tuple2();
  var index_16 = require_union2();
  var index_17 = require_sets();
  var mapped_result_1 = require_mapped_result();
  var kind_1 = require_kind();
  function FromMappedResult(K, P) {
    return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  }
  function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
  }
  function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
      Acc[L] = (0, index_10.Literal)(L);
    return Acc;
  }
  function MappedKeyToMappedResultProperties(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
  }
  function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
  }
  function FromRest(K, T) {
    return T.map((L) => FromSchemaType(K, L));
  }
  function FromProperties(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
      Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
  }
  function FromSchemaType(K, T) {
    return (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) : (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf)) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? [])) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties)) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items)) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item)) : T;
  }
  function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
      Acc[L] = FromSchemaType(L, T);
    return Acc;
  }
  function Mapped(key, map, options = {}) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, type_1.CloneType)((0, index_11.Object)(R), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mapped_key(), exports);
  __exportStar(require_mapped_result(), exports);
  __exportStar(require_mapped(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeys = KeyOfPropertyKeys;
  exports.KeyOfPattern = KeyOfPattern;
  var index_1 = require_sets();
  var kind_1 = require_kind();
  function FromRest(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(KeyOfPropertyKeys(L));
    return Acc;
  }
  function FromIntersect(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetUnionMany)(C);
    return R;
  }
  function FromUnion(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetIntersectMany)(C);
    return R;
  }
  function FromTuple(T) {
    return T.map((_, I) => I.toString());
  }
  function FromArray(_) {
    return ["[number]"];
  }
  function FromProperties(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  }
  function FromPatternProperties(patternProperties) {
    if (!includePatternProperties)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  }
  function KeyOfPropertyKeys(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? []) : (0, kind_1.IsArray)(T) ? FromArray(T.items) : (0, kind_1.IsObject)(T) ? FromProperties(T.properties) : (0, kind_1.IsRecord)(T) ? FromPatternProperties(T.patternProperties) : [];
  }
  var includePatternProperties = false;
  function KeyOfPattern(schema) {
    includePatternProperties = true;
    const keys = KeyOfPropertyKeys(schema);
    includePatternProperties = false;
    const pattern = keys.map((key) => `(${key})`);
    return `^(${pattern.join("|")})$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
  exports.KeyOf = KeyOf;
  var index_1 = require_literal2();
  var index_2 = require_number2();
  var keyof_property_keys_1 = require_keyof_property_keys();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
  var kind_1 = require_kind();
  function KeyOfPropertyKeysToRest(T) {
    return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  }
  function KeyOf(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
    } else {
      const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
      const S = KeyOfPropertyKeysToRest(K);
      const U = (0, index_3.UnionEvaluated)(S);
      return (0, type_1.CloneType)(U, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfFromMappedResult = KeyOfFromMappedResult;
  var index_1 = require_mapped2();
  var keyof_1 = require_keyof();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, keyof_1.KeyOf)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function KeyOfFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyEntries = KeyOfPropertyEntries;
  var indexed_1 = require_indexed();
  var keyof_property_keys_1 = require_keyof_property_keys();
  function KeyOfPropertyEntries(schema) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
    return keys.map((_, index) => [keys[index], schemas[index]]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_keyof_from_mapped_result(), exports);
  __exportStar(require_keyof_property_entries(), exports);
  __exportStar(require_keyof_property_keys(), exports);
  __exportStar(require_keyof(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
  var index_1 = require_symbols2();
  function Intersect(schema) {
    return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Union(schema) {
    return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Not(schema) {
    return !ExtendsUndefinedCheck(schema.not);
  }
  function ExtendsUndefinedCheck(schema) {
    return schema[index_1.Kind] === "Intersect" ? Intersect(schema) : schema[index_1.Kind] === "Union" ? Union(schema) : schema[index_1.Kind] === "Not" ? Not(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultErrorFunction = DefaultErrorFunction;
  exports.SetErrorFunction = SetErrorFunction;
  exports.GetErrorFunction = GetErrorFunction;
  var index_1 = require_symbols2();
  var errors_1 = require_errors();
  function DefaultErrorFunction(error2) {
    switch (error2.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error2.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error2.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Expected required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error2.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error2.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error2.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error2.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error2.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error2.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  var errorFunction = DefaultErrorFunction;
  function SetErrorFunction(callback) {
    errorFunction = callback;
  }
  function GetErrorFunction() {
    return errorFunction;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeDereferenceError = undefined;
  exports.Deref = Deref;
  var index_1 = require_error2();
  var index_2 = require_symbols2();

  class TypeDereferenceError extends index_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with $id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError;
  function Resolve(schema, references) {
    const target = references.find((target2) => target2.$id === schema.$ref);
    if (target === undefined)
      throw new TypeDereferenceError(schema);
    return Deref(target, references);
  }
  function Deref(schema, references) {
    return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve(schema, references) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueHashError = undefined;
  exports.Hash = Hash;
  var index_1 = require_guard2();
  var index_2 = require_error2();

  class ValueHashError extends index_2.TypeBoxError {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037");
  var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
  var F64 = new Float64Array(1);
  var F64In = new DataView(F64.buffer);
  var F64Out = new Uint8Array(F64.buffer);
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i2 = 0;i2 < byteCount; i2++) {
      yield value >> 8 * (byteCount - 1 - i2) & 255;
    }
  }
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  }
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  }
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  }
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  }
  function StringType2(value) {
    FNV1A64(ByteMarker.String);
    for (let i2 = 0;i2 < value.length; i2++) {
      for (const byte of NumberToBytes(value.charCodeAt(i2))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  }
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i2 = 0;i2 < value.length; i2++) {
      FNV1A64(value[i2]);
    }
  }
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, index_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsNull)(value))
      return NullType(value);
    if ((0, index_1.IsNumber)(value))
      return NumberType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsString)(value))
      return StringType2(value);
    if ((0, index_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, index_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, index_1.IsUndefined)(value))
      return UndefinedType(value);
    throw new ValueHashError(value);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_hash(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  exports.Errors = Errors;
  var index_1 = require_system2();
  var index_2 = require_keyof2();
  var index_3 = require_registry();
  var extends_undefined_1 = require_extends_undefined();
  var function_1 = require_function3();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_never3();
  var index_9 = require_guard2();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
  })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));

  class ValueErrorsUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined(value) {
    return value !== undefined;
  }

  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator;
  function Create(errorType, schema, path, value) {
    return { type: errorType, schema, path, value, message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value }) };
  }
  function* FromAny(schema, references, path, value) {}
  function* FromArray(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i2 = 0;i2 < value.length; i2++) {
      yield* Visit(schema.items, references, `${path}/${i2}`, value[i2]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_6.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_8.Never)();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
  }
  function* FromAsyncIterator(schema, references, path, value) {
    if (!(0, index_9.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path, value);
  }
  function* FromBigInt(schema, references, path, value) {
    if (!(0, index_9.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
  }
  function* FromBoolean(schema, references, path, value) {
    if (!(0, index_9.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path, value);
  }
  function* FromConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  function* FromDate(schema, references, path, value) {
    if (!(0, index_9.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* FromFunction(schema, references, path, value) {
    if (!(0, index_9.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path, value);
  }
  function* FromInteger(schema, references, path, value) {
    if (!(0, index_9.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
  }
  function* FromIntersect(schema, references, path, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* FromIterator(schema, references, path, value) {
    if (!(0, index_9.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path, value);
  }
  function* FromLiteral(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path, value);
  }
  function* FromNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
  }
  function* FromNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path, value);
  }
  function* FromNull(schema, references, path, value) {
    if (!(0, index_9.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path, value);
  }
  function* FromNumber(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
  }
  function* FromObject(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* FromPromise(schema, references, path, value) {
    if (!(0, index_9.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path, value);
  }
  function* FromRecord(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromRegExp(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    const regex = new RegExp(schema.source, schema.flags);
    if (!regex.test(value)) {
      return yield Create(ValueErrorType.RegExp, schema, path, value);
    }
  }
  function* FromString(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, index_9.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    if ((0, index_9.IsString)(schema.format)) {
      if (!index_3.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
      } else {
        const format = index_3.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* FromSymbol(schema, references, path, value) {
    if (!(0, index_9.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path, value);
  }
  function* FromTemplateLiteral(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  function* FromThis(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromTuple(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i2 = 0;i2 < schema.items.length; i2++) {
      yield* Visit(schema.items[i2], references, `${path}/${i2}`, value[i2]);
    }
  }
  function* FromUndefined(schema, references, path, value) {
    if (!(0, index_9.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path, value);
  }
  function* FromUnion(schema, references, path, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors2 = [...Visit(subschema, references, path, value)];
      if (errors2.length === 0)
        return;
      count += errors2.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path, value);
    }
  }
  function* FromUint8Array(schema, references, path, value) {
    if (!(0, index_9.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* FromUnknown(schema, references, path, value) {}
  function* FromVoid(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path, value);
  }
  function* FromKind(schema, references, path, value) {
    const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path, value);
  }
  function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_7.Kind]) {
      case "Any":
        return yield* FromAny(schema_, references_, path, value);
      case "Array":
        return yield* FromArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* FromBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* FromBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* FromConstructor(schema_, references_, path, value);
      case "Date":
        return yield* FromDate(schema_, references_, path, value);
      case "Function":
        return yield* FromFunction(schema_, references_, path, value);
      case "Integer":
        return yield* FromInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* FromIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* FromIterator(schema_, references_, path, value);
      case "Literal":
        return yield* FromLiteral(schema_, references_, path, value);
      case "Never":
        return yield* FromNever(schema_, references_, path, value);
      case "Not":
        return yield* FromNot(schema_, references_, path, value);
      case "Null":
        return yield* FromNull(schema_, references_, path, value);
      case "Number":
        return yield* FromNumber(schema_, references_, path, value);
      case "Object":
        return yield* FromObject(schema_, references_, path, value);
      case "Promise":
        return yield* FromPromise(schema_, references_, path, value);
      case "Record":
        return yield* FromRecord(schema_, references_, path, value);
      case "Ref":
        return yield* FromRef(schema_, references_, path, value);
      case "RegExp":
        return yield* FromRegExp(schema_, references_, path, value);
      case "String":
        return yield* FromString(schema_, references_, path, value);
      case "Symbol":
        return yield* FromSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* FromThis(schema_, references_, path, value);
      case "Tuple":
        return yield* FromTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* FromUndefined(schema_, references_, path, value);
      case "Union":
        return yield* FromUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* FromUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* FromUnknown(schema_, references_, path, value);
      case "Void":
        return yield* FromVoid(schema_, references_, path, value);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* FromKind(schema_, references_, path, value);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
  __exportStar(require_function3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Any = Any;
  var index_1 = require_symbols2();
  function Any(options = {}) {
    return { ...options, [index_1.Kind]: "Any" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_any(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unknown = Unknown;
  var index_1 = require_symbols2();
  function Unknown(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Unknown"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unknown(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeGuardUnknownTypeError = undefined;
  exports.IsReadonly = IsReadonly;
  exports.IsOptional = IsOptional;
  exports.IsAny = IsAny;
  exports.IsArray = IsArray;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsConstructor = IsConstructor;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsInteger = IsInteger;
  exports.IsProperties = IsProperties;
  exports.IsIntersect = IsIntersect;
  exports.IsIterator = IsIterator;
  exports.IsKindOf = IsKindOf;
  exports.IsLiteralString = IsLiteralString;
  exports.IsLiteralNumber = IsLiteralNumber;
  exports.IsLiteralBoolean = IsLiteralBoolean;
  exports.IsLiteral = IsLiteral;
  exports.IsLiteralValue = IsLiteralValue;
  exports.IsMappedKey = IsMappedKey;
  exports.IsMappedResult = IsMappedResult;
  exports.IsNever = IsNever;
  exports.IsNot = IsNot;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsPromise = IsPromise;
  exports.IsRecord = IsRecord;
  exports.IsRecursive = IsRecursive;
  exports.IsRef = IsRef;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsTemplateLiteral = IsTemplateLiteral;
  exports.IsThis = IsThis;
  exports.IsTransform = IsTransform;
  exports.IsTuple = IsTuple;
  exports.IsUndefined = IsUndefined;
  exports.IsUnionLiteral = IsUnionLiteral;
  exports.IsUnion = IsUnion;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUnknown = IsUnknown;
  exports.IsUnsafe = IsUnsafe;
  exports.IsVoid = IsVoid;
  exports.IsKind = IsKind;
  exports.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  var index_2 = require_error2();

  class TypeGuardUnknownTypeError extends index_2.TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var KnownTypes = [
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  function IsPattern(value) {
    try {
      new RegExp(value);
      return true;
    } catch {
      return false;
    }
  }
  function IsControlCharacterFree(value) {
    if (!ValueGuard.IsString(value))
      return false;
    for (let i2 = 0;i2 < value.length; i2++) {
      const code = value.charCodeAt(i2);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  }
  function IsAdditionalProperties(value) {
    return IsOptionalBoolean(value) || IsSchema(value);
  }
  function IsOptionalBigInt(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
  }
  function IsOptionalNumber(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
  }
  function IsOptionalBoolean(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
  }
  function IsOptionalString(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
  }
  function IsOptionalPattern(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
  }
  function IsOptionalFormat(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
  }
  function IsOptionalSchema(value) {
    return ValueGuard.IsUndefined(value) || IsSchema(value);
  }
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any") && IsOptionalString(value.$id);
  }
  function IsArray(value) {
    return IsKindOf(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsDate(value) {
    return IsKindOf(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
  }
  function IsLiteralValue(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult") && IsProperties(value.properties);
  }
  function IsNever(value) {
    return IsKindOf(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
  }
  function IsNot(value) {
    return IsKindOf(value, "Not") && IsSchema(value.not);
  }
  function IsNull(value) {
    return IsKindOf(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsObject(value) {
    return IsKindOf(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema(value.item);
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
      const keys = Object.getOwnPropertyNames(schema.patternProperties);
      return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
    })(value);
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp") && IsOptionalString(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
  }
  function IsString(value) {
    return IsKindOf(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
  }
  function IsThis(value) {
    return IsKindOf(value, "This") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema(schema)));
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
  }
  function IsUnionLiteral(value) {
    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union") && IsOptionalString(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema(schema));
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown") && IsOptionalString(value.$id);
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes.includes(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return ValueGuard.IsObject(value) && (IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueGuard = exports.TypeGuard = exports.KindGuard = undefined;
  exports.KindGuard = require_kind();
  exports.TypeGuard = require_type3();
  exports.ValueGuard = require_value();
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsResult = exports.ExtendsResolverError = undefined;
  exports.ExtendsCheck = ExtendsCheck;
  var index_1 = require_any2();
  var index_2 = require_function2();
  var index_3 = require_number2();
  var index_4 = require_string2();
  var index_5 = require_unknown2();
  var index_6 = require_template_literal2();
  var index_7 = require_patterns2();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var index_10 = require_guard3();

  class ExtendsResolverError extends index_9.TypeBoxError {
  }
  exports.ExtendsResolverError = ExtendsResolverError;
  var ExtendsResult;
  (function(ExtendsResult2) {
    ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
    ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
    ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
  })(ExtendsResult || (exports.ExtendsResult = ExtendsResult = {}));
  function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
  }
  function Throw(message) {
    throw new ExtendsResolverError(message);
  }
  function IsStructuralRight(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  }
  function StructuralRight(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
  }
  function FromAnyRight(left, right) {
    return ExtendsResult.True;
  }
  function FromAny(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
  }
  function FromArrayRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromArray(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromAsyncIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromBigInt(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBooleanRight(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBoolean(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromConstructor(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromDate(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromFunction(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromIntegerRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromInteger(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
  }
  function FromIntersectRight(left, right) {
    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIntersect(left, right) {
    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromLiteral(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
  }
  function FromNeverRight(left, right) {
    return ExtendsResult.False;
  }
  function FromNever(left, right) {
    return ExtendsResult.True;
  }
  function UnwrapTNot(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  }
  function FromNot(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
  }
  function FromNull(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumberRight(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumber(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function IsObjectPropertyCount(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
  }
  function IsObjectStringLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectSymbolLike(schema) {
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
  }
  function IsObjectNumberLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBooleanLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBigIntLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectDateLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectUint8ArrayLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectFunctionLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectConstructorLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectArrayLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectPromiseLike(schema) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === ExtendsResult.True;
  }
  function Property(left, right) {
    return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
  }
  function FromObjectRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left)) ? (() => {
      return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
    })() : ExtendsResult.False;
  }
  function FromObject(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.True;
        }
        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })();
  }
  function FromPromise(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
  }
  function RecordKey(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : (index_7.PatternStringExact in schema.patternProperties) ? (0, index_4.String)() : Throw("Unknown record key pattern");
  }
  function RecordValue(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : (index_7.PatternStringExact in schema.patternProperties) ? schema.patternProperties[index_7.PatternStringExact] : Throw("Unable to get record value schema");
  }
  function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property(Value, left.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })() : ExtendsResult.False;
  }
  function FromRecord(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
  }
  function FromRegExp(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit(L, R);
  }
  function FromStringRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromString(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromSymbol(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromTemplateLiteral(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw("Invalid fallthrough for TemplateLiteral");
  }
  function IsArrayOfTuple(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True);
  }
  function FromTupleRight(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
  }
  function FromTuple(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUint8Array(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUndefined(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnionRight(left, right) {
    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnion(left, right) {
    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnknownRight(left, right) {
    return ExtendsResult.True;
  }
  function FromUnknown(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoidRight(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoid(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function Visit(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot(left, right) : index_10.TypeGuard.IsAny(left) ? FromAny(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) : index_10.TypeGuard.IsString(left) ? FromString(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[index_8.Kind]}'`);
  }
  function ExtendsCheck(left, right) {
    return Visit(left, right);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedResult = ExtendsFromMappedResult;
  var index_1 = require_mapped2();
  var extends_1 = require_extends();
  function FromProperties(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, options);
    return Acc;
  }
  function FromMappedResult(Left, Right, True, False, options) {
    return FromProperties(Left.properties, Right, True, False, options);
  }
  function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extends = Extends;
  var index_1 = require_union2();
  var extends_check_1 = require_extends_check();
  var type_1 = require_type2();
  var extends_from_mapped_key_1 = require_extends_from_mapped_key();
  var extends_from_mapped_result_1 = require_extends_from_mapped_result();
  var kind_1 = require_kind();
  function ExtendsResolve(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  }
  function Extends(L, R, T, F, options = {}) {
    return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CloneType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CloneType)(ExtendsResolve(L, R, T, F), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedKey = ExtendsFromMappedKey;
  var index_1 = require_mapped2();
  var index_2 = require_literal2();
  var extends_1 = require_extends();
  function FromPropertyKey(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, options)
    };
  }
  function FromPropertyKeys(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
    }, {});
  }
  function FromMappedKey(K, U, L, R, options) {
    return FromPropertyKeys(K.keys, U, L, R, options);
  }
  function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extends_check(), exports);
  __exportStar(require_extends_from_mapped_key(), exports);
  __exportStar(require_extends_from_mapped_result(), exports);
  __exportStar(require_extends_undefined(), exports);
  __exportStar(require_extends(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCheckUnknownTypeError = undefined;
  exports.Check = Check;
  var index_1 = require_system2();
  var index_2 = require_deref2();
  var index_3 = require_hash2();
  var index_4 = require_symbols2();
  var index_5 = require_keyof2();
  var index_6 = require_extends2();
  var index_7 = require_registry();
  var index_8 = require_error2();
  var index_9 = require_never3();
  var index_10 = require_guard2();
  var type_1 = require_type3();

  class ValueCheckUnknownTypeError extends index_8.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  function IsAnyOrUnknown(schema) {
    return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
  }
  function IsDefined(value) {
    return value !== undefined;
  }
  function FromAny(schema, references, value) {
    return true;
  }
  function FromArray(schema, references, value) {
    if (!(0, index_10.IsArray)(value))
      return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_3.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  }
  function FromAsyncIterator(schema, references, value) {
    return (0, index_10.IsAsyncIterator)(value);
  }
  function FromBigInt(schema, references, value) {
    if (!(0, index_10.IsBigInt)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function FromBoolean(schema, references, value) {
    return (0, index_10.IsBoolean)(value);
  }
  function FromConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  }
  function FromDate(schema, references, value) {
    if (!(0, index_10.IsDate)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function FromFunction(schema, references, value) {
    return (0, index_10.IsFunction)(value);
  }
  function FromInteger(schema, references, value) {
    if (!(0, index_10.IsInteger)(value)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromIntersect(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function FromIterator(schema, references, value) {
    return (0, index_10.IsIterator)(value);
  }
  function FromLiteral(schema, references, value) {
    return value === schema.const;
  }
  function FromNever(schema, references, value) {
    return false;
  }
  function FromNot(schema, references, value) {
    return !Visit(schema.not, references, value);
  }
  function FromNull(schema, references, value) {
    return (0, index_10.IsNull)(value);
  }
  function FromNumber(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromObject(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  }
  function FromPromise(schema, references, value) {
    return (0, index_10.IsPromise)(value);
  }
  function FromRecord(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex.test(key) ? Visit(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromRegExp(schema, references, value) {
    const regex = new RegExp(schema.source, schema.flags);
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    return regex.test(value);
  }
  function FromString(schema, references, value) {
    if (!(0, index_10.IsString)(value)) {
      return false;
    }
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value))
        return false;
    }
    if (IsDefined(schema.format)) {
      if (!index_7.FormatRegistry.Has(schema.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  }
  function FromSymbol(schema, references, value) {
    return (0, index_10.IsSymbol)(value);
  }
  function FromTemplateLiteral(schema, references, value) {
    return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_10.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i2 = 0;i2 < schema.items.length; i2++) {
      if (!Visit(schema.items[i2], references, value[i2]))
        return false;
    }
    return true;
  }
  function FromUndefined(schema, references, value) {
    return (0, index_10.IsUndefined)(value);
  }
  function FromUnion(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
  }
  function FromUint8Array(schema, references, value) {
    if (!(0, index_10.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  }
  function FromUnknown(schema, references, value) {
    return true;
  }
  function FromVoid(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  }
  function FromKind(schema, references, value) {
    if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
    return func(schema, value);
  }
  function Visit(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny(schema_, references_, value);
      case "Array":
        return FromArray(schema_, references_, value);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Function":
        return FromFunction(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Iterator":
        return FromIterator(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Not":
        return FromNot(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Promise":
        return FromPromise(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "RegExp":
        return FromRegExp(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Uint8Array":
        return FromUint8Array(schema_, references_, value);
      case "Unknown":
        return FromUnknown(schema_, references_, value);
      case "Void":
        return FromVoid(schema_, references_, value);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return FromKind(schema_, references_, value);
    }
  }
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_check(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js
var require_clone = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone;
  var index_1 = require_guard2();
  function ObjectType(value) {
    const Acc = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      Acc[key] = Clone(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      Acc[key] = Clone(value[key]);
    }
    return Acc;
  }
  function ArrayType(value) {
    return value.map((element) => Clone(element));
  }
  function TypedArrayType(value) {
    return value.slice();
  }
  function DateType(value) {
    return new Date(value.toISOString());
  }
  function ValueType(value) {
    return value;
  }
  function Clone(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsTypedArray)(value))
      return TypedArrayType(value);
    if ((0, index_1.IsValueType)(value))
      return ValueType(value);
    throw new Error("ValueClone: Unable to clone value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/index.js
var require_clone2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/create/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCreateError = undefined;
  exports.Create = Create;
  var index_1 = require_guard2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_template_literal2();
  var index_6 = require_patterns2();
  var index_7 = require_registry();
  var index_8 = require_symbols2();
  var index_9 = require_error2();

  class ValueCreateError extends index_9.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCreateError = ValueCreateError;
  function FromDefault(value) {
    return typeof value === "function" ? value : (0, index_3.Clone)(value);
  }
  function FromAny(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromArray(schema, references) {
    if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return FromDefault(schema.default);
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit(schema.items, references);
      });
    } else {
      return [];
    }
  }
  function FromAsyncIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return async function* () {}();
    }
  }
  function FromBigInt(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return BigInt(0);
    }
  }
  function FromBoolean(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return false;
    }
  }
  function FromConstructor(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = Visit(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self = this;
              self[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  }
  function FromDate(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date;
    }
  }
  function FromFunction(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return () => Visit(schema.returns, references);
    }
  }
  function FromInteger(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromIntersect(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next = Visit(schema2, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, index_2.Check)(schema, references, value))
        throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
      return value;
    }
  }
  function FromIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return function* () {}();
    }
  }
  function FromLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return schema.const;
    }
  }
  function FromNever(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
    }
  }
  function FromNot(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Not types must have a default value");
    }
  }
  function FromNull(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return null;
    }
  }
  function FromNumber(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromObject(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const required = new Set(schema.required);
      const Acc = {};
      for (const [key, subschema] of Object.entries(schema.properties)) {
        if (!required.has(key))
          continue;
        Acc[key] = Visit(subschema, references);
      }
      return Acc;
    }
  }
  function FromPromise(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Promise.resolve(Visit(schema.item, references));
    }
  }
  function FromRecord(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      const Acc = {};
      for (const key of propertyKeys)
        Acc[key] = Visit(valueSchema, references);
      return Acc;
    } else {
      return {};
    }
  }
  function FromRef(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromRegExp(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
    }
  }
  function FromString(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with patterns must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else if (schema.format !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with formats must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault(schema.default);
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => " ").join("");
      } else {
        return "";
      }
    }
  }
  function FromSymbol(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  }
  function FromTemplateLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema))
      throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
    const generated = (0, index_5.TemplateLiteralGenerate)(schema);
    return generated[0];
  }
  function FromThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
      throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromTuple(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
  }
  function FromUndefined(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromUnion(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit(schema.anyOf[0], references);
    }
  }
  function FromUint8Array(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  }
  function FromUnknown(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromVoid(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromKind(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new Error("User defined types must specify a default value");
    }
  }
  function Visit(schema, references) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return FromAny(schema_, references_);
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "BigInt":
        return FromBigInt(schema_, references_);
      case "Boolean":
        return FromBoolean(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Date":
        return FromDate(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Integer":
        return FromInteger(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Literal":
        return FromLiteral(schema_, references_);
      case "Never":
        return FromNever(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Null":
        return FromNull(schema_, references_);
      case "Number":
        return FromNumber(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "RegExp":
        return FromRegExp(schema_, references_);
      case "String":
        return FromString(schema_, references_);
      case "Symbol":
        return FromSymbol(schema_, references_);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Undefined":
        return FromUndefined(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      case "Uint8Array":
        return FromUint8Array(schema_, references_);
      case "Unknown":
        return FromUnknown(schema_, references_);
      case "Void":
        return FromVoid(schema_, references_);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueCreateError(schema_, "Unknown type");
        return FromKind(schema_, references_);
    }
  }
  var recursiveMaxDepth = 512;
  var recursiveDepth = 0;
  function Create(...args) {
    recursiveDepth = 0;
    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/index.js
var require_create2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_create(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js
var require_cast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCastError = undefined;
  exports.Cast = Cast;
  var index_1 = require_guard2();
  var index_2 = require_error2();
  var index_3 = require_symbols2();
  var index_4 = require_create2();
  var index_5 = require_check2();
  var index_6 = require_clone2();
  var index_7 = require_deref2();

  class ValueCastError extends index_2.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCastError = ValueCastError;
  function ScoreUnion(schema, references, value) {
    if (schema[index_3.Kind] === "Object" && typeof value === "object" && !(0, index_1.IsNull)(value)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value);
      const entries = Object.entries(object.properties);
      const [point2, max3] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[index_3.Kind] === "Literal" && schema2.const === value[key] ? max3 : 0;
        const checks = (0, index_5.Check)(schema2, references, value[key]) ? point2 : 0;
        const exists2 = keys.includes(key) ? point2 : 0;
        return acc + (literal + checks + exists2);
      }, 0);
    } else {
      return (0, index_5.Check)(schema, references, value) ? 1 : 0;
    }
  }
  function SelectUnion(union2, references, value) {
    const schemas = union2.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
    let [select, best] = [schemas[0], 0];
    for (const schema of schemas) {
      const score = ScoreUnion(schema, references, value);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function CastUnion(union2, references, value) {
    if ("default" in union2) {
      return typeof value === "function" ? union2.default : (0, index_6.Clone)(union2.default);
    } else {
      const schema = SelectUnion(union2, references, value);
      return Cast(schema, references, value);
    }
  }
  function DefaultClone(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
  }
  function Default(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
  }
  function FromArray(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema, references, unique))
      throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
    return unique;
  }
  function FromConstructor(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {};
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
  }
  function FromIntersect(schema, references, value) {
    const created = (0, index_4.Create)(schema, references);
    const mapped = (0, index_1.IsStandardObject)(created) && (0, index_1.IsStandardObject)(value) ? { ...created, ...value } : value;
    return (0, index_5.Check)(schema, references, mapped) ? mapped : (0, index_4.Create)(schema, references);
  }
  function FromNever(schema, references, value) {
    throw new ValueCastError(schema, "Never types cannot be cast");
  }
  function FromObject(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, index_4.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (!(0, index_1.IsArray)(value))
      return (0, index_4.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
  }
  function FromUnion(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion(schema, references, value);
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_3.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone(schema, references, value);
      default:
        return Default(schema_, references_, value);
    }
  }
  function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/index.js
var require_cast2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_cast(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js
var require_clean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clean = Clean;
  var index_1 = require_keyof2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_symbols2();
  var index_6 = require_guard2();
  var type_1 = require_type3();
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_5.Kind] !== "Unsafe";
  }
  function FromArray(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    return value.map((value2) => Visit(schema.items, references, value2));
  }
  function FromIntersect(schema, references, value) {
    const unevaluatedProperties = schema.unevaluatedProperties;
    const intersections = schema.allOf.map((schema2) => Visit(schema2, references, (0, index_3.Clone)(value)));
    const composite = intersections.reduce((acc, value2) => (0, index_6.IsObject)(value2) ? { ...acc, ...value2 } : value2, {});
    if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, type_1.IsSchema)(unevaluatedProperties))
      return composite;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
    for (const key of Object.getOwnPropertyNames(value)) {
      if (knownkeys.includes(key))
        continue;
      if ((0, index_2.Check)(unevaluatedProperties, references, value[key])) {
        composite[key] = Visit(unevaluatedProperties, references, value[key]);
      }
    }
    return composite;
  }
  function FromObject(schema, references, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value)) {
      if (key in schema.properties) {
        value[key] = Visit(schema.properties[key], references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRecord(schema, references, value) {
    if (!(0, index_6.IsObject)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    const propertyKeys = Object.getOwnPropertyNames(value);
    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
      if (propertyKeyTest.test(key)) {
        value[key] = Visit(propertySchema, references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    if ((0, index_6.IsUndefined)(schema.items))
      return [];
    const length = Math.min(value.length, schema.items.length);
    for (let i2 = 0;i2 < length; i2++) {
      value[i2] = Visit(schema.items[i2], references, value[i2]);
    }
    return value.length > length ? value.slice(0, length) : value;
  }
  function FromUnion(schema, references, value) {
    for (const inner of schema.anyOf) {
      if (IsCheckable(inner) && (0, index_2.Check)(inner, references, value)) {
        return Visit(inner, references, value);
      }
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_6.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_5.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return value;
    }
  }
  function Clean(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/index.js
var require_clean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js
var require_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = Convert;
  var index_1 = require_clone2();
  var index_2 = require_check2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  function IsStringNumeric(value) {
    return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  function IsValueToString(value) {
    return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
  }
  function IsValueTrue(value) {
    return value === true || (0, index_5.IsNumber)(value) && value === 1 || (0, index_5.IsBigInt)(value) && value === BigInt("1") || (0, index_5.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  }
  function IsValueFalse(value) {
    return value === false || (0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, index_5.IsBigInt)(value) && value === BigInt("0") || (0, index_5.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  }
  function IsTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsDateTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateString(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  function TryConvertLiteralString(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralNumber(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralBoolean(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteral(schema, value) {
    return (0, index_5.IsString)(schema.const) ? TryConvertLiteralString(value, schema.const) : (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber(value, schema.const) : (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : (0, index_1.Clone)(value);
  }
  function TryConvertBoolean(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
  }
  function TryConvertBigInt(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, index_5.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
  }
  function TryConvertString(value) {
    return IsValueToString(value) ? value.toString() : (0, index_5.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;
  }
  function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertNull(value) {
    return (0, index_5.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  }
  function TryConvertUndefined(value) {
    return (0, index_5.IsString)(value) && value === "undefined" ? undefined : value;
  }
  function TryConvertDate(value) {
    return (0, index_5.IsDate)(value) ? value : (0, index_5.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  function Default(value) {
    return value;
  }
  function FromArray(schema, references, value) {
    const elements = (0, index_5.IsArray)(value) ? value : [value];
    return elements.map((element) => Visit(schema.items, references, element));
  }
  function FromBigInt(schema, references, value) {
    return TryConvertBigInt(value);
  }
  function FromBoolean(schema, references, value) {
    return TryConvertBoolean(value);
  }
  function FromDate(schema, references, value) {
    return TryConvertDate(value);
  }
  function FromInteger(schema, references, value) {
    return TryConvertInteger(value);
  }
  function FromIntersect(schema, references, value) {
    return schema.allOf.reduce((value2, schema2) => Visit(schema2, references, value2), value);
  }
  function FromLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
  }
  function FromNull(schema, references, value) {
    return TryConvertNull(value);
  }
  function FromNumber(schema, references, value) {
    return TryConvertNumber(value);
  }
  function FromObject(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const result = {};
    for (const key of Object.keys(value)) {
      result[key] = (0, index_5.HasPropertyKey)(schema.properties, key) ? Visit(schema.properties[key], references, value[key]) : value[key];
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(property, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromString(schema, references, value) {
    return TryConvertString(value);
  }
  function FromSymbol(schema, references, value) {
    return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
    if (!isConvertable)
      return value;
    return value.map((value2, index) => {
      return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
    });
  }
  function FromUndefined(schema, references, value) {
    return TryConvertUndefined(value);
  }
  function FromUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit(subschema, references, value);
      if (!(0, index_2.Check)(subschema, references, converted))
        continue;
      return converted;
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return Default(value);
    }
  }
  function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/index.js
var require_convert2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_convert(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/default/default.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Default = Default;
  var index_1 = require_check2();
  var index_2 = require_clone2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  var type_1 = require_type3();
  function ValueOrDefault(schema, value) {
    return value === undefined && "default" in schema ? (0, index_2.Clone)(schema.default) : value;
  }
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_4.Kind] !== "Unsafe";
  }
  function IsDefaultSchema(value) {
    return (0, type_1.IsSchema)(value) && "default" in value;
  }
  function FromArray(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted))
      return defaulted;
    for (let i2 = 0;i2 < defaulted.length; i2++) {
      defaulted[i2] = Visit(schema.items, references, defaulted[i2]);
    }
    return defaulted;
  }
  function FromIntersect(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    return schema.allOf.reduce((acc, schema2) => {
      const next = Visit(schema2, references, defaulted);
      return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
    }, {});
  }
  function FromObject(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
    for (const key of knownPropertyKeys) {
      if (!IsDefaultSchema(schema.properties[key]))
        continue;
      defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKeys.includes(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRecord(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
        continue;
      defaulted[key] = Visit(propertySchema, references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKey.test(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, ValueOrDefault(schema, value));
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
      return defaulted;
    const [items, max3] = [schema.items, Math.max(schema.items.length, defaulted.length)];
    for (let i2 = 0;i2 < max3; i2++) {
      if (i2 < items.length)
        defaulted[i2] = Visit(items[i2], references, defaulted[i2]);
    }
    return defaulted;
  }
  function FromUnion(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    for (const inner of schema.anyOf) {
      const result = Visit(inner, references, defaulted);
      if (IsCheckable(inner) && (0, index_1.Check)(inner, result)) {
        return result;
      }
    }
    return defaulted;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return ValueOrDefault(schema_, value);
    }
  }
  function Default(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/index.js
var require_default2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_default(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js
var require_pointer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;
  exports.Format = Format;
  exports.Set = Set2;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Get = Get;
  var index_1 = require_error2();

  class ValuePointerRootSetError extends index_1.TypeBoxError {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError;

  class ValuePointerRootDeleteError extends index_1.TypeBoxError {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  function Escape(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format(pointer) {
    if (pointer === "")
      return;
    let [start, end] = [0, 0];
    for (let i2 = 0;i2 < pointer.length; i2++) {
      const char2 = pointer.charAt(i2);
      if (char2 === "/") {
        if (i2 === 0) {
          start = i2 + 1;
        } else {
          end = i2;
          yield Escape(pointer.slice(start, end));
          start = i2 + 1;
        }
      } else {
        end = i2;
      }
    }
    yield Escape(pointer.slice(start));
  }
  function Set2(value, pointer, update) {
    if (pointer === "")
      throw new ValuePointerRootSetError(value, pointer, update);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  }
  function Delete(value, pointer) {
    if (pointer === "")
      throw new ValuePointerRootDeleteError(value, pointer);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  function Has(value, pointer) {
    if (pointer === "")
      return true;
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  function Get(value, pointer) {
    if (pointer === "")
      return value;
    let current = value;
    for (const component of Format(pointer)) {
      if (current[component] === undefined)
        return;
      current = current[component];
    }
    return current;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js
var require_pointer2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = undefined;
  exports.ValuePointer = require_pointer();
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js
var require_delta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueDeltaSymbolError = exports.ValueDeltaError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  exports.Diff = Diff;
  exports.Patch = Patch;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();
  var index_5 = require_literal2();
  var index_6 = require_object2();
  var index_7 = require_string2();
  var index_8 = require_unknown2();
  var index_9 = require_union2();
  exports.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)("insert"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)("update"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)("delete"),
    path: (0, index_7.String)()
  });
  exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);

  class ValueDeltaError extends index_4.TypeBoxError {
    constructor(value, message) {
      super(message);
      this.value = value;
    }
  }
  exports.ValueDeltaError = ValueDeltaError;

  class ValueDeltaSymbolError extends ValueDeltaError {
    constructor(value) {
      super(value, "Cannot diff objects with symbol keys");
      this.value = value;
    }
  }
  exports.ValueDeltaSymbolError = ValueDeltaSymbolError;
  function CreateUpdate(path, value) {
    return { type: "update", path, value };
  }
  function CreateInsert(path, value) {
    return { type: "insert", path, value };
  }
  function CreateDelete(path) {
    return { type: "delete", path };
  }
  function* ObjectType(path, current, next) {
    if (!(0, index_1.IsStandardObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
    const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsUndefined)(current[key]) || (0, index_1.IsUndefined)(next[key]))
        continue;
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      yield* Visit(`${path}/${globalThis.String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${globalThis.String(key)}`);
    }
  }
  function* ArrayType(path, current, next) {
    if (!(0, index_1.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i2 = 0;i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
    }
    for (let i2 = 0;i2 < next.length; i2++) {
      if (i2 < current.length)
        continue;
      yield CreateInsert(`${path}/${i2}`, next[i2]);
    }
    for (let i2 = current.length - 1;i2 >= 0; i2--) {
      if (i2 < next.length)
        continue;
      yield CreateDelete(`${path}/${i2}`);
    }
  }
  function* TypedArrayType(path, current, next) {
    if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i2 = 0;i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
    }
  }
  function* ValueType(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit(path, current, next) {
    if ((0, index_1.IsStandardObject)(current))
      return yield* ObjectType(path, current, next);
    if ((0, index_1.IsArray)(current))
      return yield* ArrayType(path, current, next);
    if ((0, index_1.IsTypedArray)(current))
      return yield* TypedArrayType(path, current, next);
    if ((0, index_1.IsValueType)(current))
      return yield* ValueType(path, current, next);
    throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
  }
  function Diff(current, next) {
    return [...Visit("", current, next)];
  }
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, index_3.Clone)(current);
    }
    const clone = (0, index_3.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "update": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "delete": {
          index_2.ValuePointer.Delete(clone, edit.path);
          break;
        }
      }
    }
    return clone;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/index.js
var require_delta2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_delta(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = Equal;
  var index_1 = require_guard2();
  function ObjectType(left, right) {
    if (!(0, index_1.IsStandardObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
  }
  function DateType(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
  }
  function ArrayType(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function TypedArrayType(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function ValueType(left, right) {
    return left === right;
  }
  function Equal(left, right) {
    if ((0, index_1.IsStandardObject)(left))
      return ObjectType(left, right);
    if ((0, index_1.IsDate)(left))
      return DateType(left, right);
    if ((0, index_1.IsTypedArray)(left))
      return TypedArrayType(left, right);
    if ((0, index_1.IsArray)(left))
      return ArrayType(left, right);
    if ((0, index_1.IsValueType)(left))
      return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/index.js
var require_equal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_equal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js
var require_mutate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueMutateError = undefined;
  exports.Mutate = Mutate;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();

  class ValueMutateError extends index_4.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports.ValueMutateError = ValueMutateError;
  function ObjectType(root, path, current, next) {
    if (!(0, index_1.IsStandardObject)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      const currentKeys = Object.getOwnPropertyNames(current);
      const nextKeys = Object.getOwnPropertyNames(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  }
  function ArrayType(root, path, current, next) {
    if (!(0, index_1.IsArray)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  }
  function TypedArrayType(root, path, current, next) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i2 = 0;i2 < current.length; i2++) {
        current[i2] = next[i2];
      }
    } else {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
  }
  function ValueType(root, path, current, next) {
    if (current === next)
      return;
    index_2.ValuePointer.Set(root, path, next);
  }
  function Visit(root, path, current, next) {
    if ((0, index_1.IsArray)(next))
      return ArrayType(root, path, current, next);
    if ((0, index_1.IsTypedArray)(next))
      return TypedArrayType(root, path, current, next);
    if ((0, index_1.IsStandardObject)(next))
      return ObjectType(root, path, current, next);
    if ((0, index_1.IsValueType)(next))
      return ValueType(root, path, current, next);
  }
  function IsNonMutableValue(value) {
    return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
  }
  function IsMismatchedValue(current, next) {
    return (0, index_1.IsStandardObject)(current) && (0, index_1.IsArray)(next) || (0, index_1.IsArray)(current) && (0, index_1.IsStandardObject)(next);
  }
  function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
      throw new ValueMutateError("Only object and array types can be mutated at the root level");
    if (IsMismatchedValue(current, next))
      throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
    Visit(current, "", current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js
var require_mutate2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mutate(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js
var require_decode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformDecodeError = exports.TransformDecodeCheckError = undefined;
  exports.TransformDecode = TransformDecode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformDecodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error2) {
      super(`Unable to decode value as it does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error2;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError;

  class TransformDecodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error2) {
      super(error2 instanceof Error ? error2.message : "Unknown error");
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error2;
    }
  }
  exports.TransformDecodeError = TransformDecodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
    } catch (error2) {
      throw new TransformDecodeError(schema, path, value, error2);
    }
  }
  function FromArray(schema, references, path, value) {
    return (0, index_6.IsArray)(value) ? Default(schema, path, value.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
  }
  function FromIntersect(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return Default(schema, path, value);
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...value };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromNot(schema, references, path, value) {
    return Default(schema, path, Visit(schema.not, references, path, value));
  }
  function FromObject(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...value };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRecord(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...value };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromTuple(schema, references, path, value) {
    return (0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const decoded = Visit(subschema, references, path, value);
      return Default(schema, path, decoded);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "Symbol":
        return Default(schema_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformDecode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js
var require_encode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeError = exports.TransformEncodeCheckError = undefined;
  exports.TransformEncode = TransformEncode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformEncodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error2) {
      super(`The encoded value does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error2;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError;

  class TransformEncodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error2) {
      super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error2;
    }
  }
  exports.TransformEncodeError = TransformEncodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    } catch (error2) {
      throw new TransformEncodeError(schema, path, value, error2);
    }
  }
  function FromArray(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    return (0, index_6.IsArray)(defaulted) ? defaulted.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2)) : defaulted;
  }
  function FromIntersect(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return defaulted;
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...defaulted };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromNot(schema, references, path, value) {
    return Default(schema.not, path, Default(schema, path, value));
  }
  function FromObject(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(defaulted))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...defaulted };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRecord(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value))
      return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...defaulted };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromTuple(schema, references, path, value) {
    const value1 = Default(schema, path, value);
    return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value1[index])) : [];
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const value1 = Visit(subschema, references, path, value);
      return Default(schema, path, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit(subschema, references, path, value);
      if (!(0, index_5.Check)(schema, references, value1))
        continue;
      return Default(schema, path, value1);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformEncode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/has.js
var require_has = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HasTransform = HasTransform;
  var index_1 = require_deref2();
  var index_2 = require_symbols2();
  var type_1 = require_type3();
  var index_3 = require_guard2();
  function FromArray(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromAsyncIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromConstructor(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromFunction(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromIntersect(schema, references) {
    return (0, type_1.IsTransform)(schema) || (0, type_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
  }
  function FromIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromNot(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.not, references);
  }
  function FromObject(schema, references) {
    return (0, type_1.IsTransform)(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || (0, type_1.IsSchema)(schema.additionalProperties) && Visit(schema.additionalProperties, references);
  }
  function FromPromise(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.item, references);
  }
  function FromRecord(schema, references) {
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern];
    return (0, type_1.IsTransform)(schema) || Visit(property, references) || (0, type_1.IsSchema)(schema.additionalProperties) && (0, type_1.IsTransform)(schema.additionalProperties);
  }
  function FromRef(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromThis(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromTuple(schema, references) {
    return (0, type_1.IsTransform)(schema) || !(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
  }
  function FromUnion(schema, references) {
    return (0, type_1.IsTransform)(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
  }
  function Visit(schema, references) {
    const references_ = (0, index_3.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
      return false;
    if (schema.$id)
      visited.add(schema.$id);
    switch (schema[index_2.Kind]) {
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      default:
        return (0, type_1.IsTransform)(schema);
    }
  }
  var visited = new Set;
  function HasTransform(schema, references) {
    visited.clear();
    return Visit(schema, references);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/index.js
var require_transform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_decode(), exports);
  __exportStar(require_encode(), exports);
  __exportStar(require_has(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/value/value.js
var require_value3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = Cast;
  exports.Create = Create;
  exports.Check = Check;
  exports.Clean = Clean;
  exports.Convert = Convert;
  exports.Clone = Clone;
  exports.Decode = Decode;
  exports.Default = Default;
  exports.Encode = Encode;
  exports.Errors = Errors;
  exports.Equal = Equal;
  exports.Diff = Diff;
  exports.Hash = Hash;
  exports.Patch = Patch;
  exports.Mutate = Mutate;
  var index_1 = require_transform();
  var index_2 = require_mutate2();
  var index_3 = require_hash2();
  var index_4 = require_equal2();
  var index_5 = require_cast2();
  var index_6 = require_clone2();
  var index_7 = require_convert2();
  var index_8 = require_create2();
  var index_9 = require_clean2();
  var index_10 = require_check2();
  var index_11 = require_default2();
  var index_12 = require_delta2();
  var index_13 = require_errors2();
  function Cast(...args) {
    return index_5.Cast.apply(index_5.Cast, args);
  }
  function Create(...args) {
    return index_8.Create.apply(index_8.Create, args);
  }
  function Check(...args) {
    return index_10.Check.apply(index_10.Check, args);
  }
  function Clean(...args) {
    return index_9.Clean.apply(index_9.Clean, args);
  }
  function Convert(...args) {
    return index_7.Convert.apply(index_7.Convert, args);
  }
  function Clone(value) {
    return (0, index_6.Clone)(value);
  }
  function Decode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check(schema, references, value))
      throw new index_1.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
    return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
  }
  function Default(...args) {
    return index_11.Default.apply(index_11.Default, args);
  }
  function Encode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
    if (!Check(schema, references, encoded))
      throw new index_1.TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
    return encoded;
  }
  function Errors(...args) {
    return index_13.Errors.apply(index_13.Errors, args);
  }
  function Equal(left, right) {
    return (0, index_4.Equal)(left, right);
  }
  function Diff(current, next) {
    return (0, index_12.Diff)(current, next);
  }
  function Hash(value) {
    return (0, index_3.Hash)(value);
  }
  function Patch(current, edits) {
    return (0, index_12.Patch)(current, edits);
  }
  function Mutate(current, next) {
    (0, index_2.Mutate)(current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/value/index.js
var require_value4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  exports.Value = require_value3();
});

// node_modules/@sinclair/typebox/build/cjs/value/index.js
var require_value5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_guard2(), exports);
  __exportStar(require_cast2(), exports);
  __exportStar(require_check2(), exports);
  __exportStar(require_clean2(), exports);
  __exportStar(require_clone2(), exports);
  __exportStar(require_convert2(), exports);
  __exportStar(require_create2(), exports);
  __exportStar(require_default2(), exports);
  __exportStar(require_delta2(), exports);
  __exportStar(require_equal2(), exports);
  __exportStar(require_hash2(), exports);
  __exportStar(require_mutate2(), exports);
  __exportStar(require_pointer2(), exports);
  __exportStar(require_transform(), exports);
  var index_2 = require_value4();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return index_2.Value;
  } });
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/safe-parse-type.js
var require_safe_parse_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "safeParseType", {
    enumerable: true,
    get: function() {
      return safeParseType;
    }
  });
  var _value = require_value5();
  function safeParseType(schema, value) {
    const parsedValue = _value.Value.Convert(schema, _value.Value.Clean(schema, _value.Value.Default(schema, structuredClone(value))));
    if (!_value.Value.Check(schema, parsedValue)) {
      const typeboxErrors = _value.Value.Errors(schema, parsedValue);
      const errors2 = {};
      for (const typeboxError of typeboxErrors) {
        errors2[typeboxError.path] = typeboxError.message;
      }
      return {
        success: false,
        errors: errors2
      };
    }
    return {
      success: true,
      data: parsedValue
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_type2(), exports);
  __exportStar(require_value2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Increment = Increment;
  function Increment(T) {
    return (parseInt(T) + 1).toString();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_helpers(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Awaited = Awaited;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => AwaitedResolve(L));
  }
  function FromIntersect(T) {
    return (0, index_1.Intersect)(FromRest(T));
  }
  function FromUnion(T) {
    return (0, index_2.Union)(FromRest(T));
  }
  function FromPromise(T) {
    return AwaitedResolve(T);
  }
  function AwaitedResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsPromise)(T) ? FromPromise(T.item) : T;
  }
  function Awaited(T, options = {}) {
    return (0, type_1.CloneType)(AwaitedResolve(T), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_awaited(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composite = Composite;
  var index_1 = require_intersect2();
  var index_2 = require_indexed2();
  var index_3 = require_keyof2();
  var index_4 = require_object2();
  var index_5 = require_sets();
  var kind_1 = require_kind();
  function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
  }
  function FilterNever(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever(Acc);
  }
  function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
      Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
    }
    return Acc;
  }
  function Composite(T, options = {}) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_composite(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Date = Date2;
  var index_1 = require_symbols2();
  function Date2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Date",
      type: "Date"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_date(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Null = Null;
  var index_1 = require_symbols2();
  function Null(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Null",
      type: "null"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_null(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Symbol = Symbol2;
  var index_1 = require_symbols2();
  function Symbol2(options) {
    return { ...options, [index_1.Kind]: "Symbol", type: "symbol" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbol(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Undefined = Undefined;
  var index_1 = require_symbols2();
  function Undefined(options = {}) {
    return { ...options, [index_1.Kind]: "Undefined", type: "undefined" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_undefined(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8Array = Uint8Array2;
  var index_1 = require_symbols2();
  function Uint8Array2(options = {}) {
    return { ...options, [index_1.Kind]: "Uint8Array", type: "Uint8Array" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_uint8array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Const = Const;
  var index_1 = require_any2();
  var index_2 = require_bigint2();
  var index_3 = require_date2();
  var index_4 = require_function2();
  var index_5 = require_literal2();
  var index_6 = require_null2();
  var index_7 = require_object2();
  var index_8 = require_symbol2();
  var index_9 = require_tuple2();
  var index_10 = require_readonly2();
  var index_11 = require_undefined2();
  var index_12 = require_uint8array2();
  var index_13 = require_unknown2();
  var index_14 = require_clone3();
  var value_1 = require_value();
  function FromArray(T) {
    return T.map((L) => FromValue(L, false));
  }
  function FromProperties(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
      Acc[K] = (0, index_10.Readonly)(FromValue(value[K], false));
    return Acc;
  }
  function ConditionalReadonly(T, root) {
    return root === true ? T : (0, index_10.Readonly)(T);
  }
  function FromValue(value, root) {
    return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value)), root) : (0, value_1.IsFunction)(value) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
  }
  function Const(T, options = {}) {
    return (0, index_14.CloneType)(FromValue(T, true), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_const(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConstructorParameters = ConstructorParameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function ConstructorParameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js
var require_deref3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = Deref;
  var type_1 = require_type2();
  var index_1 = require_discard2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function FromRest(schema, references) {
    return schema.map((schema2) => Deref(schema2, references));
  }
  function FromProperties(properties, references) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
      Acc[K] = Deref(properties[K], references);
    }
    return Acc;
  }
  function FromConstructor(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromFunction(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromIntersect(schema, references) {
    schema.allOf = FromRest(schema.allOf, references);
    return schema;
  }
  function FromUnion(schema, references) {
    schema.anyOf = FromRest(schema.anyOf, references);
    return schema;
  }
  function FromTuple(schema, references) {
    if ((0, value_1.IsUndefined)(schema.items))
      return schema;
    schema.items = FromRest(schema.items, references);
    return schema;
  }
  function FromArray(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromObject(schema, references) {
    schema.properties = FromProperties(schema.properties, references);
    return schema;
  }
  function FromPromise(schema, references) {
    schema.item = Deref(schema.item, references);
    return schema;
  }
  function FromAsyncIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromRef(schema, references) {
    const target = references.find((remote) => remote.$id === schema.$ref);
    if (target === undefined)
      throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
    const discard = (0, index_1.Discard)(target, ["$id"]);
    return Deref(discard, references);
  }
  function DerefResolve(schema, references) {
    return (0, kind_1.IsConstructor)(schema) ? FromConstructor(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef(schema, references) : schema;
  }
  function Deref(schema, references) {
    return DerefResolve((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/index.js
var require_deref4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Enum = Enum;
  var index_1 = require_literal2();
  var index_2 = require_symbols2();
  var index_3 = require_union2();
  var value_1 = require_value();
  function Enum(item, options = {}) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => (0, index_1.Literal)(value));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_enum(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
  var exclude_1 = require_exclude();
  var index_1 = require_template_literal2();
  function ExcludeFromTemplateLiteral(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Exclude = Exclude;
  var index_1 = require_union2();
  var index_2 = require_never3();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
  var exclude_from_template_literal_1 = require_exclude_from_template_literal();
  var kind_1 = require_kind();
  function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  }
  function Exclude(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromMappedResult = ExcludeFromMappedResult;
  var index_1 = require_mapped2();
  var exclude_1 = require_exclude();
  function FromProperties(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_exclude_from_mapped_result(), exports);
  __exportStar(require_exclude_from_template_literal(), exports);
  __exportStar(require_exclude(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
  var extract_1 = require_extract();
  var index_1 = require_template_literal2();
  function ExtractFromTemplateLiteral(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extract = Extract;
  var index_1 = require_union2();
  var index_2 = require_never3();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var extract_from_mapped_result_1 = require_extract_from_mapped_result();
  var extract_from_template_literal_1 = require_extract_from_template_literal();
  var kind_1 = require_kind();
  function ExtractRest(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  }
  function Extract(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromMappedResult = ExtractFromMappedResult;
  var index_1 = require_mapped2();
  var extract_1 = require_extract();
  function FromProperties(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extract_from_mapped_result(), exports);
  __exportStar(require_extract_from_template_literal(), exports);
  __exportStar(require_extract(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstanceType = InstanceType;
  var type_1 = require_type2();
  function InstanceType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instance_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integer = Integer;
  var index_1 = require_symbols2();
  function Integer(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Integer",
      type: "integer"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_integer(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
  var index_1 = require_mapped2();
  var intrinsic_1 = require_intrinsic();
  var index_2 = require_literal2();
  function MappedIntrinsicPropertyKey(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, options)
    };
  }
  function MappedIntrinsicPropertyKeys(K, M, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
  }
  function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T["keys"], M, options);
  }
  function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intrinsic = Intrinsic;
  var index_1 = require_template_literal2();
  var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
  var index_2 = require_literal2();
  var index_3 = require_union2();
  var kind_1 = require_kind();
  function ApplyUncapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join("");
  }
  function ApplyCapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join("");
  }
  function ApplyUppercase(value) {
    return value.toUpperCase();
  }
  function ApplyLowercase(value) {
    return value.toLowerCase();
  }
  function FromTemplateLiteral(schema, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
    const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite)
      return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value) => (0, index_2.Literal)(value));
    const mapped = FromRest(literals, mode);
    const union2 = (0, index_3.Union)(mapped);
    return (0, index_1.TemplateLiteral)([union2], options);
  }
  function FromLiteralValue(value, mode) {
    return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
  }
  function FromRest(T, M) {
    return T.map((L) => Intrinsic(L, M));
  }
  function Intrinsic(schema, mode, options = {}) {
    return (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, schema) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Capitalize = Capitalize;
  var intrinsic_1 = require_intrinsic();
  function Capitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Lowercase = Lowercase;
  var intrinsic_1 = require_intrinsic();
  function Lowercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uncapitalize = Uncapitalize;
  var intrinsic_1 = require_intrinsic();
  function Uncapitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uppercase = Uppercase;
  var intrinsic_1 = require_intrinsic();
  function Uppercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_capitalize(), exports);
  __exportStar(require_intrinsic_from_mapped_key(), exports);
  __exportStar(require_intrinsic(), exports);
  __exportStar(require_lowercase(), exports);
  __exportStar(require_uncapitalize(), exports);
  __exportStar(require_uppercase(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Not = Not;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Not(schema, options) {
    return {
      ...options,
      [index_1.Kind]: "Not",
      not: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_not2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedResult = OmitFromMappedResult;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, omit_1.Omit)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function OmitFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Omit = Omit;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var omit_from_mapped_key_1 = require_omit_from_mapped_key();
  var omit_from_mapped_result_1 = require_omit_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromProperty(T, K) {
    const { [K]: _, ...R } = T;
    return R;
  }
  function FromProperties(T, K) {
    return K.reduce((T2, K2) => FromProperty(T2, K2), T);
  }
  function OmitResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Omit(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(OmitResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedKey = OmitFromMappedKey;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, omit_1.Omit)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function OmitFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_omit_from_mapped_key(), exports);
  __exportStar(require_omit_from_mapped_result(), exports);
  __exportStar(require_omit(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parameters = Parameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function Parameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Partial = Partial;
  var index_1 = require_optional2();
  var index_2 = require_object2();
  var index_3 = require_intersect2();
  var index_4 = require_union2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var partial_from_mapped_result_1 = require_partial_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => PartialResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_1.Optional)(T[K]);
    return Acc;
  }
  function PartialResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_4.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_2.Object)(FromProperties(T.properties)) : (0, index_2.Object)({});
  }
  function Partial(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T))
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PartialResolve(T), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PartialFromMappedResult = PartialFromMappedResult;
  var index_1 = require_mapped2();
  var partial_1 = require_partial();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, partial_1.Partial)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function PartialFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_partial_from_mapped_result(), exports);
  __exportStar(require_partial(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedResult = PickFromMappedResult;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, pick_1.Pick)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function PickFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pick = Pick;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var pick_from_mapped_key_1 = require_pick_from_mapped_key();
  var pick_from_mapped_result_1 = require_pick_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromProperties(T, K) {
    const Acc = {};
    for (const K2 of K)
      if (K2 in T)
        Acc[K2] = T[K2];
    return Acc;
  }
  function PickResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Pick(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PickResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedKey = PickFromMappedKey;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, pick_1.Pick)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function PickFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_pick_from_mapped_key(), exports);
  __exportStar(require_pick_from_mapped_result(), exports);
  __exportStar(require_pick(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyOptional = ReadonlyOptional;
  var index_1 = require_readonly2();
  var index_2 = require_optional2();
  function ReadonlyOptional(schema) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Record = Record;
  var index_1 = require_object2();
  var index_2 = require_never3();
  var index_3 = require_union2();
  var index_4 = require_template_literal2();
  var index_5 = require_patterns2();
  var index_6 = require_indexed2();
  var index_7 = require_symbols2();
  var type_1 = require_type2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function RecordCreateFromPattern(pattern, T, options) {
    return {
      ...options,
      [index_7.Kind]: "Record",
      type: "object",
      patternProperties: { [pattern]: (0, type_1.CloneType)(T) }
    };
  }
  function RecordCreateFromKeys(K, T, options) {
    const Acc = {};
    for (const K2 of K)
      Acc[K2] = (0, type_1.CloneType)(T);
    return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
  }
  function FromTemplateLiteralKey(K, T, options) {
    return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
  }
  function FromUnionKey(K, T, options) {
    return RecordCreateFromKeys((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
  }
  function FromLiteralKey(K, T, options) {
    return RecordCreateFromKeys([K.toString()], T, options);
  }
  function FromRegExpKey(K, T, options) {
    return RecordCreateFromPattern(K.source, T, options);
  }
  function FromStringKey(K, T, options) {
    const pattern = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
    return RecordCreateFromPattern(pattern, T, options);
  }
  function FromAnyKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternStringExact, T, options);
  }
  function FromNeverKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternNeverExact, T, options);
  }
  function FromIntegerKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function FromNumberKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function Record(K, T, options = {}) {
    return (0, kind_1.IsUnion)(K) ? FromUnionKey(K.anyOf, T, options) : (0, kind_1.IsTemplateLiteral)(K) ? FromTemplateLiteralKey(K, T, options) : (0, kind_1.IsLiteral)(K) ? FromLiteralKey(K.const, T, options) : (0, kind_1.IsInteger)(K) ? FromIntegerKey(K, T, options) : (0, kind_1.IsNumber)(K) ? FromNumberKey(K, T, options) : (0, kind_1.IsRegExp)(K) ? FromRegExpKey(K, T, options) : (0, kind_1.IsString)(K) ? FromStringKey(K, T, options) : (0, kind_1.IsAny)(K) ? FromAnyKey(K, T, options) : (0, kind_1.IsNever)(K) ? FromNeverKey(K, T, options) : (0, index_2.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_record(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Recursive = Recursive;
  var type_1 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  var Ordinal = 0;
  function Recursive(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal++}`;
    const thisType = callback({ [index_1.Kind]: "This", $ref: `${options.$id}` });
    thisType.$id = options.$id;
    return (0, type_1.CloneType)({ ...options, [index_1.Hint]: "Recursive", ...thisType });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_recursive(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ref = Ref;
  var index_1 = require_symbols2();
  var value_1 = require_value();
  function Ref(unresolved, options = {}) {
    if ((0, value_1.IsString)(unresolved))
      return { ...options, [index_1.Kind]: "Ref", $ref: unresolved };
    if ((0, value_1.IsUndefined)(unresolved.$id))
      throw new Error("Reference target type must specify an $id");
    return {
      ...options,
      [index_1.Kind]: "Ref",
      $ref: unresolved.$id
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RegExp = RegExp2;
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function RegExp2(unresolved, options = {}) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return { ...options, [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_regexp(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Required = Required;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_symbols2();
  var type_1 = require_type2();
  var index_5 = require_discard2();
  var required_from_mapped_result_1 = require_required_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => RequiredResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_5.Discard)(T[K], [index_4.OptionalKind]);
    return Acc;
  }
  function RequiredResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties)) : (0, index_3.Object)({});
  }
  function Required(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
    } else {
      const D = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required"]);
      const R = (0, type_1.CloneType)(RequiredResolve(T), options);
      return { ...D, ...R };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequiredFromMappedResult = RequiredFromMappedResult;
  var index_1 = require_mapped2();
  var required_1 = require_required();
  function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_required_from_mapped_result(), exports);
  __exportStar(require_required(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Rest = Rest;
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function RestResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, type_1.CloneRest)(T.allOf) : (0, kind_1.IsUnion)(T) ? (0, type_1.CloneRest)(T.anyOf) : (0, kind_1.IsTuple)(T) ? (0, type_1.CloneRest)(T.items ?? []) : [];
  }
  function Rest(T) {
    return (0, type_1.CloneRest)(RestResolve(T));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_rest(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReturnType = ReturnType;
  var type_1 = require_type2();
  function ReturnType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_return_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_anyschema(), exports);
  __exportStar(require_schema(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_static(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js
var require_strict = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = Strict;
  function Strict(schema) {
    return JSON.parse(JSON.stringify(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/index.js
var require_strict2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_strict(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = undefined;
  exports.Transform = Transform;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();

  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    EncodeTransform(encode, schema) {
      const Encode = (value) => schema[index_1.TransformKind].Encode(encode(value));
      const Decode = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
      const Codec = { Encode, Decode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode, schema) {
      const Codec = { Decode: this.decode, Encode: encode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    Encode(encode) {
      const schema = (0, type_1.CloneType)(this.schema);
      return (0, kind_1.IsTransform)(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema);
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  function Transform(schema) {
    return new TransformDecodeBuilder(schema);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_transform2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Void = Void;
  var index_1 = require_symbols2();
  function Void(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Void",
      type: "void"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_void(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTypeBuilder = undefined;
  var index_1 = require_any2();
  var index_2 = require_array2();
  var index_3 = require_boolean2();
  var index_4 = require_composite2();
  var index_5 = require_const2();
  var index_6 = require_deref4();
  var index_7 = require_enum2();
  var index_8 = require_exclude2();
  var index_9 = require_extends2();
  var index_10 = require_extract2();
  var index_11 = require_indexed2();
  var index_12 = require_integer2();
  var index_13 = require_intersect2();
  var index_14 = require_intrinsic2();
  var index_15 = require_keyof2();
  var index_16 = require_literal2();
  var index_17 = require_mapped2();
  var index_18 = require_never3();
  var index_19 = require_not3();
  var index_20 = require_null2();
  var index_21 = require_number2();
  var index_22 = require_object2();
  var index_23 = require_omit2();
  var index_24 = require_optional2();
  var index_25 = require_partial2();
  var index_26 = require_pick2();
  var index_27 = require_readonly2();
  var index_28 = require_readonly_optional2();
  var index_29 = require_record2();
  var index_30 = require_recursive2();
  var index_31 = require_ref2();
  var index_32 = require_required2();
  var index_33 = require_rest2();
  var index_34 = require_strict2();
  var index_35 = require_string2();
  var index_36 = require_template_literal2();
  var index_37 = require_transform3();
  var index_38 = require_tuple2();
  var index_39 = require_union2();
  var index_40 = require_unknown2();
  var index_41 = require_unsafe2();

  class JsonTypeBuilder {
    Strict(schema) {
      return (0, index_34.Strict)(schema);
    }
    ReadonlyOptional(schema) {
      return (0, index_28.ReadonlyOptional)(schema);
    }
    Readonly(schema, enable) {
      return (0, index_27.Readonly)(schema, enable ?? true);
    }
    Optional(schema, enable) {
      return (0, index_24.Optional)(schema, enable ?? true);
    }
    Any(options = {}) {
      return (0, index_1.Any)(options);
    }
    Array(schema, options = {}) {
      return (0, index_2.Array)(schema, options);
    }
    Boolean(options = {}) {
      return (0, index_3.Boolean)(options);
    }
    Capitalize(schema, options = {}) {
      return (0, index_14.Capitalize)(schema, options);
    }
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    Const(value, options = {}) {
      return (0, index_5.Const)(value, options);
    }
    Deref(schema, references) {
      return (0, index_6.Deref)(schema, references);
    }
    Enum(item, options = {}) {
      return (0, index_7.Enum)(item, options);
    }
    Exclude(unionType2, excludedMembers, options = {}) {
      return (0, index_8.Exclude)(unionType2, excludedMembers, options);
    }
    Extends(L, R, T, F, options = {}) {
      return (0, index_9.Extends)(L, R, T, F, options);
    }
    Extract(type, union2, options = {}) {
      return (0, index_10.Extract)(type, union2, options);
    }
    Index(schema, unresolved, options = {}) {
      return (0, index_11.Index)(schema, unresolved, options);
    }
    Integer(options = {}) {
      return (0, index_12.Integer)(options);
    }
    Intersect(T, options = {}) {
      return (0, index_13.Intersect)(T, options);
    }
    KeyOf(schema, options = {}) {
      return (0, index_15.KeyOf)(schema, options);
    }
    Literal(value, options = {}) {
      return (0, index_16.Literal)(value, options);
    }
    Lowercase(schema, options = {}) {
      return (0, index_14.Lowercase)(schema, options);
    }
    Mapped(key, map, options = {}) {
      return (0, index_17.Mapped)(key, map, options);
    }
    Never(options = {}) {
      return (0, index_18.Never)(options);
    }
    Not(schema, options) {
      return (0, index_19.Not)(schema, options);
    }
    Null(options = {}) {
      return (0, index_20.Null)(options);
    }
    Number(options = {}) {
      return (0, index_21.Number)(options);
    }
    Object(properties, options = {}) {
      return (0, index_22.Object)(properties, options);
    }
    Omit(schema, unresolved, options = {}) {
      return (0, index_23.Omit)(schema, unresolved, options);
    }
    Partial(schema, options = {}) {
      return (0, index_25.Partial)(schema, options);
    }
    Pick(schema, unresolved, options = {}) {
      return (0, index_26.Pick)(schema, unresolved, options);
    }
    Record(key, schema, options = {}) {
      return (0, index_29.Record)(key, schema, options);
    }
    Recursive(callback, options = {}) {
      return (0, index_30.Recursive)(callback, options);
    }
    Ref(unresolved, options = {}) {
      return (0, index_31.Ref)(unresolved, options);
    }
    Required(schema, options = {}) {
      return (0, index_32.Required)(schema, options);
    }
    Rest(schema) {
      return (0, index_33.Rest)(schema);
    }
    String(options = {}) {
      return (0, index_35.String)(options);
    }
    TemplateLiteral(unresolved, options = {}) {
      return (0, index_36.TemplateLiteral)(unresolved, options);
    }
    Transform(schema) {
      return (0, index_37.Transform)(schema);
    }
    Tuple(items, options = {}) {
      return (0, index_38.Tuple)(items, options);
    }
    Uncapitalize(schema, options = {}) {
      return (0, index_14.Uncapitalize)(schema, options);
    }
    Union(schemas, options = {}) {
      return (0, index_39.Union)(schemas, options);
    }
    Unknown(options = {}) {
      return (0, index_40.Unknown)(options);
    }
    Unsafe(options = {}) {
      return (0, index_41.Unsafe)(options);
    }
    Uppercase(schema, options = {}) {
      return (0, index_14.Uppercase)(schema, options);
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = exports.ReturnType = exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Deref = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Any = undefined;
  exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = undefined;
  var index_1 = require_any2();
  Object.defineProperty(exports, "Any", { enumerable: true, get: function() {
    return index_1.Any;
  } });
  var index_2 = require_array2();
  Object.defineProperty(exports, "Array", { enumerable: true, get: function() {
    return index_2.Array;
  } });
  var index_3 = require_async_iterator2();
  Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function() {
    return index_3.AsyncIterator;
  } });
  var index_4 = require_awaited2();
  Object.defineProperty(exports, "Awaited", { enumerable: true, get: function() {
    return index_4.Awaited;
  } });
  var index_5 = require_bigint2();
  Object.defineProperty(exports, "BigInt", { enumerable: true, get: function() {
    return index_5.BigInt;
  } });
  var index_6 = require_boolean2();
  Object.defineProperty(exports, "Boolean", { enumerable: true, get: function() {
    return index_6.Boolean;
  } });
  var index_7 = require_composite2();
  Object.defineProperty(exports, "Composite", { enumerable: true, get: function() {
    return index_7.Composite;
  } });
  var index_8 = require_const2();
  Object.defineProperty(exports, "Const", { enumerable: true, get: function() {
    return index_8.Const;
  } });
  var index_9 = require_constructor2();
  Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
    return index_9.Constructor;
  } });
  var index_10 = require_constructor_parameters2();
  Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function() {
    return index_10.ConstructorParameters;
  } });
  var index_11 = require_date2();
  Object.defineProperty(exports, "Date", { enumerable: true, get: function() {
    return index_11.Date;
  } });
  var index_12 = require_deref4();
  Object.defineProperty(exports, "Deref", { enumerable: true, get: function() {
    return index_12.Deref;
  } });
  var index_13 = require_enum2();
  Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
    return index_13.Enum;
  } });
  var index_14 = require_exclude2();
  Object.defineProperty(exports, "Exclude", { enumerable: true, get: function() {
    return index_14.Exclude;
  } });
  var index_15 = require_extends2();
  Object.defineProperty(exports, "Extends", { enumerable: true, get: function() {
    return index_15.Extends;
  } });
  var index_16 = require_extract2();
  Object.defineProperty(exports, "Extract", { enumerable: true, get: function() {
    return index_16.Extract;
  } });
  var index_17 = require_function2();
  Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
    return index_17.Function;
  } });
  var index_18 = require_indexed2();
  Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
    return index_18.Index;
  } });
  var index_19 = require_instance_type2();
  Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function() {
    return index_19.InstanceType;
  } });
  var index_20 = require_integer2();
  Object.defineProperty(exports, "Integer", { enumerable: true, get: function() {
    return index_20.Integer;
  } });
  var index_21 = require_intersect2();
  Object.defineProperty(exports, "Intersect", { enumerable: true, get: function() {
    return index_21.Intersect;
  } });
  var index_22 = require_intrinsic2();
  Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function() {
    return index_22.Capitalize;
  } });
  Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function() {
    return index_22.Uncapitalize;
  } });
  Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function() {
    return index_22.Lowercase;
  } });
  Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function() {
    return index_22.Uppercase;
  } });
  var index_23 = require_iterator3();
  Object.defineProperty(exports, "Iterator", { enumerable: true, get: function() {
    return index_23.Iterator;
  } });
  var index_24 = require_keyof2();
  Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function() {
    return index_24.KeyOf;
  } });
  var index_25 = require_literal2();
  Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
    return index_25.Literal;
  } });
  var index_26 = require_mapped2();
  Object.defineProperty(exports, "Mapped", { enumerable: true, get: function() {
    return index_26.Mapped;
  } });
  var index_27 = require_never3();
  Object.defineProperty(exports, "Never", { enumerable: true, get: function() {
    return index_27.Never;
  } });
  var index_28 = require_not3();
  Object.defineProperty(exports, "Not", { enumerable: true, get: function() {
    return index_28.Not;
  } });
  var index_29 = require_null2();
  Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
    return index_29.Null;
  } });
  var index_30 = require_number2();
  Object.defineProperty(exports, "Number", { enumerable: true, get: function() {
    return index_30.Number;
  } });
  var index_31 = require_object2();
  Object.defineProperty(exports, "Object", { enumerable: true, get: function() {
    return index_31.Object;
  } });
  var index_32 = require_omit2();
  Object.defineProperty(exports, "Omit", { enumerable: true, get: function() {
    return index_32.Omit;
  } });
  var index_33 = require_optional2();
  Object.defineProperty(exports, "Optional", { enumerable: true, get: function() {
    return index_33.Optional;
  } });
  var index_34 = require_parameters2();
  Object.defineProperty(exports, "Parameters", { enumerable: true, get: function() {
    return index_34.Parameters;
  } });
  var index_35 = require_partial2();
  Object.defineProperty(exports, "Partial", { enumerable: true, get: function() {
    return index_35.Partial;
  } });
  var index_36 = require_pick2();
  Object.defineProperty(exports, "Pick", { enumerable: true, get: function() {
    return index_36.Pick;
  } });
  var index_37 = require_promise2();
  Object.defineProperty(exports, "Promise", { enumerable: true, get: function() {
    return index_37.Promise;
  } });
  var index_38 = require_readonly2();
  Object.defineProperty(exports, "Readonly", { enumerable: true, get: function() {
    return index_38.Readonly;
  } });
  var index_39 = require_readonly_optional2();
  Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function() {
    return index_39.ReadonlyOptional;
  } });
  var index_40 = require_record2();
  Object.defineProperty(exports, "Record", { enumerable: true, get: function() {
    return index_40.Record;
  } });
  var index_41 = require_recursive2();
  Object.defineProperty(exports, "Recursive", { enumerable: true, get: function() {
    return index_41.Recursive;
  } });
  var index_42 = require_ref2();
  Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
    return index_42.Ref;
  } });
  var index_43 = require_regexp2();
  Object.defineProperty(exports, "RegExp", { enumerable: true, get: function() {
    return index_43.RegExp;
  } });
  var index_44 = require_required2();
  Object.defineProperty(exports, "Required", { enumerable: true, get: function() {
    return index_44.Required;
  } });
  var index_45 = require_rest2();
  Object.defineProperty(exports, "Rest", { enumerable: true, get: function() {
    return index_45.Rest;
  } });
  var index_46 = require_return_type2();
  Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function() {
    return index_46.ReturnType;
  } });
  var index_47 = require_strict2();
  Object.defineProperty(exports, "Strict", { enumerable: true, get: function() {
    return index_47.Strict;
  } });
  var index_48 = require_string2();
  Object.defineProperty(exports, "String", { enumerable: true, get: function() {
    return index_48.String;
  } });
  var index_49 = require_symbol2();
  Object.defineProperty(exports, "Symbol", { enumerable: true, get: function() {
    return index_49.Symbol;
  } });
  var index_50 = require_template_literal2();
  Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function() {
    return index_50.TemplateLiteral;
  } });
  var index_51 = require_transform3();
  Object.defineProperty(exports, "Transform", { enumerable: true, get: function() {
    return index_51.Transform;
  } });
  var index_52 = require_tuple2();
  Object.defineProperty(exports, "Tuple", { enumerable: true, get: function() {
    return index_52.Tuple;
  } });
  var index_53 = require_uint8array2();
  Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function() {
    return index_53.Uint8Array;
  } });
  var index_54 = require_undefined2();
  Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
    return index_54.Undefined;
  } });
  var index_55 = require_union2();
  Object.defineProperty(exports, "Union", { enumerable: true, get: function() {
    return index_55.Union;
  } });
  var index_56 = require_unknown2();
  Object.defineProperty(exports, "Unknown", { enumerable: true, get: function() {
    return index_56.Unknown;
  } });
  var index_57 = require_unsafe2();
  Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function() {
    return index_57.Unsafe;
  } });
  var index_58 = require_void2();
  Object.defineProperty(exports, "Void", { enumerable: true, get: function() {
    return index_58.Void;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JavaScriptTypeBuilder = undefined;
  var json_1 = require_json();
  var index_1 = require_async_iterator2();
  var index_2 = require_awaited2();
  var index_3 = require_bigint2();
  var index_4 = require_constructor2();
  var index_5 = require_constructor_parameters2();
  var index_6 = require_date2();
  var index_7 = require_function2();
  var index_8 = require_instance_type2();
  var index_9 = require_iterator3();
  var index_10 = require_parameters2();
  var index_11 = require_promise2();
  var index_12 = require_regexp2();
  var index_13 = require_return_type2();
  var index_14 = require_symbol2();
  var index_15 = require_uint8array2();
  var index_16 = require_undefined2();
  var index_17 = require_void2();

  class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return (0, index_1.AsyncIterator)(items, options);
    }
    Awaited(schema, options = {}) {
      return (0, index_2.Awaited)(schema, options);
    }
    BigInt(options = {}) {
      return (0, index_3.BigInt)(options);
    }
    ConstructorParameters(schema, options = {}) {
      return (0, index_5.ConstructorParameters)(schema, options);
    }
    Constructor(parameters, returns, options) {
      return (0, index_4.Constructor)(parameters, returns, options);
    }
    Date(options = {}) {
      return (0, index_6.Date)(options);
    }
    Function(parameters, returns, options) {
      return (0, index_7.Function)(parameters, returns, options);
    }
    InstanceType(schema, options = {}) {
      return (0, index_8.InstanceType)(schema, options);
    }
    Iterator(items, options = {}) {
      return (0, index_9.Iterator)(items, options);
    }
    Parameters(schema, options = {}) {
      return (0, index_10.Parameters)(schema, options);
    }
    Promise(item, options = {}) {
      return (0, index_11.Promise)(item, options);
    }
    RegExp(unresolved, options = {}) {
      return (0, index_12.RegExp)(unresolved, options);
    }
    ReturnType(schema, options = {}) {
      return (0, index_13.ReturnType)(schema, options);
    }
    Symbol(options) {
      return (0, index_14.Symbol)(options);
    }
    Undefined(options = {}) {
      return (0, index_16.Undefined)(options);
    }
    Uint8Array(options = {}) {
      return (0, index_15.Uint8Array)(options);
    }
    Void(options = {}) {
      return (0, index_17.Void)(options);
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = undefined;
  var json_1 = require_json();
  Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function() {
    return json_1.JsonTypeBuilder;
  } });
  var TypeBuilder = require_type4();
  var javascript_1 = require_javascript();
  Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
    return javascript_1.JavaScriptTypeBuilder;
  } });
  var Type = TypeBuilder;
  exports.Type = Type;
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m, k);
    if (!desc2 || ("get" in desc2 ? !m.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone3(), exports);
  __exportStar(require_error2(), exports);
  __exportStar(require_guard3(), exports);
  __exportStar(require_helpers2(), exports);
  __exportStar(require_patterns2(), exports);
  __exportStar(require_registry(), exports);
  __exportStar(require_sets(), exports);
  __exportStar(require_symbols2(), exports);
  __exportStar(require_any2(), exports);
  __exportStar(require_array2(), exports);
  __exportStar(require_async_iterator2(), exports);
  __exportStar(require_awaited2(), exports);
  __exportStar(require_bigint2(), exports);
  __exportStar(require_boolean2(), exports);
  __exportStar(require_composite2(), exports);
  __exportStar(require_const2(), exports);
  __exportStar(require_constructor2(), exports);
  __exportStar(require_constructor_parameters2(), exports);
  __exportStar(require_date2(), exports);
  __exportStar(require_deref4(), exports);
  __exportStar(require_enum2(), exports);
  __exportStar(require_exclude2(), exports);
  __exportStar(require_extends2(), exports);
  __exportStar(require_extract2(), exports);
  __exportStar(require_function2(), exports);
  __exportStar(require_indexed2(), exports);
  __exportStar(require_instance_type2(), exports);
  __exportStar(require_integer2(), exports);
  __exportStar(require_intersect2(), exports);
  __exportStar(require_iterator3(), exports);
  __exportStar(require_intrinsic2(), exports);
  __exportStar(require_keyof2(), exports);
  __exportStar(require_literal2(), exports);
  __exportStar(require_mapped2(), exports);
  __exportStar(require_never3(), exports);
  __exportStar(require_not3(), exports);
  __exportStar(require_null2(), exports);
  __exportStar(require_number2(), exports);
  __exportStar(require_object2(), exports);
  __exportStar(require_omit2(), exports);
  __exportStar(require_optional2(), exports);
  __exportStar(require_parameters2(), exports);
  __exportStar(require_partial2(), exports);
  __exportStar(require_pick2(), exports);
  __exportStar(require_promise2(), exports);
  __exportStar(require_readonly2(), exports);
  __exportStar(require_readonly_optional2(), exports);
  __exportStar(require_record2(), exports);
  __exportStar(require_recursive2(), exports);
  __exportStar(require_ref2(), exports);
  __exportStar(require_regexp2(), exports);
  __exportStar(require_required2(), exports);
  __exportStar(require_rest2(), exports);
  __exportStar(require_return_type2(), exports);
  __exportStar(require_schema2(), exports);
  __exportStar(require_static2(), exports);
  __exportStar(require_strict2(), exports);
  __exportStar(require_string2(), exports);
  __exportStar(require_symbol2(), exports);
  __exportStar(require_template_literal2(), exports);
  __exportStar(require_transform3(), exports);
  __exportStar(require_tuple2(), exports);
  __exportStar(require_uint8array2(), exports);
  __exportStar(require_undefined2(), exports);
  __exportStar(require_union2(), exports);
  __exportStar(require_unknown2(), exports);
  __exportStar(require_unsafe2(), exports);
  __exportStar(require_void2(), exports);
  __exportStar(require_type5(), exports);
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    FlowcoreEventSchema: function() {
      return FlowcoreEventSchema;
    },
    TransformerHeadersSchema: function() {
      return TransformerHeadersSchema;
    },
    TransformerResponseSchema: function() {
      return TransformerResponseSchema;
    }
  });
  var _typebox = require_cjs2();
  var FlowcoreEventSchema = _typebox.Type.Object({
    eventId: _typebox.Type.String(),
    aggregator: _typebox.Type.String(),
    eventType: _typebox.Type.String(),
    validTime: _typebox.Type.String({
      pattern: "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?Z$"
    }),
    payload: _typebox.Type.Unknown(),
    metadata: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()))
  }, {
    $id: "FlowcoreEvent"
  });
  var TransformerHeadersSchema = _typebox.Type.Object({
    "x-secret": _typebox.Type.Optional(_typebox.Type.String())
  }, {
    $id: "TransformerHeaders"
  });
  var TransformerResponseSchema = _typebox.Type.Union([
    _typebox.Type.Object({
      status: _typebox.Type.Literal("ok"),
      statusCode: _typebox.Type.Literal(200)
    }),
    _typebox.Type.Object({
      status: _typebox.Type.Literal("error"),
      statusCode: _typebox.Type.Number(),
      message: _typebox.Type.String()
    }),
    _typebox.Type.Object({
      status: _typebox.Type.Literal("error"),
      statusCode: _typebox.Type.Literal(400),
      message: _typebox.Type.String(),
      errors: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()))
    })
  ], {
    $id: "TransformerResponse"
  });
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/transformer-builder.js
var require_transformer_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "TransformerBuilder", {
    enumerable: true,
    get: function() {
      return TransformerBuilder;
    }
  });
  var _value = require_value5();
  var _safeparsetype = require_safe_parse_type();
  var _exceptions = require_exceptions();
  var _types = require_types2();
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class TransformerBuilder {
    withSecret(secret) {
      this.secret = secret;
      return this;
    }
    withSuccessHandler(successHandler) {
      this.successHandler = successHandler;
      return this;
    }
    withErrorHandler(errorHandler2) {
      this.errorHandler = errorHandler2;
      return this;
    }
    onEventType(eventType, schema, handler) {
      if (!eventType) {
        throw new _exceptions.TransformerError("Event type is required to construct a transformer");
      }
      if (!this.eventTypes[eventType]) {
        this.eventTypes[eventType] = {
          handlers: [],
          schema
        };
      }
      this.eventTypes[eventType].handlers.push(handler);
      return this;
    }
    getHandler() {
      return (event2, secret, context) => {
        if (!_value.Value.Check(_types.FlowcoreEventSchema, event2)) {
          const errors2 = {};
          const typeboxErrors = _value.Value.Errors(_types.FlowcoreEventSchema, event2);
          for (const typeboxError of typeboxErrors) {
            errors2[typeboxError.path] = typeboxError.message;
          }
          throw new _exceptions.TransformerError("Invalid event", {
            errors: errors2
          });
        }
        return this.handleEvent(event2, secret, context);
      };
    }
    async handleEvent(event2, secret, context) {
      const response = await this.processEvent(event2, context ?? {}, secret);
      this.processResponse(event2, response).catch((error2) => {
        throw new _exceptions.TransformerError("Failed to run after response handler", {
          exception: error2
        });
      });
      return response;
    }
    async processEvent(event2, context, secret) {
      if (this.secret && this.secret !== secret) {
        return {
          status: "error",
          statusCode: 401,
          message: "Unauthorized"
        };
      }
      if (event2.aggregator !== this.flowType) {
        return {
          status: "error",
          message: "Invalid flow type",
          statusCode: 400
        };
      }
      const eventConsumer = this.eventTypes[event2.eventType];
      if (!eventConsumer || eventConsumer.handlers.length === 0) {
        return {
          status: "error",
          message: "Invalid event type",
          statusCode: 400
        };
      }
      const parsedPayload = (0, _safeparsetype.safeParseType)(eventConsumer.schema, event2.payload);
      if (!parsedPayload.success) {
        return {
          status: "error",
          message: "Invalid payload",
          statusCode: 400,
          errors: parsedPayload.errors
        };
      }
      try {
        for (const handler of eventConsumer.handlers) {
          await handler(parsedPayload.data, event2, context);
        }
      } catch (error2) {
        throw new _exceptions.TransformerError("Failed to handle event", {
          exception: error2
        });
      }
      return {
        status: "ok",
        statusCode: 200
      };
    }
    async processResponse(event2, response) {
      if (response.status === "ok") {
        await this.successHandler?.(event2, response);
      } else {
        await this.errorHandler?.(event2, response);
      }
    }
    constructor(flowType) {
      _define_property(this, "secret", undefined);
      _define_property(this, "flowType", undefined);
      _define_property(this, "successHandler", undefined);
      _define_property(this, "errorHandler", undefined);
      _define_property(this, "eventTypes", {});
      if (!flowType) {
        throw new _exceptions.TransformerError("Flow type is required to construct a transformer");
      }
      this.flowType = flowType;
    }
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/index.js
var require_transformer_builder2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_exceptions(), exports);
  _export_star(require_transformer_builder(), exports);
  _export_star(require_types2(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/exceptions.js
var require_exceptions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    WebhookLocalTransformerError: function() {
      return WebhookLocalTransformerError;
    },
    WebhookPredicateError: function() {
      return WebhookPredicateError;
    },
    WebhookSendError: function() {
      return WebhookSendError;
    }
  });
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class WebhookSendError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookSendError");
      _define_property(this, "response", undefined);
      _define_property(this, "exception", undefined);
      this.response = options?.response;
      this.exception = options?.exception;
    }
  }

  class WebhookLocalTransformerError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookLocalTransformerError");
      _define_property(this, "exception", undefined);
      _define_property(this, "response", undefined);
      this.exception = options?.exception;
      this.response = options?.response;
    }
  }

  class WebhookPredicateError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookPredicateError");
      _define_property(this, "exception", undefined);
      _define_property(this, "eventIds", undefined);
      this.exception = options?.exception;
      this.eventIds = options?.eventIds;
    }
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports, {
    RETRYABLE_STATUS_CODES: function() {
      return RETRYABLE_STATUS_CODES;
    },
    WebhookBatchResponseSchema: function() {
      return WebhookBatchResponseSchema;
    },
    WebhookBatchSuccessResponseSchema: function() {
      return WebhookBatchSuccessResponseSchema;
    },
    WebhookError500ResponseSchema: function() {
      return WebhookError500ResponseSchema;
    },
    WebhookErrorResponseSchema: function() {
      return WebhookErrorResponseSchema;
    },
    WebhookFileResponseSchema: function() {
      return WebhookFileResponseSchema;
    },
    WebhookFileSuccessResponseSchema: function() {
      return WebhookFileSuccessResponseSchema;
    },
    WebhookResponseSchema: function() {
      return WebhookResponseSchema;
    },
    WebhookSuccessResponseSchema: function() {
      return WebhookSuccessResponseSchema;
    }
  });
  var _typebox = require_cjs2();
  var RETRYABLE_STATUS_CODES = [
    408,
    429,
    500,
    502,
    503,
    504
  ];
  var WebhookSuccessResponseSchema = _typebox.Type.Object({
    eventId: _typebox.Type.String()
  });
  var WebhookBatchSuccessResponseSchema = _typebox.Type.Object({
    eventIds: _typebox.Type.Array(_typebox.Type.String())
  });
  var WebhookFileSuccessResponseSchema = _typebox.Type.Object({
    checksum: _typebox.Type.String(),
    hashType: _typebox.Type.String(),
    eventIds: _typebox.Type.Array(_typebox.Type.String())
  });
  var WebhookErrorResponseSchema = _typebox.Type.Object({
    error: _typebox.Type.String(),
    message: _typebox.Type.String(),
    __localError: _typebox.Type.Optional(_typebox.Type.Any())
  });
  var WebhookError500ResponseSchema = _typebox.Type.Object({
    statusCode: _typebox.Type.Literal(500),
    message: _typebox.Type.String()
  });
  var WebhookResponseSchema = _typebox.Type.Union([
    WebhookSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
  var WebhookBatchResponseSchema = _typebox.Type.Union([
    WebhookBatchSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
  var WebhookFileResponseSchema = _typebox.Type.Union([
    WebhookFileSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/webhook-builder.js
var require_webhook_builder = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "WebhookBuilder", {
    enumerable: true,
    get: function() {
      return WebhookBuilder;
    }
  });
  var _value = require_value5();
  var _exceptions = require_exceptions2();
  var _types = require_types3();
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class WebhookBuilder {
    withRetry(retryOptions) {
      this.retryOptions = {
        maxAttempts: retryOptions?.maxAttempts ?? this.retryOptions?.maxAttempts ?? 1,
        attemptDelayMs: retryOptions?.attemptDelayMs ?? this.retryOptions?.attemptDelayMs ?? 250
      };
      return this;
    }
    withPredicate({ predicate, options }) {
      this.predicate = predicate ?? this.predicate;
      this.predicateOptions = {
        maxAttempts: options?.maxAttempts ?? this.predicateOptions?.maxAttempts ?? 8,
        attemptDelayMs: options?.attemptDelayMs ?? this.predicateOptions?.attemptDelayMs ?? 250
      };
      return this;
    }
    withLocalTransform(options) {
      this.localTransformOptions = {
        baseUrl: options.baseUrl,
        secret: options.secret
      };
      return this;
    }
    factory() {
      return () => {
        const factory = new WebhookBuilder({
          baseUrl: this.baseUrl,
          tenant: this.tenant,
          dataCore: this.dataCore,
          apiKey: this.apiKey
        });
        if (this.retryOptions) {
          factory.withRetry(this.retryOptions);
        }
        if (this.predicate) {
          factory.withPredicate({
            predicate: this.predicate,
            options: this.predicateOptions
          });
        }
        if (this.localTransformOptions) {
          factory.withLocalTransform(this.localTransformOptions);
        }
        return factory;
      };
    }
    buildWebhook(flowType, eventType) {
      const send = async (payload, metadata, options) => {
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "event"), {
          method: "POST",
          headers: this.getHeaders(metadata, {
            contentType: "application/json",
            ...options
          }),
          body: JSON.stringify(payload)
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookSuccessResponseSchema);
        const eventId = response.eventId;
        await this.doLocalTransform(flowType, eventType, payload, eventId);
        await this.doPredicateCheck(eventId);
        return eventId;
      };
      const sendBatch = async (payload, metadata, options) => {
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "events"), {
          method: "POST",
          headers: this.getHeaders(metadata, {
            contentType: "application/json",
            ...options
          }),
          body: JSON.stringify(payload)
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookBatchSuccessResponseSchema);
        const eventIds = response.eventIds;
        if (eventIds.length !== payload.length) {
          throw new _exceptions.WebhookSendError("Webhook batch returned different number of event ids than payloads", {
            response
          });
        }
        await Promise.all(payload.map((payload2, index) => this.doLocalTransform(flowType, eventType, payload2, eventIds[index])));
        await this.doPredicateCheck(eventIds);
        return eventIds;
      };
      return {
        send,
        sendBatch
      };
    }
    buildFileWebhook(flowType, eventType) {
      const send = async (payload, metadata, options) => {
        const formData = new FormData;
        process.env.DEBUG?.includes("transformer-core") && console.log("additionalProperties", payload.additionalProperties);
        formData.append("additionalProperties", JSON.stringify(payload.additionalProperties ?? "{}"));
        formData.append("fileId", payload.fileId);
        formData.append("type", payload.fileType);
        formData.append("file", payload.fileContent, payload.fileName);
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "file"), {
          method: "POST",
          headers: this.getHeaders(metadata, options),
          body: formData
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookFileSuccessResponseSchema);
        const eventIds = response.eventIds;
        await this.doPredicateCheck(eventIds);
        return eventIds;
      };
      return {
        send
      };
    }
    async doLocalTransform(flowType, eventType, payload, eventId) {
      if (!this.localTransformOptions?.baseUrl) {
        return;
      }
      const url = `${this.localTransformOptions.baseUrl}/${flowType}`;
      const event2 = {
        aggregator: flowType,
        eventType,
        payload,
        eventId: eventId ?? "00000000-0000-0000-0000-000000000000",
        validTime: new Date().toISOString()
      };
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "X-Secret": this.localTransformOptions.secret ?? "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(event2)
        });
        if (!response.ok) {
          const responseBody = await response.json();
          throw new _exceptions.WebhookLocalTransformerError("Failed to send event to local transformer", {
            response: responseBody
          });
        }
      } catch (error2) {
        throw new _exceptions.WebhookLocalTransformerError("Failed to send event to local transformer", {
          exception: error2
        });
      }
    }
    validateWebhookResponse(response, responseSchema) {
      if (_value.Value.Check(_types.WebhookError500ResponseSchema, response)) {
        throw new _exceptions.WebhookSendError("Webhook failed", {
          response
        });
      }
      if (_value.Value.Check(_types.WebhookErrorResponseSchema, response)) {
        if (response.__localError) {
          throw new _exceptions.WebhookSendError("Webhook failed with exception", {
            exception: response.__localError
          });
        }
        throw new _exceptions.WebhookSendError("Webhook failed", {
          response
        });
      }
      if (!_value.Value.Check(responseSchema, response)) {
        throw new _exceptions.WebhookSendError("Webhook returned invalid response", {
          response
        });
      }
      return response;
    }
    async doPredicateCheck(eventIds) {
      if (!this.predicate || !this.predicateOptions) {
        return;
      }
      const predicate = this.predicate;
      const { maxAttempts, attemptDelayMs } = this.predicateOptions;
      let checks = Array.isArray(eventIds) ? eventIds : [
        eventIds
      ];
      for (let attempt = 1;attempt <= maxAttempts; attempt++) {
        try {
          checks = await Promise.all(checks.map(async (eventId) => {
            if (eventId === true) {
              return true;
            }
            const check = await predicate(eventId) ?? false;
            if (check) {
              return true;
            }
            return eventId;
          }));
          if (checks.every((check) => check === true)) {
            return;
          }
          if (attempt >= maxAttempts) {
            throw new _exceptions.WebhookPredicateError("Predicate check failed", {
              eventIds: Array.isArray(eventIds) ? eventIds : [
                eventIds
              ]
            });
          }
        } catch (error2) {
          if (attempt >= maxAttempts) {
            if (error2 instanceof _exceptions.WebhookPredicateError) {
              throw error2;
            }
            throw new _exceptions.WebhookPredicateError("Predicate check failed with exception", {
              eventIds: Array.isArray(eventIds) ? eventIds : [
                eventIds
              ],
              exception: error2
            });
          }
        }
        await sleep2(attemptDelayMs, attempt);
      }
      throw new _exceptions.WebhookPredicateError("Predicate check failed", {
        eventIds: Array.isArray(eventIds) ? eventIds : [
          eventIds
        ]
      });
    }
    async fetchWithRetry(url, options) {
      const { maxAttempts, attemptDelayMs } = this.retryOptions ?? {
        maxAttempts: 1,
        attemptDelayMs: 0
      };
      for (let attempt = 1;attempt <= maxAttempts; attempt++) {
        try {
          const response = await fetch(url, options);
          if (response.ok) {
            return response.json().catch((error2) => {
              return {
                success: false,
                message: "Failed to parse response",
                error: error2 instanceof Error ? error2.message : "Unknown error"
              };
            });
          }
          if (!_types.RETRYABLE_STATUS_CODES.includes(response.status) || attempt >= maxAttempts) {
            return response.json().catch((error2) => {
              return {
                success: false,
                message: "Failed to parse error response",
                error: error2 instanceof Error ? error2.message : "Unknown error"
              };
            });
          }
          await sleep2(attemptDelayMs, attempt);
        } catch (error2) {
          if (attempt >= maxAttempts) {
            return {
              success: false,
              message: "Failed with local exception",
              error: error2 instanceof Error ? error2.message : "Unknown error",
              __localError: error2
            };
          }
          await sleep2(attemptDelayMs, attempt);
        }
      }
    }
    getHeaders(metadata, options) {
      const headers = {
        Authorization: `${this.apiKey}`,
        ...options?.contentType ? {
          "Content-Type": options.contentType
        } : {},
        ...options?.eventTime ? {
          "x-flowcore-event-time": options.eventTime.toISOString()
        } : {},
        ...options?.validTime ? {
          "x-flowcore-valid-time": options.validTime.toISOString()
        } : {},
        ...options?.eventTimeKey ? {
          "x-flowcore-event-time-key": options.eventTimeKey
        } : {},
        ...options?.validTimeKey ? {
          "x-flowcore-valid-time-key": options.validTimeKey
        } : {},
        ...metadata ? {
          "x-flowcore-metadata-json": Buffer.from(JSON.stringify(metadata), "utf-8").toString("base64")
        } : {}
      };
      return headers;
    }
    getUrl(flowType, eventType, type) {
      return `${this.baseUrl}/${type}/${this.tenant}/${this.dataCore}/${flowType}/${eventType}`;
    }
    constructor(options) {
      _define_property(this, "baseUrl", undefined);
      _define_property(this, "tenant", undefined);
      _define_property(this, "dataCore", undefined);
      _define_property(this, "apiKey", undefined);
      _define_property(this, "retryOptions", undefined);
      _define_property(this, "predicate", undefined);
      _define_property(this, "predicateOptions", undefined);
      _define_property(this, "localTransformOptions", undefined);
      this.baseUrl = options.baseUrl ?? "https://webhook.api.flowcore.io";
      this.tenant = options.tenant;
      this.dataCore = options.dataCore;
      this.apiKey = options.apiKey;
    }
  }
  function sleep2(ms, attempt = 1) {
    return new Promise((resolve) => setTimeout(resolve, typeof ms === "function" ? ms(attempt) : ms));
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/metadata-webhook.js
var require_metadata_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "metadataWebhook", {
    enumerable: true,
    get: function() {
      return metadataWebhook;
    }
  });
  var metadataWebhook = (metadata) => async (webhook, payload, additionalMetadata) => {
    const augmentedMetadata = {
      ...additionalMetadata,
      ...metadata
    };
    return webhook(payload, augmentedMetadata);
  };
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/index.js
var require_webhook_builder2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_webhook_builder(), exports);
  _export_star(require_exceptions2(), exports);
  _export_star(require_types3(), exports);
  _export_star(require_metadata_webhook(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/index.js
var require_flowcore = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_transformer_builder2(), exports);
  _export_star(require_webhook_builder2(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/throw-safe-error.js
var require_throw_safe_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "throwSafeError", {
    enumerable: true,
    get: function() {
      return throwSafeError;
    }
  });
  var throwSafeError = (message, error2) => {
    if (error2 instanceof Error) {
      throw new Error(`${message}: ${error2.message}`);
    }
    throw new Error(`${message}: an unexpected error type`);
  };
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/index.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_throw_safe_error(), exports);
  _export_star(require_safe_parse_type(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/index.js
var require_dist3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  _export_star(require_contracts(), exports);
  _export_star(require_flowcore(), exports);
  _export_star(require_utils3(), exports);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/pathways/esm/compatibility/flowcore-transformer-core.sdk.js
var import_sdk_transformer_core, WebhookBuilder;
var init_flowcore_transformer_core_sdk = __esm(() => {
  import_sdk_transformer_core = __toESM(require_dist3(), 1);
  ({ WebhookBuilder } = import_sdk_transformer_core.default);
});

// node_modules/bun-sqlite-key-value/dist/index.js
import { Database } from "bun:sqlite";
import { serialize as serialize2, deserialize } from "v8";
import { dirname, resolve } from "path";
import { existsSync, mkdirSync } from "fs";

class BunSqliteKeyValue {
  db;
  ttlMs;
  maxExpiringItemsInDb;
  data = this.getDataObject();
  d = this.data;
  deleteExpiredStatement;
  deleteStatement;
  clearStatement;
  countStatement;
  countValidStatement;
  setItemStatement;
  getItemStatement;
  getAllItemsStatement;
  getItemsStartsWithStatement;
  getKeyStatement;
  getAllKeysStatement;
  getKeysStartsWithStatement;
  countExpiringStatement;
  deleteExpiringStatement;
  getRandomKeyStatement;
  getRandomItemStatement;
  renameStatement;
  setExpiresStatement;
  getExpiresStatement;
  addTagStatement;
  deleteTagStatement;
  deleteAllTagsStatement;
  getTaggedKeysStatement;
  deleteTaggedItemsStatement;
  constructor(filename, options) {
    const {
      ttlMs,
      maxExpiringItemsInDb,
      ...otherOptions
    } = options ?? {};
    this.ttlMs = ttlMs;
    this.maxExpiringItemsInDb = maxExpiringItemsInDb;
    const dbOptions = {
      ...otherOptions,
      strict: true,
      readwrite: otherOptions?.readwrite ?? true,
      create: otherOptions?.create ?? true
    };
    if (filename?.length && filename.toLowerCase() !== ":memory:" && dbOptions.create) {
      const dbDir = dirname(resolve(filename));
      if (!existsSync(dbDir)) {
        console.log(`The "${dbDir}" folder is created.`);
        mkdirSync(dbDir, { recursive: true });
      }
    }
    this.db = new Database(filename, dbOptions);
    this.db.run("PRAGMA journal_mode = WAL");
    this.db.run("PRAGMA foreign_keys = ON");
    this.db.run(`
        CREATE TABLE IF NOT EXISTS items (
            key TEXT NOT NULL PRIMARY KEY, 
            value BLOB, 
            expires INT
        ) STRICT`);
    this.db.run("CREATE INDEX IF NOT EXISTS ix_items_expires ON items (expires)");
    this.db.run(`
        CREATE TABLE IF NOT EXISTS tags (
            tag TEXT NOT NULL,
            item_key TEXT NOT NULL REFERENCES items ON DELETE CASCADE ON UPDATE CASCADE,
            PRIMARY KEY (tag, item_key)
        ) STRICT`);
    this.db.run("CREATE INDEX IF NOT EXISTS ix_tags_item_key ON tags (item_key)");
    this.clearStatement = this.db.query("DELETE FROM items");
    this.deleteStatement = this.db.query("DELETE FROM items WHERE key = $key");
    this.deleteExpiredStatement = this.db.query("DELETE FROM items WHERE expires < $now");
    this.setItemStatement = this.db.query("INSERT OR REPLACE INTO items (key, value, expires) VALUES ($key, $value, $expires)");
    this.countStatement = this.db.query("SELECT COUNT(*) AS count FROM items");
    this.countValidStatement = this.db.query("SELECT COUNT(*) AS count FROM items WHERE expires IS NULL OR expires > $now");
    this.getAllItemsStatement = this.db.query("SELECT key, value, expires FROM items");
    this.getItemStatement = this.db.query("SELECT value, expires FROM items WHERE key = $key");
    this.getItemsStartsWithStatement = this.db.query("SELECT key, value, expires FROM items WHERE key = $key OR key >= $gte AND key < $lt");
    this.getAllKeysStatement = this.db.query("SELECT key, expires FROM items");
    this.getKeyStatement = this.db.query("SELECT expires FROM items WHERE key = $key");
    this.getKeysStartsWithStatement = this.db.query("SELECT key, expires FROM items WHERE key = $key OR key >= $gte AND key < $lt");
    this.countExpiringStatement = this.db.query("SELECT COUNT(*) as count FROM items WHERE expires IS NOT NULL");
    this.deleteExpiringStatement = this.db.query(`
        DELETE FROM items WHERE key IN (
            SELECT key FROM items
            WHERE expires IS NOT NULL
            ORDER BY expires ASC
            LIMIT $limit
        )`);
    this.getRandomKeyStatement = this.db.query(`
        SELECT key FROM items 
        WHERE expires IS NULL OR expires > $now
        ORDER BY RANDOM() 
        LIMIT 1
        `);
    this.getRandomItemStatement = this.db.query(`
        SELECT key, value from items
        WHERE key = (
            SELECT key FROM items 
            WHERE expires IS NULL OR expires > $now
            ORDER BY RANDOM() 
            LIMIT 1
        )`);
    this.renameStatement = this.db.query("UPDATE items SET key = $newKey WHERE key = $oldKey");
    this.setExpiresStatement = this.db.query("UPDATE items SET expires = $expires WHERE key = $key");
    this.getExpiresStatement = this.db.query("SELECT expires FROM items WHERE key = $key");
    this.addTagStatement = this.db.query("INSERT OR IGNORE INTO tags (tag, item_key) VALUES ($tag, $item_key)");
    this.deleteTagStatement = this.db.query("DELETE FROM tags WHERE tag = $tag AND item_key = $key");
    this.deleteAllTagsStatement = this.db.query("DELETE FROM tags WHERE item_key = $key");
    this.getTaggedKeysStatement = this.db.query("SELECT item_key AS key FROM tags WHERE tag = $tag");
    this.deleteTaggedItemsStatement = this.db.query("DELETE FROM items WHERE key IN (SELECT item_key FROM tags WHERE tag = $tag)");
    this.deleteExpired();
    this.deleteOldExpiringItems();
  }
  deleteExpired() {
    this.deleteExpiredStatement.run({ now: Date.now() });
  }
  delete(keyOrKeys) {
    if (typeof keyOrKeys === "string") {
      this.deleteStatement.run({ key: keyOrKeys });
    } else if (keyOrKeys?.length) {
      this.db.transaction(() => {
        keyOrKeys.forEach((key) => {
          this.deleteStatement.run({ key });
        });
      })();
    } else {
      this.clearStatement.run();
    }
  }
  del = this.delete;
  clear() {
    this.delete();
  }
  close() {
    this.db.close();
  }
  getCount() {
    return this.countStatement.get().count;
  }
  count = this.getCount;
  get length() {
    return this.getCount();
  }
  getCountValid(deleteExpired) {
    if (deleteExpired === true) {
      return this.db.transaction(() => {
        this.deleteExpiredStatement.run({ now: Date.now() });
        return this.countStatement.get().count;
      })();
    } else {
      return this.countValidStatement.get({ now: Date.now() }).count;
    }
  }
  set(key, value, ttlMs) {
    let expires;
    ttlMs = ttlMs ?? this.ttlMs;
    if (ttlMs !== undefined && ttlMs > 0) {
      expires = Date.now() + ttlMs;
    }
    if (key === undefined) {
      key = crypto.randomUUID();
    }
    this.setItemStatement.run({ key, value: serialize2(value), expires });
    return key;
  }
  setValue = this.set;
  put = this.set;
  setItems(items) {
    this.db.transaction(() => {
      items.forEach(({ key, value, ttlMs }) => {
        this.set(key, value, ttlMs);
      });
    })();
  }
  get(key) {
    const record = this.getItemStatement.get({ key });
    if (!record)
      return;
    const { value, expires } = record;
    if (expires) {
      if (expires < Date.now()) {
        this.delete(key);
        return;
      }
    }
    return value ? deserialize(value) : undefined;
  }
  getValue = this.get;
  getItem(key) {
    return {
      key,
      value: this.get(key)
    };
  }
  getItems(startsWithOrKeys) {
    let records;
    if (startsWithOrKeys && typeof startsWithOrKeys === "string") {
      const key = startsWithOrKeys;
      const gte2 = key + MIN_UTF8_CHAR;
      const lt2 = key + MAX_UTF8_CHAR;
      records = this.getItemsStartsWithStatement.all({ key, gte: gte2, lt: lt2 });
    } else if (startsWithOrKeys) {
      records = this.db.transaction(() => {
        return startsWithOrKeys.map((key) => {
          const record = this.getItemStatement.get({ key });
          return { ...record, key };
        });
      })();
    } else {
      records = this.getAllItemsStatement.all();
    }
    if (!records?.length)
      return;
    const now = Date.now();
    const result = [];
    const keysToDelete = [];
    for (const record of records) {
      const { key, value, expires } = record;
      if (expires && expires < now) {
        keysToDelete.push(key);
      } else {
        result.push({
          key,
          value: value ? deserialize(value) : undefined
        });
      }
    }
    if (keysToDelete.length === 1) {
      this.delete(keysToDelete[0]);
    } else if (keysToDelete.length > 1) {
      this.delete(keysToDelete);
    }
    if (result.length) {
      return result;
    }
  }
  getItemsArray = this.getItems;
  get items() {
    return this.getItems();
  }
  getValues(startsWithOrKeys) {
    return this.getItems(startsWithOrKeys)?.map((result) => result.value);
  }
  getValuesArray = this.getValues;
  get values() {
    return this.getValues();
  }
  getItemsAsObject(startsWithOrKeys) {
    const items = this.getItems(startsWithOrKeys);
    if (!items)
      return;
    return Object.fromEntries(items.map((item) => [item.key, item.value]));
  }
  getItemsObject = this.getItemsAsObject;
  getItemsAsMap(startsWithOrKeys) {
    const items = this.getItems(startsWithOrKeys);
    if (!items)
      return;
    return new Map(items.map((item) => [item.key, item.value]));
  }
  getItemsMap = this.getItemsAsMap;
  getValuesAsSet(startsWithOrKeys) {
    const values = this.getValues(startsWithOrKeys);
    if (!values)
      return;
    return new Set(values);
  }
  getValuesSet = this.getValuesAsSet;
  has(key) {
    const record = this.getKeyStatement.get({ key });
    if (!record)
      return false;
    if (record.expires) {
      if (record.expires < Date.now()) {
        this.delete(key);
        return false;
      }
    }
    return true;
  }
  exists = this.has;
  getKeys(startsWithOrKeys) {
    let records;
    if (startsWithOrKeys && typeof startsWithOrKeys === "string") {
      const key = startsWithOrKeys;
      const gte2 = key + MIN_UTF8_CHAR;
      const lt2 = key + MAX_UTF8_CHAR;
      records = this.getKeysStartsWithStatement.all({ key, gte: gte2, lt: lt2 });
    } else if (startsWithOrKeys) {
      records = this.db.transaction(() => {
        return startsWithOrKeys.map((key) => {
          const record = this.getKeyStatement.get({ key });
          return record ? { ...record, key } : undefined;
        });
      })();
    } else {
      records = this.getAllKeysStatement.all();
    }
    if (!records?.length)
      return;
    const now = Date.now();
    const result = [];
    const keysToDelete = [];
    for (const record of records) {
      if (!record)
        continue;
      const { key, expires } = record;
      if (expires && expires < now) {
        keysToDelete.push(key);
      } else {
        result.push(key);
      }
    }
    if (keysToDelete.length === 1) {
      this.delete(keysToDelete[0]);
    } else if (keysToDelete.length > 1) {
      this.delete(keysToDelete);
    }
    if (result.length) {
      return result;
    }
  }
  get keys() {
    return this.getKeys();
  }
  getExpiringItemsCount() {
    return this.countExpiringStatement.get().count;
  }
  deleteOldExpiringItems(maxExpiringItemsInDb) {
    let maxExpiringItems = maxExpiringItemsInDb ?? this.maxExpiringItemsInDb;
    if (maxExpiringItems === undefined)
      return;
    this.db.transaction(() => {
      const count = this.getExpiringItemsCount();
      if (count <= maxExpiringItems)
        return;
      const limit = count - maxExpiringItems;
      this.deleteExpiringStatement.run({ limit });
    })();
  }
  deleteOldestExpiringItems = this.deleteOldExpiringItems;
  getDataObject() {
    const self = this;
    return new Proxy({}, {
      get(_, property) {
        return self.get(property);
      },
      set(_, property, value) {
        self.set(property, value);
        return true;
      },
      has(_, property) {
        return self.has(property);
      },
      deleteProperty(_, property) {
        self.delete(property);
        return true;
      }
    });
  }
  incr(key, incrBy = 1, ttlMs) {
    return this.db.transaction(() => {
      const newValue = Number(this.get(key) ?? 0) + incrBy;
      if (isNaN(newValue))
        return NaN;
      this.set(key, newValue, ttlMs);
      return newValue;
    }).immediate();
  }
  decr(key, decrBy = 1, ttlMs) {
    return this.incr(key, decrBy * -1, ttlMs);
  }
  append(key, value, ttlMs) {
    return this.db.transaction(() => {
      const newValue = String(this.get(key) ?? "") + value;
      this.set(key, newValue, ttlMs);
      return newValue.length;
    }).immediate();
  }
  getSet(key, value, ttlMs) {
    return this.db.transaction(() => {
      const oldValue = this.get(key);
      this.set(key, value, ttlMs);
      return oldValue;
    }).immediate();
  }
  getRandomKey() {
    return this.getRandomKeyStatement.get({ now: Date.now() })?.key ?? undefined;
  }
  randomKey = this.getRandomKey;
  getRandomItem() {
    const record = this.getRandomItemStatement.get({ now: Date.now() });
    if (!record)
      return;
    return {
      key: record.key,
      value: record.value ? deserialize(record.value) : undefined
    };
  }
  randomItem = this.getRandomItem;
  getRandomValue() {
    const item = this.randomItem();
    if (item)
      return item.value;
  }
  randomValue = this.getRandomValue;
  rename(oldKey, newKey) {
    return this.db.transaction(() => {
      if (this.has(oldKey)) {
        this.deleteStatement.run({ key: newKey });
        this.renameStatement.run({ oldKey, newKey });
        return true;
      } else {
        return false;
      }
    }).immediate();
  }
  setTtl(key, ttlMs) {
    let expires;
    ttlMs = ttlMs ?? this.ttlMs;
    if (ttlMs !== undefined && ttlMs > 0) {
      expires = Date.now() + ttlMs;
    }
    return this.setExpiresStatement.run({ key, expires }).changes === 1;
  }
  getTtl(key) {
    const record = this.getExpiresStatement.get({ key });
    if (!record)
      return;
    const expires = record?.expires;
    if (!expires)
      return;
    const now = Date.now();
    if (expires < now) {
      this.delete(key);
      return;
    }
    return expires - now;
  }
  hSet(key, field, value, ttlMs) {
    return this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      const isNewField = !map.has(field);
      map.set(field, value);
      this.set(key, map, ttlMs);
      return isNewField;
    }).immediate();
  }
  hGet(key, field) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.get(field);
  }
  hmSet(key, fields, ttlMs) {
    this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      Object.entries(fields).forEach(([field, value]) => {
        map.set(field, value);
      });
      this.set(key, map, ttlMs);
    }).immediate();
  }
  hmGet(key, fields) {
    const map = this.get(key);
    if (map === undefined)
      return;
    const result = {};
    if (fields) {
      fields.forEach((field) => {
        result[field] = map.get(field);
      });
    } else {
      Object.assign(result, Object.fromEntries(map.entries()));
    }
    return result;
  }
  hHasField(key, field) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.has(field);
  }
  hExists = this.hHasField;
  hGetCount(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.size;
  }
  hLen = this.hGetCount;
  hGetFields(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return Array.from(map.keys());
  }
  hKeys = this.hGetFields;
  hGetValues(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return Array.from(map.values());
  }
  hVals = this.hGetValues;
  hDelete(key, field) {
    return this.db.transaction(() => {
      const map = this.get(key);
      if (map === undefined)
        return;
      const result = map.delete(field);
      this.set(key, map);
      return result;
    }).immediate();
  }
  hIncr(key, field, incrBy = 1, ttlMs) {
    return this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      let newValue;
      try {
        newValue = Number(map.get(field) ?? 0) + incrBy;
      } catch (error2) {
        if (error2.toString().includes("TypeError"))
          return NaN;
        throw error2;
      }
      if (isNaN(newValue))
        return NaN;
      map.set(field, newValue);
      this.set(key, map, ttlMs);
      return newValue;
    }).immediate();
  }
  hDecr(key, field, decrBy = 1, ttlMs) {
    return this.hIncr(key, field, decrBy * -1, ttlMs);
  }
  lPush(key, ...values) {
    return this.db.transaction(() => {
      const array = this.get(key) ?? new Array;
      let newLength;
      try {
        values.forEach((value) => {
          newLength = array.unshift(value);
        });
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return newLength;
    }).immediate();
  }
  rPush(key, ...values) {
    return this.db.transaction(() => {
      const array = this.get(key) ?? new Array;
      let newLength;
      try {
        newLength = array.push(...values);
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return newLength;
    }).immediate();
  }
  lPop(key, count) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined)
        return;
      let result;
      try {
        if (count === undefined) {
          result = array.shift();
        } else if (count > 0) {
          result = array.splice(0, count);
          if (!result?.length)
            return;
        } else {
          throw new Error(INVALID_COUNT_ERROR_LABEL + " `count` must be greater then 0.");
        }
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return result;
    }).immediate();
  }
  rPop(key, count) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined)
        return;
      let result;
      try {
        if (count === undefined) {
          result = array.pop();
        } else if (count > 0) {
          result = array.splice(count * -1, count);
          if (!result?.length)
            return;
          result.reverse();
        } else {
          throw new Error(INVALID_COUNT_ERROR_LABEL + " `count` must be greater then 0.");
        }
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return result;
    }).immediate();
  }
  lIndex(key, index) {
    const array = this.get(key);
    if (array === undefined)
      return;
    try {
      return array.at(index);
    } catch (error2) {
      if (error2.toString().includes("TypeError")) {
        throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
      }
      throw error2;
    }
  }
  lLen(key) {
    const array = this.get(key);
    if (array === undefined)
      return 0;
    if (Array.isArray(array) === false) {
      throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
    }
    return array.length;
  }
  lSet(key, index, value) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined) {
        throw new Error(ITEM_NOT_EXISTS_ERROR_LABEL + ` Key "${key.substring(-80)}" not found.`);
      }
      if (Array.isArray(array) === false) {
        throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
      }
      const len = array.length;
      if (index >= len || index < len * -1) {
        throw new Error(INDEX_OUT_OF_RANGE_ERROR_LABEL + ` Array length: ${len}`);
      }
      if (index < 0) {
        array[len + index] = value;
      } else {
        array[index] = value;
      }
      this.set(key, array);
      return true;
    }).immediate();
  }
  addTag(key, tag) {
    try {
      return this.addTagStatement.run({ item_key: key, tag }).changes === 1;
    } catch (error2) {
      if (error2.toString().includes("FOREIGN KEY constraint failed")) {
        throw new Error(ITEM_NOT_EXISTS_ERROR_LABEL + ` Key "${key.substring(-80)}" not found.`);
      } else {
        throw error2;
      }
    }
  }
  deleteTag(key, tag) {
    return this.deleteTagStatement.run({ key, tag }).changes === 1;
  }
  deleteTags(key, tags) {
    if (tags) {
      this.db.transaction(() => {
        tags.forEach((tag) => this.deleteTag(key, tag));
      })();
    } else {
      this.deleteAllTagsStatement.run({ key });
    }
  }
  deleteTaggedItems(tag) {
    this.deleteTaggedItemsStatement.run({ tag });
  }
  getTaggedKeys(tag) {
    const records = this.getTaggedKeysStatement.all({ tag });
    if (!records?.length)
      return;
    return records.map((record) => record.key);
  }
  getTaggedValues(tag) {
    return this.db.transaction(() => {
      const taggedKeys = this.getTaggedKeys(tag);
      if (!taggedKeys)
        return;
      return this.getValues(taggedKeys);
    })();
  }
  getTaggedItems(tag) {
    return this.db.transaction(() => {
      const taggedKeys = this.getTaggedKeys(tag);
      if (!taggedKeys)
        return;
      return this.getItems(taggedKeys);
    })();
  }
}
var MIN_UTF8_CHAR, MAX_UTF8_CHAR, INVALID_COUNT_ERROR_LABEL = "[INVALID_COUNT_ERROR]", NO_ARRAY_ERROR_LABEL = "[NO_ARRAY_ERROR]", ITEM_NOT_EXISTS_ERROR_LABEL = "[ITEM_NOT_EXISTS]", INDEX_OUT_OF_RANGE_ERROR_LABEL = "[INDEX_OUT_OF_RANGE]";
var init_dist = __esm(() => {
  MIN_UTF8_CHAR = String.fromCodePoint(1);
  MAX_UTF8_CHAR = String.fromCodePoint(1114111);
});

// node_modules/@flowcore/pathways/esm/pathways/kv/bun-kv-adapter.js
var exports_bun_kv_adapter = {};
__export(exports_bun_kv_adapter, {
  BunKvAdapter: () => BunKvAdapter
});

class BunKvAdapter {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.store = new BunSqliteKeyValue(":memory:");
  }
  get(key) {
    const value = this.store.get(key);
    return value;
  }
  set(key, value, ttlMs) {
    this.store.set(key, value, ttlMs);
  }
}
var init_bun_kv_adapter = __esm(() => {
  init_dist();
});

// node_modules/clone/clone.js
var require_clone4 = __commonJS((exports, module) => {
  var clone = function() {
    function _instanceof(obj, type) {
      return type != null && obj instanceof type;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {};
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {};
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {};
    }
    function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap;
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet;
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve2, reject) {
            parent2.then(function(value) {
              resolve2(_clone(value, depth2 - 1));
            }, function(err2) {
              reject(_clone(err2, depth2 - 1));
            });
          });
        } else if (clone2.__isArray(parent2)) {
          child = [];
        } else if (clone2.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone2.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i2 in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i2);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i2] = _clone(parent2[i2], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent2);
          for (var i2 = 0;i2 < symbols.length; i2++) {
            var symbol = symbols[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent2[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i2 = 0;i2 < allPropertyNames.length; i2++) {
            var propertyName = allPropertyNames[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone2.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c = function() {};
      c.prototype = parent;
      return new c;
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone2.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone2.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone2.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone2.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      if (re.global)
        flags += "g";
      if (re.ignoreCase)
        flags += "i";
      if (re.multiline)
        flags += "m";
      return flags;
    }
    clone2.__getRegExpFlags = __getRegExpFlags;
    return clone2;
  }();
  if (typeof module === "object" && module.exports) {
    module.exports = clone;
  }
});

// node_modules/node-cache/lib/node_cache.js
var require_node_cache = __commonJS((exports, module) => {
  (function() {
    var EventEmitter, NodeCache, clone, splice = [].splice, boundMethodCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new Error("Bound instance method accessed before binding");
      }
    }, indexOf2 = [].indexOf;
    clone = require_clone4();
    EventEmitter = __require("events").EventEmitter;
    module.exports = NodeCache = function() {

      class NodeCache2 extends EventEmitter {
        constructor(options = {}) {
          super();
          this.get = this.get.bind(this);
          this.mget = this.mget.bind(this);
          this.set = this.set.bind(this);
          this.mset = this.mset.bind(this);
          this.del = this.del.bind(this);
          this.take = this.take.bind(this);
          this.ttl = this.ttl.bind(this);
          this.getTtl = this.getTtl.bind(this);
          this.keys = this.keys.bind(this);
          this.has = this.has.bind(this);
          this.getStats = this.getStats.bind(this);
          this.flushAll = this.flushAll.bind(this);
          this.flushStats = this.flushStats.bind(this);
          this.close = this.close.bind(this);
          this._checkData = this._checkData.bind(this);
          this._check = this._check.bind(this);
          this._isInvalidKey = this._isInvalidKey.bind(this);
          this._wrap = this._wrap.bind(this);
          this._getValLength = this._getValLength.bind(this);
          this._error = this._error.bind(this);
          this._initErrors = this._initErrors.bind(this);
          this.options = options;
          this._initErrors();
          this.data = {};
          this.options = Object.assign({
            forceString: false,
            objectValueSize: 80,
            promiseValueSize: 80,
            arrayValueSize: 40,
            stdTTL: 0,
            checkperiod: 600,
            useClones: true,
            deleteOnExpire: true,
            enableLegacyCallbacks: false,
            maxKeys: -1
          }, this.options);
          if (this.options.enableLegacyCallbacks) {
            console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
            ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
              var oldMethod;
              oldMethod = this[methodKey];
              this[methodKey] = function(...args) {
                var cb, err2, ref, res;
                ref = args, [...args] = ref, [cb] = splice.call(args, -1);
                if (typeof cb === "function") {
                  try {
                    res = oldMethod(...args);
                    cb(null, res);
                  } catch (error1) {
                    err2 = error1;
                    cb(err2);
                  }
                } else {
                  return oldMethod(...args, cb);
                }
              };
            });
          }
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.validKeyTypes = ["string", "number"];
          this._checkData();
          return;
        }
        get(key) {
          var _ret, err2;
          boundMethodCheck(this, NodeCache2);
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            this.stats.hits++;
            _ret = this._unwrap(this.data[key]);
            return _ret;
          } else {
            this.stats.misses++;
            return;
          }
        }
        mget(keys) {
          var _err, err2, i2, key, len, oRet;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            _err = this._error("EKEYSTYPE");
            throw _err;
          }
          oRet = {};
          for (i2 = 0, len = keys.length;i2 < len; i2++) {
            key = keys[i2];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              this.stats.hits++;
              oRet[key] = this._unwrap(this.data[key]);
            } else {
              this.stats.misses++;
            }
          }
          return oRet;
        }
        set(key, value, ttl) {
          var _err, err2, existent;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          if (this.options.forceString && false === "string") {
            value = JSON.stringify(value);
          }
          if (ttl == null) {
            ttl = this.options.stdTTL;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          existent = false;
          if (this.data[key]) {
            existent = true;
            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
          }
          this.data[key] = this._wrap(value, ttl);
          this.stats.vsize += this._getValLength(value);
          if (!existent) {
            this.stats.ksize += this._getKeyLength(key);
            this.stats.keys++;
          }
          this.emit("set", key, value);
          return true;
        }
        mset(keyValueSet) {
          var _err, err2, i2, j, key, keyValuePair, len, len1, ttl, val;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          for (i2 = 0, len = keyValueSet.length;i2 < len; i2++) {
            keyValuePair = keyValueSet[i2];
            ({ key, val, ttl } = keyValuePair);
            if (ttl && typeof ttl !== "number") {
              _err = this._error("ETTLTYPE");
              throw _err;
            }
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
          }
          for (j = 0, len1 = keyValueSet.length;j < len1; j++) {
            keyValuePair = keyValueSet[j];
            ({ key, val, ttl } = keyValuePair);
            this.set(key, val, ttl);
          }
          return true;
        }
        del(keys) {
          var delCount, err2, i2, key, len, oldVal;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          delCount = 0;
          for (i2 = 0, len = keys.length;i2 < len; i2++) {
            key = keys[i2];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null) {
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
              this.stats.ksize -= this._getKeyLength(key);
              this.stats.keys--;
              delCount++;
              oldVal = this.data[key];
              delete this.data[key];
              this.emit("del", key, oldVal.v);
            }
          }
          return delCount;
        }
        take(key) {
          var _ret;
          boundMethodCheck(this, NodeCache2);
          _ret = this.get(key);
          if (_ret != null) {
            this.del(key);
          }
          return _ret;
        }
        ttl(key, ttl) {
          var err2;
          boundMethodCheck(this, NodeCache2);
          ttl || (ttl = this.options.stdTTL);
          if (!key) {
            return false;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            if (ttl >= 0) {
              this.data[key] = this._wrap(this.data[key].v, ttl, false);
            } else {
              this.del(key);
            }
            return true;
          } else {
            return false;
          }
        }
        getTtl(key) {
          var _ttl, err2;
          boundMethodCheck(this, NodeCache2);
          if (!key) {
            return;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            _ttl = this.data[key].t;
            return _ttl;
          } else {
            return;
          }
        }
        keys() {
          var _keys;
          boundMethodCheck(this, NodeCache2);
          _keys = Object.keys(this.data);
          return _keys;
        }
        has(key) {
          var _exists;
          boundMethodCheck(this, NodeCache2);
          _exists = this.data[key] != null && this._check(key, this.data[key]);
          return _exists;
        }
        getStats() {
          boundMethodCheck(this, NodeCache2);
          return this.stats;
        }
        flushAll(_startPeriod = true) {
          boundMethodCheck(this, NodeCache2);
          this.data = {};
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this._killCheckPeriod();
          this._checkData(_startPeriod);
          this.emit("flush");
        }
        flushStats() {
          boundMethodCheck(this, NodeCache2);
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.emit("flush_stats");
        }
        close() {
          boundMethodCheck(this, NodeCache2);
          this._killCheckPeriod();
        }
        _checkData(startPeriod = true) {
          var key, ref, value;
          boundMethodCheck(this, NodeCache2);
          ref = this.data;
          for (key in ref) {
            value = ref[key];
            this._check(key, value);
          }
          if (startPeriod && this.options.checkperiod > 0) {
            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);
            if (this.checkTimeout != null && this.checkTimeout.unref != null) {
              this.checkTimeout.unref();
            }
          }
        }
        _killCheckPeriod() {
          if (this.checkTimeout != null) {
            return clearTimeout(this.checkTimeout);
          }
        }
        _check(key, data) {
          var _retval;
          boundMethodCheck(this, NodeCache2);
          _retval = true;
          if (data.t !== 0 && data.t < Date.now()) {
            if (this.options.deleteOnExpire) {
              _retval = false;
              this.del(key);
            }
            this.emit("expired", key, this._unwrap(data));
          }
          return _retval;
        }
        _isInvalidKey(key) {
          var ref;
          boundMethodCheck(this, NodeCache2);
          if (ref = typeof key, indexOf2.call(this.validKeyTypes, ref) < 0) {
            return this._error("EKEYTYPE", {
              type: typeof key
            });
          }
        }
        _wrap(value, ttl, asClone = true) {
          var livetime, now, oReturn, ttlMultiplicator;
          boundMethodCheck(this, NodeCache2);
          if (!this.options.useClones) {
            asClone = false;
          }
          now = Date.now();
          livetime = 0;
          ttlMultiplicator = 1000;
          if (ttl === 0) {
            livetime = 0;
          } else if (ttl) {
            livetime = now + ttl * ttlMultiplicator;
          } else {
            if (this.options.stdTTL === 0) {
              livetime = this.options.stdTTL;
            } else {
              livetime = now + this.options.stdTTL * ttlMultiplicator;
            }
          }
          return oReturn = {
            t: livetime,
            v: asClone ? clone(value) : value
          };
        }
        _unwrap(value, asClone = true) {
          if (!this.options.useClones) {
            asClone = false;
          }
          if (value.v != null) {
            if (asClone) {
              return clone(value.v);
            } else {
              return value.v;
            }
          }
          return null;
        }
        _getKeyLength(key) {
          return key.toString().length;
        }
        _getValLength(value) {
          boundMethodCheck(this, NodeCache2);
          if (typeof value === "string") {
            return value.length;
          } else if (this.options.forceString) {
            return JSON.stringify(value).length;
          } else if (Array.isArray(value)) {
            return this.options.arrayValueSize * value.length;
          } else if (typeof value === "number") {
            return 8;
          } else if (typeof (value != null ? value.then : undefined) === "function") {
            return this.options.promiseValueSize;
          } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value) : undefined) {
            return value.length;
          } else if (value != null && typeof value === "object") {
            return this.options.objectValueSize * Object.keys(value).length;
          } else if (typeof value === "boolean") {
            return 8;
          } else {
            return 0;
          }
        }
        _error(type, data = {}) {
          var error2;
          boundMethodCheck(this, NodeCache2);
          error2 = new Error;
          error2.name = type;
          error2.errorcode = type;
          error2.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : "-";
          error2.data = data;
          return error2;
        }
        _initErrors() {
          var _errMsg, _errT, ref;
          boundMethodCheck(this, NodeCache2);
          this.ERRORS = {};
          ref = this._ERRORS;
          for (_errT in ref) {
            _errMsg = ref[_errT];
            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
          }
        }
        createErrorMessage(errMsg) {
          return function(args) {
            return errMsg.replace("__key", args.type);
          };
        }
      }
      NodeCache2.prototype._ERRORS = {
        ENOTFOUND: "Key `__key` not found",
        ECACHEFULL: "Cache max keys amount exceeded",
        EKEYTYPE: "The key argument has to be of type `string` or `number`. Found: `__key`",
        EKEYSTYPE: "The keys argument has to be an array.",
        ETTLTYPE: "The ttl argument has to be a number."
      };
      return NodeCache2;
    }.call(this);
  }).call(exports);
});

// node_modules/node-cache/index.js
var require_node_cache2 = __commonJS((exports, module) => {
  (function() {
    var exports2;
    exports2 = module.exports = require_node_cache();
    exports2.version = "5.1.2";
  }).call(exports);
});

// node_modules/@flowcore/pathways/esm/pathways/kv/node-kv-adapter.js
var exports_node_kv_adapter = {};
__export(exports_node_kv_adapter, {
  NodeKvAdapter: () => NodeKvAdapter
});

class NodeKvAdapter {
  constructor() {
    Object.defineProperty(this, "kv", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new import_node_cache.default
    });
  }
  async get(key) {
    const result = await this.kv.get(key);
    return result ?? null;
  }
  async set(key, value, ttlMs) {
    await this.kv.set(key, value, ttlMs / 1000);
  }
}
var import_node_cache;
var init_node_kv_adapter = __esm(() => {
  import_node_cache = __toESM(require_node_cache2(), 1);
});

// node_modules/@flowcore/pathways/esm/pathways/kv/kv-adapter.js
async function createKvAdapter() {
  try {
    const { BunKvAdapter: BunKvAdapter2 } = await Promise.resolve().then(() => (init_bun_kv_adapter(), exports_bun_kv_adapter));
    return new BunKvAdapter2;
  } catch {
    const { NodeKvAdapter: NodeKvAdapter2 } = await Promise.resolve().then(() => (init_node_kv_adapter(), exports_node_kv_adapter));
    return new NodeKvAdapter2;
  }
}

// node_modules/@flowcore/pathways/esm/pathways/internal-pathway.state.js
class InternalPathwayState {
  constructor() {
    Object.defineProperty(this, "kv", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
  }
  async getKv() {
    if (!this.kv) {
      this.kv = await createKvAdapter();
    }
    return this.kv;
  }
  async isProcessed(eventId) {
    const kv = await this.getKv();
    const result = await kv.get(eventId);
    return result === true;
  }
  async setProcessed(eventId) {
    const kv = await this.getKv();
    await kv.set(eventId, true, InternalPathwayState.DEFAULT_TTL_MS);
  }
}
var init_internal_pathway_state = __esm(() => {
  Object.defineProperty(InternalPathwayState, "DEFAULT_TTL_MS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5 * 60 * 1000
  });
});

// node_modules/@flowcore/pathways/esm/pathways/logger.js
class ConsoleLogger {
  debug(message, context) {
    console.debug(message, context ? JSON.stringify(context) : "");
  }
  info(message, context) {
    console.info(message, context ? JSON.stringify(context) : "");
  }
  warn(message, context) {
    console.warn(message, context ? JSON.stringify(context) : "");
  }
  error(messageOrError, errorOrContext, context) {
    if (typeof messageOrError === "string") {
      if (errorOrContext instanceof Error) {
        console.error(messageOrError, errorOrContext, context ? JSON.stringify(context) : "");
      } else {
        console.error(messageOrError, errorOrContext ? JSON.stringify(errorOrContext) : "");
      }
    } else {
      console.error(messageOrError, errorOrContext ? JSON.stringify(errorOrContext) : "");
    }
  }
}

class NoopLogger2 {
  debug(_message, _context) {}
  info(_message, _context) {}
  warn(_message, _context) {}
  error(_messageOrError, _errorOrContext, _context) {}
}

// node_modules/@flowcore/pathways/esm/pathways/constants.js
var AUDIT_SESSION_ID = "audit/session-id", AUDIT_ENTITY_ID = "audit/entity-id", AUDIT_ON_BEHALF_OF_TYPE = "audit/on-behalf-of-type", AUDIT_ON_BEHALF_OF_ID = "audit/on-behalf-of-id", AUDIT_MODE = "audit/mode", AUDIT_ENTITY_TYPE = "audit/entity-type", AUDIT_SYSTEM_MODE = "system", AUDIT_USER_MODE = "user", AUDIT_USER_ENTITY_TYPE = "user", AUDIT_KEY_ENTITY_TYPE = "key";

// node_modules/@flowcore/pathways/esm/pathways/types.js
import { Buffer as Buffer2 } from "buffer";
var FileInputSchema, FileEventSchema;
var init_types2 = __esm(() => {
  init_esm();
  FileInputSchema = exports_external.object({
    fileId: exports_external.string(),
    fileName: exports_external.string(),
    fileContent: exports_external.instanceof(Buffer2)
  });
  FileEventSchema = exports_external.object({
    fileName: exports_external.string(),
    fileType: exports_external.string(),
    fileSize: exports_external.number(),
    data: exports_external.string(),
    part: exports_external.number(),
    totalParts: exports_external.number(),
    checksum: exports_external.string(),
    hashType: exports_external.string(),
    fileId: exports_external.string()
  });
});

// node_modules/@flowcore/pathways/esm/pathways/builder.js
import process2 from "process";

class SessionUser {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.store = new Map;
  }
  get(key) {
    const entry = this.store.get(key);
    if (!entry) {
      return;
    }
    return entry.value;
  }
  set(key, value, ttlMs = 1000 * 60 * 5) {
    const existingEntry = this.store.get(key);
    if (existingEntry) {
      clearTimeout(existingEntry.timeout);
    }
    const timeout = setTimeout(() => {
      this.store.delete(key);
    }, ttlMs);
    this.store.set(key, { value, timeout });
  }
}

class PathwaysBuilder {
  constructor({ baseUrl, tenant, dataCore, apiKey, pathwayTimeoutMs, logger, enableSessionUserResolvers, overrideSessionUserResolvers, logLevel }) {
    Object.defineProperty(this, "pathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "beforeObservable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "afterObservers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "errorObservers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "globalErrorSubject", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new import_rxjs.Subject
    });
    Object.defineProperty(this, "writers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "batchWriters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "fileWriters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "schemas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "inputSchemas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "writable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "timeouts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "retryDelays", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "filePathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Set
    });
    Object.defineProperty(this, "webhookBuilderFactory", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "pathwayState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new InternalPathwayState
    });
    Object.defineProperty(this, "pathwayTimeoutMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: DEFAULT_PATHWAY_TIMEOUT_MS
    });
    Object.defineProperty(this, "auditHandler", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "userIdResolver", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "sessionUserResolvers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "logger", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "baseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tenant", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "dataCore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "logLevel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.logger = logger ?? new NoopLogger2;
    this.logLevel = {
      writeSuccess: logLevel?.writeSuccess ?? "info"
    };
    this.baseUrl = baseUrl;
    this.tenant = tenant;
    this.dataCore = dataCore;
    this.apiKey = apiKey;
    if (enableSessionUserResolvers) {
      this.sessionUserResolvers = overrideSessionUserResolvers ?? new SessionUser;
    }
    this.logger.debug("Initializing PathwaysBuilder", {
      baseUrl,
      tenant,
      dataCore,
      pathwayTimeoutMs
    });
    this.webhookBuilderFactory = new WebhookBuilder({
      baseUrl,
      tenant,
      dataCore,
      apiKey
    }).withRetry({
      maxAttempts: 5,
      attemptDelayMs: 250
    }).factory();
    if (pathwayTimeoutMs) {
      this.pathwayTimeoutMs = pathwayTimeoutMs;
    }
  }
  withPathwayState(state) {
    this.logger.debug("Setting custom pathway state");
    this.pathwayState = state;
    return this;
  }
  withAudit(handler) {
    this.logger.debug("Configuring audit functionality");
    this.auditHandler = handler;
    return this;
  }
  withUserResolver(resolver) {
    this.logger.debug("Configuring user resolver");
    this.userIdResolver = resolver;
    return this;
  }
  withSessionUserResolver(sessionId, resolver) {
    if (!this.sessionUserResolvers) {
      throw new Error("Session user resolvers not configured");
    }
    this.logger.debug("Configuring session-specific user resolver", { sessionId });
    this.sessionUserResolvers.set(sessionId, resolver, DEFAULT_SESSION_USER_RESOLVER_TTL_MS);
    return this;
  }
  getSessionUserResolver(sessionId) {
    if (!this.sessionUserResolvers) {
      return;
    }
    const resolver = this.sessionUserResolvers.get(sessionId);
    return resolver;
  }
  async process(pathway, data) {
    const pathwayStr = String(pathway);
    this.logger.debug(`Processing pathway event`, {
      pathway: pathwayStr,
      eventId: data.eventId
    });
    if (!this.pathways[pathway]) {
      const error2 = `Pathway ${pathwayStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (this.schemas[pathway]) {
      const parsedPayload = this.schemas[pathway].safeParse(data.payload);
      try {
        if (!parsedPayload.success) {
          const validationMessage = this.validationErrorToString(parsedPayload.error);
          const error2 = `Event payload does not match schema for pathway ${pathwayStr}. ${validationMessage}`;
          this.logger.error(error2, {
            pathway: pathwayStr,
            schema: this.schemas[pathway].toString(),
            validationErrors: parsedPayload.error.errors
          });
          throw new Error(error2);
        }
      } catch (err2) {
        const error2 = `Error validating event payload against schema for pathway ${pathwayStr}: ${err2 instanceof Error ? err2.message : String(err2)}`;
        this.logger.error(error2);
        throw new Error(error2);
      }
      data.payload = parsedPayload.data;
    }
    if (this.auditHandler) {
      this.logger.debug(`Calling audit handler for pathway`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.auditHandler(pathwayStr, data);
    }
    if (this.handlers[pathway]) {
      let retryCount = 0;
      const maxRetries = this.maxRetries[pathway] ?? DEFAULT_MAX_RETRIES;
      const retryDelayMs = this.retryDelays[pathway] ?? DEFAULT_RETRY_DELAY_MS;
      this.logger.debug(`Emitting 'before' event`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.beforeObservable[pathway].next(data);
      while (true) {
        try {
          this.logger.debug(`Executing handler for pathway`, {
            pathway: pathwayStr,
            eventId: data.eventId,
            attempt: retryCount + 1
          });
          const handle = this.handlers[pathway](data);
          await handle;
          this.logger.debug(`Handler executed successfully, emitting 'after' event`, {
            pathway: pathwayStr,
            eventId: data.eventId
          });
          this.afterObservers[pathway].next(data);
          await this.pathwayState.setProcessed(data.eventId);
          this.logger.info(`Successfully processed pathway event`, {
            pathway: pathwayStr,
            eventId: data.eventId
          });
          return;
        } catch (error2) {
          const errorObj = error2 instanceof Error ? error2 : new Error(String(error2));
          this.logger.error(`Error processing pathway event`, errorObj, {
            pathway: pathwayStr,
            eventId: data.eventId,
            retryCount,
            maxRetries
          });
          this.errorObservers[pathway].next({ event: data, error: errorObj });
          this.globalErrorSubject.next({
            pathway: pathwayStr,
            event: data,
            error: errorObj
          });
          if (retryCount < maxRetries) {
            retryCount++;
            const nextDelay = retryDelayMs * retryCount;
            this.logger.debug(`Retrying pathway event processing`, {
              pathway: pathwayStr,
              eventId: data.eventId,
              attempt: retryCount,
              maxRetries,
              nextDelay
            });
            await new Promise((resolve2) => setTimeout(resolve2, nextDelay));
            continue;
          }
          this.logger.warn(`Max retries exceeded for pathway event, marking as processed`, {
            pathway: pathwayStr,
            eventId: data.eventId,
            retryCount,
            maxRetries
          });
          await this.pathwayState.setProcessed(data.eventId);
          throw error2;
        }
      }
    } else {
      this.logger.debug(`No handler for pathway, emitting events and marking as processed`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.beforeObservable[pathway].next(data);
      this.afterObservers[pathway].next(data);
      await this.pathwayState.setProcessed(data.eventId);
    }
  }
  register(contract) {
    const path = `${contract.flowType}/${contract.eventType}`;
    const writable = contract.writable ?? true;
    this.logger.debug(`Registering pathway`, {
      pathway: path,
      flowType: contract.flowType,
      eventType: contract.eventType,
      writable,
      isFilePathway: contract.isFilePathway,
      timeoutMs: contract.timeoutMs,
      maxRetries: contract.maxRetries,
      retryDelayMs: contract.retryDelayMs
    });
    this.pathways[path] = true;
    this.beforeObservable[path] = new import_rxjs.Subject;
    this.afterObservers[path] = new import_rxjs.Subject;
    this.errorObservers[path] = new import_rxjs.Subject;
    if (writable) {
      if (contract.isFilePathway) {
        this.filePathways.add(path);
        this.fileWriters[path] = this.webhookBuilderFactory().buildFileWebhook(contract.flowType, contract.eventType).send;
      } else {
        this.writers[path] = this.webhookBuilderFactory().buildWebhook(contract.flowType, contract.eventType).send;
        this.batchWriters[path] = this.webhookBuilderFactory().buildWebhook(contract.flowType, contract.eventType).sendBatch;
      }
    }
    if (contract.timeoutMs) {
      this.timeouts[path] = contract.timeoutMs;
    }
    if (contract.maxRetries !== undefined) {
      this.maxRetries[path] = contract.maxRetries;
    }
    if (contract.retryDelayMs !== undefined) {
      this.retryDelays[path] = contract.retryDelayMs;
    }
    if (contract.isFilePathway) {
      this.schemas[path] = (contract.schema ?? exports_external.object({})).merge(FileEventSchema);
      this.inputSchemas[path] = (contract.schema ?? exports_external.object({})).merge(FileInputSchema);
    } else {
      this.schemas[path] = contract.schema ?? exports_external.object({});
      this.inputSchemas[path] = contract.schema ?? exports_external.object({});
    }
    this.writable[path] = writable;
    this.logger.info(`Pathway registered successfully`, {
      pathway: path,
      flowType: contract.flowType,
      eventType: contract.eventType,
      writable,
      isFilePathway: contract.isFilePathway
    });
    return this;
  }
  get(path) {
    this.logger.debug(`Getting pathway`, { pathway: String(path) });
    return this.pathways[path];
  }
  handle(path, handler) {
    const pathStr = String(path);
    this.logger.debug(`Setting handler for pathway`, { pathway: pathStr });
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (this.handlers[path]) {
      const error2 = `Someone is already handling pathway ${pathStr} in this instance`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    this.handlers[path] = handler;
    this.logger.info(`Handler set for pathway`, { pathway: pathStr });
    return this;
  }
  subscribe(path, handler, type = "before") {
    const pathStr = String(path);
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const typedHandler = handler;
    if (type === "before" || type === "all") {
      this.beforeObservable[path].subscribe(typedHandler);
      this.logger.debug(`Subscribed to 'before' events for pathway`, { pathway: pathStr });
    }
    if (type === "after" || type === "all") {
      this.afterObservers[path].subscribe(typedHandler);
      this.logger.debug(`Subscribed to 'after' events for pathway`, { pathway: pathStr });
    }
    this.logger.info(`Subscription to pathway events set up`, {
      pathway: pathStr,
      type
    });
    return this;
  }
  onError(path, handler) {
    const pathStr = String(path);
    this.logger.debug(`Setting error handler for pathway`, { pathway: pathStr });
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const typedHandler = (payload) => handler(payload.error, payload.event);
    this.errorObservers[path].subscribe(typedHandler);
    this.logger.info(`Error handler set for pathway`, { pathway: pathStr });
    return this;
  }
  onAnyError(handler) {
    this.logger.debug(`Subscribing to all pathway errors`);
    this.globalErrorSubject.subscribe(({ pathway, event: event2, error: error2 }) => handler(error2, event2, pathway));
    this.logger.debug(`Subscribed to all pathway errors`);
    return this;
  }
  async write(path, input) {
    const pathStr = String(path);
    const { data: inputData, metadata, options, batch } = input;
    if (batch && this.filePathways.has(path)) {
      const error2 = `Batch is not possible for file pathways. Pathway ${pathStr} is a file pathway`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    this.logger.debug(`Writing to pathway`, {
      pathway: pathStr,
      metadata,
      options: {
        fireAndForget: options?.fireAndForget,
        sessionId: options?.sessionId
      }
    });
    if (!this.pathways[path]) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (!this.writable[path]) {
      const error2 = `Pathway ${pathStr} is not writable`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const schema = batch ? exports_external.array(this.inputSchemas[path]) : this.inputSchemas[path];
    const parsedData = schema.safeParse(inputData);
    if (!parsedData.success) {
      const validationMessage = this.validationErrorToString(parsedData.error);
      const errorMessage = `Invalid data for pathway ${pathStr}. ${validationMessage}`;
      this.logger.error(errorMessage, {
        pathway: pathStr,
        schema: schema.toString(),
        validationErrors: parsedData.error.errors
      });
      throw new Error(errorMessage);
    }
    const data = parsedData.data;
    const finalMetadata = metadata ? { ...metadata } : {};
    let userId;
    if (options?.sessionId) {
      const sessionUserResolver = this.getSessionUserResolver(options.sessionId);
      if (sessionUserResolver) {
        try {
          userId = await sessionUserResolver();
          this.logger.debug(`Using session-specific user resolver`, {
            pathway: pathStr,
            sessionId: options.sessionId,
            userId
          });
        } catch (error2) {
          this.logger.error(`Error resolving session user ID`, error2 instanceof Error ? error2 : new Error(String(error2)), {
            pathway: pathStr,
            sessionId: options.sessionId
          });
        }
      }
    }
    if (this.userIdResolver) {
      if (!userId) {
        this.logger.debug(`Resolving user ID for audit metadata`, { pathway: pathStr });
        userId = await this.userIdResolver();
      }
    }
    const auditMode = options?.auditMode ?? "user";
    this.logger.debug(`Adding audit metadata`, {
      pathway: pathStr,
      auditMode,
      userId
    });
    if (userId) {
      if (auditMode === AUDIT_SYSTEM_MODE) {
        finalMetadata[AUDIT_MODE] = AUDIT_SYSTEM_MODE;
        finalMetadata[AUDIT_ENTITY_TYPE] = "system";
        finalMetadata[AUDIT_ENTITY_ID] = "system";
        finalMetadata[AUDIT_ON_BEHALF_OF_TYPE] = userId.entityType;
        finalMetadata[AUDIT_ON_BEHALF_OF_ID] = userId.entityId;
      } else {
        finalMetadata[AUDIT_MODE] = AUDIT_USER_MODE;
        finalMetadata[AUDIT_ENTITY_TYPE] = userId.entityType;
        finalMetadata[AUDIT_ENTITY_ID] = userId.entityId;
      }
    }
    if (options?.sessionId) {
      finalMetadata[AUDIT_SESSION_ID] = options.sessionId;
    }
    let eventIds = [];
    this.logger.debug(`Writing webhook data to pathway`, { pathway: pathStr, batch });
    if (batch) {
      eventIds = await this.batchWriters[path](data, finalMetadata, options);
    } else if (this.filePathways.has(path)) {
      const { fileId, fileName, fileContent, ...additionalProperties } = data;
      const fileType = await fileTypeFromBuffer(fileContent);
      process2.env.DEBUG?.includes("pathways") && console.log("additionalProperties", additionalProperties);
      eventIds = await this.fileWriters[path]({
        fileId,
        fileName,
        fileType: fileType?.mime ?? "application/octet-stream",
        fileContent: new Blob([fileContent]),
        additionalProperties
      }, finalMetadata, options);
    } else {
      eventIds = await this.writers[path](data, finalMetadata, options);
    }
    this.logger[this.logLevel.writeSuccess](`Successfully wrote to pathway`, {
      pathway: pathStr,
      eventIds: Array.isArray(eventIds) ? eventIds : [eventIds],
      fireAndForget: options?.fireAndForget
    });
    if (!options?.fireAndForget) {
      this.logger.debug(`Waiting for pathway to be processed`, {
        pathway: pathStr,
        eventIds: Array.isArray(eventIds) ? eventIds : [eventIds]
      });
      await Promise.all(Array.isArray(eventIds) ? eventIds.map((id) => this.waitForPathwayToBeProcessed(id)) : [this.waitForPathwayToBeProcessed(eventIds)]);
    }
    return eventIds;
  }
  async waitForPathwayToBeProcessed(eventId) {
    const startTime = Date.now();
    const timeoutMs = this.timeouts[eventId] ?? this.pathwayTimeoutMs;
    this.logger.debug(`Waiting for event to be processed`, {
      eventId,
      timeoutMs
    });
    let attempts = 0;
    while (!await this.pathwayState.isProcessed(eventId)) {
      attempts++;
      const elapsedTime = Date.now() - startTime;
      if (elapsedTime > timeoutMs) {
        const errorMessage = `Pathway processing timed out after ${timeoutMs}ms for event ${eventId}`;
        this.logger.error(errorMessage, new Error(errorMessage), {
          eventId,
          timeoutMs,
          elapsedTime,
          attempts
        });
        throw new Error(errorMessage);
      }
      if (attempts % 10 === 0) {
        this.logger.debug(`Still waiting for event to be processed`, {
          eventId,
          elapsedTime,
          attempts,
          timeoutMs
        });
      }
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    this.logger.debug(`Event has been processed`, {
      eventId,
      elapsedTime: Date.now() - startTime,
      attempts
    });
  }
  validationErrorToString(error2) {
    const primaryError = error2?.errors[0];
    if (!primaryError) {
      return "Unknown validation error";
    }
    const path = primaryError.path.join(".");
    const pathOutput = path ? `${path}: ` : "";
    return `${pathOutput}${primaryError.message}`;
  }
}
var import_rxjs, DEFAULT_PATHWAY_TIMEOUT_MS = 1e4, DEFAULT_MAX_RETRIES = 3, DEFAULT_RETRY_DELAY_MS = 500, DEFAULT_SESSION_USER_RESOLVER_TTL_MS;
var init_builder = __esm(() => {
  init_esm();
  init_file_type();
  init_flowcore_transformer_core_sdk();
  init_internal_pathway_state();
  init_types2();
  import_rxjs = __toESM(require_cjs(), 1);
  DEFAULT_SESSION_USER_RESOLVER_TTL_MS = 10 * 1000;
});

// node_modules/postgres/src/query.js
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x2;
  return originCache.get(xs);
}
var originCache, originStackCache, originError, CLOSE, Query2;
var init_query = __esm(() => {
  originCache = new Map;
  originStackCache = new Map;
  originError = Symbol("OriginError");
  CLOSE = {};
  Query2 = class Query2 extends Promise {
    constructor(strings, args, handler, canceller, options = {}) {
      let resolve2, reject;
      super((a, b) => {
        resolve2 = a;
        reject = b;
      });
      this.tagged = Array.isArray(strings.raw);
      this.strings = strings;
      this.args = args;
      this.handler = handler;
      this.canceller = canceller;
      this.options = options;
      this.state = null;
      this.statement = null;
      this.resolve = (x2) => (this.active = false, resolve2(x2));
      this.reject = (x2) => (this.active = false, reject(x2));
      this.active = false;
      this.cancelled = null;
      this.executed = false;
      this.signature = "";
      this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
    }
    get origin() {
      return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
    }
    static get [Symbol.species]() {
      return Promise;
    }
    cancel() {
      return this.canceller && (this.canceller(this), this.canceller = null);
    }
    simple() {
      this.options.simple = true;
      this.options.prepare = false;
      return this;
    }
    async readable() {
      this.simple();
      this.streaming = true;
      return this;
    }
    async writable() {
      this.simple();
      this.streaming = true;
      return this;
    }
    cursor(rows = 1, fn) {
      this.options.simple = false;
      if (typeof rows === "function") {
        fn = rows;
        rows = 1;
      }
      this.cursorRows = rows;
      if (typeof fn === "function")
        return this.cursorFn = fn, this;
      let prev;
      return {
        [Symbol.asyncIterator]: () => ({
          next: () => {
            if (this.executed && !this.active)
              return { done: true };
            prev && prev();
            const promise = new Promise((resolve2, reject) => {
              this.cursorFn = (value) => {
                resolve2({ value, done: false });
                return new Promise((r) => prev = r);
              };
              this.resolve = () => (this.active = false, resolve2({ done: true }));
              this.reject = (x2) => (this.active = false, reject(x2));
            });
            this.execute();
            return promise;
          },
          return() {
            prev && prev(CLOSE);
            return { done: true };
          }
        })
      };
    }
    describe() {
      this.options.simple = false;
      this.onlyDescribe = this.options.prepare = true;
      return this;
    }
    stream() {
      throw new Error(".stream has been renamed to .forEach");
    }
    forEach(fn) {
      this.forEachFn = fn;
      this.handle();
      return this;
    }
    raw() {
      this.isRaw = true;
      return this;
    }
    values() {
      this.isRaw = "values";
      return this;
    }
    async handle() {
      !this.executed && (this.executed = true) && await 1 && this.handler(this);
    }
    execute() {
      this.handle();
      return this;
    }
    then() {
      this.handle();
      return super.then.apply(this, arguments);
    }
    catch() {
      this.handle();
      return super.catch.apply(this, arguments);
    }
    finally() {
      this.handle();
      return super.finally.apply(this, arguments);
    }
  };
});

// node_modules/postgres/src/errors.js
function connection(x2, options, socket) {
  const { host, port } = socket || options;
  const error2 = Object.assign(new Error("write " + x2 + " " + (options.path || host + ":" + port)), {
    code: x2,
    errno: x2,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error2, connection);
  return error2;
}
function postgres(x2) {
  const error2 = new PostgresError(x2);
  Error.captureStackTrace(error2, postgres);
  return error2;
}
function generic(code, message) {
  const error2 = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error2, generic);
  return error2;
}
function notSupported(x2) {
  const error2 = Object.assign(new Error(x2 + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x2
  });
  Error.captureStackTrace(error2, notSupported);
  return error2;
}
var PostgresError, Errors;
var init_errors2 = __esm(() => {
  PostgresError = class PostgresError extends Error {
    constructor(x2) {
      super(x2.message);
      this.name = this.constructor.name;
      Object.assign(this, x2);
    }
  };
  Errors = {
    connection,
    postgres,
    generic,
    notSupported
  };
});

// node_modules/postgres/src/types.js
class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}
function handleValue(x2, parameters, types5, options) {
  let value = x2 instanceof Parameter ? x2.value : x2;
  if (value === undefined) {
    x2 instanceof Parameter ? x2.value = options.transform.undefined : value = x2 = options.transform.undefined;
    if (value === undefined)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types5.push(x2 instanceof Parameter ? (parameters.push(x2.value), x2.array ? x2.array[x2.type || inferType(x2.value)] || x2.type || firstIsString(x2.value) : x2.type) : (parameters.push(x2), inferType(x2)));
}
function stringify2(q, string, value, parameters, types5, options) {
  for (let i2 = 1;i2 < q.strings.length; i2++) {
    string += stringifyValue(string, value, parameters, types5, options) + q.strings[i2];
    value = q.args[i2];
  }
  return string;
}
function stringifyValue(string, value, parameters, types5, o) {
  return value instanceof Builder ? value.build(string, parameters, types5, o) : value instanceof Query2 ? fragment(value, parameters, types5, o) : value instanceof Identifier ? value.value : value && value[0] instanceof Query2 ? value.reduce((acc, x2) => acc + " " + fragment(x2, parameters, types5, o), "") : handleValue(value, parameters, types5, o);
}
function fragment(q, parameters, types5, options) {
  q.fragment = true;
  return stringify2(q, q.strings[0], q.args[0], parameters, types5, options);
}
function valuesBuilder(first, parameters, types5, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue("values", row[column], parameters, types5, options)).join(",") + ")").join(",");
}
function values(first, rest, parameters, types5, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types5, columns, options);
}
function select(first, rest, parameters, types5, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns = rest.length ? rest.flat() : Object.keys(first);
  return columns.map((x2) => {
    value = first[x2];
    return (value instanceof Query2 ? fragment(value, parameters, types5, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types5, options)) + " as " + escapeIdentifier2(options.transform.column.to ? options.transform.column.to(x2) : x2);
  }).join(",");
}
function notTagged() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
function firstIsString(x2) {
  if (Array.isArray(x2))
    return firstIsString(x2[0]);
  return typeof x2 === "string" ? 1009 : 0;
}
function typeHandlers(types5) {
  return Object.keys(types5).reduce((acc, k) => {
    types5[k].from && [].concat(types5[k].from).forEach((x2) => acc.parsers[x2] = types5[k].parse);
    if (types5[k].serialize) {
      acc.serializers[types5[k].to] = types5[k].serialize;
      types5[k].from && [].concat(types5[k].from).forEach((x2) => acc.serializers[x2] = types5[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column } }) {
  return xs.map((x2) => escapeIdentifier2(column.to ? column.to(x2) : x2)).join(",");
}
function arrayEscape(x2) {
  return x2.replace(escapeBackslash, "\\\\").replace(escapeQuote, "\\\"");
}
function arrayParserLoop(s, x2, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x2.length; s.i++) {
    s.char = x2[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x2[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x2[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x2, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i + 1)) : x2.slice(s.last, s.i + 1));
  return xs;
}
function createJsonTransform(fn) {
  return function jsonTransform(x2, column) {
    return typeof x2 === "object" && x2 !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x2) ? x2.map((x3) => jsonTransform(x3, column)) : Object.entries(x2).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {}) : x2;
  };
}
var types4, Identifier, Parameter, Builder, defaultHandlers, builders, serializers, parsers, mergeUserTypes = function(types5) {
  const user = typeHandlers(types5 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
}, escapeIdentifier2 = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
}, inferType = function inferType2(x2) {
  return x2 instanceof Parameter ? x2.type : x2 instanceof Date ? 1184 : x2 instanceof Uint8Array ? 17 : x2 === true || x2 === false ? 16 : typeof x2 === "bigint" ? 20 : Array.isArray(x2) ? inferType2(x2[0]) : 0;
}, escapeBackslash, escapeQuote, arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x2) => arraySerializer2(x2, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x2) => {
    if (x2 === undefined) {
      x2 = options.transform.undefined;
      if (x2 === undefined)
        throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x2 === null ? "null" : '"' + arrayEscape(serializer ? serializer(x2.type ? x2.value : x2) : "" + x2) + '"';
  }).join(delimiter) + "}";
}, arrayParserState, arrayParser = function arrayParser2(x2, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x2, parser, typarray);
}, toCamel = (x2) => {
  let str = x2[0];
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
}, toPascal = (x2) => {
  let str = x2[0].toUpperCase();
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
}, toKebab = (x2) => x2.replace(/_/g, "-"), fromCamel = (x2) => x2.replace(/([A-Z])/g, "_$1").toLowerCase(), fromPascal = (x2) => (x2.slice(0, 1) + x2.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase(), fromKebab = (x2) => x2.replace(/-/g, "_"), camel, pascal, kebab;
var init_types3 = __esm(() => {
  init_query();
  init_errors2();
  types4 = {
    string: {
      to: 25,
      from: null,
      serialize: (x2) => "" + x2
    },
    number: {
      to: 0,
      from: [21, 23, 26, 700, 701],
      serialize: (x2) => "" + x2,
      parse: (x2) => +x2
    },
    json: {
      to: 114,
      from: [114, 3802],
      serialize: (x2) => JSON.stringify(x2),
      parse: (x2) => JSON.parse(x2)
    },
    boolean: {
      to: 16,
      from: 16,
      serialize: (x2) => x2 === true ? "t" : "f",
      parse: (x2) => x2 === "t"
    },
    date: {
      to: 1184,
      from: [1082, 1114, 1184],
      serialize: (x2) => (x2 instanceof Date ? x2 : new Date(x2)).toISOString(),
      parse: (x2) => new Date(x2)
    },
    bytea: {
      to: 17,
      from: 17,
      serialize: (x2) => "\\x" + Buffer.from(x2).toString("hex"),
      parse: (x2) => Buffer.from(x2.slice(2), "hex")
    }
  };
  Identifier = class Identifier extends NotTagged {
    constructor(value) {
      super();
      this.value = escapeIdentifier2(value);
    }
  };
  Parameter = class Parameter extends NotTagged {
    constructor(value, type, array) {
      super();
      this.value = value;
      this.type = type;
      this.array = array;
    }
  };
  Builder = class Builder extends NotTagged {
    constructor(first, rest) {
      super();
      this.first = first;
      this.rest = rest;
    }
    build(before, parameters, types5, options) {
      const keyword = builders.map(([x2, fn]) => ({ fn, i: before.search(x2) })).sort((a, b) => a.i - b.i).pop();
      return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types5, options);
    }
  };
  defaultHandlers = typeHandlers(types4);
  builders = Object.entries({
    values,
    in: (...xs) => {
      const x2 = values(...xs);
      return x2 === "()" ? "(null)" : x2;
    },
    select,
    as: select,
    returning: select,
    "\\(": select,
    update(first, rest, parameters, types5, options) {
      return (rest.length ? rest.flat() : Object.keys(first)).map((x2) => escapeIdentifier2(options.transform.column.to ? options.transform.column.to(x2) : x2) + "=" + stringifyValue("values", first[x2], parameters, types5, options));
    },
    insert(first, rest, parameters, types5, options) {
      const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
      return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types5, columns, options);
    }
  }).map(([x2, fn]) => [new RegExp("((?:^|[\\s(])" + x2 + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
  serializers = defaultHandlers.serializers;
  parsers = defaultHandlers.parsers;
  escapeBackslash = /\\/g;
  escapeQuote = /"/g;
  arrayParserState = {
    i: 0,
    char: null,
    str: "",
    quoted: false,
    last: 0
  };
  toCamel.column = { from: toCamel };
  toCamel.value = { from: createJsonTransform(toCamel) };
  fromCamel.column = { to: fromCamel };
  camel = { ...toCamel };
  camel.column.to = fromCamel;
  toPascal.column = { from: toPascal };
  toPascal.value = { from: createJsonTransform(toPascal) };
  fromPascal.column = { to: fromPascal };
  pascal = { ...toPascal };
  pascal.column.to = fromPascal;
  toKebab.column = { from: toKebab };
  toKebab.value = { from: createJsonTransform(toKebab) };
  fromKebab.column = { to: fromKebab };
  kebab = { ...toKebab };
  kebab.column.to = fromKebab;
});

// node_modules/postgres/src/result.js
var Result2;
var init_result = __esm(() => {
  Result2 = class Result2 extends Array {
    constructor() {
      super();
      Object.defineProperties(this, {
        count: { value: null, writable: true },
        state: { value: null, writable: true },
        command: { value: null, writable: true },
        columns: { value: null, writable: true },
        statement: { value: null, writable: true }
      });
    }
    static get [Symbol.species]() {
      return Array;
    }
  };
});

// node_modules/postgres/src/queue.js
function Queue(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x2) => {
      const index2 = xs.indexOf(x2);
      return index2 === -1 ? null : (xs.splice(index2, 1), x2);
    },
    push: (x2) => (xs.push(x2), x2),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
}
var queue_default;
var init_queue = __esm(() => {
  queue_default = Queue;
});

// node_modules/postgres/src/bytes.js
function fit(x2) {
  if (buffer.length - b.i < x2) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x2);
    prev.copy(buffer);
  }
}
function reset() {
  b.i = 0;
  return b;
}
var size = 256, buffer, messages, b, bytes_default;
var init_bytes = __esm(() => {
  buffer = Buffer.allocUnsafe(size);
  messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x2) => {
    const v = x2.charCodeAt(0);
    acc[x2] = () => {
      buffer[0] = v;
      b.i = 5;
      return b;
    };
    return acc;
  }, {});
  b = Object.assign(reset, messages, {
    N: String.fromCharCode(0),
    i: 0,
    inc(x2) {
      b.i += x2;
      return b;
    },
    str(x2) {
      const length = Buffer.byteLength(x2);
      fit(length);
      b.i += buffer.write(x2, b.i, length, "utf8");
      return b;
    },
    i16(x2) {
      fit(2);
      buffer.writeUInt16BE(x2, b.i);
      b.i += 2;
      return b;
    },
    i32(x2, i2) {
      if (i2 || i2 === 0) {
        buffer.writeUInt32BE(x2, i2);
        return b;
      }
      fit(4);
      buffer.writeUInt32BE(x2, b.i);
      b.i += 4;
      return b;
    },
    z(x2) {
      fit(x2);
      buffer.fill(0, b.i, b.i + x2);
      b.i += x2;
      return b;
    },
    raw(x2) {
      buffer = Buffer.concat([buffer.subarray(0, b.i), x2]);
      b.i = buffer.length;
      return b;
    },
    end(at = 1) {
      buffer.writeUInt32BE(b.i - at, at);
      const out = buffer.subarray(0, b.i);
      b.i = 0;
      buffer = Buffer.allocUnsafe(size);
      return out;
    }
  });
  bytes_default = b;
});

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import { performance as performance2 } from "perf_hooks";
function Connection2(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max: max3,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result = new Result2, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query2) {
      initial = query2;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x2;
    try {
      x2 = options.socket ? await Promise.resolve(options.socket(options)) : new net.Socket;
    } catch (e) {
      error2(e);
      return;
    }
    x2.on("error", error2);
    x2.on("close", closed);
    x2.on("drain", drain);
    return x2;
  }
  async function cancel({ pid, secret }, resolve2, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve2);
    } catch (error3) {
      reject(error3);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query ? sent.push(q) : (query = q, query.active = true);
      build(q);
      return write(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error3) {
      sent.length === 0 && write(Sync);
      errored(error3);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types5 = [];
    const string = stringify2(q, q.strings[0], q.args[0], parameters, types5, options);
    !q.tagged && q.args.forEach((x2) => handleValue(x2, parameters, types5, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types5 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types5, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types5);
  }
  function write(x2, fn) {
    chunk = chunk ? Buffer.concat([chunk, x2]) : Buffer.from(x2);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x2 = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x2;
  }
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x2) => r(x2[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error2);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query && onopen(connection2);
  }
  function data(x2) {
    if (incomings) {
      incomings.push(x2);
      remaining -= x2.length;
      if (remaining > 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x2 : Buffer.concat([incoming, x2], incoming.length + x2.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query && (query.cursorFn || query.describeFirst) && write(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance2.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write(s);
    } catch (err2) {
      error2(err2);
    }
  }
  function error2(err2) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err2);
    while (sent.length)
      queryError(sent.shift(), err2);
  }
  function errored(err2) {
    stream && (stream.destroy(err2), stream = null);
    query && queryError(query, err2);
    initial && (queryError(initial, err2), initial = null);
  }
  function queryError(query2, err2) {
    if (query2.reserve)
      return query2.reject(err2);
    if (!err2 || typeof err2 !== "object")
      err2 = new Error(err2);
    "query" in err2 || "parameters" in err2 || Object.defineProperties(err2, {
      stack: { value: err2.stack + query2.origin.replace(/.*\n/, `
`), enumerable: options.debug },
      query: { value: query2.string, enumerable: options.debug },
      parameters: { value: query2.parameters, enumerable: options.debug },
      args: { value: query2.args, enumerable: options.debug },
      types: { value: query2.statement && query2.statement.types, enumerable: options.debug }
    });
    query2.reject(err2);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query || initial || sent.length)
      error2(Errors.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    socket.removeAllListeners();
    socket = null;
    if (initial)
      return reconnect();
    !hadError && (query || sent.length) && error2(Errors.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance2.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x2 = xs[0]) {
    (x2 === 68 ? DataRow : x2 === 100 ? CopyData : x2 === 65 ? NotificationResponse : x2 === 83 ? ParameterStatus : x2 === 90 ? ReadyForQuery : x2 === 67 ? CommandComplete : x2 === 50 ? BindComplete : x2 === 49 ? ParseComplete : x2 === 116 ? ParameterDescription : x2 === 84 ? RowDescription : x2 === 82 ? Authentication : x2 === 110 ? NoData : x2 === 75 ? BackendKeyData : x2 === 69 ? ErrorResponse : x2 === 115 ? PortalSuspended : x2 === 51 ? CloseComplete : x2 === 71 ? CopyInResponse : x2 === 78 ? NoticeResponse : x2 === 72 ? CopyOutResponse : x2 === 99 ? CopyDone : x2 === 73 ? EmptyQueryResponse : x2 === 86 ? FunctionCallResponse : x2 === 118 ? NegotiateProtocolVersion : x2 === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x2) {
    let index = 7;
    let length2;
    let column;
    let value;
    const row = query.isRaw ? new Array(query.statement.columns.length) : {};
    for (let i2 = 0;i2 < query.statement.columns.length; i2++) {
      column = query.statement.columns[i2];
      length2 = x2.readInt32BE(index);
      index += 4;
      value = length2 === -1 ? null : query.isRaw === true ? x2.subarray(index, index += length2) : column.parser === undefined ? x2.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x2.toString("utf8", index + 1, index += length2)) : column.parser(x2.toString("utf8", index, index += length2));
      query.isRaw ? row[i2] = query.isRaw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
    }
    query.forEachFn ? query.forEachFn(transform.row.from ? transform.row.from(row) : row, result) : result[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  function ParameterStatus(x2) {
    const [k, v] = x2.toString("utf8", 5, x2.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options.parameters[k] !== v) {
      options.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  function ReadyForQuery(x2) {
    query && query.options.simple && query.resolve(results || result);
    query = results = null;
    result = new Result2;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial.reserve && (initial = null);
        return fetchArrayTypes();
      }
      initial && !initial.reserve && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))
      Connection2(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject);
    if (query)
      return;
    connection2.reserved ? !connection2.reserved.release && x2[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x2) {
    rows = 0;
    for (let i2 = x2.length - 1;i2 > 0; i2--) {
      if (x2[i2] === 32 && x2[i2 + 1] < 58 && result.count === null)
        result.count = +x2.toString("utf8", i2 + 1, x2.length - 1);
      if (x2[i2 - 1] >= 65) {
        result.command = x2.toString("utf8", 5, i2);
        result.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result.command === "BEGIN" && max3 !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query.options.simple)
      return BindComplete();
    if (query.cursorFn) {
      result.count && query.cursorFn(result);
      write(Sync);
    }
    query.resolve(result);
  }
  function ParseComplete() {
    query.parsing = false;
  }
  function BindComplete() {
    !result.statement && (result.statement = query.statement);
    result.columns = query.statement.columns;
  }
  function ParameterDescription(x2) {
    const length2 = x2.readUInt16BE(5);
    for (let i2 = 0;i2 < length2; ++i2)
      !query.statement.types[i2] && (query.statement.types[i2] = x2.readUInt32BE(7 + i2 * 4));
    query.prepare && (statements[query.signature] = query.statement);
    query.describeFirst && !query.onlyDescribe && (write(prepared(query)), query.describeFirst = false);
  }
  function RowDescription(x2) {
    if (result.command) {
      results = results || [result];
      results.push(result = new Result2);
      result.count = null;
      query.statement.columns = null;
    }
    const length2 = x2.readUInt16BE(5);
    let index = 7;
    let start;
    query.statement.columns = Array(length2);
    for (let i2 = 0;i2 < length2; ++i2) {
      start = index;
      while (x2[index++] !== 0)
        ;
      const table = x2.readUInt32BE(index);
      const number = x2.readUInt16BE(index + 4);
      const type = x2.readUInt32BE(index + 6);
      query.statement.columns[i2] = {
        name: transform.column.from ? transform.column.from(x2.toString("utf8", start, index - 1)) : x2.toString("utf8", start, index - 1),
        parser: parsers2[type],
        table,
        number,
        type
      };
      index += 18;
    }
    result.statement = query.statement;
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  async function Authentication(x2, type = x2.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x2, type);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x2) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x2.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i2 = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i2 - 4, i2).end());
  }
  async function SASLContinue(x2) {
    const res = x2.toString("utf8", 9).split(",").reduce((acc, x3) => (acc[x3[0]] = x3.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + "," + "r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha2562(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x2) {
    if (x2.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result.statement = query.statement;
    result.statement.columns = [];
    if (query.onlyDescribe)
      return query.resolve(query.statement), write(Sync);
  }
  function BackendKeyData(x2) {
    backend.pid = x2.readUInt32BE(5);
    backend.secret = x2.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types5 = await new Query2([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types5.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x2, xs) {
    return x2 === "read-write" && xs.default_transaction_read_only === "on" || x2 === "read-only" && xs.default_transaction_read_only === "off" || x2 === "primary" && xs.in_hot_standby === "on" || x2 === "standby" && xs.in_hot_standby === "off" || x2 === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query2 = new Query2([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query2.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query2.execute();
  }
  function ErrorResponse(x2) {
    query && (query.cursorFn || query.describeFirst) && write(Sync);
    const error3 = Errors.postgres(parseError2(x2));
    query && query.retried ? errored(query.retried) : query && query.prepared && retryRoutines.has(error3.routine) ? retry2(query, error3) : errored(error3);
  }
  function retry2(q, error3) {
    delete statements[q.signature];
    q.retried = error3;
    execute(q);
  }
  function NotificationResponse(x2) {
    if (!onnotify)
      return;
    let index = 9;
    while (x2[index++] !== 0)
      ;
    onnotify(x2.toString("utf8", 9, index - 1), x2.toString("utf8", index, x2.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x2 = await Promise.resolve(query.cursorFn(result));
      rows = 0;
      x2 === CLOSE ? write(Close(query.portal)) : (result = new Result2, write(Execute("", query.cursorRows)));
    } catch (err2) {
      write(Sync);
      query.reject(err2);
    }
  }
  function CloseComplete() {
    result.count && query.cursorFn(result);
    query.resolve(result);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error3, callback) {
        callback(error3);
        socket.write(bytes_default().f().str(error3 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error3, callback) {
        callback(error3);
        socket.write(bytes_default().f().str(error3 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyData(x2) {
    stream && (stream.push(x2.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x2) {
    onnotice ? onnotice(parseError2(x2)) : console.log(parseError2(x2));
  }
  function EmptyQueryResponse() {}
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x2) {
    console.error("Postgres.js : Unknown Message:", x2[0]);
  }
  function UnknownAuth(x2, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types5, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x2, i2) => {
      if (x2 === null)
        return bytes_default.i32(4294967295);
      type = types5[i2];
      parameters[i2] = x2 = type in options.serializers ? options.serializers[type](x2) : "" + x2;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x2).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters, types5, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x2, i2) => bytes_default.i32(types5[i2] || 0));
    return bytes_default.end();
  }
  function Describe(x2, name = "") {
    return bytes_default().D().str(x2).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
}
function parseError2(x2) {
  const error2 = {};
  let start = 5;
  for (let i2 = 5;i2 < x2.length - 1; i2++) {
    if (x2[i2] === 0) {
      error2[errorFields[x2[start]]] = x2.toString("utf8", start + 1, i2);
      start = i2 + 1;
    }
  }
  return error2;
}
function md5(x2) {
  return crypto2.createHash("md5").update(x2).digest("hex");
}
function hmac(key, x2) {
  return crypto2.createHmac("sha256", key).update(x2).digest();
}
function sha2562(x2) {
  return crypto2.createHash("sha256").update(x2).digest();
}
function xor(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i2 = 0;i2 < length; i2++)
    buffer2[i2] = a[i2] ^ b2[i2];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
}
var connection_default, uid = 1, Sync, Flush, SSLRequest, ExecuteUnnamed, DescribeUnnamed, noop = () => {}, retryRoutines, errorFields;
var init_connection = __esm(() => {
  init_types3();
  init_errors2();
  init_result();
  init_queue();
  init_query();
  init_bytes();
  connection_default = Connection2;
  Sync = bytes_default().S().end();
  Flush = bytes_default().H().end();
  SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
  ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
  DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
  retryRoutines = new Set([
    "FetchPreparedStatement",
    "RevalidateCachedQuery",
    "transformAssignedExpr"
  ]);
  errorFields = {
    83: "severity_local",
    86: "severity",
    67: "code",
    77: "message",
    68: "detail",
    72: "hint",
    80: "position",
    112: "internal_position",
    113: "internal_query",
    87: "where",
    115: "schema_name",
    116: "table_name",
    99: "column_name",
    100: "data type_name",
    110: "constraint_name",
    70: "file",
    76: "line",
    82: "routine"
  };
});

// node_modules/postgres/src/subscribe.js
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql2 = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init(sql2, slot, options.publications));
      subscribers.forEach((event2) => event2.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql2;
  sql2.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql2.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event2, fn, onsubscribe = noop2, onerror = noop2) {
    event2 = parseEvent(event2);
    if (!connection2)
      connection2 = init(sql2, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event2) ? subscribers.get(event2).add(subscriber) : subscribers.set(event2, new Set([subscriber])).get(event2);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event2);
    };
    return connection2.then((x2) => {
      connected(x2);
      onsubscribe();
      stream && stream.on("error", onerror);
      return { unsubscribe, state, sql: sql2 };
    });
  }
  function connected(x2) {
    stream = x2.stream;
    state.pid = x2.state.pid;
    state.secret = x2.state.secret;
  }
  async function init(sql3, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql3.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x2] = xs;
    const stream2 = await sql3.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x2.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x2.consistent_point.split("/").map((x3) => Buffer.from(("00000000" + x3).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error2);
    stream2.on("close", sql3.close);
    return { stream: stream2, state: xs.state };
    function error2(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x3) {
      if (x3[0] === 119) {
        parse4(x3.subarray(25), state2, sql3.options.parsers, handle, options.transform);
      } else if (x3[0] === 107 && x3[17]) {
        state2.lsn = x3.subarray(1, 9);
        pong();
      }
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
    }
    function pong() {
      const x3 = Buffer.alloc(34);
      x3[0] = 114;
      x3.fill(state2.lsn, 1);
      x3.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x3);
    }
  }
  function call(x2, a, b2) {
    subscribers.has(x2) && subscribers.get(x2).forEach(({ fn }) => fn(a, b2, x2));
  }
}
function Time(x2) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x2 / BigInt(1000)));
}
function parse4(x2, state, parsers2, handle, transform) {
  const char2 = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x3) => {
      let i2 = 1;
      const r = state[x3.readUInt32BE(i2)] = {
        schema: x3.toString("utf8", i2 += 4, i2 = x3.indexOf(0, i2)) || "pg_catalog",
        table: x3.toString("utf8", i2 + 1, i2 = x3.indexOf(0, i2 + 1)),
        columns: Array(x3.readUInt16BE(i2 += 2)),
        keys: []
      };
      i2 += 2;
      let columnIndex = 0, column;
      while (i2 < x3.length) {
        column = r.columns[columnIndex++] = {
          key: x3[i2++],
          name: transform.column.from ? transform.column.from(x3.toString("utf8", i2, i2 = x3.indexOf(0, i2))) : x3.toString("utf8", i2, i2 = x3.indexOf(0, i2)),
          type: x3.readUInt32BE(i2 += 1),
          parser: parsers2[x3.readUInt32BE(i2)],
          atttypmod: x3.readUInt32BE(i2 += 4)
        };
        column.key && r.keys.push(column);
        i2 += 4;
      }
    },
    Y: () => {},
    O: () => {},
    B: (x3) => {
      state.date = Time(x3.readBigInt64BE(9));
      state.lsn = x3.subarray(1, 9);
    },
    I: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      const { row } = tuples(x3, relation.columns, i2 += 7, transform);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      handle(key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      const xs = key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform) : null;
      xs && (i2 = xs.i);
      const { row } = tuples(x3, relation.columns, i2 + 3, transform);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {},
    C: () => {}
  }).reduce(char2, {})[x2[0]](x2);
}
function tuples(x2, columns, xi, transform) {
  let type, column, value;
  const row = transform.raw ? new Array(columns.length) : {};
  for (let i2 = 0;i2 < columns.length; i2++) {
    type = x2[xi++];
    column = columns[i2];
    value = type === 110 ? null : type === 117 ? undefined : column.parser === undefined ? x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x2.toString("utf8", xi + 5, xi += 4 + x2.readUInt32BE(xi))) : column.parser(x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)));
    transform.raw ? row[i2] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
}
function parseEvent(x2) {
  const xs = x2.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x2);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
}
var noop2 = () => {};

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql2, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve2, reject) => {
    await sql2.begin(async (sql3) => {
      let finish;
      !oid && ([{ oid }] = await sql3`select lo_creat(-1) as oid`);
      const [{ fd: fd2 }] = await sql3`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql3`select lo_close(${fd2})`.then(finish),
        tell: () => sql3`select lo_tell64(${fd2})`,
        read: (x2) => sql3`select loread(${fd2}, ${x2}) as data`,
        write: (x2) => sql3`select lowrite(${fd2}, ${x2})`,
        truncate: (x2) => sql3`select lo_truncate64(${fd2}, ${x2})`,
        seek: (x2, whence = 0) => sql3`select lo_lseek64(${fd2}, ${x2}, ${whence})`,
        size: () => sql3`
          select
            lo_lseek64(${fd2}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve2(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max3 = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max3 ? size2 - max3 : size2;
            max3 -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}
var init_large = () => {};

// node_modules/postgres/src/index.js
var exports_src = {};
__export(exports_src, {
  default: () => src_default
});
import os from "os";
import fs from "fs";
function Postgres(a, b2) {
  const options = parseOptions(a, b2), subscribe = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql2 = Sql(handler);
  Object.assign(sql2, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql2),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql2;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x2) => new Parameter(x2, type.to);
      return acc;
    }, typed);
    Object.assign(sql3, {
      types: typed,
      typed,
      unsafe,
      notify,
      array,
      json: json2,
      file
    });
    return sql3;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql3(strings, ...args) {
      const query = strings && Array.isArray(strings.raw) ? new Query2(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query2([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query2([], args, (query2) => {
        fs.readFile(path, "utf8", (err2, string) => {
          if (err2)
            return query2.reject(err2);
          query2.strings = [string];
          handler2(query2);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql3 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {})));
        });
      },
      onnotify(c, x2) {
        c in listen.channels && listen.channels[c].listeners.forEach((l) => l.fn(x2));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists2 = name in channels;
    if (exists2) {
      channels[name].listeners.push(listener);
      const result2 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result2.state, unlisten };
    }
    channels[name] = { result: sql3`listen ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x2) => x2 !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql3`unlisten ${sql3.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql2`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue = queue_default();
    const c = open.length ? open.shift() : await new Promise((resolve2, reject) => {
      const query = { reserve: resolve2, reject };
      queries.push(query);
      closed.length && connect(closed.shift(), query);
    });
    move(c, reserved);
    c.reserved = () => queue.length ? c.execute(queue.shift()) : move(c, reserved);
    c.reserved.release = true;
    const sql3 = Sql(handler2);
    sql3.release = () => {
      c.reserved = null;
      onopen(c);
    };
    return sql3;
    function handler2(q) {
      c.queue === full ? queue.push(q) : c.execute(q) || move(c, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection2, prepare = null;
    try {
      await sql2.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection2, fn),
        new Promise((_, reject) => connection2.onclose = reject)
      ]);
    } catch (error2) {
      throw error2;
    }
    async function scope(c, fn2, name) {
      const sql3 = Sql(handler2);
      sql3.savepoint = savepoint;
      sql3.prepare = (x2) => prepare = x2.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result;
      name && await sql3`savepoint ${sql3(name)}`;
      try {
        result = await new Promise((resolve2, reject) => {
          const x2 = fn2(sql3);
          Promise.resolve(Array.isArray(x2) ? Promise.all(x2) : x2).then(resolve2, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql3`rollback to ${sql3(name)}` : sql3`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql3`prepare transaction '${sql3.unsafe(prepare)}'` : await sql3`commit`;
      }
      return result;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql4) => sql4.apply(sql4, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c.queue === full ? queries2.push(q) : c.execute(q) || move(c, full);
      }
    }
    function onexecute(c) {
      connection2 = c;
      move(c, reserved);
      c.reserved = () => queries2.length ? c.execute(queries2.shift()) : move(c, reserved);
    }
  }
  function move(c, queue) {
    c.queue.remove(c);
    queue.push(c);
    c.queue = queue;
    queue === open ? c.idleTimer.start() : c.idleTimer.cancel();
    return c;
  }
  function json2(x2) {
    return new Parameter(x2, 3802);
  }
  function array(x2, type) {
    if (!Array.isArray(x2))
      return array(Array.from(arguments));
    return new Parameter(x2, type || (x2.length ? inferType(x2) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query) {
    if (ending)
      return query.reject(Errors.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query);
    if (closed.length)
      return connect(closed.shift(), query);
    busy.length ? go(busy.shift(), query) : queries.push(query);
  }
  function go(c, query) {
    return c.execute(query) ? move(c, busy) : move(c, full);
  }
  function cancel(query) {
    return new Promise((resolve2, reject) => {
      query.state ? query.active ? connection_default(options).cancel(query.state, resolve2, reject) : query.cancelled = { resolve: resolve2, reject } : (queries.remove(query), query.cancelled = true, query.reject(Errors.generic("57014", "canceling statement due to user request")), resolve2());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c) => c.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c) => c.end()));
  }
  async function destroy(resolve2) {
    await Promise.all(connections.map((c) => c.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options));
    resolve2();
  }
  function connect(c, query) {
    move(c, connecting);
    c.connect(query);
    return c;
  }
  function onend(c) {
    move(c, ended);
  }
  function onopen(c) {
    if (queries.length === 0)
      return move(c, open);
    let max3 = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max3-- > 0) {
      const query = queries.shift();
      if (query.reserve)
        return query.reserve(c);
      ready = c.execute(query);
    }
    ready ? move(c, busy) : move(c, full);
  }
  function onclose(c, e) {
    move(c, closed);
    c.reserved = null;
    c.onclose && (c.onclose(e), c.onclose = null);
    options.onclose && options.onclose(c.id);
    queries.length && connect(c, queries.shift());
  }
}
function parseOptions(a, b2) {
  if (a && a.shared)
    return a;
  const env = process.env, o = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query = [...url.searchParams].reduce((a2, [b3, c]) => (a2[b3] = c, a2), {}), host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || "localhost", port = o.port || url.port || env.PGPORT || 5432, user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o.no_prepare && (o.prepare = false);
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
  "timeout" in o && (console.log("The timeout option is deprecated, use idle_timeout instead"), o.idle_timeout = o.timeout);
  query.sslrootcert === "system" && (query.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults2 = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x2) => x2.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x2) => parseInt(x2.split(":")[1] || port)),
    path: o.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o.database || o.db || (url.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o.pass || o.password || url.password || env.PGPASSWORD || "",
    ...Object.entries(defaults2).reduce((acc, [k, d]) => {
      const value = k in o ? o[k] : (k in query) ? query[k] === "disable" || query[k] === "false" ? false : query[k] : env["PG" + k.toUpperCase()] || d;
      acc[k] = typeof value === "string" && ints.includes(k) ? +value : value;
      return acc;
    }, {}),
    connection: {
      application_name: env.PGAPPNAME || "postgres.js",
      ...o.connection,
      ...Object.entries(query).reduce((acc, [k, v]) => ((k in defaults2) || (acc[k] = v), acc), {})
    },
    types: o.types || {},
    target_session_attrs: tsa(o, url, env),
    onnotice: o.onnotice,
    onnotify: o.onnotify,
    onclose: o.onclose,
    onparameter: o.onparameter,
    socket: o.socket,
    transform: parseTransform(o.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o.types)
  };
}
function tsa(o, url, env) {
  const x2 = o.target_session_attrs || url.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x2 || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x2))
    return x2;
  throw new Error("target_session_attrs " + x2 + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x2) {
  return {
    undefined: x2.undefined,
    column: {
      from: typeof x2.column === "function" ? x2.column : x2.column && x2.column.from,
      to: x2.column && x2.column.to
    },
    value: {
      from: typeof x2.value === "function" ? x2.value : x2.value && x2.value.from,
      to: x2.value && x2.value.to
    },
    row: {
      from: typeof x2.row === "function" ? x2.row : x2.row && x2.row.from,
      to: x2.row && x2.row.to
    }
  };
}
function parseUrl(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
}
var src_default;
var init_src = __esm(() => {
  init_types3();
  init_connection();
  init_query();
  init_queue();
  init_errors2();
  init_large();
  Object.assign(Postgres, {
    PostgresError,
    toPascal,
    pascal,
    toCamel,
    camel,
    toKebab,
    kebab,
    fromPascal,
    fromCamel,
    fromKebab,
    BigInt: {
      to: 20,
      from: [20],
      parse: (x2) => BigInt(x2),
      serialize: (x2) => x2.toString()
    }
  });
  src_default = Postgres;
});

// node_modules/@flowcore/pathways/esm/pathways/postgres/postgres-adapter.js
class PostgresJsAdapter {
  constructor(config) {
    Object.defineProperty(this, "postgres", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "sql", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "connectionString", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.config = config;
    if ("connectionString" in config && config.connectionString) {
      this.connectionString = config.connectionString;
    } else {
      this.connectionString = `postgres://${config.user}:${config.password}@${config.host}:${config.port}/${config.database}`;
      if (config.ssl) {
        this.connectionString += "?sslmode=require";
      }
    }
  }
  async connect() {
    try {
      const module = await Promise.resolve().then(() => (init_src(), exports_src));
      this.postgres = module.default;
      const postgresOptions = {};
      if (this.config.pool) {
        if (this.config.pool.max !== undefined) {
          postgresOptions.max = this.config.pool.max;
        }
        if (this.config.pool.max_lifetime !== undefined) {
          postgresOptions.max_lifetime = this.config.pool.max_lifetime;
        }
        if (this.config.pool.idle_timeout !== undefined) {
          postgresOptions.idle_timeout = this.config.pool.idle_timeout;
        }
        if (this.config.pool.connect_timeout !== undefined) {
          postgresOptions.connect_timeout = this.config.pool.connect_timeout;
        }
      }
      this.sql = this.postgres(this.connectionString, postgresOptions);
    } catch (error2) {
      console.error("Failed to connect to PostgreSQL:", error2);
      throw error2;
    }
  }
  async disconnect() {
    if (this.sql) {
      await this.sql.end();
      this.sql = null;
    }
  }
  async query(sql2, params = []) {
    if (!this.sql) {
      await this.connect();
    }
    return await this.sql.unsafe(sql2, params);
  }
  async execute(sql2, params = []) {
    if (!this.sql) {
      await this.connect();
    }
    await this.sql.unsafe(sql2, params);
  }
}
async function createPostgresAdapter(config) {
  const adapter = new PostgresJsAdapter(config);
  await adapter.connect();
  return adapter;
}

// node_modules/@flowcore/pathways/esm/pathways/postgres/postgres-pathway-state.js
class PostgresPathwayState {
  constructor(config) {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: config
    });
    Object.defineProperty(this, "postgres", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tableName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "ttlMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "initialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.tableName = config.tableName || PostgresPathwayState.DEFAULT_TABLE_NAME;
    this.ttlMs = config.ttlMs || PostgresPathwayState.DEFAULT_TTL_MS;
    this.postgres = null;
  }
  async initialize() {
    if (this.initialized) {
      return;
    }
    if ("connectionString" in this.config && this.config.connectionString) {
      this.postgres = await createPostgresAdapter({
        connectionString: this.config.connectionString,
        pool: this.config.pool
      });
    } else {
      this.postgres = await createPostgresAdapter({
        host: this.config.host,
        port: this.config.port,
        user: this.config.user,
        password: this.config.password,
        database: this.config.database,
        ssl: this.config.ssl,
        pool: this.config.pool
      });
    }
    const tableExists = await this.postgres.query(`
      SELECT EXISTS (
        SELECT 1
        FROM information_schema.tables
        WHERE table_name = $1
      )
    `, [this.tableName]);
    if (!tableExists[0]?.exists) {
      await this.postgres.execute(`
        CREATE TABLE IF NOT EXISTS ${this.tableName} (
          event_id TEXT PRIMARY KEY,
          processed BOOLEAN NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
          expires_at TIMESTAMP WITH TIME ZONE NOT NULL
        )
      `);
      await this.postgres.execute(`
        CREATE INDEX IF NOT EXISTS ${this.tableName}_expires_at_idx ON ${this.tableName} (expires_at)
      `);
    }
    this.initialized = true;
  }
  async isProcessed(eventId) {
    await this.initialize();
    await this.cleanupExpired();
    const result = await this.postgres.query(`
      SELECT processed FROM ${this.tableName}
      WHERE event_id = $1 AND expires_at > NOW()
    `, [eventId]);
    return result.length > 0 && result[0].processed;
  }
  async setProcessed(eventId) {
    await this.initialize();
    await this.postgres.execute(`
      INSERT INTO ${this.tableName} (event_id, processed, expires_at)
      VALUES ($1, TRUE, NOW() + interval '${Math.floor(this.ttlMs / 1000)} seconds')
      ON CONFLICT (event_id)
      DO UPDATE SET
        processed = TRUE,
        expires_at = NOW() + interval '${Math.floor(this.ttlMs / 1000)} seconds'
    `, [eventId]);
  }
  async cleanupExpired() {
    await this.postgres.execute(`
      DELETE FROM ${this.tableName}
      WHERE expires_at < NOW()
    `);
  }
  async close() {
    if (this.postgres) {
      await this.postgres.disconnect();
    }
  }
}
function createPostgresPathwayState(config) {
  const state = new PostgresPathwayState(config);
  return state;
}
var init_postgres_pathway_state = __esm(() => {
  Object.defineProperty(PostgresPathwayState, "DEFAULT_TTL_MS", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5 * 60 * 1000
  });
  Object.defineProperty(PostgresPathwayState, "DEFAULT_TABLE_NAME", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: "pathway_state"
  });
});

// node_modules/@flowcore/pathways/esm/pathways/postgres/index.js
var init_postgres = __esm(() => {
  init_postgres_pathway_state();
});

// node_modules/@flowcore/pathways/esm/pathways/session-pathway.js
function generateUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}

class SessionPathwayBuilder {
  constructor(pathwaysBuilder, sessionId) {
    Object.defineProperty(this, "pathwaysBuilder", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "sessionId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.pathwaysBuilder = pathwaysBuilder;
    this.sessionId = sessionId ?? generateUUID();
  }
  getSessionId() {
    return this.sessionId;
  }
  withUserResolver(resolver) {
    this.pathwaysBuilder.withSessionUserResolver(this.sessionId, resolver);
    return this;
  }
  async write(path, input) {
    const { data, metadata, options, batch } = input;
    const finalOptions = options ? { ...options } : {};
    finalOptions.sessionId = options?.sessionId ?? this.sessionId;
    return await this.pathwaysBuilder.write(path, {
      batch,
      data,
      metadata,
      options: finalOptions
    });
  }
}

// node_modules/@flowcore/pathways/esm/pathways/index.js
var init_pathways = __esm(() => {
  init_builder();
  init_internal_pathway_state();
  init_postgres();
  init_types2();
});

// node_modules/@flowcore/pathways/esm/router/index.js
class PathwayRouter {
  constructor(pathways, secretKey, logger2) {
    Object.defineProperty(this, "pathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: pathways
    });
    Object.defineProperty(this, "secretKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: secretKey
    });
    Object.defineProperty(this, "logger", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.logger = logger2 ?? new NoopLogger2;
    if (!secretKey || secretKey.trim() === "") {
      const errorMsg = "Secret key is required for PathwayRouter";
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    this.logger.debug("PathwayRouter initialized");
  }
  async processEvent(event2, providedSecret) {
    if (!providedSecret || providedSecret !== this.secretKey) {
      const errorMsg = "Invalid secret key";
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    const compatibleEvent = {
      ...event2,
      ...event2.aggregator ? { flowType: event2.aggregator } : {}
    };
    const pathwayKey = `${compatibleEvent.flowType}/${compatibleEvent.eventType}`;
    this.logger.debug(`Processing event for pathway: ${pathwayKey}`, {
      eventId: compatibleEvent.eventId
    });
    const pathway = this.pathways.get(pathwayKey);
    if (!pathway) {
      const errorMsg = `Pathway ${pathwayKey} not found`;
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    try {
      this.logger.debug(`Delegating event processing to pathway handler`, {
        pathwayKey,
        eventId: compatibleEvent.eventId
      });
      await this.pathways.process(pathwayKey, compatibleEvent);
      this.logger.debug(`Event successfully processed through pathway`, {
        pathwayKey,
        eventId: compatibleEvent.eventId
      });
      return { success: true, message: `Event processed through pathway ${pathwayKey}` };
    } catch (error2) {
      const errorObj = error2 instanceof Error ? error2 : new Error(String(error2));
      this.logger.error(`Error processing pathway ${pathwayKey}`, errorObj, {
        eventId: compatibleEvent.eventId
      });
      throw new Error(`Failed to process event in pathway ${pathwayKey}: ${errorObj.message}`);
    }
  }
}
var init_router = () => {};

// node_modules/@flowcore/pathways/esm/mod.js
var exports_mod = {};
__export(exports_mod, {
  createPostgresPathwayState: () => createPostgresPathwayState,
  createPostgresAdapter: () => createPostgresAdapter,
  createKvAdapter: () => createKvAdapter,
  SessionUser: () => SessionUser,
  SessionPathwayBuilder: () => SessionPathwayBuilder,
  PostgresPathwayState: () => PostgresPathwayState,
  PostgresJsAdapter: () => PostgresJsAdapter,
  PathwaysBuilder: () => PathwaysBuilder,
  PathwayRouter: () => PathwayRouter,
  NoopLogger: () => NoopLogger2,
  InternalPathwayState: () => InternalPathwayState,
  FileInputSchema: () => FileInputSchema,
  FileEventSchema: () => FileEventSchema,
  ConsoleLogger: () => ConsoleLogger,
  AUDIT_USER_MODE: () => AUDIT_USER_MODE,
  AUDIT_USER_ENTITY_TYPE: () => AUDIT_USER_ENTITY_TYPE,
  AUDIT_SYSTEM_MODE: () => AUDIT_SYSTEM_MODE,
  AUDIT_SESSION_ID: () => AUDIT_SESSION_ID,
  AUDIT_ON_BEHALF_OF_TYPE: () => AUDIT_ON_BEHALF_OF_TYPE,
  AUDIT_ON_BEHALF_OF_ID: () => AUDIT_ON_BEHALF_OF_ID,
  AUDIT_MODE: () => AUDIT_MODE,
  AUDIT_KEY_ENTITY_TYPE: () => AUDIT_KEY_ENTITY_TYPE,
  AUDIT_ENTITY_TYPE: () => AUDIT_ENTITY_TYPE,
  AUDIT_ENTITY_ID: () => AUDIT_ENTITY_ID
});
var init_mod = __esm(() => {
  init_common();
  init_contracts();
  init_pathways();
  init_router();
});

// node_modules/@scalar/core/dist/libs/html-rendering/html-rendering.js
function getScriptTags(configuration, cdn) {
  const restConfig = { ...configuration };
  const functionProps = [];
  for (const [key, value] of Object.entries(configuration)) {
    if (typeof value === "function") {
      functionProps.push(`"${key}": ${value.toString()}`);
      delete restConfig[key];
    } else if (Array.isArray(value) && value.some((item) => typeof item === "function")) {
      functionProps.push(`"${key}": ${serializeArrayWithFunctions(value)}`);
      delete restConfig[key];
    }
  }
  const configString = JSON.stringify(restConfig, null, 2).split(`
`).map((line2, index) => index === 0 ? line2 : "      " + line2).join(`
`).replace(/\s*}$/, "");
  const functionPropsString = functionProps.length ? `,
        ${functionProps.join(`,
        `)}
      }` : "}";
  return `
    <!-- Load the Script -->
    <script src="${cdn ?? "https://cdn.jsdelivr.net/npm/@scalar/api-reference"}"></script>

    <!-- Initialize the Scalar API Reference -->
    <script type="text/javascript">
      Scalar.createApiReference('#app', ${configString}${functionPropsString})
    </script>`;
}
var addIndent = (str, spaces = 2, initialIndent = false) => {
  const indent = " ".repeat(spaces);
  const lines = str.split(`
`);
  return lines.map((line2, index) => {
    if (index === 0 && !initialIndent) {
      return line2;
    }
    return `${indent}${line2}`;
  }).join(`
`);
}, getStyles = (configuration, customTheme) => {
  const styles = [];
  if (configuration.customCss) {
    styles.push("/* Custom CSS */");
    styles.push(configuration.customCss);
  }
  if (!configuration.theme && customTheme) {
    styles.push("/* Custom Theme */");
    styles.push(customTheme);
  }
  if (styles.length === 0) {
    return "";
  }
  return `
    <style type="text/css">
      ${addIndent(styles.join(`

`), 6)}
    </style>`;
}, getHtmlDocument = (givenConfiguration, customTheme = "") => {
  const { cdn, pageTitle, customCss, theme, ...rest } = givenConfiguration;
  const configuration = getConfiguration({
    ...rest,
    ...theme ? { theme } : {},
    customCss
  });
  const content = `<!doctype html>
<html>
  <head>
    <title>${pageTitle ?? "Scalar API Reference"}</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />${getStyles(configuration, customTheme)}
  </head>
  <body>
    <div id="app"></div>${getScriptTags(configuration, cdn)}
  </body>
</html>`;
  return content;
}, serializeArrayWithFunctions = (arr) => {
  return `[${arr.map((item) => typeof item === "function" ? item.toString() : JSON.stringify(item)).join(", ")}]`;
}, getConfiguration = (givenConfiguration) => {
  const configuration = {
    ...givenConfiguration
  };
  if (typeof configuration.content === "function") {
    configuration.content = configuration.content();
  }
  if (configuration.content && configuration.url) {
    delete configuration.content;
  }
  return configuration;
};
var init_html_rendering = () => {};

// node_modules/@scalar/core/dist/libs/html-rendering/index.js
var init_html_rendering2 = __esm(() => {
  init_html_rendering();
});

// node_modules/@scalar/hono-api-reference/dist/scalar.js
var DEFAULT_CONFIGURATION, customTheme = `
.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 245, .86);
  --scalar-color-2: rgba(255, 255, 245, .6);
  --scalar-color-3: rgba(255, 255, 245, .38);
  --scalar-color-disabled: rgba(255, 255, 245, .25);
  --scalar-color-ghost: rgba(255, 255, 245, .25);
  --scalar-color-accent: #e36002;
  --scalar-background-1: #1e1e20;
  --scalar-background-2: #2a2a2a;
  --scalar-background-3: #505053;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #e360021f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,
    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #3dd68c;
  --scalar-color-red: #f66f81;
  --scalar-color-yellow: #f9b44e;
  --scalar-color-blue: #5c73e7;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
/* Sidebar */
.dark-mode .sidebar {
  --scalar-sidebar-background-1: #161618;
  --scalar-sidebar-item-hover-color: var(--scalar-color-accent);
  --scalar-sidebar-item-hover-background: transparent;
  --scalar-sidebar-item-active-background: transparent;
  --scalar-sidebar-border-color: transparent;
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: #252529;
  --scalar-sidebar-search-border-color: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
`, Scalar = (configOrResolver) => {
  return async (c) => {
    let resolvedConfig = {};
    if (typeof configOrResolver === "function") {
      resolvedConfig = await configOrResolver(c);
    } else {
      resolvedConfig = configOrResolver;
    }
    const configuration = {
      ...DEFAULT_CONFIGURATION,
      ...resolvedConfig
    };
    return c.html(getHtmlDocument(configuration, customTheme));
  };
}, apiReference;
var init_scalar = __esm(() => {
  init_html_rendering2();
  DEFAULT_CONFIGURATION = {
    _integration: "hono"
  };
  apiReference = Scalar;
});

// node_modules/@scalar/hono-api-reference/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  apiReference: () => apiReference,
  Scalar: () => Scalar
});
var init_dist2 = __esm(() => {
  init_scalar();
});

// node_modules/@asteasolutions/zod-to-openapi/dist/index.mjs
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function isZodType(schema, typeName) {
  var _a;
  return ((_a = schema === null || schema === undefined ? undefined : schema._def) === null || _a === undefined ? undefined : _a.typeName) === typeName;
}
function isAnyZodType(schema) {
  return "_def" in schema;
}
function preserveMetadataFromModifier(zod, modifier) {
  const zodModifier = zod.ZodType.prototype[modifier];
  zod.ZodType.prototype[modifier] = function(...args) {
    const result = zodModifier.apply(this, args);
    result._def.openapi = this._def.openapi;
    return result;
  };
}
function extendZodWithOpenApi(zod) {
  if (typeof zod.ZodType.prototype.openapi !== "undefined") {
    return;
  }
  zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
    var _a, _b, _c, _d, _e, _f;
    const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
    const _g = openapi !== null && openapi !== undefined ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
    const _internal = Object.assign(Object.assign({}, (_a = this._def.openapi) === null || _a === undefined ? undefined : _a._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : undefined);
    const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === undefined ? undefined : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === undefined ? undefined : _c.metadata) === null || _d === undefined ? undefined : _d.param) || param ? {
      param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === undefined ? undefined : _e.metadata) === null || _f === undefined ? undefined : _f.param), param)
    } : undefined);
    const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : undefined), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : undefined) }));
    if (isZodType(this, "ZodObject")) {
      const originalExtend = this.extend;
      result.extend = function(...args) {
        var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
        const extendedResult = originalExtend.apply(this, args);
        extendedResult._def.openapi = {
          _internal: {
            extendedFrom: ((_b2 = (_a2 = this._def.openapi) === null || _a2 === undefined ? undefined : _a2._internal) === null || _b2 === undefined ? undefined : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === undefined ? undefined : _c2._internal) === null || _d2 === undefined ? undefined : _d2.refId, schema: this } : (_f2 = (_e2 = this._def.openapi) === null || _e2 === undefined ? undefined : _e2._internal) === null || _f2 === undefined ? undefined : _f2.extendedFrom
          },
          metadata: (_g2 = extendedResult._def.openapi) === null || _g2 === undefined ? undefined : _g2.metadata
        };
        return extendedResult;
      };
    }
    return result;
  };
  preserveMetadataFromModifier(zod, "optional");
  preserveMetadataFromModifier(zod, "nullable");
  preserveMetadataFromModifier(zod, "default");
  preserveMetadataFromModifier(zod, "transform");
  preserveMetadataFromModifier(zod, "refine");
  const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
  zod.ZodObject.prototype.deepPartial = function() {
    const initialShape = this._def.shape();
    const result = zodDeepPartial.apply(this);
    const resultShape = result._def.shape();
    Object.entries(resultShape).forEach(([key, value]) => {
      var _a, _b;
      value._def.openapi = (_b = (_a = initialShape[key]) === null || _a === undefined ? undefined : _a._def) === null || _b === undefined ? undefined : _b.openapi;
    });
    result._def.openapi = undefined;
    return result;
  };
  const zodPick = zod.ZodObject.prototype.pick;
  zod.ZodObject.prototype.pick = function(...args) {
    const result = zodPick.apply(this, args);
    result._def.openapi = undefined;
    return result;
  };
  const zodOmit = zod.ZodObject.prototype.omit;
  zod.ZodObject.prototype.omit = function(...args) {
    const result = zodOmit.apply(this, args);
    result._def.openapi = undefined;
    return result;
  };
}
function isEqual(x, y) {
  if (x === null || x === undefined || y === null || y === undefined) {
    return x === y;
  }
  if (x === y || x.valueOf() === y.valueOf()) {
    return true;
  }
  if (Array.isArray(x)) {
    if (!Array.isArray(y)) {
      return false;
    }
    if (x.length !== y.length) {
      return false;
    }
  }
  if (!(x instanceof Object) || !(y instanceof Object)) {
    return false;
  }
  const keysX = Object.keys(x);
  return Object.keys(y).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x[key], y[key]));
}

class ObjectSet {
  constructor() {
    this.buckets = new Map;
  }
  put(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      this.buckets.set(hashCode, [value]);
      return;
    }
    const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
    if (!alreadyHasItem) {
      itemsByCode.push(value);
    }
  }
  contains(value) {
    const hashCode = this.hashCodeOf(value);
    const itemsByCode = this.buckets.get(hashCode);
    if (!itemsByCode) {
      return false;
    }
    return itemsByCode.some((_) => isEqual(_, value));
  }
  values() {
    return [...this.buckets.values()].flat();
  }
  stats() {
    let totalBuckets = 0;
    let totalValues = 0;
    let collisions = 0;
    for (const bucket of this.buckets.values()) {
      totalBuckets += 1;
      totalValues += bucket.length;
      if (bucket.length > 1) {
        collisions += 1;
      }
    }
    const hashEffectiveness = totalBuckets / totalValues;
    return { totalBuckets, collisions, totalValues, hashEffectiveness };
  }
  hashCodeOf(object) {
    let hashCode = 0;
    if (Array.isArray(object)) {
      for (let i = 0;i < object.length; i++) {
        hashCode ^= this.hashCodeOf(object[i]) * i;
      }
      return hashCode;
    }
    if (typeof object === "string") {
      for (let i = 0;i < object.length; i++) {
        hashCode ^= object.charCodeAt(i) * i;
      }
      return hashCode;
    }
    if (typeof object === "number") {
      return object;
    }
    if (typeof object === "object") {
      for (const [key, value] of Object.entries(object)) {
        hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== undefined ? value : "");
      }
    }
    return hashCode;
  }
}
function isUndefined(value) {
  return value === undefined;
}
function mapValues(object, mapper) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    result[key] = mapper(value);
  });
  return result;
}
function omit(object, keys) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!keys.some((keyToOmit) => keyToOmit === key)) {
      result[key] = value;
    }
  });
  return result;
}
function omitBy(object, predicate) {
  const result = {};
  Object.entries(object).forEach(([key, value]) => {
    if (!predicate(value, key)) {
      result[key] = value;
    }
  });
  return result;
}
function compact(arr) {
  return arr.filter((elem) => !isUndefined(elem));
}
var objectEquals = isEqual;
function uniq(values) {
  const set = new ObjectSet;
  values.forEach((value) => set.put(value));
  return [...set.values()];
}
function isString(val) {
  return typeof val === "string";
}
class OpenAPIRegistry {
  constructor(parents) {
    this.parents = parents;
    this._definitions = [];
  }
  get definitions() {
    var _a, _b;
    const parentDefinitions = (_b = (_a = this.parents) === null || _a === undefined ? undefined : _a.flatMap((par) => par.definitions)) !== null && _b !== undefined ? _b : [];
    return [...parentDefinitions, ...this._definitions];
  }
  register(refId, zodSchema) {
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    this._definitions.push({ type: "schema", schema: schemaWithRefId });
    return schemaWithRefId;
  }
  registerParameter(refId, zodSchema) {
    var _a, _b, _c;
    const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
    const currentMetadata = (_a = schemaWithRefId._def.openapi) === null || _a === undefined ? undefined : _a.metadata;
    const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === undefined ? undefined : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === undefined ? undefined : currentMetadata.param) === null || _b === undefined ? undefined : _b.name) !== null && _c !== undefined ? _c : refId }) }));
    this._definitions.push({
      type: "parameter",
      schema: schemaWithMetadata
    });
    return schemaWithMetadata;
  }
  registerPath(route) {
    this._definitions.push({
      type: "route",
      route
    });
  }
  registerWebhook(webhook) {
    this._definitions.push({
      type: "webhook",
      webhook
    });
  }
  registerComponent(type, name, component) {
    this._definitions.push({
      type: "component",
      componentType: type,
      name,
      component
    });
    return {
      name,
      ref: { $ref: `#/components/${type}/${name}` }
    };
  }
  schemaWithRefId(refId, zodSchema) {
    return zodSchema.openapi(refId);
  }
}

class ZodToOpenAPIError {
  constructor(message) {
    this.message = message;
  }
}

class ConflictError extends ZodToOpenAPIError {
  constructor(message, data) {
    super(message);
    this.data = data;
  }
}

class MissingParameterDataError extends ZodToOpenAPIError {
  constructor(data) {
    super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
    this.data = data;
  }
}
function enhanceMissingParametersError(action, paramsToAdd) {
  try {
    return action();
  } catch (error) {
    if (error instanceof MissingParameterDataError) {
      throw new MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
    }
    throw error;
  }
}

class UnknownZodTypeError extends ZodToOpenAPIError {
  constructor(data) {
    super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
    this.data = data;
  }
}

class Metadata {
  static getMetadata(zodSchema) {
    var _a;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a = zodSchema.description) !== null && _a !== undefined ? _a : innerSchema.description;
    return {
      _internal: metadata === null || metadata === undefined ? undefined : metadata._internal,
      metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === undefined ? undefined : metadata.metadata)
    };
  }
  static getInternalMetadata(zodSchema) {
    const innerSchema = this.unwrapChained(zodSchema);
    const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    return openapi === null || openapi === undefined ? undefined : openapi._internal;
  }
  static getParamMetadata(zodSchema) {
    var _a, _b;
    const innerSchema = this.unwrapChained(zodSchema);
    const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
    const zodDescription = (_a = zodSchema.description) !== null && _a !== undefined ? _a : innerSchema.description;
    return {
      _internal: metadata === null || metadata === undefined ? undefined : metadata._internal,
      metadata: Object.assign(Object.assign({}, metadata === null || metadata === undefined ? undefined : metadata.metadata), {
        param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _b === undefined ? undefined : _b.param)
      })
    };
  }
  static buildSchemaMetadata(metadata) {
    return omitBy(omit(metadata, ["param"]), isUndefined);
  }
  static buildParameterMetadata(metadata) {
    return omitBy(metadata, isUndefined);
  }
  static applySchemaMetadata(initialData, metadata) {
    return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isUndefined);
  }
  static getRefId(zodSchema) {
    var _a;
    return (_a = this.getInternalMetadata(zodSchema)) === null || _a === undefined ? undefined : _a.refId;
  }
  static unwrapChained(schema) {
    return this.unwrapUntil(schema);
  }
  static getDefaultValue(zodSchema) {
    const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
    return unwrapped === null || unwrapped === undefined ? undefined : unwrapped._def.defaultValue();
  }
  static unwrapUntil(schema, typeName) {
    if (typeName && isZodType(schema, typeName)) {
      return schema;
    }
    if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
      return this.unwrapUntil(schema.unwrap(), typeName);
    }
    if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
      return this.unwrapUntil(schema._def.innerType, typeName);
    }
    if (isZodType(schema, "ZodEffects")) {
      return this.unwrapUntil(schema._def.schema, typeName);
    }
    if (isZodType(schema, "ZodPipeline")) {
      return this.unwrapUntil(schema._def.in, typeName);
    }
    return typeName ? undefined : schema;
  }
  static isOptionalSchema(zodSchema) {
    return zodSchema.isOptional();
  }
}

class ArrayTransformer {
  transform(zodSchema, mapNullableType, mapItems) {
    var _a, _b;
    const itemType = zodSchema._def.type;
    return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a = zodSchema._def.minLength) === null || _a === undefined ? undefined : _a.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === undefined ? undefined : _b.value });
  }
}

class BigIntTransformer {
  transform(mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
  }
}

class DiscriminatedUnionTransformer {
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
    const options = [...zodSchema.options.values()];
    const optionSchema = options.map(mapItem);
    if (isNullable) {
      return {
        oneOf: mapNullableOfArray(optionSchema, isNullable)
      };
    }
    return {
      oneOf: optionSchema,
      discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
    };
  }
  mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
    if (zodObjects.some((obj) => Metadata.getRefId(obj) === undefined)) {
      return;
    }
    const mapping = {};
    zodObjects.forEach((obj) => {
      var _a;
      const refId = Metadata.getRefId(obj);
      const value = (_a = obj.shape) === null || _a === undefined ? undefined : _a[discriminator];
      if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
        const keys = Object.values(value.enum).filter(isString);
        keys.forEach((enumValue) => {
          mapping[enumValue] = generateSchemaRef(refId);
        });
        return;
      }
      const literalValue = value === null || value === undefined ? undefined : value._def.value;
      if (typeof literalValue !== "string") {
        throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
      }
      mapping[literalValue] = generateSchemaRef(refId);
    });
    return {
      propertyName: discriminator,
      mapping
    };
  }
}

class EnumTransformer {
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
  }
}

class IntersectionTransformer {
  transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
    const subtypes = this.flattenIntersectionTypes(zodSchema);
    const allOfSchema = {
      allOf: subtypes.map(mapItem)
    };
    if (isNullable) {
      return {
        anyOf: mapNullableOfArray([allOfSchema], isNullable)
      };
    }
    return allOfSchema;
  }
  flattenIntersectionTypes(schema) {
    if (!isZodType(schema, "ZodIntersection")) {
      return [schema];
    }
    const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
    const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
    return [...leftSubTypes, ...rightSubTypes];
  }
}

class LiteralTransformer {
  transform(zodSchema, mapNullableType) {
    return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
  }
}
function enumInfo(enumObject) {
  const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
  const values = keysExceptReverseMappings.map((key) => enumObject[key]);
  const numericCount = values.filter((_) => typeof _ === "number").length;
  const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
  return { values, type };
}

class NativeEnumTransformer {
  transform(zodSchema, mapNullableType) {
    const { type, values } = enumInfo(zodSchema._def.values);
    if (type === "mixed") {
      throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
    }
    return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
  }
}

class NumberTransformer {
  transform(zodSchema, mapNullableType, getNumberChecks) {
    return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
  }
}

class ObjectTransformer {
  transform(zodSchema, defaultValue, mapNullableType, mapItem) {
    var _a;
    const extendedFrom = (_a = Metadata.getInternalMetadata(zodSchema)) === null || _a === undefined ? undefined : _a.extendedFrom;
    const required = this.requiredKeysOf(zodSchema);
    const properties = mapValues(zodSchema._def.shape(), mapItem);
    if (!extendedFrom) {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    }
    const parent = extendedFrom.schema;
    mapItem(parent);
    const keysRequiredByParent = this.requiredKeysOf(parent);
    const propsOfParent = mapValues(parent === null || parent === undefined ? undefined : parent._def.shape(), mapItem);
    const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
      return !objectEquals(propsOfParent[key], type);
    }));
    const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
    const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
    return {
      allOf: [
        { $ref: `#/components/schemas/${extendedFrom.refId}` },
        objectData
      ]
    };
  }
  generateAdditionalProperties(zodSchema, mapItem) {
    const unknownKeysOption = zodSchema._def.unknownKeys;
    const catchallSchema = zodSchema._def.catchall;
    if (isZodType(catchallSchema, "ZodNever")) {
      if (unknownKeysOption === "strict") {
        return { additionalProperties: false };
      }
      return {};
    }
    return { additionalProperties: mapItem(catchallSchema) };
  }
  requiredKeysOf(objectSchema) {
    return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key, _type]) => key);
  }
}

class RecordTransformer {
  transform(zodSchema, mapNullableType, mapItem) {
    const propertiesType = zodSchema._def.valueType;
    const keyType = zodSchema._def.keyType;
    const propertiesSchema = mapItem(propertiesType);
    if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
      const keys = Object.values(keyType.enum).filter(isString);
      const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
      return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
    }
    return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
  }
}

class StringTransformer {
  transform(zodSchema, mapNullableType) {
    var _a, _b, _c;
    const regexCheck = this.getZodStringCheck(zodSchema, "regex");
    const length = (_a = this.getZodStringCheck(zodSchema, "length")) === null || _a === undefined ? undefined : _a.value;
    const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== undefined ? _b : undefined : undefined;
    const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== undefined ? _c : undefined : undefined;
    return Object.assign(Object.assign({}, mapNullableType("string")), {
      minLength: length !== null && length !== undefined ? length : maxLength,
      maxLength: length !== null && length !== undefined ? length : minLength,
      format: this.mapStringFormat(zodSchema),
      pattern: regexCheck === null || regexCheck === undefined ? undefined : regexCheck.regex.source
    });
  }
  mapStringFormat(zodString) {
    if (zodString.isUUID)
      return "uuid";
    if (zodString.isEmail)
      return "email";
    if (zodString.isURL)
      return "uri";
    if (zodString.isDate)
      return "date";
    if (zodString.isDatetime)
      return "date-time";
    if (zodString.isCUID)
      return "cuid";
    if (zodString.isCUID2)
      return "cuid2";
    if (zodString.isULID)
      return "ulid";
    if (zodString.isIP)
      return "ip";
    if (zodString.isEmoji)
      return "emoji";
    return;
  }
  getZodStringCheck(zodString, kind) {
    return zodString._def.checks.find((check) => {
      return check.kind === kind;
    });
  }
}

class TupleTransformer {
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
  }
  transform(zodSchema, mapNullableType, mapItem) {
    const { items } = zodSchema._def;
    const schemas = items.map(mapItem);
    return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
  }
}

class UnionTransformer {
  transform(zodSchema, mapNullableOfArray, mapItem) {
    const options = this.flattenUnionTypes(zodSchema);
    const schemas = options.map((schema) => {
      const optionToGenerate = this.unwrapNullable(schema);
      return mapItem(optionToGenerate);
    });
    return {
      anyOf: mapNullableOfArray(schemas)
    };
  }
  flattenUnionTypes(schema) {
    if (!isZodType(schema, "ZodUnion")) {
      return [schema];
    }
    const options = schema._def.options;
    return options.flatMap((option) => this.flattenUnionTypes(option));
  }
  unwrapNullable(schema) {
    if (isZodType(schema, "ZodNullable")) {
      return this.unwrapNullable(schema.unwrap());
    }
    return schema;
  }
}

class OpenApiTransformer {
  constructor(versionSpecifics) {
    this.versionSpecifics = versionSpecifics;
    this.objectTransformer = new ObjectTransformer;
    this.stringTransformer = new StringTransformer;
    this.numberTransformer = new NumberTransformer;
    this.bigIntTransformer = new BigIntTransformer;
    this.literalTransformer = new LiteralTransformer;
    this.enumTransformer = new EnumTransformer;
    this.nativeEnumTransformer = new NativeEnumTransformer;
    this.arrayTransformer = new ArrayTransformer;
    this.unionTransformer = new UnionTransformer;
    this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer;
    this.intersectionTransformer = new IntersectionTransformer;
    this.recordTransformer = new RecordTransformer;
    this.tupleTransformer = new TupleTransformer(versionSpecifics);
  }
  transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
    if (isZodType(zodSchema, "ZodNull")) {
      return this.versionSpecifics.nullType;
    }
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(undefined, isNullable);
    }
    if (isZodType(zodSchema, "ZodObject")) {
      return this.objectTransformer.transform(zodSchema, defaultValue, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
    return Object.assign(Object.assign({}, schema), { default: defaultValue });
  }
  transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
    if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
      return this.versionSpecifics.mapNullableType(undefined, isNullable);
    }
    if (isZodType(zodSchema, "ZodString")) {
      return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNumber")) {
      return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_) => this.versionSpecifics.getNumberChecks(_));
    }
    if (isZodType(zodSchema, "ZodBigInt")) {
      return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodBoolean")) {
      return this.versionSpecifics.mapNullableType("boolean", isNullable);
    }
    if (isZodType(zodSchema, "ZodLiteral")) {
      return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodEnum")) {
      return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodNativeEnum")) {
      return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
    }
    if (isZodType(zodSchema, "ZodArray")) {
      return this.arrayTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodTuple")) {
      return this.tupleTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodUnion")) {
      return this.unionTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
      return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);
    }
    if (isZodType(zodSchema, "ZodIntersection")) {
      return this.intersectionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodRecord")) {
      return this.recordTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
    }
    if (isZodType(zodSchema, "ZodDate")) {
      return this.versionSpecifics.mapNullableType("string", isNullable);
    }
    const refId = Metadata.getRefId(zodSchema);
    throw new UnknownZodTypeError({
      currentSchema: zodSchema._def,
      schemaName: refId
    });
  }
}

class OpenAPIGenerator {
  constructor(definitions, versionSpecifics) {
    this.definitions = definitions;
    this.versionSpecifics = versionSpecifics;
    this.schemaRefs = {};
    this.paramRefs = {};
    this.pathRefs = {};
    this.rawComponents = [];
    this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
    this.sortDefinitions();
  }
  generateDocumentData() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents(),
      paths: this.pathRefs
    };
  }
  generateComponents() {
    this.definitions.forEach((definition) => this.generateSingle(definition));
    return {
      components: this.buildComponents()
    };
  }
  buildComponents() {
    var _a, _b;
    const rawComponents = {};
    this.rawComponents.forEach(({ componentType, name, component }) => {
      var _a2;
      (_a2 = rawComponents[componentType]) !== null && _a2 !== undefined || (rawComponents[componentType] = {});
      rawComponents[componentType][name] = component;
    });
    return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a = rawComponents.schemas) !== null && _a !== undefined ? _a : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== undefined ? _b : {}), this.paramRefs) });
  }
  sortDefinitions() {
    const generationOrder = [
      "schema",
      "parameter",
      "component",
      "route"
    ];
    this.definitions.sort((left, right) => {
      if (!("type" in left)) {
        if (!("type" in right)) {
          return 0;
        }
        return -1;
      }
      if (!("type" in right)) {
        return 1;
      }
      const leftIndex = generationOrder.findIndex((type) => type === left.type);
      const rightIndex = generationOrder.findIndex((type) => type === right.type);
      return leftIndex - rightIndex;
    });
  }
  generateSingle(definition) {
    if (!("type" in definition)) {
      this.generateSchemaWithRef(definition);
      return;
    }
    switch (definition.type) {
      case "parameter":
        this.generateParameterDefinition(definition.schema);
        return;
      case "schema":
        this.generateSchemaWithRef(definition.schema);
        return;
      case "route":
        this.generateSingleRoute(definition.route);
        return;
      case "component":
        this.rawComponents.push(definition);
        return;
    }
  }
  generateParameterDefinition(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateParameter(zodSchema);
    if (refId) {
      this.paramRefs[refId] = result;
    }
    return result;
  }
  getParameterRef(schemaMetadata, external) {
    var _a, _b, _c, _d, _e;
    const parameterMetadata = (_a = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata.metadata) === null || _a === undefined ? undefined : _a.param;
    const existingRef = ((_b = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata._internal) === null || _b === undefined ? undefined : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === undefined ? undefined : _c.refId] : undefined;
    if (!((_d = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata._internal) === null || _d === undefined ? undefined : _d.refId) || !existingRef) {
      return;
    }
    if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === undefined ? undefined : external.in) && existingRef.in !== external.in) {
      throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
        key: "in",
        values: compact([
          existingRef.in,
          external === null || external === undefined ? undefined : external.in,
          parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.in
        ])
      });
    }
    if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === undefined ? undefined : external.name) && existingRef.name !== (external === null || external === undefined ? undefined : external.name)) {
      throw new ConflictError(`Conflicting names for parameter`, {
        key: "name",
        values: compact([
          existingRef.name,
          external === null || external === undefined ? undefined : external.name,
          parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.name
        ])
      });
    }
    return {
      $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === undefined ? undefined : _e.refId}`
    };
  }
  generateInlineParameters(zodSchema, location) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const parameterMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
    const referencedSchema = this.getParameterRef(metadata, { in: location });
    if (referencedSchema) {
      return [referencedSchema];
    }
    if (isZodType(zodSchema, "ZodObject")) {
      const propTypes = zodSchema._def.shape();
      const parameters = Object.entries(propTypes).map(([key, schema]) => {
        var _a2, _b;
        const innerMetadata = Metadata.getMetadata(schema);
        const referencedSchema2 = this.getParameterRef(innerMetadata, {
          in: location,
          name: key
        });
        if (referencedSchema2) {
          return referencedSchema2;
        }
        const innerParameterMetadata = (_a2 = innerMetadata === null || innerMetadata === undefined ? undefined : innerMetadata.metadata) === null || _a2 === undefined ? undefined : _a2.param;
        if ((innerParameterMetadata === null || innerParameterMetadata === undefined ? undefined : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
          throw new ConflictError(`Conflicting names for parameter`, {
            key: "name",
            values: [key, innerParameterMetadata.name]
          });
        }
        if ((innerParameterMetadata === null || innerParameterMetadata === undefined ? undefined : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
          throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== undefined ? _b : key}`, {
            key: "in",
            values: [location, innerParameterMetadata.in]
          });
        }
        return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
      });
      return parameters;
    }
    if ((parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.in) && parameterMetadata.in !== location) {
      throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
        key: "in",
        values: [location, parameterMetadata.in]
      });
    }
    return [
      this.generateParameter(zodSchema.openapi({ param: { in: location } }))
    ];
  }
  generateSimpleParameter(zodSchema) {
    var _a;
    const metadata = Metadata.getParamMetadata(zodSchema);
    const paramMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
    const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
    const schema = this.generateSchemaWithRef(zodSchema);
    return Object.assign({
      schema,
      required
    }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
  }
  generateParameter(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const paramMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
    const paramName = paramMetadata === null || paramMetadata === undefined ? undefined : paramMetadata.name;
    const paramLocation = paramMetadata === null || paramMetadata === undefined ? undefined : paramMetadata.in;
    if (!paramName) {
      throw new MissingParameterDataError({ missingField: "name" });
    }
    if (!paramLocation) {
      throw new MissingParameterDataError({
        missingField: "in",
        paramName
      });
    }
    const baseParameter = this.generateSimpleParameter(zodSchema);
    return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
  }
  generateSchemaWithMetadata(zodSchema) {
    var _a;
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const metadata = Metadata.getMetadata(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const result = ((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.type) ? { type: metadata === null || metadata === undefined ? undefined : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
    return (metadata === null || metadata === undefined ? undefined : metadata.metadata) ? Metadata.applySchemaMetadata(result, metadata.metadata) : omitBy(result, isUndefined);
  }
  constructReferencedOpenAPISchema(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const innerSchema = Metadata.unwrapChained(zodSchema);
    const defaultValue = Metadata.getDefaultValue(zodSchema);
    const isNullableSchema = zodSchema.isNullable();
    if ((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.type) {
      return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);
    }
    return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
  }
  generateSimpleSchema(zodSchema) {
    var _a;
    const metadata = Metadata.getMetadata(zodSchema);
    const refId = Metadata.getRefId(zodSchema);
    if (!refId || !this.schemaRefs[refId]) {
      return this.generateSchemaWithMetadata(zodSchema);
    }
    const schemaRef = this.schemaRefs[refId];
    const referenceObject = {
      $ref: this.generateSchemaRef(refId)
    };
    const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) !== null && _a !== undefined ? _a : {}), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));
    if (newMetadata.type) {
      return {
        allOf: [referenceObject, newMetadata]
      };
    }
    const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));
    const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
    if (Object.keys(appliedMetadata).length > 0) {
      return {
        allOf: [referenceObject, appliedMetadata]
      };
    }
    return referenceObject;
  }
  generateSchemaWithRef(zodSchema) {
    const refId = Metadata.getRefId(zodSchema);
    const result = this.generateSimpleSchema(zodSchema);
    if (refId && this.schemaRefs[refId] === undefined) {
      this.schemaRefs[refId] = result;
      return { $ref: this.generateSchemaRef(refId) };
    }
    return result;
  }
  generateSchemaRef(refId) {
    return `#/components/schemas/${refId}`;
  }
  getRequestBody(requestBody) {
    if (!requestBody) {
      return;
    }
    const { content } = requestBody, rest = __rest(requestBody, ["content"]);
    const requestBodyContent = this.getBodyContent(content);
    return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
  }
  getParameters(request) {
    if (!request) {
      return [];
    }
    const { headers } = request;
    const query = this.cleanParameter(request.query);
    const params = this.cleanParameter(request.params);
    const cookies = this.cleanParameter(request.cookies);
    const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
    const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
    const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
    const headerParameters = enhanceMissingParametersError(() => {
      if (Array.isArray(headers)) {
        return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
      }
      const cleanHeaders = this.cleanParameter(headers);
      return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
    }, { location: "header" });
    return [
      ...pathParameters,
      ...queryParameters,
      ...headerParameters,
      ...cookieParameters
    ];
  }
  cleanParameter(schema) {
    if (!schema) {
      return;
    }
    return isZodType(schema, "ZodEffects") ? this.cleanParameter(schema._def.schema) : schema;
  }
  generatePath(route) {
    const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
    const generatedResponses = mapValues(responses, (response) => {
      return this.getResponse(response);
    });
    const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
    const requestBody = this.getRequestBody(request === null || request === undefined ? undefined : request.body);
    const routeDoc = {
      [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
        parameters: [...pathItemConfig.parameters || [], ...parameters]
      } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
    };
    return routeDoc;
  }
  generateSingleRoute(route) {
    const routeDoc = this.generatePath(route);
    this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
    return routeDoc;
  }
  getResponse(response) {
    if (this.isReferenceObject(response)) {
      return response;
    }
    const { content, headers } = response, rest = __rest(response, ["content", "headers"]);
    const responseContent = content ? { content: this.getBodyContent(content) } : {};
    if (!headers) {
      return Object.assign(Object.assign({}, rest), responseContent);
    }
    const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : headers;
    return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
  }
  isReferenceObject(schema) {
    return "$ref" in schema;
  }
  getResponseHeaders(headers) {
    const schemaShape = headers._def.shape();
    const responseHeaders = mapValues(schemaShape, (_) => this.generateSimpleParameter(_));
    return responseHeaders;
  }
  getBodyContent(content) {
    return mapValues(content, (config) => {
      if (!config || !isAnyZodType(config.schema)) {
        return config;
      }
      const { schema: configSchema } = config, rest = __rest(config, ["schema"]);
      const schema = this.generateSchemaWithRef(configSchema);
      return Object.assign({ schema }, rest);
    });
  }
  toOpenAPISchema(zodSchema, isNullable, defaultValue) {
    return this.openApiTransformer.transform(zodSchema, isNullable, (_) => this.generateSchemaWithRef(_), (_) => this.generateSchemaRef(_), defaultValue);
  }
}

class OpenApiGeneratorV30Specifics {
  get nullType() {
    return { nullable: true };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    return Object.assign(Object.assign({}, type ? { type } : undefined), isNullable ? this.nullType : undefined);
  }
  mapTupleItems(schemas) {
    const uniqueSchemas = uniq(schemas);
    return {
      items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
      minItems: schemas.length,
      maxItems: schemas.length
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
        default:
          return {};
      }
    }));
  }
}

class OpenApiGeneratorV3 {
  constructor(definitions) {
    const specifics = new OpenApiGeneratorV30Specifics;
    this.generator = new OpenAPIGenerator(definitions, specifics);
  }
  generateDocument(config) {
    const baseData = this.generator.generateDocumentData();
    return Object.assign(Object.assign({}, config), baseData);
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
}

class OpenApiGeneratorV31Specifics {
  get nullType() {
    return { type: "null" };
  }
  mapNullableOfArray(objects, isNullable) {
    if (isNullable) {
      return [...objects, this.nullType];
    }
    return objects;
  }
  mapNullableType(type, isNullable) {
    if (!type) {
      return {};
    }
    if (isNullable) {
      return {
        type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
      };
    }
    return {
      type
    };
  }
  mapTupleItems(schemas) {
    return {
      prefixItems: schemas
    };
  }
  getNumberChecks(checks) {
    return Object.assign({}, ...checks.map((check) => {
      switch (check.kind) {
        case "min":
          return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
        case "max":
          return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
        default:
          return {};
      }
    }));
  }
}
function isWebhookDefinition(definition) {
  return "type" in definition && definition.type === "webhook";
}

class OpenApiGeneratorV31 {
  constructor(definitions) {
    this.definitions = definitions;
    this.webhookRefs = {};
    const specifics = new OpenApiGeneratorV31Specifics;
    this.generator = new OpenAPIGenerator(this.definitions, specifics);
  }
  generateDocument(config) {
    const baseDocument = this.generator.generateDocumentData();
    this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
    return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
  }
  generateComponents() {
    return this.generator.generateComponents();
  }
  generateSingleWebhook(route) {
    const routeDoc = this.generator.generatePath(route);
    this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
    return routeDoc;
  }
}

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.charCodeAt(9) === 58 ? 13 : 8);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v]) => {
          return v.length === 1 ? [k, v[0]] : [k, v];
        }));
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    await next();
  };
};

// node_modules/@hono/zod-validator/dist/index.js
var zValidator = (target, schema, hook, options) => validator(target, async (value, c) => {
  let validatorValue = value;
  if (target === "header" && "_def" in schema || target === "header" && "_zod" in schema) {
    const schemaKeys = Object.keys("in" in schema ? schema.in.shape : schema.shape);
    const caseInsensitiveKeymap = Object.fromEntries(schemaKeys.map((key) => [key.toLowerCase(), key]));
    validatorValue = Object.fromEntries(Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2]));
  }
  const result = options && options.validationFunction ? await options.validationFunction(schema, validatorValue) : await schema.safeParseAsync(validatorValue);
  if (hook) {
    const hookResult = await hook({ data: validatorValue, ...result, target }, c);
    if (hookResult) {
      if (hookResult instanceof Response) {
        return hookResult;
      }
      if ("response" in hookResult) {
        return hookResult.response;
      }
    }
  }
  if (!result.success) {
    return c.json(result, 400);
  }
  return result.data;
});

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("json");
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    this.header("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          if (!part) {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/@hono/zod-openapi/dist/index.js
init_esm();
var OpenAPIHono = class _OpenAPIHono extends Hono2 {
  openAPIRegistry;
  defaultHook;
  constructor(init) {
    super(init);
    this.openAPIRegistry = new OpenAPIRegistry;
    this.defaultHook = init?.defaultHook;
  }
  openapi = ({ middleware: routeMiddleware, hide, ...route }, handler, hook = this.defaultHook) => {
    if (!hide) {
      this.openAPIRegistry.registerPath(route);
    }
    const validators = [];
    if (route.request?.query) {
      const validator2 = zValidator("query", route.request.query, hook);
      validators.push(validator2);
    }
    if (route.request?.params) {
      const validator2 = zValidator("param", route.request.params, hook);
      validators.push(validator2);
    }
    if (route.request?.headers) {
      const validator2 = zValidator("header", route.request.headers, hook);
      validators.push(validator2);
    }
    if (route.request?.cookies) {
      const validator2 = zValidator("cookie", route.request.cookies, hook);
      validators.push(validator2);
    }
    const bodyContent = route.request?.body?.content;
    if (bodyContent) {
      for (const mediaType of Object.keys(bodyContent)) {
        if (!bodyContent[mediaType]) {
          continue;
        }
        const schema = bodyContent[mediaType]["schema"];
        if (!(schema instanceof ZodType)) {
          continue;
        }
        if (isJSONContentType(mediaType)) {
          const validator2 = zValidator("json", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = async (c, next) => {
              if (c.req.header("content-type")) {
                if (isJSONContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("json", {});
              await next();
            };
            validators.push(mw);
          }
        }
        if (isFormContentType(mediaType)) {
          const validator2 = zValidator("form", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = async (c, next) => {
              if (c.req.header("content-type")) {
                if (isFormContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("form", {});
              await next();
            };
            validators.push(mw);
          }
        }
      }
    }
    const middleware = routeMiddleware ? Array.isArray(routeMiddleware) ? routeMiddleware : [routeMiddleware] : [];
    this.on([route.method], route.path.replaceAll(/\/{(.+?)}/g, "/:$1"), ...middleware, ...validators, handler);
    return this;
  };
  getOpenAPIDocument = (config) => {
    const generator = new OpenApiGeneratorV3(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  };
  getOpenAPI31Document = (config) => {
    const generator = new OpenApiGeneratorV31(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  };
  doc = (path, configure) => {
    return this.get(path, (c) => {
      const config = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPIDocument(config);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  };
  doc31 = (path, configure) => {
    return this.get(path, (c) => {
      const config = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPI31Document(config);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  };
  route(path, app) {
    const pathForOpenAPI = path.replaceAll(/:([^\/]+)/g, "{$1}");
    super.route(path, app);
    if (!(app instanceof _OpenAPIHono)) {
      return this;
    }
    app.openAPIRegistry.definitions.forEach((def) => {
      switch (def.type) {
        case "component":
          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);
        case "route": {
          this.openAPIRegistry.registerPath({
            ...def.route,
            path: mergePath(pathForOpenAPI, app._basePath.replaceAll(/:([^\/]+)/g, "{$1}"), def.route.path)
          });
          return;
        }
        case "webhook": {
          this.openAPIRegistry.registerWebhook({
            ...def.webhook,
            path: mergePath(pathForOpenAPI, app._basePath.replaceAll(/:([^\/]+)/g, "{$1}"), def.webhook.path)
          });
          return;
        }
        case "schema":
          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);
        case "parameter":
          return this.openAPIRegistry.registerParameter(def.schema._def.openapi._internal.refId, def.schema);
        default: {
          const errorIfNotExhaustive = def;
          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);
        }
      }
    });
    return this;
  }
  basePath(path) {
    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });
  }
};
var createRoute = (routeConfig) => {
  const route = {
    ...routeConfig,
    getRoutingPath() {
      return routeConfig.path.replaceAll(/\/{(.+?)}/g, "/:$1");
    }
  };
  return Object.defineProperty(route, "getRoutingPath", { enumerable: false });
};
extendZodWithOpenApi(exports_external);
function addBasePathToDocument(document2, basePath) {
  const updatedPaths = {};
  Object.keys(document2.paths).forEach((path) => {
    updatedPaths[mergePath(basePath.replaceAll(/:([^\/]+)/g, "{$1}"), path)] = document2.paths[path];
  });
  return {
    ...document2,
    paths: updatedPaths
  };
}
function isJSONContentType(contentType) {
  return /^application\/([a-z-\.]+\+)?json/.test(contentType);
}
function isFormContentType(contentType) {
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  };
};

// env.ts
init_esm();
var envSchema = exports_external.object({
  POSTGRES_CONNECTION_STRING: exports_external.string(),
  POSTGRES_SSL_REJECT_UNAUTHORIZED: exports_external.enum(["true", "false"]).optional(),
  FLOWCORE_TENANT: exports_external.string(),
  FLOWCORE_DATA_CORE_NAME: exports_external.string(),
  FLOWCORE_WEBHOOK_API_KEY: exports_external.string(),
  FLOWCORE_WEBHOOK_BASE_URL: exports_external.string(),
  CLERK_SECRET_KEY: exports_external.string(),
  LOCAL_IP: exports_external.string().optional(),
  TRANSFORMER_SECRET: exports_external.string().default("123")
});
var cachedEnv;
function getEnv() {
  if (cachedEnv)
    return cachedEnv;
  const parsed = envSchema.safeParse(process.env);
  if (!parsed.success) {
    const fields = parsed.error.issues.map((i) => i.path.join(".") || "(root)").join(", ");
    const message = `Missing/invalid required environment variables: ${fields}`;
    console.error(message, parsed.error.flatten());
    throw new Error(message);
  }
  cachedEnv = parsed.data;
  return cachedEnv;
}
var zodEnv = new Proxy({}, {
  get(_target, prop) {
    return getEnv()[prop];
  }
});

// node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs
var DEV_OR_STAGING_SUFFIXES = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
];

// node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs
var defaultOptions = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (_, iteration) => iteration < 5,
  retryImmediately: false,
  jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms) => new Promise((s) => setTimeout(s, ms));
var applyJitter = (delay, jitter) => {
  return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts) => {
  let timesCalled = 0;
  const calculateDelayInMs = () => {
    const constant = opts.initialDelay;
    const base = opts.factor;
    let delay = constant * Math.pow(base, timesCalled);
    delay = applyJitter(delay, opts.jitter);
    return Math.min(opts.maxDelayBetweenRetries || delay, delay);
  };
  return async () => {
    await sleep(calculateDelayInMs());
    timesCalled++;
  };
};
var retry = async (callback, options = {}) => {
  let iterations = 0;
  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter } = {
    ...defaultOptions,
    ...options
  };
  const delay = createExponentialDelayAsyncFn({
    initialDelay,
    maxDelayBetweenRetries,
    factor,
    jitter
  });
  while (true) {
    try {
      return await callback();
    } catch (e) {
      iterations++;
      if (!shouldRetry(e, iterations)) {
        throw e;
      }
      if (retryImmediately && iterations === 1) {
        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
      } else {
        await delay();
      }
    }
  }
};

// node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") {
    return atob(data);
  } else if (typeof global !== "undefined" && global.Buffer) {
    return new global.Buffer(data, "base64").toString();
  }
  return data;
};

// node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs
function createDevOrStagingUrlCache() {
  const devOrStagingUrlCache = /* @__PURE__ */ new Map;
  return {
    isDevOrStagingUrl: (url) => {
      if (!url) {
        return false;
      }
      const hostname = typeof url === "string" ? url : url.hostname;
      let res = devOrStagingUrlCache.get(hostname);
      if (res === undefined) {
        res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
        devOrStagingUrlCache.set(hostname, res);
      }
      return res;
    }
  };
}

// node_modules/@clerk/shared/dist/chunk-35WGBVWP.mjs
var DefaultMessages = Object.freeze({
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  function buildMessage(rawMessage, replacements) {
    if (!replacements) {
      return `${pkg}: ${rawMessage}`;
    }
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  return {
    setPackageName({ packageName: packageName2 }) {
      if (typeof packageName2 === "string") {
        pkg = packageName2;
      }
      return this;
    },
    setMessages({ customMessages: customMessages2 }) {
      Object.assign(messages, customMessages2 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(params) {
      throw new Error(buildMessage(messages.MissingClerkProvider, params));
    },
    throw(message) {
      throw new Error(buildMessage(message));
    }
  };
}

// node_modules/@clerk/backend/dist/chunk-LWOXHF4E.mjs
var errorThrower = buildErrorThrower({ packageName: "@clerk/backend" });
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();

// node_modules/@clerk/backend/dist/chunk-YW6OOOXM.mjs
var TokenVerificationErrorCode = {
  InvalidSecretKey: "clerk_key_invalid"
};
var TokenVerificationErrorReason = {
  TokenExpired: "token-expired",
  TokenInvalid: "token-invalid",
  TokenInvalidAlgorithm: "token-invalid-algorithm",
  TokenInvalidAuthorizedParties: "token-invalid-authorized-parties",
  TokenInvalidSignature: "token-invalid-signature",
  TokenNotActiveYet: "token-not-active-yet",
  TokenIatInTheFuture: "token-iat-in-the-future",
  TokenVerificationFailed: "token-verification-failed",
  InvalidSecretKey: "secret-key-invalid",
  LocalJWKMissing: "jwk-local-missing",
  RemoteJWKFailedToLoad: "jwk-remote-failed-to-load",
  RemoteJWKInvalid: "jwk-remote-invalid",
  RemoteJWKMissing: "jwk-remote-missing",
  JWKFailedToResolve: "jwk-failed-to-resolve",
  JWKKidMismatch: "jwk-kid-mismatch"
};
var TokenVerificationErrorAction = {
  ContactSupport: "Contact support@clerk.com",
  EnsureClerkJWT: "Make sure that this is a valid Clerk generate JWT.",
  SetClerkJWTKey: "Set the CLERK_JWT_KEY environment variable.",
  SetClerkSecretKey: "Set the CLERK_SECRET_KEY environment variable.",
  EnsureClockSync: "Make sure your system clock is in sync (e.g. turn off and on automatic time synchronization)."
};
var TokenVerificationError = class _TokenVerificationError extends Error {
  constructor({
    action,
    message,
    reason
  }) {
    super(message);
    Object.setPrototypeOf(this, _TokenVerificationError.prototype);
    this.reason = reason;
    this.message = message;
    this.action = action;
  }
  getFullMessage() {
    return `${[this.message, this.action].filter((m) => m).join(" ")} (reason=${this.reason}, token-carrier=${this.tokenCarrier})`;
  }
};

// node_modules/@clerk/backend/dist/runtime/node/crypto.mjs
import { webcrypto } from "crypto";

// node_modules/@clerk/backend/dist/chunk-XJ4RTXJG.mjs
var globalFetch = fetch.bind(globalThis);
var runtime = {
  crypto: webcrypto,
  get fetch() {
    return globalFetch;
  },
  AbortController: globalThis.AbortController,
  Blob: globalThis.Blob,
  FormData: globalThis.FormData,
  Headers: globalThis.Headers,
  Request: globalThis.Request,
  Response: globalThis.Response
};
var base64url = {
  parse(string, opts) {
    return parse2(string, base64UrlEncoding, opts);
  },
  stringify(data, opts) {
    return stringify(data, base64UrlEncoding, opts);
  }
};
var base64UrlEncoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bits: 6
};
function parse2(string, encoding, opts = {}) {
  if (!encoding.codes) {
    encoding.codes = {};
    for (let i = 0;i < encoding.chars.length; ++i) {
      encoding.codes[encoding.chars[i]] = i;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  const out = new (opts.out ?? Uint8Array)(end * encoding.bits / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0;i < end; ++i) {
    const value = encoding.codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError("Invalid character " + string[i]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function stringify(data, encoding, opts = {}) {
  const { pad = true } = opts;
  const mask = (1 << encoding.bits) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0;i < data.length; ++i) {
    buffer = buffer << 8 | 255 & data[i];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}
var algToHash = {
  RS256: "SHA-256",
  RS384: "SHA-384",
  RS512: "SHA-512"
};
var RSA_ALGORITHM_NAME = "RSASSA-PKCS1-v1_5";
var jwksAlgToCryptoAlg = {
  RS256: RSA_ALGORITHM_NAME,
  RS384: RSA_ALGORITHM_NAME,
  RS512: RSA_ALGORITHM_NAME
};
var algs = Object.keys(algToHash);
function getCryptoAlgorithm(algorithmName) {
  const hash = algToHash[algorithmName];
  const name = jwksAlgToCryptoAlg[algorithmName];
  if (!hash || !name) {
    throw new Error(`Unsupported algorithm ${algorithmName}, expected one of ${algs.join(",")}.`);
  }
  return {
    hash: { name: algToHash[algorithmName] },
    name: jwksAlgToCryptoAlg[algorithmName]
  };
}
var isArrayString = (s) => {
  return Array.isArray(s) && s.length > 0 && s.every((a) => typeof a === "string");
};
var assertAudienceClaim = (aud, audience) => {
  const audienceList = [audience].flat().filter((a) => !!a);
  const audList = [aud].flat().filter((a) => !!a);
  const shouldVerifyAudience = audienceList.length > 0 && audList.length > 0;
  if (!shouldVerifyAudience) {
    return;
  }
  if (typeof aud === "string") {
    if (!audienceList.includes(aud)) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.EnsureClerkJWT,
        reason: TokenVerificationErrorReason.TokenVerificationFailed,
        message: `Invalid JWT audience claim (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(audienceList)}".`
      });
    }
  } else if (isArrayString(aud)) {
    if (!aud.some((a) => audienceList.includes(a))) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.EnsureClerkJWT,
        reason: TokenVerificationErrorReason.TokenVerificationFailed,
        message: `Invalid JWT audience claim array (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(audienceList)}".`
      });
    }
  }
};
var assertHeaderType = (typ) => {
  if (typeof typ === "undefined") {
    return;
  }
  if (typ !== "JWT") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenInvalid,
      message: `Invalid JWT type ${JSON.stringify(typ)}. Expected "JWT".`
    });
  }
};
var assertHeaderAlgorithm = (alg) => {
  if (!algs.includes(alg)) {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenInvalidAlgorithm,
      message: `Invalid JWT algorithm ${JSON.stringify(alg)}. Supported: ${algs}.`
    });
  }
};
var assertSubClaim = (sub) => {
  if (typeof sub !== "string") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Subject claim (sub) is required and must be a string. Received ${JSON.stringify(sub)}.`
    });
  }
};
var assertAuthorizedPartiesClaim = (azp, authorizedParties) => {
  if (!azp || !authorizedParties || authorizedParties.length === 0) {
    return;
  }
  if (!authorizedParties.includes(azp)) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenInvalidAuthorizedParties,
      message: `Invalid JWT Authorized party claim (azp) ${JSON.stringify(azp)}. Expected "${authorizedParties}".`
    });
  }
};
var assertExpirationClaim = (exp, clockSkewInMs) => {
  if (typeof exp !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT expiry date claim (exp) ${JSON.stringify(exp)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const expiryDate = /* @__PURE__ */ new Date(0);
  expiryDate.setUTCSeconds(exp);
  const expired = expiryDate.getTime() <= currentDate.getTime() - clockSkewInMs;
  if (expired) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenExpired,
      message: `JWT is expired. Expiry date: ${expiryDate.toUTCString()}, Current date: ${currentDate.toUTCString()}.`
    });
  }
};
var assertActivationClaim = (nbf, clockSkewInMs) => {
  if (typeof nbf === "undefined") {
    return;
  }
  if (typeof nbf !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT not before date claim (nbf) ${JSON.stringify(nbf)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const notBeforeDate = /* @__PURE__ */ new Date(0);
  notBeforeDate.setUTCSeconds(nbf);
  const early = notBeforeDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (early) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenNotActiveYet,
      message: `JWT cannot be used prior to not before date claim (nbf). Not before date: ${notBeforeDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
var assertIssuedAtClaim = (iat, clockSkewInMs) => {
  if (typeof iat === "undefined") {
    return;
  }
  if (typeof iat !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT issued at date claim (iat) ${JSON.stringify(iat)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const issuedAtDate = /* @__PURE__ */ new Date(0);
  issuedAtDate.setUTCSeconds(iat);
  const postIssued = issuedAtDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (postIssued) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenIatInTheFuture,
      message: `JWT issued at date claim (iat) is in the future. Issued at date: ${issuedAtDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
function pemToBuffer(secret) {
  const trimmed = secret.replace(/-----BEGIN.*?-----/g, "").replace(/-----END.*?-----/g, "").replace(/\s/g, "");
  const decoded = isomorphicAtob(trimmed);
  const buffer = new ArrayBuffer(decoded.length);
  const bufView = new Uint8Array(buffer);
  for (let i = 0, strLen = decoded.length;i < strLen; i++) {
    bufView[i] = decoded.charCodeAt(i);
  }
  return bufView;
}
function importKey(key, algorithm, keyUsage) {
  if (typeof key === "object") {
    return runtime.crypto.subtle.importKey("jwk", key, algorithm, false, [keyUsage]);
  }
  const keyData = pemToBuffer(key);
  const format = keyUsage === "sign" ? "pkcs8" : "spki";
  return runtime.crypto.subtle.importKey(format, keyData, algorithm, false, [keyUsage]);
}
var DEFAULT_CLOCK_SKEW_IN_MS = 5 * 1000;
async function hasValidSignature(jwt, key) {
  const { header, signature, raw: raw2 } = jwt;
  const encoder = new TextEncoder;
  const data = encoder.encode([raw2.header, raw2.payload].join("."));
  const algorithm = getCryptoAlgorithm(header.alg);
  try {
    const cryptoKey = await importKey(key, algorithm, "verify");
    const verified = await runtime.crypto.subtle.verify(algorithm.name, cryptoKey, signature, data);
    return { data: verified };
  } catch (error) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalidSignature,
          message: error?.message
        })
      ]
    };
  }
}
function decodeJwt(token) {
  const tokenParts = (token || "").toString().split(".");
  if (tokenParts.length !== 3) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalid,
          message: `Invalid JWT form. A JWT consists of three parts separated by dots.`
        })
      ]
    };
  }
  const [rawHeader, rawPayload, rawSignature] = tokenParts;
  const decoder = new TextDecoder;
  const header = JSON.parse(decoder.decode(base64url.parse(rawHeader, { loose: true })));
  const payload = JSON.parse(decoder.decode(base64url.parse(rawPayload, { loose: true })));
  const signature = base64url.parse(rawSignature, { loose: true });
  const data = {
    header,
    payload,
    signature,
    raw: {
      header: rawHeader,
      payload: rawPayload,
      signature: rawSignature,
      text: token
    }
  };
  return { data };
}
async function verifyJwt(token, options) {
  const { audience, authorizedParties, clockSkewInMs, key } = options;
  const clockSkew = clockSkewInMs || DEFAULT_CLOCK_SKEW_IN_MS;
  const { data: decoded, errors: errors2 } = decodeJwt(token);
  if (errors2) {
    return { errors: errors2 };
  }
  const { header, payload } = decoded;
  try {
    const { typ, alg } = header;
    assertHeaderType(typ);
    assertHeaderAlgorithm(alg);
    const { azp, sub, aud, iat, exp, nbf } = payload;
    assertSubClaim(sub);
    assertAudienceClaim([aud], [audience]);
    assertAuthorizedPartiesClaim(azp, authorizedParties);
    assertExpirationClaim(exp, clockSkew);
    assertActivationClaim(nbf, clockSkew);
    assertIssuedAtClaim(iat, clockSkew);
  } catch (err) {
    return { errors: [err] };
  }
  const { data: signatureValid, errors: signatureErrors } = await hasValidSignature(decoded, key);
  if (signatureErrors) {
    return {
      errors: [
        new TokenVerificationError({
          action: TokenVerificationErrorAction.EnsureClerkJWT,
          reason: TokenVerificationErrorReason.TokenVerificationFailed,
          message: `Error verifying JWT signature. ${signatureErrors[0]}`
        })
      ]
    };
  }
  if (!signatureValid) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalidSignature,
          message: "JWT signature is invalid."
        })
      ]
    };
  }
  return { data: payload };
}

// node_modules/@clerk/backend/dist/chunk-HJEYNBQX.mjs
var import_cookie3 = __toESM(require_dist(), 1);
var API_URL = "https://api.clerk.com";
var API_VERSION = "v1";
var USER_AGENT = `${"@clerk/backend"}@${"2.5.0"}`;
var MAX_CACHE_LAST_UPDATED_AT_SECONDS = 5 * 60;
var SUPPORTED_BAPI_VERSION = "2025-04-10";
var Cookies = {
  Session: "__session",
  Refresh: "__refresh",
  ClientUat: "__client_uat",
  Handshake: "__clerk_handshake",
  DevBrowser: "__clerk_db_jwt",
  RedirectCount: "__clerk_redirect_count",
  HandshakeNonce: "__clerk_handshake_nonce"
};
var QueryParameters = {
  ClerkSynced: "__clerk_synced",
  SuffixedCookies: "suffixed_cookies",
  ClerkRedirectUrl: "__clerk_redirect_url",
  DevBrowser: Cookies.DevBrowser,
  Handshake: Cookies.Handshake,
  HandshakeHelp: "__clerk_help",
  LegacyDevBrowser: "__dev_session",
  HandshakeReason: "__clerk_hs_reason",
  HandshakeNonce: Cookies.HandshakeNonce,
  HandshakeFormat: "format"
};
var SEPARATOR = "/";
var MULTIPLE_SEPARATOR_REGEX = new RegExp("(?<!:)" + SEPARATOR + "{1,}", "g");
function joinPaths(...args) {
  return args.filter((p) => p).join(SEPARATOR).replace(MULTIPLE_SEPARATOR_REGEX, SEPARATOR);
}
var mapObjectSkip = Symbol("mapObjectSkip");
var PlainObjectConstructor = {}.constructor;
var cache = {};
var lastUpdatedAt = 0;
function getFromCache(kid) {
  return cache[kid];
}
function getCacheValues() {
  return Object.values(cache);
}
function setInCache(jwk, shouldExpire = true) {
  cache[jwk.kid] = jwk;
  lastUpdatedAt = shouldExpire ? Date.now() : -1;
}
var LocalJwkKid = "local";
var PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
var PEM_TRAILER = "-----END PUBLIC KEY-----";
var RSA_PREFIX = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA";
var RSA_SUFFIX = "IDAQAB";
function loadClerkJWKFromLocal(localKey) {
  if (!getFromCache(LocalJwkKid)) {
    if (!localKey) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.SetClerkJWTKey,
        message: "Missing local JWK.",
        reason: TokenVerificationErrorReason.LocalJWKMissing
      });
    }
    const modulus = localKey.replace(/\r\n|\n|\r/g, "").replace(PEM_HEADER, "").replace(PEM_TRAILER, "").replace(RSA_PREFIX, "").replace(RSA_SUFFIX, "").replace(/\+/g, "-").replace(/\//g, "_");
    setInCache({
      kid: "local",
      kty: "RSA",
      alg: "RS256",
      n: modulus,
      e: "AQAB"
    }, false);
  }
  return getFromCache(LocalJwkKid);
}
async function loadClerkJWKFromRemote({
  secretKey,
  apiUrl = API_URL,
  apiVersion = API_VERSION,
  kid,
  skipJwksCache
}) {
  if (skipJwksCache || cacheHasExpired() || !getFromCache(kid)) {
    if (!secretKey) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: "Failed to load JWKS from Clerk Backend or Frontend API.",
        reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
      });
    }
    const fetcher = () => fetchJWKSFromBAPI(apiUrl, secretKey, apiVersion);
    const { keys } = await retry(fetcher);
    if (!keys || !keys.length) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: "The JWKS endpoint did not contain any signing keys. Contact support@clerk.com.",
        reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
      });
    }
    keys.forEach((key) => setInCache(key));
  }
  const jwk = getFromCache(kid);
  if (!jwk) {
    const cacheValues = getCacheValues();
    const jwkKeys = cacheValues.map((jwk2) => jwk2.kid).sort().join(", ");
    throw new TokenVerificationError({
      action: `Go to your Dashboard and validate your secret and public keys are correct. ${TokenVerificationErrorAction.ContactSupport} if the issue persists.`,
      message: `Unable to find a signing key in JWKS that matches the kid='${kid}' of the provided session token. Please make sure that the __session cookie or the HTTP authorization header contain a Clerk-generated session JWT. The following kid is available: ${jwkKeys}`,
      reason: TokenVerificationErrorReason.JWKKidMismatch
    });
  }
  return jwk;
}
async function fetchJWKSFromBAPI(apiUrl, key, apiVersion) {
  if (!key) {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.SetClerkSecretKey,
      message: "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance.",
      reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
    });
  }
  const url = new URL(apiUrl);
  url.pathname = joinPaths(url.pathname, apiVersion, "/jwks");
  const response = await runtime.fetch(url.href, {
    headers: {
      Authorization: `Bearer ${key}`,
      "Clerk-API-Version": SUPPORTED_BAPI_VERSION,
      "Content-Type": "application/json",
      "User-Agent": USER_AGENT
    }
  });
  if (!response.ok) {
    const json = await response.json();
    const invalidSecretKeyError = getErrorObjectByCode(json?.errors, TokenVerificationErrorCode.InvalidSecretKey);
    if (invalidSecretKeyError) {
      const reason = TokenVerificationErrorReason.InvalidSecretKey;
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: invalidSecretKeyError.message,
        reason
      });
    }
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.ContactSupport,
      message: `Error loading Clerk JWKS from ${url.href} with code=${response.status}`,
      reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
    });
  }
  return response.json();
}
function cacheHasExpired() {
  if (lastUpdatedAt === -1) {
    return false;
  }
  const isExpired = Date.now() - lastUpdatedAt >= MAX_CACHE_LAST_UPDATED_AT_SECONDS * 1000;
  if (isExpired) {
    cache = {};
  }
  return isExpired;
}
var getErrorObjectByCode = (errors2, code) => {
  if (!errors2) {
    return null;
  }
  return errors2.find((err) => err.code === code);
};
async function verifyToken(token, options) {
  const { data: decodedResult, errors: errors2 } = decodeJwt(token);
  if (errors2) {
    return { errors: errors2 };
  }
  const { header } = decodedResult;
  const { kid } = header;
  try {
    let key;
    if (options.jwtKey) {
      key = loadClerkJWKFromLocal(options.jwtKey);
    } else if (options.secretKey) {
      key = await loadClerkJWKFromRemote({ ...options, kid });
    } else {
      return {
        errors: [
          new TokenVerificationError({
            action: TokenVerificationErrorAction.SetClerkJWTKey,
            message: "Failed to resolve JWK during verification.",
            reason: TokenVerificationErrorReason.JWKFailedToResolve
          })
        ]
      };
    }
    return await verifyJwt(token, { ...options, key });
  } catch (error) {
    return { errors: [error] };
  }
}

// node_modules/@clerk/backend/dist/chunk-P263NW7Z.mjs
function withLegacyReturn(cb) {
  return async (...args) => {
    const { data, errors: errors2 } = await cb(...args);
    if (errors2) {
      throw errors2[0];
    }
    return data;
  };
}

// node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs
function snakeToCamel(str) {
  return str ? str.replace(/([-_][a-z])/g, (match2) => match2.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform) => {
  const deepTransform = (obj) => {
    if (!obj) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((el) => {
        if (typeof el === "object" || Array.isArray(el)) {
          return deepTransform(el);
        }
        return el;
      });
    }
    const copy = { ...obj };
    const keys = Object.keys(copy);
    for (const oldName of keys) {
      const newName = transform(oldName.toString());
      if (newName !== oldName) {
        copy[newName] = copy[oldName];
        delete copy[oldName];
      }
      if (typeof copy[newName] === "object") {
        copy[newName] = deepTransform(copy[newName]);
      }
    }
    return copy;
  };
  return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);

// node_modules/@clerk/shared/dist/chunk-YXR7ZZRP.mjs
var _storageKey;
var _cacheTtl;
var _TelemetryEventThrottler_instances;
var generateKey_fn;
var cache_get;
var isValidBrowser_get;
_storageKey = new WeakMap;
_cacheTtl = new WeakMap;
_TelemetryEventThrottler_instances = new WeakSet;
generateKey_fn = function(event) {
  const { sk: _sk, pk: _pk, payload, ...rest } = event;
  const sanitizedEvent = {
    ...payload,
    ...rest
  };
  return JSON.stringify(Object.keys({
    ...payload,
    ...rest
  }).sort().map((key) => sanitizedEvent[key]));
};
cache_get = function() {
  const cacheString = localStorage.getItem(__privateGet(this, _storageKey));
  if (!cacheString) {
    return {};
  }
  return JSON.parse(cacheString);
};
isValidBrowser_get = function() {
  if (typeof window === "undefined") {
    return false;
  }
  const storage = window.localStorage;
  if (!storage) {
    return false;
  }
  try {
    const testKey = "test";
    storage.setItem(testKey, testKey);
    storage.removeItem(testKey);
    return true;
  } catch (err) {
    const isQuotaExceededError = err instanceof DOMException && (err.name === "QuotaExceededError" || err.name === "NS_ERROR_DOM_QUOTA_REACHED");
    if (isQuotaExceededError && storage.length > 0) {
      storage.removeItem(__privateGet(this, _storageKey));
    }
    return false;
  }
};
var _config;
var _eventThrottler;
var _metadata;
var _buffer;
var _pendingFlush;
var _TelemetryCollector_instances;
var shouldRecord_fn;
var shouldBeSampled_fn;
var scheduleFlush_fn;
var flush_fn;
var logEvent_fn;
var getSDKMetadata_fn;
var preparePayload_fn;
_config = new WeakMap;
_eventThrottler = new WeakMap;
_metadata = new WeakMap;
_buffer = new WeakMap;
_pendingFlush = new WeakMap;
_TelemetryCollector_instances = new WeakSet;
shouldRecord_fn = function(preparedPayload, eventSamplingRate) {
  return this.isEnabled && !this.isDebug && __privateMethod(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);
};
shouldBeSampled_fn = function(preparedPayload, eventSamplingRate) {
  const randomSeed = Math.random();
  const toBeSampled = randomSeed <= __privateGet(this, _config).samplingRate && (typeof eventSamplingRate === "undefined" || randomSeed <= eventSamplingRate);
  if (!toBeSampled) {
    return false;
  }
  return !__privateGet(this, _eventThrottler).isEventThrottled(preparedPayload);
};
scheduleFlush_fn = function() {
  if (typeof window === "undefined") {
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  const isBufferFull = __privateGet(this, _buffer).length >= __privateGet(this, _config).maxBufferSize;
  if (isBufferFull) {
    if (__privateGet(this, _pendingFlush)) {
      const cancel = typeof cancelIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
      cancel(__privateGet(this, _pendingFlush));
    }
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  if (__privateGet(this, _pendingFlush)) {
    return;
  }
  if ("requestIdleCallback" in window) {
    __privateSet(this, _pendingFlush, requestIdleCallback(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }));
  } else {
    __privateSet(this, _pendingFlush, setTimeout(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }, 0));
  }
};
flush_fn = function() {
  fetch(new URL("/v1/event", __privateGet(this, _config).endpoint), {
    method: "POST",
    body: JSON.stringify({
      events: __privateGet(this, _buffer)
    }),
    headers: {
      "Content-Type": "application/json"
    }
  }).catch(() => {
    return;
  }).then(() => {
    __privateSet(this, _buffer, []);
  }).catch(() => {
    return;
  });
};
logEvent_fn = function(event, payload) {
  if (!this.isDebug) {
    return;
  }
  if (typeof console.groupCollapsed !== "undefined") {
    console.groupCollapsed("[clerk/telemetry]", event);
    console.log(payload);
    console.groupEnd();
  } else {
    console.log("[clerk/telemetry]", event, payload);
  }
};
getSDKMetadata_fn = function() {
  let sdkMetadata = {
    name: __privateGet(this, _metadata).sdk,
    version: __privateGet(this, _metadata).sdkVersion
  };
  if (typeof window !== "undefined" && window.Clerk) {
    sdkMetadata = { ...sdkMetadata, ...window.Clerk.constructor.sdkMetadata };
  }
  return sdkMetadata;
};
preparePayload_fn = function(event, payload) {
  const sdkMetadata = __privateMethod(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);
  return {
    event,
    cv: __privateGet(this, _metadata).clerkVersion ?? "",
    it: __privateGet(this, _metadata).instanceType ?? "",
    sdk: sdkMetadata.name,
    sdkv: sdkMetadata.version,
    ...__privateGet(this, _metadata).publishableKey ? { pk: __privateGet(this, _metadata).publishableKey } : {},
    ...__privateGet(this, _metadata).secretKey ? { sk: __privateGet(this, _metadata).secretKey } : {},
    payload
  };
};

// node_modules/@clerk/backend/dist/index.mjs
var verifyToken2 = withLegacyReturn(verifyToken);

// src/utils/api-responses.ts
var StatusCodes = {
  CREATED: 201,
  OK: 200,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  UNPROCESSABLE: 422,
  SERVER_ERROR: 500,
  SERVICE_UNAVAILABLE: 503
};
function success(message, data) {
  if (data !== undefined) {
    return {
      success: true,
      message,
      data
    };
  }
  return {
    success: true,
    message
  };
}
function error(message, errors2) {
  return {
    success: false,
    message,
    errors: errors2
  };
}
var ApiResponse = {
  success,
  error
};

// src/middleware/auth.ts
var clerkAuth = () => {
  return async (c, next) => {
    try {
      const authHeader = c.req.header("Authorization");
      if (!authHeader?.startsWith("Bearer ")) {
        return c.json(ApiResponse.error("Authorization header with Bearer token is required"), StatusCodes.UNAUTHORIZED);
      }
      const token = authHeader.substring(7);
      const payload = await verifyToken2(token, {
        secretKey: zodEnv.CLERK_SECRET_KEY
      });
      if (!payload || !payload.sub) {
        return c.json(ApiResponse.error("Invalid or expired token"), StatusCodes.UNAUTHORIZED);
      }
      c.userId = payload.sub;
      await next();
    } catch (error2) {
      console.error("Authentication error:", error2);
      return c.json(ApiResponse.error("Authentication failed", error2), StatusCodes.UNAUTHORIZED);
    }
  };
};
var requireAuth = clerkAuth;

// src/routes/api/food-item/index.ts
var foodItem = new Hono2;
foodItem.use("/*", requireAuth());
var food_item_default = foodItem;

// src/routes/api/habit/index.ts
var habit = new Hono2;
habit.use("/*", requireAuth());
var habit_default = habit;

// src/routes/api/meal/index.ts
var meal = new Hono2;
meal.use("/*", requireAuth());
var meal_default = meal;

// src/routes/api/recipe/index.ts
var recipe = new Hono2;
recipe.use("/*", requireAuth());
var recipe_default = recipe;

// src/routes/api/todo/index.ts
var todo = new Hono2;
todo.use("/*", requireAuth());
var todo_default = todo;

// src/contracts/food/food-item/food-item.contract.ts
var foodItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  name: exports_external.string().min(1, "The name of the food item is required").max(100, "The name of the food item must be less than 100 characters"),
  categoryHierarchy: exports_external.array(exports_external.string().min(1, "Category level cannot be empty").max(30, "Category level must be less than 30 characters").regex(/^[a-zA-Z0-9\s\-_]+$/, "Category can only contain letters, numbers, spaces, hyphens, and underscores")).min(1, "if foodItemCategoryHierarchy is NOT undefined, then you must have atleast 1 string in the array").max(5, "Maximum 5 category levels allowed").optional()
});
var foodItemDeletedSchema = exports_external.object({
  foodItemId: exports_external.string().uuid()
});
// src/contracts/food/food-item/food-item.shared_utils.ts
var UnitOfMeasurementEnum;
((UnitOfMeasurementEnum2) => {
  UnitOfMeasurementEnum2["GRAM"] = "Gram";
  UnitOfMeasurementEnum2["KILOGRAM"] = "Kilogram";
  UnitOfMeasurementEnum2["MILLILITER"] = "Milliliter";
  UnitOfMeasurementEnum2["LITER"] = "Liter";
  UnitOfMeasurementEnum2["TABLESPOON"] = "Tablespoon";
  UnitOfMeasurementEnum2["TEASPOON"] = "Teaspoon";
  UnitOfMeasurementEnum2["PIECE"] = "Piece";
  UnitOfMeasurementEnum2["WHOLE"] = "Whole";
  UnitOfMeasurementEnum2["PINCH"] = "Pinch";
  UnitOfMeasurementEnum2["HANDFUL"] = "Handful";
  UnitOfMeasurementEnum2["CLOVE"] = "Clove";
  UnitOfMeasurementEnum2["SLICE"] = "Slice";
  UnitOfMeasurementEnum2["STRIP"] = "Strip";
  UnitOfMeasurementEnum2["HEAD"] = "Head";
  UnitOfMeasurementEnum2["BUNCH"] = "Bunch";
  UnitOfMeasurementEnum2["TO_TASTE"] = "To taste";
  UnitOfMeasurementEnum2["AS_NEEDED"] = "As needed";
  UnitOfMeasurementEnum2["SHOT"] = "Shot";
  UnitOfMeasurementEnum2["DASH"] = "Dash";
  UnitOfMeasurementEnum2["DROP"] = "Drop";
  UnitOfMeasurementEnum2["SPLASH"] = "Splash";
  UnitOfMeasurementEnum2["SCOOP"] = "Scoop";
  UnitOfMeasurementEnum2["DRIZZLE"] = "Drizzle";
})(UnitOfMeasurementEnum ||= {});

// src/contracts/food/food-item/food-item-units.contract.ts
var foodItemUnitBaseSchema = exports_external.object({
  id: exports_external.string().uuid(),
  unitOfMeasurement: exports_external.nativeEnum(UnitOfMeasurementEnum),
  unitDescription: exports_external.string().max(100, "Unit description must be less than 100 characters").optional(),
  nutritionPerOfThisUnit: exports_external.object({
    calories: exports_external.number().min(0, "Calories must be 0 or greater"),
    proteinInGrams: exports_external.number().min(0, "Protein must be 0 or greater").optional(),
    carbohydratesInGrams: exports_external.number().min(0, "Carbohydrates must be 0 or greater").optional(),
    fatInGrams: exports_external.number().min(0, "Fat must be 0 or greater").optional(),
    fiberInGrams: exports_external.number().min(0, "Fiber must be 0 or greater").optional(),
    sugarInGrams: exports_external.number().min(0, "Sugar must be 0 or greater").optional(),
    sodiumInMilligrams: exports_external.number().min(0, "Sodium must be 0 or greater").optional()
  }),
  source: exports_external.enum(["user_measured", "package_label", "database", "estimated"]).default("user_measured")
});
var foodItemUnitSchema = exports_external.object({
  foodItemId: exports_external.string().uuid(),
  units: exports_external.array(foodItemUnitBaseSchema).min(1, "Food must have at least one unit").max(20, "Food can have at most 20 units")
});
var foodItemUnitUpdatedSchema = foodItemUnitSchema.extend({
  oldValues: foodItemUnitSchema
});
var foodItemUnitDeletedSchema = foodItemUnitSchema;
// src/contracts/food/meal/meal.contract.ts
var mealSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  mealName: exports_external.string().min(1, "Meal name is required").max(100, "Meal name must be less than 100 characters")
});
var mealUpdateSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  mealName: exports_external.string().min(1, "Meal name is required").max(100, "Meal name must be less than 100 characters").optional()
});
var mealRecipeAttachSchema = exports_external.object({
  mealId: exports_external.string().uuid(),
  recipes: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    orderInMeal: exports_external.number().int().min(0)
  })).min(1, "At least one recipe is required")
});
var mealRecipeDetachSchema = exports_external.object({
  mealRecipeId: exports_external.string().uuid()
});
// src/contracts/food/recipe/recipe.shared_utils.ts
var MealTimingEnum;
((MealTimingEnum2) => {
  MealTimingEnum2["BREAKFAST"] = "Breakfast";
  MealTimingEnum2["BRUNCH"] = "Brunch";
  MealTimingEnum2["LUNCH"] = "Lunch";
  MealTimingEnum2["DINNER"] = "Dinner";
  MealTimingEnum2["ON_THE_GO"] = "On The Go";
  MealTimingEnum2["SNACK"] = "Snack";
  MealTimingEnum2["LATE_NIGHT"] = "Late Night";
  MealTimingEnum2["AFTERNOON_TEA"] = "Afternoon Tea";
  MealTimingEnum2["SUPPER"] = "Supper";
})(MealTimingEnum ||= {});

// src/contracts/food/recipe/recipe.contract.ts
var recipeSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  whenIsItConsumed: exports_external.array(exports_external.nativeEnum(MealTimingEnum)).optional(),
  nameOfTheRecipe: exports_external.string().min(1, "The name of the recipe is required").max(75, "The name of the recipe must be less than 75 characters"),
  generalDescriptionOfTheRecipe: exports_external.string().min(1, "If generalDescriptionOfTheRecipe is NOT undefined, you must have at least one character").max(250, "The general description of the recipe must be less than 250 characters").optional()
});
var recipeUpdateSchema = recipeSchema.extend({
  oldValues: recipeSchema
});
var recipeDeletedSchema = exports_external.object({
  recipeId: exports_external.string().uuid()
});
// src/contracts/food/recipe/recipe-ingredients.contract.ts
init_esm();
var recipeIngredientsSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  ingredients: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    ingredientText: exports_external.string().min(1, "Ingredient text is required").max(150, "Ingredient text must be less than 150 characters")
  })).min(1, "You must have at least one ingredient").max(50, "Maximum 50 ingredients allowed")
});
var recipeIngredientsUpdateSchema = recipeIngredientsSchema.extend({
  oldValues: recipeIngredientsSchema
});
// src/contracts/food/recipe/recipe-instructions.contract.ts
init_esm();
var recipeInstructionsSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  stepByStepInstructions: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    instructionNumber: exports_external.number().positive("Step number must be greater than 0").int("Step number must be an integer"),
    stepInstruction: exports_external.string().min(1, "The instruction is required").max(250, "The instruction must be less than 250 characters"),
    foodItemUnitsUsedInStep: exports_external.array(exports_external.object({
      foodItemUnitId: exports_external.string().uuid(),
      quantityOfFoodItemUnit: exports_external.number().positive("Quantity used in this step must be greater than 0").max(1e6, "Quantity is unreasonably large").refine((n) => Math.floor(n * 1000) === n * 1000, {
        message: "Max 3 decimal places allowed"
      }).default(1)
    })).min(1, "If ingredientsUsedInThisStep is NOT undefined, you must have at least one ingredient").max(50, "The number of ingredients used in this step must be less than 50").optional()
  })).min(1, "You must have at least one step").max(30, "The number of steps in the recipe must be less than 30")
});
var recipeInstructionsUpdateSchema = recipeInstructionsSchema.extend({
  oldValues: recipeInstructionsSchema
});
// src/contracts/habit/habit.contract.ts
var YMD = exports_external.string().regex(/^\d{4}-\d{2}-\d{2}$/);
var HHMM = exports_external.string().regex(/^\d{2}:\d{2}$/);
var Weekday = exports_external.enum([
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday",
  "sunday"
]);
var weeklyHabitCreationSchema = exports_external.object({
  userId: exports_external.string(),
  domain: exports_external.string(),
  entityId: exports_external.string().uuid(),
  recurrenceType: exports_external.literal("weekly"),
  targetWeekday: Weekday,
  targetTime: HHMM.optional(),
  startDate: YMD,
  subEntities: exports_external.array(exports_external.object({
    subEntityId: exports_external.string().uuid().optional(),
    scheduledWeekday: Weekday,
    scheduledTime: HHMM.optional()
  })).min(1)
});
var baseSimpleHabitCreationSchema = exports_external.object({
  userId: exports_external.string(),
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  targetTime: HHMM.optional(),
  startDate: YMD
});
var weeklySimpleHabitCreationSchema = baseSimpleHabitCreationSchema.extend({
  recurrenceType: exports_external.literal("weekly"),
  targetWeekday: Weekday
});
var dailySimpleHabitCreationSchema = baseSimpleHabitCreationSchema.extend({
  recurrenceType: exports_external.literal("daily")
});
var habitsCreatedSchema = weeklyHabitCreationSchema;
var simpleHabitCreatedSchema = exports_external.discriminatedUnion("recurrenceType", [
  weeklySimpleHabitCreationSchema,
  dailySimpleHabitCreationSchema
]);
var habitDeletedSchema = exports_external.object({
  habitId: exports_external.string().uuid()
});

// src/contracts/todo/todo.completed.ts
init_esm();
var todoCompletedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string()
});
// src/contracts/todo/todo.contract.ts
var mealRelationSchema = exports_external.object({
  mealId: exports_external.string().uuid(),
  mealName: exports_external.string().min(1).max(100),
  stepId: exports_external.string().uuid().optional(),
  instructionNumber: exports_external.number().int().positive().optional(),
  recipeName: exports_external.string().optional()
});
var mealInstructionRelationSchema = exports_external.object({
  mealStepId: exports_external.string().uuid(),
  mealId: exports_external.string().uuid(),
  recipeId: exports_external.string().uuid(),
  instructionNumber: exports_external.number().int().positive()
});
var todoSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  completed: exports_external.boolean().default(false),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
var todoUpdateSchema = todoSchema.extend({
  oldValues: todoSchema
});
var todoCancelledSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string()
});
var todoRelationsUpdatedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema.optional()
  })).max(5, "you can only have up to 5 relations")
});
var todoWithMealRelationSchema = todoSchema.extend({
  relations: exports_external.object({
    meal: mealRelationSchema
  })
});
// src/contracts/todo/todo-generated.contract.ts
init_esm();
var todoGeneratedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  completed: exports_external.boolean().default(false),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
// node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result.push(value2);
      i = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result.push(value);
    i = newStartFrom;
  }
  return [result, i];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size) {
    return new PgArrayBuilder(this.config.name, this, size);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}
class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/version.js
var version = "0.44.2";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config2) {
    const config = Object.assign({}, _config2, {
      inlineParams: _config2.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config2.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result.push(p);
          if (i < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config2.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw2(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw2;
  function join(chunks, separator) {
    const result = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values) {
  const entries = Object.entries(values).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config) {
    super(name, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgCharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b) => {
    const { name, config } = getColumnNameAndConfig(a, b);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgIntervalBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}

// node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0;i < 8; i++) {
    view.setUint8(i, bytes[offset + i]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x, y];
  }
  throw new Error("Unsupported geometry type");
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTextBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config) {
    super(name, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b = {}) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVarcharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgBinaryVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgHalfVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgSparseVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b) {
  const { name, config } = getColumnNameAndConfig(a, b);
  return new PgVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values, column)}`;
}
function notInArray(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function notBetween(column, min, max) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/drizzle-orm/sql/functions/aggregate.js
function max(expression) {
  return sql`max(${expression})`.mapWith(is(expression, Column) ? expression : String);
}

// node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib2(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types2 = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;
var esm_default = import_lib.default;

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i) => {
    const formattedWord = i === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index, joinMeta] of joins.entries()) {
      if (index === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select) {
      const select2 = valuesOrSelect;
      if (is(select2, SQL)) {
        valuesSqlList.push(select2);
      } else {
        valuesSqlList.push(select2.getSQL());
      }
    } else {
      const values = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
  $withCache(config) {
    this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select) => ({
      type,
      isAll,
      rightSelect: select
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: { on }
      });
    }
    return { select, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select, SQL) && !haveSameKeys(this.table[Columns], select._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values, session, dialect, withList, select, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values, withList, select, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {} };
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  with(...queries) {
    const self = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self.session, self.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self.session, self.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self.session, self.dialect, queries);
    }
    return { select, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config2) {}
  async onMutate(_params) {}
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// node_modules/drizzle-orm/errors/index.js
class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

// node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query, cache2, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache2;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache2 && cache2.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2, token) {
    const res = await this.execute(sql2, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// node_modules/drizzle-orm/node-postgres/session.js
var { Pool: Pool2, types: types3 } = esm_default;

class NodePgPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger, cache2, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache2, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      name,
      text: queryString,
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types3.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types3.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types3.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types3.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types3.getTypeParser(typeId, format);
        }
      }
    };
    this.queryConfig = {
      name,
      text: queryString,
      rowMode: "array",
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types3.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types3.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types3.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types3.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types3.getTypeParser(typeId, format);
        }
      }
    };
  }
  static [entityKind] = "NodePgPreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", async (span) => {
          span?.setAttributes({
            "drizzle.query.name": rawQuery.name,
            "drizzle.query.text": rawQuery.text,
            "drizzle.query.params": JSON.stringify(params)
          });
          return this.queryWithCache(rawQuery.text, params, async () => {
            return await client.query(rawQuery, params);
          });
        });
      }
      const result = await tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": query.name,
          "drizzle.query.text": query.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(query.text, params, async () => {
          return await client.query(query, params);
        });
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      return tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": this.rawQueryConfig.name,
          "drizzle.query.text": this.rawQueryConfig.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(this.rawQueryConfig.text, params, async () => {
          return this.client.query(this.rawQueryConfig, params);
        }).then((result) => result.rows);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class NodePgSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "NodePgSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new NodePgPreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    const session = this.client instanceof Pool2 ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;
    const tx = new NodePgTransaction(this.dialect, session, this.schema);
    await tx.execute(sql`begin${config ? sql` ${tx.getTransactionConfigSQL(config)}` : undefined}`);
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (error2) {
      await tx.execute(sql`rollback`);
      throw error2;
    } finally {
      if (this.client instanceof Pool2) {
        session.client.release();
      }
    }
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res["rows"][0]["count"]);
  }
}

class NodePgTransaction extends PgTransaction {
  static [entityKind] = "NodePgTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new NodePgTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

// node_modules/drizzle-orm/node-postgres/driver.js
class NodePgDriver {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "NodePgDriver";
  createSession(schema) {
    return new NodePgSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class NodePgDatabase extends PgDatabase {
  static [entityKind] = "NodePgDatabase";
}
function construct(client, config = {}) {
  const dialect = new PgDialect({ casing: config.casing });
  let logger;
  if (config.logger === true) {
    logger = new DefaultLogger;
  } else if (config.logger !== false) {
    logger = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NodePgDriver(client, dialect, { logger, cache: config.cache });
  const session = driver.createSession(schema);
  const db = new NodePgDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = new esm_default.Pool({
      connectionString: params[0]
    });
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    const instance = typeof connection === "string" ? new esm_default.Pool({
      connectionString: connection
    }) : new esm_default.Pool(connection);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/db/schemas.ts
var exports_schemas = {};
__export(exports_schemas, {
  todos: () => todos,
  recipes: () => recipes,
  recipeInstructions: () => recipeInstructions,
  recipeInstructionFoodItemUnits: () => recipeInstructionFoodItemUnits,
  recipeIngredients: () => recipeIngredients,
  meals: () => meals,
  mealRecipes: () => mealRecipes,
  habits: () => habits,
  habitTriggers: () => habitTriggers,
  habitTriggerExecutions: () => habitTriggerExecutions,
  habitSubEntities: () => habitSubEntities,
  foodItems: () => foodItems,
  foodItemUnits: () => foodItemUnits
});
var recipes = pgTable("recipes", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  nameOfTheRecipe: text("name_of_the_recipe").notNull(),
  generalDescriptionOfTheRecipe: text("general_description_of_the_recipe"),
  whenIsItConsumed: text("when_is_it_consumed").array(),
  version: integer("version").notNull().default(1)
});
var recipeInstructions = pgTable("recipe_instructions", {
  id: uuid("id").primaryKey(),
  recipeId: uuid("recipe_id").references(() => recipes.id, {
    onDelete: "cascade"
  }),
  instruction: text("instruction").notNull(),
  instructionNumber: integer("instruction_number").notNull()
});
var recipeInstructionFoodItemUnits = pgTable("recipe_instructions_food_item_units", {
  id: uuid("id").primaryKey(),
  recipeInstructionId: uuid("recipe_instruction_id").references(() => recipeInstructions.id),
  foodItemUnitId: uuid("food_item_unit_id").notNull(),
  quantity: doublePrecision("quantity").notNull()
});
var recipeIngredients = pgTable("recipe_ingredients", {
  id: uuid("id").primaryKey(),
  recipeId: uuid("recipe_id").references(() => recipes.id, { onDelete: "cascade" }).notNull(),
  ingredientText: text("ingredient_text").notNull()
});
var meals = pgTable("meals", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  mealName: text("meal_name").notNull()
});
var mealRecipes = pgTable("meal_recipes", {
  id: uuid("id").primaryKey(),
  mealId: uuid("meal_id").notNull().references(() => meals.id, { onDelete: "cascade" }),
  recipeId: uuid("recipe_id").notNull(),
  orderInMeal: integer("order_in_meal").notNull().default(0)
});
var todos = pgTable("todos", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  title: text("title").notNull(),
  description: text("description"),
  completed: boolean("completed").notNull().default(false),
  scheduledFor: timestamp("scheduled_for"),
  dueDate: text("due_date"),
  preferredTime: text("preferred_time"),
  completedAt: timestamp("completed_at"),
  habitId: uuid("habit_id").references(() => habits.id),
  instanceId: uuid("instance_id"),
  domain: text("domain"),
  entityId: uuid("entity_id"),
  subEntityId: uuid("sub_entity_id"),
  relations: text("relations"),
  eventId: text("event_id")
});
var foodItems = pgTable("food_items", {
  id: uuid("id").primaryKey(),
  name: text("name").notNull(),
  categoryHierarchy: text("category_hierarchy").notNull().array(),
  userId: text("user_id").notNull()
});
var foodItemUnits = pgTable("food_item_units", {
  id: uuid("id").primaryKey(),
  foodItemId: uuid("food_item_id").references(() => foodItems.id).notNull(),
  unitOfMeasurement: text("unit_of_measurement").notNull(),
  unitDescription: text("unit_description"),
  calories: integer("calories").notNull(),
  proteinInGrams: integer("protein_in_grams"),
  carbohydratesInGrams: integer("carbohydrates_in_grams"),
  fatInGrams: integer("fat_in_grams"),
  fiberInGrams: integer("fiber_in_grams"),
  sugarInGrams: integer("sugar_in_grams"),
  sodiumInMilligrams: integer("sodium_in_milligrams"),
  source: text("source").notNull()
});
var habits = pgTable("habits", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  domain: text("domain").notNull(),
  description: text("description"),
  entityId: uuid("entity_id").notNull(),
  recurrenceType: text("recurrence_type").notNull(),
  targetWeekday: text("target_weekday").notNull(),
  targetTime: text("target_time"),
  startDate: text("start_date").notNull(),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var habitTriggers = pgTable("habit_triggers", {
  id: uuid("id").primaryKey(),
  habitId: uuid("habit_id").references(() => habits.id, { onDelete: "cascade" }).notNull(),
  triggerSubEntityId: uuid("trigger_sub_entity_id"),
  triggerWeekday: text("trigger_weekday").notNull()
});
var habitSubEntities = pgTable("habit_subentities", {
  id: uuid("id").primaryKey(),
  habitId: uuid("habit_id").references(() => habits.id, { onDelete: "cascade" }).notNull(),
  entityId: uuid("entity_id"),
  subEntityId: uuid("sub_entity_id"),
  scheduledWeekday: text("scheduled_weekday").notNull(),
  scheduledTime: text("scheduled_time")
});
var habitTriggerExecutions = pgTable("habit_trigger_executions", {
  userId: text("user_id").primaryKey(),
  triggerDate: text("trigger_date").notNull()
});

// src/db/index.ts
var pool;
var drizzleDb;
function normalizeConnectionString(raw2) {
  const trimmed = raw2.trim().replace(/^['"]|['"]$/g, "");
  const withoutPrefix = trimmed.replace(/^POSTGRES_CONNECTION_STRING=/i, "");
  return withoutPrefix.trim();
}
function getPoolSslConfig(connectionString, envRejectUnauthorized, caCert) {
  const connectionUrl = new URL(normalizeConnectionString(connectionString));
  const hostname = connectionUrl.hostname.toLowerCase();
  const isLocalHost = hostname === "localhost" || hostname === "127.0.0.1" || hostname === "::1";
  if (isLocalHost)
    return;
  const sslMode = connectionUrl.searchParams.get("sslmode")?.toLowerCase();
  const rejectUnauthorized = envRejectUnauthorized === "true" ? true : envRejectUnauthorized === "false" ? false : sslMode === "no-verify" ? false : true;
  if (caCert) {
    return { rejectUnauthorized, ca: caCert.replace(/\\n/g, `
`) };
  }
  return { rejectUnauthorized };
}
function initDb() {
  if (drizzleDb)
    return drizzleDb;
  const env = getEnv();
  const connectionString = normalizeConnectionString(env.POSTGRES_CONNECTION_STRING);
  pool ??= new Pool({
    connectionString,
    ssl: getPoolSslConfig(connectionString, env.POSTGRES_SSL_REJECT_UNAUTHORIZED, env.POSTGRES_SSL_CA_CERT)
  });
  drizzleDb = drizzle(pool, { schema: exports_schemas });
  return drizzleDb;
}
var db = new Proxy({}, {
  get(_target, prop) {
    const instance = initDb();
    const value = instance[prop];
    return typeof value === "function" ? value.bind(instance) : value;
  }
});

// src/handlers/food-item/food-item.handler.ts
async function handleFoodItemCreated(event) {
  const { payload } = event;
  await db.insert(foodItems).values({
    id: payload.id,
    name: payload.name,
    categoryHierarchy: payload.categoryHierarchy,
    userId: payload.userId
  });
}
async function handleFoodItemDeleted(event) {
  const { payload } = event;
  await db.delete(foodItems).where(eq(foodItems.id, payload.foodItemId));
}

// src/handlers/food-item/food-item-units.handler.ts
async function handleFoodItemUnitsCreated(event) {
  const { payload } = event;
  await db.insert(foodItemUnits).values(payload.units.map((unit) => ({
    id: unit.id,
    foodItemId: payload.foodItemId,
    unitOfMeasurement: unit.unitOfMeasurement,
    unitDescription: unit.unitDescription,
    calories: unit.nutritionPerOfThisUnit.calories,
    proteinInGrams: unit.nutritionPerOfThisUnit.proteinInGrams,
    carbohydratesInGrams: unit.nutritionPerOfThisUnit.carbohydratesInGrams,
    fatInGrams: unit.nutritionPerOfThisUnit.fatInGrams,
    fiberInGrams: unit.nutritionPerOfThisUnit.fiberInGrams,
    sugarInGrams: unit.nutritionPerOfThisUnit.sugarInGrams,
    sodiumInMilligrams: unit.nutritionPerOfThisUnit.sodiumInMilligrams,
    source: unit.source
  })));
}
async function handleFoodItemUnitsDeleted(event) {
  const { payload } = event;
  const unitIds = payload.units.map((unit) => unit.id);
  await db.delete(foodItemUnits).where(and(inArray(foodItemUnits.id, unitIds), eq(foodItemUnits.foodItemId, payload.foodItemId)));
}

// src/handlers/habit/habit.handler.ts
import { randomUUID } from "crypto";
var weekdays = [
  "sunday",
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday"
];
function getWeekdayFromYmd(dateStr) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
    throw new Error(`Invalid date format: ${dateStr}. Expected YYYY-MM-DD`);
  }
  const date2 = new Date(`${dateStr}T12:00:00.000Z`);
  if (Number.isNaN(date2.getTime())) {
    throw new Error(`Invalid date created from: ${dateStr}`);
  }
  return weekdays[date2.getDay()];
}
async function handleHabitsCreated(event) {
  const { payload } = event;
  const habitId = randomUUID();
  const habitRecord = {
    id: habitId,
    userId: payload.userId,
    domain: payload.domain,
    entityId: payload.entityId,
    recurrenceType: payload.recurrenceType,
    targetWeekday: payload.targetWeekday,
    targetTime: payload.targetTime || null,
    startDate: payload.startDate,
    isActive: true
  };
  const triggerSubEntity = findTriggerSubEntityForWeekRecurrenceType(payload.targetWeekday, payload.subEntities);
  const triggerRecord = {
    id: randomUUID(),
    habitId,
    triggerSubEntityId: triggerSubEntity.subEntityId || null,
    triggerWeekday: triggerSubEntity.scheduledWeekday ?? payload.targetWeekday
  };
  const subEntityRecords = payload.subEntities.map((subEntity) => ({
    id: randomUUID(),
    habitId,
    subEntityId: subEntity.subEntityId || null,
    scheduledWeekday: subEntity.scheduledWeekday ?? payload.targetWeekday,
    scheduledTime: subEntity.scheduledTime || null
  }));
  await db.transaction(async (tx) => {
    await tx.insert(habits).values(habitRecord);
    await tx.insert(habitTriggers).values(triggerRecord);
    await tx.insert(habitSubEntities).values(subEntityRecords);
  });
}
async function handleSimpleHabitCreated(event) {
  const { payload } = event;
  const habitId = randomUUID();
  const effectiveTargetWeekday = payload.recurrenceType === "daily" ? getWeekdayFromYmd(payload.startDate) : payload.targetWeekday;
  const habitRecord = {
    id: habitId,
    userId: payload.userId,
    domain: "simple",
    description: payload.description,
    entityId: habitId,
    recurrenceType: payload.recurrenceType,
    targetWeekday: effectiveTargetWeekday,
    targetTime: payload.targetTime || null,
    startDate: payload.startDate,
    isActive: true
  };
  const triggerRecord = {
    id: randomUUID(),
    habitId,
    triggerSubEntityId: null,
    triggerWeekday: effectiveTargetWeekday
  };
  const subEntityRecord = {
    id: randomUUID(),
    habitId,
    subEntityId: null,
    scheduledWeekday: effectiveTargetWeekday,
    scheduledTime: payload.targetTime || null
  };
  await db.transaction(async (tx) => {
    await tx.insert(habits).values(habitRecord);
    await tx.insert(habitTriggers).values(triggerRecord);
    await tx.insert(habitSubEntities).values(subEntityRecord);
  });
}
async function handleHabitDeleted(event) {
  const { payload } = event;
  await db.delete(habits).where(eq(habits.id, payload.habitId));
}
function findTriggerSubEntityForWeekRecurrenceType(targetWeekday, subEntities) {
  const weekdays2 = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  const targetDay = weekdays2.indexOf(targetWeekday);
  let maxOffset = -1;
  let triggerSubEntity = subEntities[0];
  for (const subEntity of subEntities) {
    if (!subEntity.scheduledWeekday)
      continue;
    const subEntityDay = weekdays2.indexOf(subEntity.scheduledWeekday);
    let offset = targetDay - subEntityDay;
    if (offset < 0)
      offset += 7;
    if (offset > maxOffset) {
      maxOffset = offset;
      triggerSubEntity = subEntity;
    }
  }
  return triggerSubEntity;
}

// src/handlers/meal/meal.handler.ts
async function handleMealCreated(event) {
  const { payload } = event;
  await db.insert(meals).values({
    id: payload.id,
    userId: payload.userId,
    mealName: payload.mealName
  });
}

// src/handlers/meal/meal-recipes.handler.ts
async function handleMealRecipeAttached(event) {
  const { payload } = event;
  const values = payload.recipes.map((recipe4) => ({
    id: crypto.randomUUID(),
    mealId: payload.mealId,
    recipeId: recipe4.recipeId,
    orderInMeal: recipe4.orderInMeal
  }));
  await db.insert(mealRecipes).values(values);
}

// src/handlers/recipe/recipe.handler.ts
async function handleRecipeCreated(event) {
  const { payload } = event;
  await db.insert(recipes).values({
    id: payload.id,
    userId: payload.userId,
    nameOfTheRecipe: payload.nameOfTheRecipe,
    generalDescriptionOfTheRecipe: payload.generalDescriptionOfTheRecipe,
    whenIsItConsumed: payload.whenIsItConsumed
  });
}
async function handleRecipeDeleted(event) {
  const { payload } = event;
  await db.delete(recipes).where(eq(recipes.id, payload.recipeId));
}

// src/handlers/recipe/recipe-ingredients.handler.ts
async function handleRecipeIngredientsCreated(event) {
  const { payload } = event;
  for (const ingredient of payload.ingredients) {
    await db.insert(recipeIngredients).values({
      id: ingredient.id,
      recipeId: payload.recipeId,
      ingredientText: ingredient.ingredientText
    });
  }
}

// src/handlers/recipe/recipe-instructions.handler.ts
async function handleRecipeInstructionsCreated(event) {
  const { payload } = event;
  for (const step of payload.stepByStepInstructions) {
    await db.insert(recipeInstructions).values({
      id: step.id,
      recipeId: payload.recipeId,
      instruction: step.stepInstruction,
      instructionNumber: step.instructionNumber
    });
    if (step.foodItemUnitsUsedInStep) {
      for (const foodItemUnit of step.foodItemUnitsUsedInStep) {
        await db.insert(recipeInstructionFoodItemUnits).values({
          id: crypto.randomUUID(),
          recipeInstructionId: step.id,
          foodItemUnitId: foodItemUnit.foodItemUnitId,
          quantity: foodItemUnit.quantityOfFoodItemUnit
        });
      }
    }
  }
}

// src/handlers/todo/todo.cancelled.ts
async function handleTodoCancelled(event) {
  const { payload } = event;
  await db.delete(todos).where(eq(todos.id, payload.id));
}

// src/handlers/todo/todo.completed.ts
async function handleTodoCompleted(event) {
  const { payload } = event;
  await db.delete(todos).where(eq(todos.id, payload.id));
}

// src/handlers/todo/todo.generated.ts
async function handleTodoGenerated(event) {
  const { payload } = event;
  await db.insert(todos).values({
    id: payload.id,
    userId: payload.userId,
    title: payload.description,
    description: payload.description,
    completed: payload.completed,
    scheduledFor: payload.scheduledFor ? (() => {
      const date2 = new Date(payload.scheduledFor);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid scheduledFor date: ${payload.scheduledFor}`);
      }
      return date2;
    })() : null,
    completedAt: payload.completedAt ? (() => {
      const date2 = new Date(payload.completedAt);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid completedAt date: ${payload.completedAt}`);
      }
      return date2;
    })() : null,
    relations: payload.relations ? JSON.stringify(payload.relations) : null
  });
}

// src/handlers/todo/todo.handler.ts
async function handleTodoCreated(event) {
  const { payload } = event;
  await db.insert(todos).values({
    id: payload.id,
    userId: payload.userId,
    title: payload.description,
    description: payload.description,
    completed: payload.completed,
    scheduledFor: payload.scheduledFor ? (() => {
      const date2 = new Date(payload.scheduledFor);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid scheduledFor date: ${payload.scheduledFor}`);
      }
      return date2;
    })() : null,
    completedAt: payload.completedAt ? (() => {
      const date2 = new Date(payload.completedAt);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid completedAt date: ${payload.completedAt}`);
      }
      return date2;
    })() : null,
    relations: payload.relations ? JSON.stringify(payload.relations) : null
  });
}

// src/utils/flowcore.ts
var flowcoreModulePromise;
async function loadFlowcoreModule() {
  flowcoreModulePromise ??= Promise.resolve().then(() => (init_mod(), exports_mod));
  return flowcoreModulePromise;
}
async function buildFlowcorePathways(config) {
  const { createPostgresPathwayState: createPostgresPathwayState2, PathwaysBuilder: PathwaysBuilder2 } = await loadFlowcoreModule();
  return new PathwaysBuilder2({
    baseUrl: config.baseUrl,
    tenant: config.tenant,
    dataCore: config.dataCore,
    apiKey: config.apiKey
  }).withPathwayState(createPostgresPathwayState2({
    connectionString: config.postgresUrl
  })).register({
    flowType: "food-item.v0",
    eventType: "food-item.created.v0",
    retryDelayMs: 1e4,
    schema: foodItemSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.deleted.v0",
    retryDelayMs: 1e4,
    schema: foodItemDeletedSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.units.created.v0",
    retryDelayMs: 1e4,
    schema: foodItemUnitSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.units.deleted.v0",
    retryDelayMs: 1e4,
    schema: foodItemUnitDeletedSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe.created.v0",
    retryDelayMs: 1e4,
    schema: recipeSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe.deleted.v0",
    retryDelayMs: 1e4,
    schema: recipeDeletedSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe-instructions.created.v0",
    retryDelayMs: 1e4,
    schema: recipeInstructionsSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe-ingredients.created.v0",
    retryDelayMs: 1e4,
    schema: recipeIngredientsSchema
  }).register({
    flowType: "meal.v0",
    eventType: "meal.created.v0",
    retryDelayMs: 1e4,
    schema: mealSchema
  }).register({
    flowType: "meal.v0",
    eventType: "meal-recipe.attached.v0",
    retryDelayMs: 1e4,
    schema: mealRecipeAttachSchema
  }).register({
    flowType: "habit.v0",
    eventType: "complex-habit.created.v0",
    retryDelayMs: 1e4,
    schema: habitsCreatedSchema
  }).register({
    flowType: "habit.v0",
    eventType: "simple-habit.created.v0",
    retryDelayMs: 1e4,
    schema: simpleHabitCreatedSchema
  }).register({
    flowType: "habit.v0",
    eventType: "habit.deleted.v0",
    retryDelayMs: 1e4,
    schema: habitDeletedSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.created.v0",
    retryDelayMs: 1e4,
    schema: todoSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.completed.v0",
    retryDelayMs: 1e4,
    schema: todoCompletedSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.cancelled.v0",
    retryDelayMs: 1e4,
    schema: todoCancelledSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.generated.v0",
    retryDelayMs: 1e4,
    schema: todoGeneratedSchema
  }).handle("food-item.v0/food-item.created.v0", handleFoodItemCreated).handle("food-item.v0/food-item.deleted.v0", handleFoodItemDeleted).handle("food-item.v0/food-item.units.created.v0", handleFoodItemUnitsCreated).handle("food-item.v0/food-item.units.deleted.v0", handleFoodItemUnitsDeleted).handle("recipe.v0/recipe.created.v0", handleRecipeCreated).handle("recipe.v0/recipe.deleted.v0", handleRecipeDeleted).handle("recipe.v0/recipe-instructions.created.v0", handleRecipeInstructionsCreated).handle("recipe.v0/recipe-ingredients.created.v0", handleRecipeIngredientsCreated).handle("meal.v0/meal.created.v0", handleMealCreated).handle("meal.v0/meal-recipe.attached.v0", handleMealRecipeAttached).handle("todo.v0/todo.created.v0", handleTodoCreated).handle("todo.v0/todo.generated.v0", handleTodoGenerated).handle("habit.v0/complex-habit.created.v0", handleHabitsCreated).handle("habit.v0/simple-habit.created.v0", handleSimpleHabitCreated).handle("habit.v0/habit.deleted.v0", handleHabitDeleted).handle("todo.v0/todo.completed.v0", handleTodoCompleted).handle("todo.v0/todo.cancelled.v0", handleTodoCancelled);
}
var cachedPromise;
async function initFlowcore() {
  if (cachedPromise)
    return cachedPromise;
  cachedPromise = (async () => {
    const env = getEnv();
    const webhookApiKey = env.FLOWCORE_WEBHOOK_API_KEY;
    const postgresUrl = env.POSTGRES_CONNECTION_STRING;
    const pathways2 = await buildFlowcorePathways({
      baseUrl: env.FLOWCORE_WEBHOOK_BASE_URL,
      tenant: env.FLOWCORE_TENANT,
      dataCore: env.FLOWCORE_DATA_CORE_NAME,
      apiKey: webhookApiKey,
      postgresUrl
    });
    const { PathwayRouter: PathwayRouter2 } = await loadFlowcoreModule();
    const router2 = new PathwayRouter2(pathways2, webhookApiKey);
    return { webhookApiKey, pathways: pathways2, router: router2 };
  })();
  return cachedPromise;
}
async function getFlowcorePathways() {
  return (await initFlowcore()).pathways;
}
async function getPathwaysRouter() {
  return (await initFlowcore()).router;
}
var FlowcorePathways = {
  async write(...args) {
    const pathways2 = await getFlowcorePathways();
    return pathways2.write(...args);
  }
};

// src/routes/api/transformer/index.ts
var transformer = new Hono2;
transformer.post("/", async (c) => {
  try {
    const event2 = await c.req.json();
    const secret = c.req.header("X-Secret");
    console.log("Received event", {
      flowType: event2.flowType,
      eventType: event2.eventType,
      eventId: event2.eventId,
      payload: event2.payload
    });
    if (secret !== zodEnv.FLOWCORE_WEBHOOK_API_KEY) {
      return c.json(ApiResponse.error("Secret key is incorrect or missing"), StatusCodes.UNAUTHORIZED);
    }
    const router2 = await getPathwaysRouter();
    await router2.processEvent(event2, secret);
    return c.json({
      message: "Event processed \u2705"
    }, 200);
  } catch (error2) {
    console.error("Error processing event", { error: error2 });
    return c.json({
      error: "Failed to process event",
      message: error2.message
    }, 500);
  }
});
var transformer_default = transformer;

// src/routes/api/index.ts
var api = new Hono2;
api.get("/", (c) => {
  return c.text("Daily Scheduler API");
});
api.route("/transformer/", transformer_default);
api.route("/food-item", food_item_default);
api.route("/habit", habit_default);
api.route("/meal", meal_default);
api.route("/recipe", recipe_default);
api.route("/todo", todo_default);
var api_default = api;

// src/routes/api/food-item/food-item.create.ts
var createFoodItemRequestSchema = exports_external.object({
  foodItemName: exports_external.string().min(1, "Food item name min length is 1").max(100, "Food item name max length is 100"),
  categoryHierarchy: exports_external.array(exports_external.string()).optional()
});
var successResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemSchema
});
var errorResponseSchema = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createFoodItemResponses = {
  200: {
    description: "Food item created successfully",
    content: {
      "application/json": {
        schema: successResponseSchema
      }
    }
  },
  400: {
    description: "Bad Request",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  401: {
    description: "Unauthorized",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  409: {
    description: "Conflict - Food item with name already exists",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  500: {
    description: "Internal Server Error",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  }
};
var createFoodItemRoute = createRoute({
  method: "post",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createFoodItemRequestSchema
        }
      }
    }
  },
  responses: createFoodItemResponses
});
function registerCreateFoodItem(app) {
  app.openapi(createFoodItemRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateFoodItemJsonBody = c.req.valid("json");
    const existingFoodItem = await db.select().from(foodItems).where(and(eq(foodItems.name, safeCreateFoodItemJsonBody.foodItemName), eq(foodItems.userId, safeUserId)));
    if (existingFoodItem.length > 0) {
      return c.json({
        success: false,
        message: "Food item with name already exists"
      }, 409);
    }
    const newFoodItem = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      name: safeCreateFoodItemJsonBody.foodItemName,
      categoryHierarchy: safeCreateFoodItemJsonBody.categoryHierarchy
    };
    const createFoodItemEvent = foodItemSchema.safeParse(newFoodItem);
    if (!createFoodItemEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item data",
        errors: createFoodItemEvent.error.errors
      }, 400);
    }
    const safeCreateFoodItemEvent = createFoodItemEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.created.v0", {
        data: safeCreateFoodItemEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create food item",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item created successfully",
      data: safeCreateFoodItemEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item.delete.ts
var deleteFoodItemRequestSchema = exports_external.object({
  foodItemId: exports_external.string().uuid()
});
var successResponseSchema2 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemDeletedSchema
});
var errorResponseSchema2 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var deleteFoodItemRoute = createRoute({
  method: "delete",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: deleteFoodItemRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item deleted successfully",
      content: {
        "application/json": {
          schema: successResponseSchema2
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    404: {
      description: "Not Found - Food item does not exist",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    }
  }
});
function registerDeleteFoodItem(app) {
  app.openapi(deleteFoodItemRoute, async (c) => {
    const safeUserId = c.userId;
    const safeDeleteFoodItemRequestBody = c.req.valid("json");
    const foodItemFromDb = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.id, safeDeleteFoodItemRequestBody.foodItemId), eq(foodItems.userId, safeUserId))
    });
    if (!foodItemFromDb) {
      return c.json({
        success: false,
        message: "Food item not found"
      }, 404);
    }
    const foodItemDeleted = {
      foodItemId: foodItemFromDb.id
    };
    const foodItemDeletedEvent = foodItemDeletedSchema.safeParse(foodItemDeleted);
    if (!foodItemDeletedEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item deleted data",
        errors: foodItemDeletedEvent.error.errors
      }, 400);
    }
    const safeFoodItemDeletedEvent = foodItemDeletedEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.deleted.v0", {
        data: safeFoodItemDeletedEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to delete food item",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item deleted successfully",
      data: safeFoodItemDeletedEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item.list.ts
var foodItemWithUnitsSchema = exports_external.object({
  id: exports_external.string().uuid(),
  name: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable(),
  unitCount: exports_external.number(),
  hasUnits: exports_external.boolean()
});
var foodItemBasicSchema = exports_external.object({
  id: exports_external.string().uuid(),
  name: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable()
});
var listFoodItemsResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(foodItemWithUnitsSchema)
});
var searchFoodItemsResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(foodItemBasicSchema)
});
var listFoodItemsRoute = createRoute({
  method: "get",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Food items retrieved successfully",
      content: {
        "application/json": {
          schema: listFoodItemsResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var searchFoodItemsRoute = createRoute({
  method: "get",
  path: "/api/food-item/search",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    query: exports_external.object({
      q: exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Food items search results",
      content: {
        "application/json": {
          schema: searchFoodItemsResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListFoodItems(app) {
  app.openapi(listFoodItemsRoute, async (c) => {
    const safeUserId = c.userId;
    const userFoodItems = await db.select().from(foodItems).where(eq(foodItems.userId, safeUserId)).orderBy(foodItems.name);
    const foodItemsWithUnitCounts = await Promise.all(userFoodItems.map(async (item) => {
      const units = await db.select().from(foodItemUnits).where(eq(foodItemUnits.foodItemId, item.id));
      return {
        id: item.id,
        name: item.name,
        categoryHierarchy: item.categoryHierarchy,
        unitCount: units.length,
        hasUnits: units.length > 0
      };
    }));
    return c.json({
      success: true,
      message: "Food items retrieved successfully",
      data: foodItemsWithUnitCounts
    }, 200);
  });
  app.openapi(searchFoodItemsRoute, async (c) => {
    const safeUserId = c.userId;
    const query = c.req.query("q") || "";
    const dbQuery = db.select().from(foodItems).where(eq(foodItems.userId, safeUserId));
    if (query) {
      const searchResults = await dbQuery;
      const filtered = searchResults.filter((item) => item.name.toLowerCase().includes(query.toLowerCase()));
      return c.json({
        success: true,
        message: "Food items search results",
        data: filtered
      }, 200);
    }
    const results = await dbQuery.orderBy(foodItems.name);
    return c.json({
      success: true,
      message: "Food items retrieved successfully",
      data: results
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.create.ts
var createFoodItemUnitRequestSchema = foodItemUnitSchema.omit({
  foodItemId: true
}).extend({
  foodItemName: exports_external.string().min(1, "Food item name min length is 1"),
  units: exports_external.array(foodItemUnitSchema.shape.units.element.omit({
    id: true,
    source: true
  }))
});
var successResponseSchema3 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemUnitSchema
});
var errorResponseSchema3 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createFoodItemUnitsRoute = createRoute({
  method: "post",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: createFoodItemUnitRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item units created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema3
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    }
  }
});
function registerCreateFoodItemUnits(app) {
  app.openapi(createFoodItemUnitsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateFoodItemUnitJsonBody = c.req.valid("json");
    const relatedFoodItem = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.name, safeCreateFoodItemUnitJsonBody.foodItemName), eq(foodItems.userId, safeUserId))
    });
    if (!relatedFoodItem) {
      return c.json({
        success: false,
        message: "Food item does not exist"
      }, 400);
    }
    const newFoodItemUnits = {
      foodItemId: relatedFoodItem.id,
      units: safeCreateFoodItemUnitJsonBody.units.map((unit) => ({
        id: crypto.randomUUID(),
        ...unit,
        source: "user_measured"
      }))
    };
    const createdFoodItemUnitEvent = foodItemUnitSchema.safeParse(newFoodItemUnits);
    if (!createdFoodItemUnitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item unit data",
        errors: createdFoodItemUnitEvent.error.errors
      }, 400);
    }
    const safeCreateFoodItemUnitEvent = createdFoodItemUnitEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.units.created.v0", {
        data: safeCreateFoodItemUnitEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create food item units",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item units created successfully",
      data: safeCreateFoodItemUnitEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.delete.ts
var deleteFoodItemUnitRequestSchema = exports_external.object({
  unitIds: exports_external.array(exports_external.string().uuid())
});
var deleteFoodItemUnitsRoute = createRoute({
  method: "delete",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: deleteFoodItemUnitRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item units deleted successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.string()
          })
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string(),
            errors: exports_external.any().optional()
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string(),
            errors: exports_external.any().optional()
          })
        }
      }
    }
  }
});
function registerDeleteFoodItemUnits(app) {
  app.openapi(deleteFoodItemUnitsRoute, async (c) => {
    const safeDeleteFoodItemUnitRequestBody = c.req.valid("json");
    const foodItemUnitsFromDb = await db.query.foodItemUnits.findMany({
      where: inArray(foodItemUnits.id, safeDeleteFoodItemUnitRequestBody.unitIds)
    });
    if (foodItemUnitsFromDb.length !== safeDeleteFoodItemUnitRequestBody.unitIds.length) {
      return c.json({
        success: false,
        message: "One or more food item units not found"
      }, 404);
    }
    const uniqueFoodItemIds = new Set(foodItemUnitsFromDb.map((unit) => unit.foodItemId));
    if (uniqueFoodItemIds.size !== 1) {
      return c.json({
        success: false,
        message: "All units must belong to the same food item"
      }, 400);
    }
    const foodItemId = foodItemUnitsFromDb[0].foodItemId;
    const foodItemArr = foodItemUnitsFromDb.map((unit) => ({
      id: unit.id,
      unitOfMeasurement: unit.unitOfMeasurement,
      unitDescription: unit.unitDescription ?? undefined,
      nutritionPerOfThisUnit: {
        calories: unit.calories,
        proteinInGrams: unit.proteinInGrams,
        carbohydratesInGrams: unit.carbohydratesInGrams,
        fatInGrams: unit.fatInGrams,
        fiberInGrams: unit.fiberInGrams,
        sugarInGrams: unit.sugarInGrams,
        sodiumInMilligrams: unit.sodiumInMilligrams
      },
      source: unit.source
    }));
    const newDeleteFoodItemUnitEvent = foodItemUnitDeletedSchema.safeParse({
      foodItemId,
      units: foodItemArr
    });
    if (!newDeleteFoodItemUnitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item unit data",
        errors: newDeleteFoodItemUnitEvent.error.errors
      }, 400);
    }
    const safeDeleteFoodItemUnitEvent = newDeleteFoodItemUnitEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.units.deleted.v0", {
        data: safeDeleteFoodItemUnitEvent
      });
    } catch (error2) {
      console.error(error2);
      return c.json({
        success: false,
        message: "Failed to delete food item units",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item units deleted",
      data: "Food item units deleted successfully"
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.list.ts
var foodItemUnitDetailSchema = exports_external.object({
  id: exports_external.string().uuid(),
  foodItemId: exports_external.string().uuid(),
  foodItemName: exports_external.string(),
  unitOfMeasurement: exports_external.string(),
  unitDescription: exports_external.string().nullable(),
  calories: exports_external.number(),
  proteinInGrams: exports_external.number().nullable(),
  carbohydratesInGrams: exports_external.number().nullable(),
  fatInGrams: exports_external.number().nullable(),
  fiberInGrams: exports_external.number().nullable(),
  sugarInGrams: exports_external.number().nullable()
});
var allFoodItemUnitsSchema = exports_external.object({
  unitId: exports_external.string().uuid(),
  unitOfMeasurement: exports_external.string(),
  unitDescription: exports_external.string().nullable(),
  calories: exports_external.number(),
  proteinInGrams: exports_external.number().nullable(),
  carbohydratesInGrams: exports_external.number().nullable(),
  fatInGrams: exports_external.number().nullable(),
  fiberInGrams: exports_external.number().nullable(),
  sugarInGrams: exports_external.number().nullable(),
  foodItemId: exports_external.string().uuid(),
  foodItemName: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable()
});
var listFoodItemUnitsByFoodItemIdRoute = createRoute({
  method: "get",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Food item units retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(foodItemUnitDetailSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var listAllFoodItemUnitsRoute = createRoute({
  method: "get",
  path: "/api/food-item/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "All food item units retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(allFoodItemUnitsSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListFoodItemUnits(app) {
  app.openapi(listFoodItemUnitsByFoodItemIdRoute, async (c) => {
    const safeUserId = c.userId;
    const foodItemId = c.req.param("foodItemId");
    const foodItemFromDb = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.id, foodItemId), eq(foodItems.userId, safeUserId))
    });
    if (!foodItemFromDb) {
      return c.json({
        success: false,
        message: "Food item not found or access denied"
      }, 404);
    }
    const units = await db.select().from(foodItemUnits).where(eq(foodItemUnits.foodItemId, foodItemId)).orderBy(foodItemUnits.unitOfMeasurement);
    const unitsWithFoodItem = units.map((unit) => ({
      id: unit.id,
      foodItemId: unit.foodItemId,
      foodItemName: foodItemFromDb.name,
      unitOfMeasurement: unit.unitOfMeasurement,
      unitDescription: unit.unitDescription,
      calories: unit.calories,
      proteinInGrams: unit.proteinInGrams,
      carbohydratesInGrams: unit.carbohydratesInGrams,
      fatInGrams: unit.fatInGrams,
      fiberInGrams: unit.fiberInGrams,
      sugarInGrams: unit.sugarInGrams
    }));
    return c.json({
      success: true,
      message: "Food item units retrieved successfully",
      data: unitsWithFoodItem
    }, 200);
  });
  app.openapi(listAllFoodItemUnitsRoute, async (c) => {
    const safeUserId = c.userId;
    const unitsWithFoodItems = await db.select({
      unitId: foodItemUnits.id,
      unitOfMeasurement: foodItemUnits.unitOfMeasurement,
      unitDescription: foodItemUnits.unitDescription,
      calories: foodItemUnits.calories,
      proteinInGrams: foodItemUnits.proteinInGrams,
      carbohydratesInGrams: foodItemUnits.carbohydratesInGrams,
      fatInGrams: foodItemUnits.fatInGrams,
      fiberInGrams: foodItemUnits.fiberInGrams,
      sugarInGrams: foodItemUnits.sugarInGrams,
      foodItemId: foodItems.id,
      foodItemName: foodItems.name,
      categoryHierarchy: foodItems.categoryHierarchy
    }).from(foodItemUnits).innerJoin(foodItems, eq(foodItemUnits.foodItemId, foodItems.id)).where(eq(foodItems.userId, safeUserId)).orderBy(foodItems.name, foodItemUnits.unitOfMeasurement);
    return c.json({
      success: true,
      message: "All food item units retrieved successfully",
      data: unitsWithFoodItems
    }, 200);
  });
}

// src/routes/api/habit/habit.create.ts
var createComplexHabitRequestSchema = exports_external.object({
  domain: exports_external.literal("meal"),
  entityId: exports_external.string().uuid(),
  recurrenceType: exports_external.literal("weekly"),
  targetWeekday: Weekday,
  targetTime: HHMM.optional(),
  startDate: YMD,
  subEntities: exports_external.array(exports_external.object({
    subEntityId: exports_external.string().uuid().optional(),
    scheduledWeekday: Weekday,
    scheduledTime: HHMM.optional()
  })).min(1)
});
var baseSimpleHabitRequestSchema = exports_external.object({
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  targetTime: HHMM.optional(),
  startDate: YMD
});
var createSimpleHabitRequestSchema = exports_external.discriminatedUnion("recurrenceType", [
  baseSimpleHabitRequestSchema.extend({
    recurrenceType: exports_external.literal("weekly"),
    targetWeekday: Weekday
  }),
  baseSimpleHabitRequestSchema.extend({
    recurrenceType: exports_external.literal("daily")
  })
]);
var successResponseSchema4 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    domain: exports_external.string(),
    configuredSubEntitiesCount: exports_external.number()
  })
});
var errorResponseSchema4 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var simpleHabitSuccessResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    domain: exports_external.literal("simple"),
    description: exports_external.string()
  })
});
var createBatchHabitsRoute = createRoute({
  method: "post",
  path: "/api/habit/batch",
  tags: ["Habits"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createComplexHabitRequestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Batch habits created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema4
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    }
  }
});
var createSimpleHabitRoute = createRoute({
  method: "post",
  path: "/api/habit/simple",
  tags: ["Habits"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createSimpleHabitRequestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Simple habit created successfully",
      content: {
        "application/json": {
          schema: simpleHabitSuccessResponseSchema
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    }
  }
});
function registerCreateHabit(app) {
  app.openapi(createBatchHabitsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeBatchHabitData = c.req.valid("json");
    if (safeBatchHabitData.domain !== "meal") {
      return c.json({
        success: false,
        message: "Unsupported domain for batch habits",
        errors: `Expected domain 'meal', got '${safeBatchHabitData.domain}'. Only meal domain is currently supported.`
      }, 400);
    }
    const mealFromDb = await db.query.meals.findFirst({
      where: eq(meals.id, safeBatchHabitData.entityId)
    });
    if (!mealFromDb || mealFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Invalid meal entity",
        errors: `Meal ${safeBatchHabitData.entityId} not found or access denied`
      }, 404);
    }
    const mealRecipesForEntity = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, safeBatchHabitData.entityId)).orderBy(mealRecipes.orderInMeal);
    if (mealRecipesForEntity.length === 0) {
      return c.json({
        success: false,
        message: "No recipes attached to meal",
        errors: `Meal ${safeBatchHabitData.entityId} has no recipes. Attach recipes using POST /api/meal/:id/recipes before creating a habit.`
      }, 400);
    }
    const allInstructions = [];
    for (const mealRecipe of mealRecipesForEntity) {
      const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
      allInstructions.push(...instructions);
    }
    if (allInstructions.length === 0) {
      return c.json({
        success: false,
        message: "No instructions found",
        errors: `None of the recipes attached to meal ${safeBatchHabitData.entityId} have instructions`
      }, 400);
    }
    const validInstructionIds = new Set(allInstructions.map((instr) => instr.id));
    const providedSubEntityIds = safeBatchHabitData.subEntities.map((se) => se.subEntityId).filter((id) => id !== undefined);
    for (const subEntityId of providedSubEntityIds) {
      if (!validInstructionIds.has(subEntityId)) {
        return c.json({
          success: false,
          message: "Invalid subEntityId",
          errors: `Instruction ${subEntityId} not found in meal's recipes`
        }, 400);
      }
    }
    const newHabit = {
      userId: safeUserId,
      ...safeBatchHabitData
    };
    console.log(safeUserId);
    const createHabitEvent = habitsCreatedSchema.safeParse(newHabit);
    if (!createHabitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid habit data",
        errors: createHabitEvent.error.errors
      }, 400);
    }
    const safeCreateHabitEvent = createHabitEvent.data;
    try {
      await FlowcorePathways.write("habit.v0/complex-habit.created.v0", {
        data: safeCreateHabitEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create batch habits",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Batch habits created successfully",
      data: {
        domain: safeBatchHabitData.domain,
        configuredSubEntitiesCount: safeBatchHabitData.subEntities.length
      }
    }, 201);
  });
  app.openapi(createSimpleHabitRoute, async (c) => {
    const safeUserId = c.userId;
    const safeSimpleHabitData = c.req.valid("json");
    const newSimpleHabit = {
      userId: safeUserId,
      ...safeSimpleHabitData
    };
    const createSimpleHabitEvent = simpleHabitCreatedSchema.safeParse(newSimpleHabit);
    if (!createSimpleHabitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid simple habit data",
        errors: createSimpleHabitEvent.error.errors
      }, 400);
    }
    const safeCreateSimpleHabitEvent = createSimpleHabitEvent.data;
    try {
      await FlowcorePathways.write("habit.v0/simple-habit.created.v0", {
        data: safeCreateSimpleHabitEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create simple habit",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Simple habit created successfully",
      data: {
        domain: "simple",
        description: safeSimpleHabitData.description
      }
    }, 201);
  });
}

// src/routes/api/habit/habit.delete.ts
var deleteHabitRequestSchema = exports_external.object({
  habitId: exports_external.string().uuid()
});
var successResponseSchema5 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: habitDeletedSchema
});
var errorResponseSchema5 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var deleteHabitRoute = createRoute({
  method: "delete",
  path: "/api/habit",
  tags: ["Habits"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: deleteHabitRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Habit deleted successfully",
      content: {
        "application/json": {
          schema: successResponseSchema5
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    }
  }
});
function registerDeleteHabit(app) {
  app.openapi(deleteHabitRoute, async (c) => {
    const safeUserId = c.userId;
    const safeDeleteHabitRequestBody = c.req.valid("json");
    const habitFromDb = await db.query.habits.findFirst({
      where: and(eq(habits.id, safeDeleteHabitRequestBody.habitId), eq(habits.userId, safeUserId))
    });
    if (!habitFromDb) {
      return c.json({
        success: false,
        message: "Habit not found"
      }, 404);
    }
    const habitDeleted = {
      habitId: habitFromDb.id
    };
    const habitDeletedEvent = habitDeletedSchema.safeParse(habitDeleted);
    if (!habitDeletedEvent.success) {
      return c.json({
        success: false,
        message: "Invalid habit deleted data",
        errors: habitDeletedEvent.error.errors
      }, 400);
    }
    try {
      await FlowcorePathways.write("habit.v0/habit.deleted.v0", {
        data: habitDeletedEvent.data
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to delete habit",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Habit deleted successfully",
      data: habitDeletedEvent.data
    }, 200);
  });
}

// src/routes/api/meal/meal.create.ts
var createMealRequestSchema = exports_external.object({
  mealName: exports_external.string().min(1, "Meal name min length is 1").max(100, "Meal name max length is 100")
});
var successResponseSchema6 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    meal: exports_external.object({
      id: exports_external.string().uuid(),
      mealName: exports_external.string()
    }),
    message: exports_external.string()
  })
});
var errorResponseSchema6 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createMealRoute = createRoute({
  method: "post",
  path: "/api/meal",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createMealRequestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Meal created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema6
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    }
  }
});
function registerCreateMeal(app) {
  app.openapi(createMealRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateMealJsonBody = c.req.valid("json");
    const newMeal = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      mealName: safeCreateMealJsonBody.mealName
    };
    const createMealEvent = mealSchema.safeParse(newMeal);
    if (!createMealEvent.success) {
      return c.json({
        success: false,
        message: "Invalid meal data",
        errors: createMealEvent.error.errors
      }, 400);
    }
    const safeCreateMealEvent = createMealEvent.data;
    try {
      await FlowcorePathways.write("meal.v0/meal.created.v0", {
        data: safeCreateMealEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create meal",
        errors: error2
      }, 500);
    }
    const { userId: _, ...createMeal } = safeCreateMealEvent;
    return c.json({
      success: true,
      message: "Meal created successfully",
      data: {
        meal: createMeal,
        message: "Meal created. Use POST /api/meal/:id/recipes to attach recipes."
      }
    }, 201);
  });
}

// src/routes/api/meal/meal.get.ts
var fullMealSchema = exports_external.object({
  id: exports_external.string().uuid(),
  mealName: exports_external.string(),
  recipes: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    orderInMeal: exports_external.number()
  })),
  instructions: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    instruction: exports_external.string(),
    instructionNumber: exports_external.number()
  })),
  ingredients: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    ingredientText: exports_external.string()
  }))
});
var getMealRoute = createRoute({
  method: "get",
  path: "/api/meal/{mealId}",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      mealId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Meal retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: fullMealSchema
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Meal not found or access denied",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerGetMeal(app) {
  app.openapi(getMealRoute, async (c) => {
    const safeUserId = c.userId;
    const mealId = c.req.param("mealId");
    const mealFromDb = await db.query.meals.findFirst({
      where: eq(meals.id, mealId)
    });
    if (!mealFromDb || mealFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Meal not found or access denied"
      }, 404);
    }
    const mealRecipesData = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId)).orderBy(mealRecipes.orderInMeal);
    const allIngredients = [];
    const allInstructions = [];
    for (const mealRecipe of mealRecipesData) {
      const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, mealRecipe.recipeId)).orderBy(recipeIngredients.ingredientText);
      for (const ingredient of ingredients) {
        allIngredients.push({
          recipeId: mealRecipe.recipeId,
          ingredientText: ingredient.ingredientText
        });
      }
      const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
      for (const inst of instructions) {
        allInstructions.push({
          recipeId: mealRecipe.recipeId,
          instruction: inst.instruction,
          instructionNumber: inst.instructionNumber
        });
      }
    }
    const fullMeal = {
      id: mealFromDb.id,
      mealName: mealFromDb.mealName,
      recipes: mealRecipesData.map((mr) => ({
        recipeId: mr.recipeId,
        orderInMeal: mr.orderInMeal
      })),
      instructions: allInstructions,
      ingredients: allIngredients
    };
    return c.json({
      success: true,
      message: "Meal retrieved successfully",
      data: fullMeal
    }, 200);
  });
}

// src/routes/api/meal/meal.list.ts
var mealSummarySchema = exports_external.object({
  id: exports_external.string().uuid(),
  mealName: exports_external.string(),
  recipeCount: exports_external.number()
});
var listMealsRoute = createRoute({
  method: "get",
  path: "/api/meal",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Meals retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(mealSummarySchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListMeals(app) {
  app.openapi(listMealsRoute, async (c) => {
    const safeUserId = c.userId;
    const userMeals = await db.select().from(meals).where(eq(meals.userId, safeUserId));
    const mealsData = await Promise.all(userMeals.map(async (meal3) => {
      const mealRecipesData = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, meal3.id)).orderBy(mealRecipes.orderInMeal);
      return {
        id: meal3.id,
        mealName: meal3.mealName,
        recipeCount: mealRecipesData.length
      };
    }));
    return c.json({
      success: true,
      message: "Meals retrieved successfully",
      data: mealsData
    }, 200);
  });
}

// src/routes/api/meal/meal-recipes.attach.ts
var requestSchema = exports_external.object({
  recipeIds: exports_external.array(exports_external.string().uuid()).min(1, "At least one recipe ID is required")
});
var successResponseSchema7 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    mealRecipe: mealRecipeAttachSchema
  })
});
var errorResponseSchema7 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var attachRecipesToMealRoute = createRoute({
  method: "post",
  path: "/api/meal/{mealId}/recipes",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      mealId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: requestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Recipes attached to meal successfully",
      content: {
        "application/json": {
          schema: successResponseSchema7
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    404: {
      description: "Meal or recipes not found",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    }
  }
});
function registerAttachMealRecipes(app) {
  app.openapi(attachRecipesToMealRoute, async (c) => {
    const safeUserId = c.userId;
    const mealId = c.req.param("mealId");
    const { recipeIds } = c.req.valid("json");
    const mealFromDb = await db.query.meals.findFirst({
      where: and(eq(meals.id, mealId), eq(meals.userId, safeUserId))
    });
    if (!mealFromDb) {
      return c.json({
        success: false,
        message: "Meal not found or access denied"
      }, 404);
    }
    const recipesFromDb = await db.query.recipes.findMany({
      where: and(inArray(recipes.id, recipeIds), eq(recipes.userId, safeUserId))
    });
    if (recipesFromDb.length !== recipeIds.length) {
      const missingRecipeIds = recipeIds.filter((id) => !recipesFromDb.some((r) => r.id === id));
      return c.json({
        success: false,
        message: "One or more recipes not found or access denied",
        errors: `Recipes ${missingRecipeIds.join(", ")} not found or access denied`
      }, 404);
    }
    const existingRecipes = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId));
    const maxOrder = existingRecipes.length > 0 ? Math.max(...existingRecipes.map((r) => r.orderInMeal)) : -1;
    const recipesToAttach = recipesFromDb.map((recipe4, index) => ({
      recipeId: recipe4.id,
      orderInMeal: maxOrder + 1 + index
    }));
    const newMealRecipe = {
      mealId,
      recipes: recipesToAttach
    };
    const attachEvent = mealRecipeAttachSchema.safeParse(newMealRecipe);
    if (!attachEvent.success) {
      return c.json({
        success: false,
        message: "Invalid meal recipe data",
        errors: attachEvent.error.errors
      }, 400);
    }
    try {
      await FlowcorePathways.write("meal.v0/meal-recipe.attached.v0", {
        data: attachEvent.data
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to attach recipes to meal",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: `${recipeIds.length} recipe${recipeIds.length > 1 ? "s" : ""} attached to meal successfully`,
      data: {
        mealRecipe: attachEvent.data
      }
    }, 201);
  });
}

// src/routes/api/recipe/recipe.create.ts
var createRecipeRequestSchema = exports_external.object({
  nameOfTheRecipe: exports_external.string().min(1, "Recipe name min length is 1").max(75, "Recipe name max length is 75"),
  generalDescriptionOfTheRecipe: exports_external.string().max(250).optional(),
  whenIsItConsumed: exports_external.array(exports_external.nativeEnum(MealTimingEnum)).optional()
});
var successResponseSchema8 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeSchema
});
var errorResponseSchema8 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeRoute = createRoute({
  method: "post",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema8
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    409: {
      description: "Conflict - Recipe with name already exists",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    }
  }
});
function registerCreateRecipe(app) {
  app.openapi(createRecipeRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeJsonBody = c.req.valid("json");
    const existingRecipe = await db.select().from(recipes).where(and(eq(recipes.nameOfTheRecipe, safeCreateRecipeJsonBody.nameOfTheRecipe), eq(recipes.userId, safeUserId)));
    if (existingRecipe.length > 0) {
      return c.json({
        success: false,
        message: "Recipe with name already exists"
      }, 409);
    }
    const newRecipe = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      nameOfTheRecipe: safeCreateRecipeJsonBody.nameOfTheRecipe,
      generalDescriptionOfTheRecipe: safeCreateRecipeJsonBody.generalDescriptionOfTheRecipe,
      whenIsItConsumed: safeCreateRecipeJsonBody.whenIsItConsumed
    };
    const createRecipeEvent = recipeSchema.safeParse(newRecipe);
    if (!createRecipeEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe data",
        errors: createRecipeEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeEvent = createRecipeEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe.created.v0", {
        data: safeCreateRecipeEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe created successfully",
      data: safeCreateRecipeEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe.delete.ts
var deleteRecipeRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid()
});
var successResponseSchema9 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeDeletedSchema
});
var errorResponseSchema9 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var deleteRecipeRoute = createRoute({
  method: "delete",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: deleteRecipeRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe deleted successfully",
      content: {
        "application/json": {
          schema: successResponseSchema9
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    404: {
      description: "Recipe not found",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    }
  }
});
function registerDeleteRecipe(app) {
  app.openapi(deleteRecipeRoute, async (c) => {
    const safeUserId = c.userId;
    const safeDeleteRecipeRequestBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: and(eq(recipes.id, safeDeleteRecipeRequestBody.recipeId), eq(recipes.userId, safeUserId))
    });
    if (!recipeFromDb) {
      return c.json({
        success: false,
        message: "Recipe not found"
      }, 404);
    }
    const recipeDeleted = {
      recipeId: recipeFromDb.id
    };
    const recipeDeletedEvent = recipeDeletedSchema.safeParse(recipeDeleted);
    if (!recipeDeletedEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe deleted data",
        errors: recipeDeletedEvent.error.errors
      }, 400);
    }
    const safeRecipeDeletedEvent = recipeDeletedEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe.deleted.v0", {
        data: safeRecipeDeletedEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to delete recipe",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe deleted successfully",
      data: safeRecipeDeletedEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe.list.ts
var recipeMetadataSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable(),
  version: exports_external.number(),
  stepCount: exports_external.number(),
  ingredientCount: exports_external.number(),
  hasSteps: exports_external.boolean(),
  hasIngredients: exports_external.boolean(),
  completeness: exports_external.enum(["complete", "incomplete"])
});
var fullRecipeSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable(),
  version: exports_external.number(),
  instructions: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    instruction: exports_external.string(),
    instructionNumber: exports_external.number(),
    foodItemUnits: exports_external.array(exports_external.object({
      quantity: exports_external.number(),
      calories: exports_external.number(),
      unitOfMeasurement: exports_external.string(),
      foodItemName: exports_external.string()
    }))
  })),
  ingredients: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    ingredientText: exports_external.string()
  })),
  metadata: exports_external.object({
    stepCount: exports_external.number(),
    ingredientCount: exports_external.number(),
    estimatedTotalTime: exports_external.number().nullable()
  })
});
var recipeBasicSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable()
});
var listRecipesRoute = createRoute({
  method: "get",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Recipes retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(recipeMetadataSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var getRecipeByIdRoute = createRoute({
  method: "get",
  path: "/api/recipe/{recipeId}",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      recipeId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Recipe retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: fullRecipeSchema
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Recipe not found or access denied",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var searchRecipesRoute = createRoute({
  method: "get",
  path: "/api/recipe/search",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    query: exports_external.object({
      q: exports_external.string().optional(),
      timing: exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Recipe search results",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(recipeBasicSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListRecipes(app) {
  app.openapi(listRecipesRoute, async (c) => {
    const safeUserId = c.userId;
    const userRecipes = await db.select().from(recipes).where(eq(recipes.userId, safeUserId)).orderBy(recipes.nameOfTheRecipe);
    const recipesWithMetadata = await Promise.all(userRecipes.map(async (recipe4) => {
      const steps = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, recipe4.id));
      const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, recipe4.id));
      return {
        id: recipe4.id,
        nameOfTheRecipe: recipe4.nameOfTheRecipe,
        generalDescriptionOfTheRecipe: recipe4.generalDescriptionOfTheRecipe,
        whenIsItConsumed: recipe4.whenIsItConsumed,
        version: recipe4.version,
        stepCount: steps.length,
        ingredientCount: ingredients.length,
        hasSteps: steps.length > 0,
        hasIngredients: ingredients.length > 0,
        completeness: steps.length > 0 && ingredients.length > 0 ? "complete" : "incomplete"
      };
    }));
    return c.json({
      success: true,
      message: "Recipes retrieved successfully",
      data: recipesWithMetadata
    }, 200);
  });
  app.openapi(getRecipeByIdRoute, async (c) => {
    const safeUserId = c.userId;
    const recipeId = c.req.param("recipeId");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found or access denied"
      }, 404);
    }
    const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, recipeId)).orderBy(recipeInstructions.instructionNumber);
    const instructionFoodItemUnits = await db.select().from(recipeInstructionFoodItemUnits).where(inArray(recipeInstructionFoodItemUnits.recipeInstructionId, instructions.map((instruction) => instruction.id)));
    const foodItemUnitsFromDb = await db.select().from(foodItemUnits).where(inArray(foodItemUnits.id, instructionFoodItemUnits.map((instructionFoodItemUnit) => instructionFoodItemUnit.foodItemUnitId)));
    const foodItemsFromDb = await db.select().from(foodItems).where(inArray(foodItems.id, foodItemUnitsFromDb.map((foodItemUnit) => foodItemUnit.foodItemId)));
    const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, recipeId));
    const fullRecipe = {
      id: recipeFromDb.id,
      nameOfTheRecipe: recipeFromDb.nameOfTheRecipe,
      generalDescriptionOfTheRecipe: recipeFromDb.generalDescriptionOfTheRecipe,
      whenIsItConsumed: recipeFromDb.whenIsItConsumed,
      version: recipeFromDb.version,
      instructions: instructions.map((instruction) => {
        const instructionFoodUnits = instructionFoodItemUnits.filter((ifiu) => ifiu.recipeInstructionId === instruction.id).map((ifiu) => {
          const foodItemUnit = foodItemUnitsFromDb.find((fiu) => fiu.id === ifiu.foodItemUnitId);
          const foodItem2 = foodItemsFromDb.find((fi) => fi.id === foodItemUnit?.foodItemId);
          return {
            quantity: ifiu.quantity,
            calories: foodItemUnit?.calories || 0,
            unitOfMeasurement: foodItemUnit?.unitOfMeasurement || "",
            foodItemName: foodItem2?.name || ""
          };
        });
        return {
          id: instruction.id,
          instruction: instruction.instruction,
          instructionNumber: instruction.instructionNumber,
          foodItemUnits: instructionFoodUnits
        };
      }),
      ingredients: ingredients.map((ingredient) => ({
        id: ingredient.id,
        ingredientText: ingredient.ingredientText
      })),
      metadata: {
        stepCount: instructions.length,
        ingredientCount: ingredients.length,
        estimatedTotalTime: null
      }
    };
    return c.json({
      success: true,
      message: "Recipe retrieved successfully",
      data: fullRecipe
    }, 200);
  });
  app.openapi(searchRecipesRoute, async (c) => {
    const safeUserId = c.userId;
    const query = c.req.query("q") || "";
    const mealTiming = c.req.query("timing");
    let userRecipes = await db.select().from(recipes).where(eq(recipes.userId, safeUserId)).orderBy(recipes.nameOfTheRecipe);
    if (query) {
      userRecipes = userRecipes.filter((recipe4) => recipe4.nameOfTheRecipe.toLowerCase().includes(query.toLowerCase()) || (recipe4.generalDescriptionOfTheRecipe ? recipe4.generalDescriptionOfTheRecipe.toLowerCase().includes(query.toLowerCase()) : false));
    }
    if (mealTiming) {
      userRecipes = userRecipes.filter((recipe4) => recipe4.whenIsItConsumed ? recipe4.whenIsItConsumed.includes(mealTiming) : false);
    }
    return c.json({
      success: true,
      message: "Recipe search results",
      data: userRecipes
    }, 200);
  });
}

// src/routes/api/recipe/recipe-ingredients.create.ts
var createRecipeIngredientsRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  ingredients: exports_external.array(exports_external.object({
    ingredientText: exports_external.string().min(1).max(150)
  })).min(1).max(50)
});
var successResponseSchema10 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeIngredientsSchema
});
var errorResponseSchema10 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeIngredientsRoute = createRoute({
  method: "post",
  path: "/api/recipe/ingredients",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeIngredientsRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe ingredients created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema10
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    404: {
      description: "Recipe not found or access denied",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    }
  }
});
function registerCreateRecipeIngredients(app) {
  app.openapi(createRecipeIngredientsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeIngredientsJsonBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, safeCreateRecipeIngredientsJsonBody.recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found or access denied"
      }, 404);
    }
    const newRecipeIngredients = {
      recipeId: safeCreateRecipeIngredientsJsonBody.recipeId,
      ingredients: safeCreateRecipeIngredientsJsonBody.ingredients.map((ingredient) => ({
        id: crypto.randomUUID(),
        ingredientText: ingredient.ingredientText
      }))
    };
    const createRecipeIngredientsEvent = recipeIngredientsSchema.safeParse(newRecipeIngredients);
    if (!createRecipeIngredientsEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe ingredients data",
        errors: createRecipeIngredientsEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeIngredientsEvent = createRecipeIngredientsEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe-ingredients.created.v0", {
        data: safeCreateRecipeIngredientsEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe ingredients",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe ingredients created successfully",
      data: safeCreateRecipeIngredientsEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe-instructions.create.ts
var createRecipeInstructionsRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  stepByStepInstructions: exports_external.array(exports_external.object({
    stepInstruction: exports_external.string().min(1).max(250),
    foodItemUnitsUsedInStep: exports_external.array(exports_external.object({
      foodItemUnitId: exports_external.string().uuid(),
      quantityOfFoodItemUnit: exports_external.number().positive().max(1e6).default(1)
    })).optional()
  })).min(1).max(30)
});
var successResponseSchema11 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeInstructionsSchema
});
var errorResponseSchema11 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeInstructionsRoute = createRoute({
  method: "post",
  path: "/api/recipe/instructions",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeInstructionsRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe instructions created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema11
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    },
    404: {
      description: "Recipe not found",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    }
  }
});
function registerCreateRecipeInstructions(app) {
  app.openapi(createRecipeInstructionsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeInstructionsJsonBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, safeCreateRecipeInstructionsJsonBody.recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found"
      }, 404);
    }
    const maxStepResult = await db.select({ maxStep: max(recipeInstructions.instructionNumber) }).from(recipeInstructions).where(eq(recipeInstructions.recipeId, safeCreateRecipeInstructionsJsonBody.recipeId));
    const currentMaxStep = maxStepResult[0]?.maxStep ?? 0;
    const newRecipeInstructions = {
      recipeId: safeCreateRecipeInstructionsJsonBody.recipeId,
      stepByStepInstructions: safeCreateRecipeInstructionsJsonBody.stepByStepInstructions.map((step, index) => ({
        id: crypto.randomUUID(),
        instructionNumber: currentMaxStep + index + 1,
        stepInstruction: step.stepInstruction,
        foodItemUnitsUsedInStep: step.foodItemUnitsUsedInStep
      }))
    };
    const createRecipeInstructionsEvent = recipeInstructionsSchema.safeParse(newRecipeInstructions);
    if (!createRecipeInstructionsEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe instructions data",
        errors: createRecipeInstructionsEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeInstructionsEvent = createRecipeInstructionsEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe-instructions.created.v0", {
        data: safeCreateRecipeInstructionsEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe instructions",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe instructions created successfully",
      data: safeCreateRecipeInstructionsEvent
    }, 200);
  });
}

// src/routes/api/todo/todo.cancel.ts
var cancelTodoRequestSchema = exports_external.object({
  id: exports_external.string().uuid()
});
var successResponseSchema12 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: todoCancelledSchema
});
var errorResponseSchema12 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var cancelTodoRoute = createRoute({
  method: "post",
  path: "/api/todo/cancel",
  tags: ["Todos"],
  security: [
    {
      Bearer: []
    }
  ],
  request: {
    body: {
      content: {
        "application/json": {
          schema: cancelTodoRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Todo cancelled successfully",
      content: {
        "application/json": {
          schema: successResponseSchema12
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    }
  }
});
function registerCancelTodo(app) {
  app.openapi(cancelTodoRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCancelTodoJsonBody = c.req.valid("json");
    const cancelledTodo = {
      id: safeCancelTodoJsonBody.id,
      userId: safeUserId
    };
    const cancelTodoEvent = todoCancelledSchema.safeParse(cancelledTodo);
    if (!cancelTodoEvent.success) {
      return c.json({
        success: false,
        message: "Invalid cancelled todo data",
        errors: cancelTodoEvent.error.errors
      }, 400);
    }
    const safeCancelTodoEvent = cancelTodoEvent.data;
    try {
      await FlowcorePathways.write("todo.v0/todo.cancelled.v0", {
        data: safeCancelTodoEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to cancel todo",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Todo cancelled successfully",
      data: safeCancelTodoEvent
    }, 200);
  });
}

// src/routes/api/todo/todo.complete.ts
var completeTodoRequestSchema = exports_external.object({
  id: exports_external.string().uuid()
});
var successResponseSchema13 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: todoCompletedSchema
});
var errorResponseSchema13 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var completeTodoRoute = createRoute({
  method: "post",
  path: "/api/todo/complete",
  tags: ["Todos"],
  security: [
    {
      Bearer: []
    }
  ],
  request: {
    body: {
      content: {
        "application/json": {
          schema: completeTodoRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Todo completed successfully",
      content: {
        "application/json": {
          schema: successResponseSchema13
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema13
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema13
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema13
        }
      }
    }
  }
});
function registerCompleteTodo(app) {
  app.openapi(completeTodoRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCompleteTodoJsonBody = c.req.valid("json");
    const completedTodo = {
      id: safeCompleteTodoJsonBody.id,
      userId: safeUserId
    };
    const completeTodoEvent = todoCompletedSchema.safeParse(completedTodo);
    if (!completeTodoEvent.success) {
      return c.json({
        success: false,
        message: "Invalid completed todo data",
        errors: completeTodoEvent.error.errors
      }, 400);
    }
    const safeCompleteTodoEvent = completeTodoEvent.data;
    try {
      await FlowcorePathways.write("todo.v0/todo.completed.v0", {
        data: safeCompleteTodoEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to complete todo",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Todo completed successfully",
      data: safeCompleteTodoEvent
    }, 200);
  });
}

// src/routes/api/todo/todo.create.ts
var createTodoRequestSchema = exports_external.object({
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  scheduledFor: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: exports_external.object({
      mealStepId: exports_external.string().uuid(),
      mealId: exports_external.string().uuid(),
      recipeId: exports_external.string().uuid(),
      instructionNumber: exports_external.number().int().positive()
    })
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
var successResponseSchema14 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: todoSchema
});
var errorResponseSchema14 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createTodoRoute = createRoute({
  method: "post",
  path: "/api/todo",
  tags: ["Todos"],
  security: [
    {
      Bearer: []
    }
  ],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createTodoRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Todo created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema14
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema14
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema14
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema14
        }
      }
    }
  }
});
function registerCreateTodo(app) {
  app.openapi(createTodoRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateTodoJsonBody = c.req.valid("json");
    const newTodo = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      description: safeCreateTodoJsonBody.description,
      completed: false,
      scheduledFor: safeCreateTodoJsonBody.scheduledFor,
      completedAt: undefined,
      relations: safeCreateTodoJsonBody.relations
    };
    const createTodoEvent = todoSchema.safeParse(newTodo);
    if (!createTodoEvent.success) {
      return c.json({
        success: false,
        message: "Invalid todo data",
        errors: createTodoEvent.error.errors
      }, 400);
    }
    const safeCreateTodoEvent = createTodoEvent.data;
    try {
      await FlowcorePathways.write("todo.v0/todo.created.v0", {
        data: safeCreateTodoEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create todo",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Todo created successfully",
      data: safeCreateTodoEvent
    }, 200);
  });
}

// src/services/habit-generation.ts
import crypto3 from "crypto";

// node_modules/date-fns/esm/_lib/toInteger/index.js
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

// node_modules/date-fns/esm/_lib/requiredArgs/index.js
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}

// node_modules/date-fns/esm/constants/index.js
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
var millisecondsInMinute = 60000;
var millisecondsInHour = 3600000;
var minTime = -maxTime;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/esm/parseISO/index.js
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === undefined ? undefined : options.additionalDigits) !== null && _options$additionalDi !== undefined ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date2;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date2 = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date2 || isNaN(date2.getTime())) {
    return new Date(NaN);
  }
  var timestamp2 = date2.getTime();
  var time2 = 0;
  var offset;
  if (dateStrings.time) {
    time2 = parseTime(dateStrings.time);
    if (isNaN(time2)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp2 + time2);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp2 + time2 + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex2 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex2 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex2);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date2 = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date2;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex2);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date2 = new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date2.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date2) {
  return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
// src/services/domain-resolvers/meal-resolver.ts
class MealTitleResolver {
  async getMainEventTitle(mealId) {
    const meal3 = await db.query.meals.findFirst({
      where: eq(meals.id, mealId)
    });
    if (!meal3) {
      console.warn(`Meal not found for ID: ${mealId}`);
      return "Unknown Meal";
    }
    return `Eat: ${meal3.mealName}`;
  }
  async getSubEntityTitle(instructionId) {
    const instruction = await db.query.recipeInstructions.findFirst({
      where: eq(recipeInstructions.id, instructionId)
    });
    if (!instruction) {
      console.warn(`Recipe instruction not found for ID: ${instructionId}`);
      return "Unknown Instruction";
    }
    return instruction.instruction;
  }
}

// src/services/domain-resolvers/simple-resolver.ts
class SimpleTitleResolver {
  async getMainEventTitle(habitId) {
    const habit2 = await db.query.habits.findFirst({
      where: eq(habits.id, habitId)
    });
    if (!habit2 || !habit2.description) {
      console.warn(`Simple habit not found for ID: ${habitId}`);
      return "Habit";
    }
    return habit2.description;
  }
  async getSubEntityTitle(_subEntityId) {
    return "Habit";
  }
}

// src/services/domain-resolvers/index.ts
var RESOLVERS = {
  meal: new MealTitleResolver,
  simple: new SimpleTitleResolver
};
function getTitleResolver(domain) {
  const resolver = RESOLVERS[domain];
  if (!resolver) {
    throw new Error(`No title resolver found for domain: ${domain}. Available domains: ${Object.keys(RESOLVERS).join(", ")}`);
  }
  return resolver;
}

// src/services/habit-generation.ts
function subtractMinutesFromTime(time2, minutes) {
  const [hours, mins] = time2.split(":").map(Number);
  const totalMinutes = hours * 60 + mins - minutes;
  const adjustedMinutes = totalMinutes < 0 ? 0 : totalMinutes;
  const newHours = Math.floor(adjustedMinutes / 60);
  const newMins = adjustedMinutes % 60;
  return `${String(newHours).padStart(2, "0")}:${String(newMins).padStart(2, "0")}`;
}
async function fetchCurrentMealInstructions(mealId) {
  const mealRecipesForEntity = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId)).orderBy(mealRecipes.orderInMeal);
  const allInstructions = [];
  for (const mealRecipe of mealRecipesForEntity) {
    const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
    allInstructions.push(...instructions);
  }
  return allInstructions;
}
function calculateScheduledFor(dueDate, preferredTime) {
  const timeToUse = preferredTime || "09:00";
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dueDate)) {
    throw new Error(`Invalid dueDate format: ${dueDate}. Expected YYYY-MM-DD`);
  }
  if (!/^\d{2}:\d{2}$/.test(timeToUse)) {
    throw new Error(`Invalid time format: ${timeToUse}. Expected HH:MM`);
  }
  const dateTimeString = `${dueDate}T${timeToUse}:00.000Z`;
  const utcDate = parseISO(dateTimeString);
  if (Number.isNaN(utcDate.getTime())) {
    throw new Error(`Invalid date created from: ${dateTimeString}`);
  }
  return utcDate;
}
function getWeekdayFromDate(dateStr) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
    throw new Error(`Invalid date format: ${dateStr}. Expected YYYY-MM-DD`);
  }
  const dateTimeString = `${dateStr}T12:00:00.000Z`;
  const date2 = parseISO(dateTimeString);
  if (Number.isNaN(date2.getTime())) {
    throw new Error(`Invalid date created from: ${dateTimeString}`);
  }
  const weekdays2 = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  return weekdays2[date2.getDay()];
}
async function selectTriggersForDate(userId, targetDate) {
  const weekday = getWeekdayFromDate(targetDate);
  const weeklyTriggers = await db.query.habitTriggers.findMany({
    where: eq(habitTriggers.triggerWeekday, weekday)
  });
  const weeklyTriggerHabitIds = Array.from(new Set(weeklyTriggers.map((t) => t.habitId)));
  const weeklyHabits = weeklyTriggerHabitIds.length > 0 ? await db.query.habits.findMany({
    where: and(inArray(habits.id, weeklyTriggerHabitIds), eq(habits.userId, userId), eq(habits.isActive, true), eq(habits.recurrenceType, "weekly"))
  }) : [];
  const dailyHabits = await db.query.habits.findMany({
    where: and(eq(habits.userId, userId), eq(habits.isActive, true), eq(habits.recurrenceType, "daily"))
  });
  const allHabits = [...weeklyHabits, ...dailyHabits];
  if (allHabits.length === 0) {
    return [];
  }
  const allHabitIds = allHabits.map((habit2) => habit2.id);
  const allSubEntities = await db.query.habitSubEntities.findMany({
    where: inArray(habitSubEntities.habitId, allHabitIds),
    orderBy: habitSubEntities.scheduledWeekday
  });
  const subEntitiesByHabitId = new Map;
  for (const subEntity of allSubEntities) {
    const existing = subEntitiesByHabitId.get(subEntity.habitId) || [];
    existing.push(subEntity);
    subEntitiesByHabitId.set(subEntity.habitId, existing);
  }
  const weeklyHabitMap = new Map(weeklyHabits.map((h) => [h.id, h]));
  const triggersWithSubEntities = [];
  for (const trigger of weeklyTriggers) {
    const habit2 = weeklyHabitMap.get(trigger.habitId);
    if (!habit2)
      continue;
    const subEntities = subEntitiesByHabitId.get(habit2.id) || [];
    triggersWithSubEntities.push({
      trigger,
      habit: habit2,
      subEntities
    });
  }
  for (const habit2 of dailyHabits) {
    const subEntities = subEntitiesByHabitId.get(habit2.id) || [];
    triggersWithSubEntities.push({
      trigger: {
        id: `daily-${habit2.id}`,
        habitId: habit2.id,
        triggerSubEntityId: null,
        triggerWeekday: weekday
      },
      habit: habit2,
      subEntities
    });
  }
  return triggersWithSubEntities;
}
async function generateHabitInstance(habit2, subEntities, triggerDate) {
  const instanceId = crypto3.randomUUID();
  const todoEvents = [];
  const resolver = getTitleResolver(habit2.domain);
  for (const subEntity of subEntities) {
    if (!subEntity.subEntityId)
      continue;
    const scheduledDate = calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, subEntity.scheduledWeekday);
    const scheduledTime = subEntity.scheduledTime || "09:00";
    const scheduledFor = calculateScheduledFor(scheduledDate, scheduledTime);
    const title = subEntity.subEntityId ? await resolver.getSubEntityTitle(subEntity.subEntityId) : "Unknown Task";
    const todoEvent = {
      id: crypto3.randomUUID(),
      userId: habit2.userId,
      description: title,
      completed: false,
      scheduledFor: scheduledFor.toISOString(),
      completedAt: undefined,
      relations: undefined
    };
    todoEvents.push(todoEvent);
  }
  if (habit2.domain === "meal") {
    const currentInstructions = await fetchCurrentMealInstructions(habit2.entityId);
    const configuredInstructionIds = new Set(subEntities.map((se) => se.subEntityId).filter((id) => id !== null));
    const unconfiguredInstructions = currentInstructions.filter((instr) => !configuredInstructionIds.has(instr.id));
    for (const instruction of unconfiguredInstructions) {
      const scheduledDate = calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, habit2.targetWeekday);
      const scheduledTime = habit2.targetTime ? subtractMinutesFromTime(habit2.targetTime, 30) : "09:00";
      const scheduledFor = calculateScheduledFor(scheduledDate, scheduledTime);
      const title = await resolver.getSubEntityTitle(instruction.id);
      const todoEvent = {
        id: crypto3.randomUUID(),
        userId: habit2.userId,
        description: title,
        completed: false,
        scheduledFor: scheduledFor.toISOString(),
        completedAt: undefined,
        relations: undefined
      };
      todoEvents.push(todoEvent);
    }
  }
  const mainEventDate = habit2.recurrenceType === "daily" ? triggerDate : calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, habit2.targetWeekday);
  const mainEventTime = habit2.targetTime || "09:00";
  const mainEventScheduledFor = calculateScheduledFor(mainEventDate, mainEventTime);
  const mainEventTitle = await resolver.getMainEventTitle(habit2.entityId);
  const mainEventTodo = {
    id: crypto3.randomUUID(),
    userId: habit2.userId,
    description: mainEventTitle,
    completed: false,
    scheduledFor: mainEventScheduledFor.toISOString(),
    completedAt: undefined,
    relations: undefined
  };
  todoEvents.push(mainEventTodo);
  await FlowcorePathways.write("todo.v0/todo.generated.v0", {
    batch: true,
    data: todoEvents
  });
  return { instanceId, todosGenerated: todoEvents.length };
}
function calculateScheduledDateForSubEntity(triggerDate, _targetWeekday, subEntityWeekday) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(triggerDate)) {
    throw new Error(`Invalid triggerDate format: ${triggerDate}. Expected YYYY-MM-DD`);
  }
  const weekdays2 = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  const subEntityDay = weekdays2.indexOf(subEntityWeekday);
  if (subEntityDay === -1) {
    throw new Error(`Invalid subEntityWeekday: ${subEntityWeekday}`);
  }
  const triggerDay = getWeekdayFromDate(triggerDate);
  const triggerDayIndex = weekdays2.indexOf(triggerDay);
  if (triggerDayIndex === -1) {
    throw new Error(`Invalid triggerDay: ${triggerDay}`);
  }
  let offset = subEntityDay - triggerDayIndex;
  if (offset < 0)
    offset += 7;
  const triggerDateObj = parseISO(`${triggerDate}T12:00:00.000Z`);
  if (Number.isNaN(triggerDateObj.getTime())) {
    throw new Error(`Invalid trigger date created from: ${triggerDate}T12:00:00.000Z`);
  }
  const scheduledDateObj = new Date(triggerDateObj);
  scheduledDateObj.setDate(scheduledDateObj.getDate() + offset);
  if (Number.isNaN(scheduledDateObj.getTime())) {
    throw new Error(`Invalid scheduled date calculated from triggerDate: ${triggerDate}, offset: ${offset}`);
  }
  return scheduledDateObj.toISOString().split("T")[0];
}
async function generateMissingHabitTodos(userId, targetDate) {
  try {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(targetDate)) {
      throw new Error(`Invalid targetDate format: ${targetDate}. Expected YYYY-MM-DD`);
    }
    const hasExecutedToday = await db.query.habitTriggerExecutions.findFirst({
      where: and(eq(habitTriggerExecutions.userId, userId), eq(habitTriggerExecutions.triggerDate, targetDate))
    });
    if (hasExecutedToday) {
      console.log(`Habit generation already completed for ${targetDate}`);
      return {
        success: 0,
        skipped: 0,
        failed: 0,
        errors: []
      };
    }
    await db.insert(habitTriggerExecutions).values({
      userId,
      triggerDate: targetDate
    }).onConflictDoUpdate({
      target: habitTriggerExecutions.userId,
      set: {
        triggerDate: targetDate
      }
    });
    console.log(`Starting weekly habit todo generation for user ${userId} on ${targetDate}`);
    const triggersToFire = await selectTriggersForDate(userId, targetDate);
    console.log(`Found ${triggersToFire.length} habit triggers for ${targetDate}`);
    const results = {
      success: 0,
      skipped: 0,
      failed: 0,
      errors: []
    };
    for (const { habit: habit2, subEntities } of triggersToFire) {
      try {
        const { instanceId, todosGenerated } = await generateHabitInstance(habit2, subEntities, targetDate);
        results.success++;
        console.log(`Generated habit instance for ${habit2.entityId}: ${todosGenerated} todos created (instance: ${instanceId})`);
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : String(error2);
        console.error(`Failed to generate habit instance for ${habit2.entityId}:`, error2);
        results.failed++;
        results.errors.push({
          habitId: habit2.id,
          error: errorMessage
        });
      }
    }
    console.log(`Weekly habit generation completed: ${results.success} successful, ${results.skipped} skipped, ${results.failed} failed`);
    return results;
  } catch (error2) {
    console.error(`Critical error in generateMissingHabitTodos:`, error2);
    throw error2;
  }
}

// src/utils/timezone.ts
function getDayBoundsInTimezone(timezone, date2 = new Date) {
  if (Number.isNaN(date2.getTime())) {
    throw new Error(`Invalid input date provided: ${date2}`);
  }
  try {
    const year = date2.getFullYear();
    const month = date2.getMonth();
    const day = date2.getDate();
    const startOfDayLocal = new Date(year, month, day, 0, 0, 0, 0);
    const endOfDayLocal = new Date(year, month, day, 23, 59, 59, 999);
    if (Number.isNaN(startOfDayLocal.getTime()) || Number.isNaN(endOfDayLocal.getTime())) {
      throw new Error(`Invalid local dates created from year=${year}, month=${month}, day=${day}`);
    }
    const startOfDayUTC = convertLocalTimeToUTC(startOfDayLocal, timezone);
    const endOfDayUTC = convertLocalTimeToUTC(endOfDayLocal, timezone);
    return {
      startOfDay: startOfDayUTC,
      endOfDay: endOfDayUTC
    };
  } catch (error2) {
    console.error(`Error in getDayBoundsInTimezone: ${error2}`);
    console.error(`Input: timezone=${timezone}, date=${date2}`);
    throw error2;
  }
}
function convertLocalTimeToUTC(localDate, timezone) {
  if (Number.isNaN(localDate.getTime())) {
    throw new Error(`Invalid localDate provided: ${localDate}`);
  }
  try {
    const localString = localDate.toISOString().slice(0, 19);
    const timeInTargetTz = new Date(`${localString}Z`);
    if (Number.isNaN(timeInTargetTz.getTime())) {
      throw new Error(`Invalid intermediate date created: ${localString}Z`);
    }
    const utcTime = timeInTargetTz.getTime();
    const timezoneString = timeInTargetTz.toLocaleString("sv-SE", {
      timeZone: timezone
    });
    const timezoneTime = new Date(timezoneString).getTime();
    if (Number.isNaN(timezoneTime)) {
      throw new Error(`Invalid timezone conversion: ${timezoneString} for timezone ${timezone}`);
    }
    const offset = utcTime - timezoneTime;
    const result = new Date(localDate.getTime() + offset);
    if (Number.isNaN(result.getTime())) {
      throw new Error(`Invalid result date calculated with offset ${offset}`);
    }
    return result;
  } catch (error2) {
    console.error(`Error in convertLocalTimeToUTC: ${error2}`);
    console.error(`Input: localDate=${localDate}, timezone=${timezone}`);
    throw error2;
  }
}
function getCurrentDateInTimezone(timezone) {
  const now = new Date;
  if (Number.isNaN(now.getTime())) {
    throw new Error(`Invalid current date: ${now}`);
  }
  try {
    const dateString = now.toLocaleDateString("en-CA", {
      timeZone: timezone
    });
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
      throw new Error(`Invalid date format returned: ${dateString}. Expected YYYY-MM-DD`);
    }
    return dateString;
  } catch (error2) {
    console.error(`Error in getCurrentDateInTimezone: ${error2}`);
    console.error(`Input: timezone=${timezone}`);
    throw error2;
  }
}

// src/routes/api/todo/todo.list.ts
var todayTodoItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  description: exports_external.string().nullable(),
  scheduledFor: exports_external.string().datetime().optional(),
  completed: exports_external.boolean(),
  context: exports_external.union([
    exports_external.object({
      type: exports_external.literal("meal"),
      mealName: exports_external.string(),
      instructionNumber: exports_external.number(),
      estimatedDuration: exports_external.number().nullable()
    }),
    exports_external.object({
      type: exports_external.literal("standalone")
    })
  ]),
  canStartNow: exports_external.boolean(),
  isOverdue: exports_external.boolean(),
  urgency: exports_external.enum(["overdue", "now", "upcoming", "later"])
});
var todayTodosResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    todos: exports_external.array(todayTodoItemSchema),
    counts: exports_external.object({
      total: exports_external.number(),
      completed: exports_external.number(),
      remaining: exports_external.number(),
      overdue: exports_external.number()
    })
  })
});
var allTodosItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  description: exports_external.string().nullable(),
  completed: exports_external.boolean(),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.any().nullable()
});
var allTodosResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(allTodosItemSchema)
});
var getTodayTodosRoute = createRoute({
  method: "get",
  path: "/api/todo/today",
  tags: ["Todos"],
  security: [{ Bearer: [] }],
  request: {
    headers: exports_external.object({
      "x-timezone": exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Today's todos retrieved successfully",
      content: {
        "application/json": {
          schema: todayTodosResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var getAllTodosRoute = createRoute({
  method: "get",
  path: "/api/todo",
  tags: ["Todos"],
  security: [{ Bearer: [] }],
  request: {
    headers: exports_external.object({
      "x-timezone": exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "All todos retrieved successfully",
      content: {
        "application/json": {
          schema: allTodosResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListTodos(app) {
  app.openapi(getTodayTodosRoute, async (c) => {
    const safeUserId = c.userId;
    const userTimezone = c.req.header("X-Timezone") || "UTC";
    const todayDate = getCurrentDateInTimezone(userTimezone);
    generateMissingHabitTodos(safeUserId, todayDate).catch((error2) => {
      console.error("Failed to generate habit todos in background:", error2);
    });
    const { startOfDay: startOfDayUTC, endOfDay: endOfDayUTC } = getDayBoundsInTimezone(userTimezone);
    const now = new Date;
    const todaysTodos = await db.select().from(todos).where(and(eq(todos.userId, safeUserId), or(isNull(todos.scheduledFor), and(gte(todos.scheduledFor, startOfDayUTC), lte(todos.scheduledFor, endOfDayUTC))))).orderBy(todos.scheduledFor);
    const transformedTodos = todaysTodos.map((todo4) => {
      let relations = null;
      if (todo4.relations) {
        try {
          relations = JSON.parse(todo4.relations);
        } catch (error2) {
          console.warn("Invalid todo relations JSON", {
            todoId: todo4.id,
            error: error2
          });
        }
      }
      const mealRelation = relations?.[0]?.mealInstruction;
      const scheduledTime = todo4.scheduledFor ? new Date(todo4.scheduledFor) : null;
      const isOverdue = scheduledTime ? scheduledTime < now : false;
      const canStartNow = !scheduledTime || scheduledTime <= now;
      let urgency = "later";
      if (isOverdue)
        urgency = "overdue";
      else if (canStartNow)
        urgency = "now";
      else if (scheduledTime && scheduledTime.getTime() - now.getTime() <= 60 * 60 * 1000)
        urgency = "upcoming";
      return {
        id: todo4.id,
        description: todo4.description,
        scheduledFor: todo4.scheduledFor?.toISOString(),
        completed: todo4.completed,
        context: mealRelation ? {
          type: "meal",
          mealName: `Step ${mealRelation.instructionNumber}`,
          instructionNumber: Number(mealRelation.instructionNumber),
          estimatedDuration: null
        } : {
          type: "standalone"
        },
        canStartNow,
        isOverdue,
        urgency
      };
    });
    const counts = {
      total: transformedTodos.length,
      completed: transformedTodos.filter((t) => t.completed).length,
      remaining: transformedTodos.filter((t) => !t.completed).length,
      overdue: transformedTodos.filter((t) => t.urgency === "overdue").length
    };
    return c.json({
      success: true,
      message: "Today's todos retrieved successfully",
      data: {
        todos: transformedTodos,
        counts
      }
    }, 200);
  });
  app.openapi(getAllTodosRoute, async (c) => {
    const safeUserId = c.userId;
    const userTimezone = c.req.header("X-Timezone") || "UTC";
    const todayDate = getCurrentDateInTimezone(userTimezone);
    try {
      await generateMissingHabitTodos(safeUserId, todayDate);
    } catch (error2) {
      console.error("Failed to generate habit todos:", error2);
    }
    const allTodos = await db.select().from(todos).where(eq(todos.userId, safeUserId)).orderBy(todos.scheduledFor);
    const transformedTodos = allTodos.map((todo4) => ({
      id: todo4.id,
      description: todo4.description,
      completed: todo4.completed,
      scheduledFor: todo4.scheduledFor?.toISOString(),
      completedAt: todo4.completedAt?.toISOString(),
      relations: (() => {
        if (!todo4.relations)
          return null;
        try {
          return JSON.parse(todo4.relations);
        } catch (error2) {
          console.warn("Invalid todo relations JSON", {
            todoId: todo4.id,
            error: error2
          });
          return null;
        }
      })()
    }));
    return c.json({
      success: true,
      message: "Todos retrieved successfully",
      data: transformedTodos
    }, 200);
  });
}

// src/index.ts
var app = new OpenAPIHono;
app.onError((err2, c) => {
  console.error("Unhandled error", err2);
  return c.json({
    error: "INTERNAL_SERVER_ERROR",
    message: err2 instanceof Error ? err2.message : String(err2)
  }, 500);
});
var defaultLocalApiBaseUrl = "http://localhost:3030";
var rawLocalApiBaseUrl = zodEnv.LOCAL_IP ?? defaultLocalApiBaseUrl;
var localApiBaseUrl = rawLocalApiBaseUrl.includes("://") ? rawLocalApiBaseUrl : `http://${rawLocalApiBaseUrl}`;
var localApiUrl;
try {
  localApiUrl = new URL(localApiBaseUrl);
} catch {
  localApiUrl = new URL(defaultLocalApiBaseUrl);
}
var defaultAllowedOrigins = ["https://flowday.io", "https://www.flowday.io"];
var localFrontendOrigins = localApiUrl ? ["3000", "3001"].map((port) => {
  const protocol = localApiUrl?.protocol ?? "http:";
  const hostname = localApiUrl?.hostname ?? "localhost";
  return `${protocol}//${hostname}:${port}`;
}) : ["http://localhost:3000", "http://localhost:3001"];
var allowedOrigins = Array.from(new Set([...defaultAllowedOrigins, ...localFrontendOrigins]));
var localApiHost = localApiUrl?.hostname;
var localApiPort = Number(localApiUrl?.port || "3030");
app.use("/*", cors({
  origin: allowedOrigins,
  allowHeaders: [
    "Content-Type",
    "Authorization",
    "X-Timezone",
    "X-Secret"
  ],
  allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  maxAge: 86400,
  credentials: true
}));
app.get("/health", (c) => {
  return c.json({ ok: true }, 200);
});
app.get("/api/health", (c) => {
  return c.json({ ok: true }, 200);
});
app.openAPIRegistry.registerComponent("securitySchemes", "Bearer", {
  type: "http",
  scheme: "bearer",
  bearerFormat: "JWT"
});
app.use("/api/todo/*", requireAuth());
app.use("/api/food-item/*", requireAuth());
app.use("/api/habit/*", requireAuth());
app.use("/api/recipe/*", requireAuth());
app.use("/api/meal/*", requireAuth());
registerCreateTodo(app);
registerCancelTodo(app);
registerCompleteTodo(app);
registerListTodos(app);
registerCreateFoodItem(app);
registerListFoodItems(app);
registerDeleteFoodItem(app);
registerCreateFoodItemUnits(app);
registerListFoodItemUnits(app);
registerDeleteFoodItemUnits(app);
registerCreateHabit(app);
registerDeleteHabit(app);
registerCreateRecipe(app);
registerDeleteRecipe(app);
registerListRecipes(app);
registerCreateRecipeIngredients(app);
registerCreateRecipeInstructions(app);
registerCreateMeal(app);
registerListMeals(app);
registerGetMeal(app);
registerAttachMealRecipes(app);
app.route("/api", api_default);
app.doc31("/api/openapi.json", {
  openapi: "3.1.0",
  info: {
    title: "Daily Scheduler API",
    version: "1.0.0",
    description: "API for managing todos, habits, meals, recipes, and food items"
  },
  servers: [
    {
      url: localApiUrl?.origin ?? defaultLocalApiBaseUrl,
      description: "Local development server"
    },
    {
      url: "https://api.flowday.io",
      description: "Production server"
    }
  ]
});
var scalarHandler;
var scalarHandlerInit;
async function getScalarHandler() {
  if (scalarHandler)
    return scalarHandler;
  scalarHandlerInit ??= Promise.resolve().then(() => (init_dist2(), exports_dist)).then(({ Scalar: Scalar2 }) => {
    scalarHandler = Scalar2({
      url: "/api/openapi.json",
      theme: "purple"
    });
    return scalarHandler;
  });
  return scalarHandlerInit;
}
app.get("/api/swagger", async (c, next) => {
  const handler = await getScalarHandler();
  return handler(c, next);
});
var serverConfig = {
  port: localApiPort,
  fetch: app.fetch
};
if (localApiHost) {
  serverConfig.hostname = localApiHost;
}
var src_default2 = serverConfig;
export {
  src_default2 as default,
  app
};
