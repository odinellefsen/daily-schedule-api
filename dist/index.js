var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/@asteasolutions/zod-to-openapi/dist/index.cjs
var require_dist = __commonJS((exports2) => {
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function isZodType(schema, typeName) {
    var _a;
    return ((_a = schema === null || schema === undefined ? undefined : schema._def) === null || _a === undefined ? undefined : _a.typeName) === typeName;
  }
  function isAnyZodType(schema) {
    return "_def" in schema;
  }
  function preserveMetadataFromModifier(zod, modifier) {
    const zodModifier = zod.ZodType.prototype[modifier];
    zod.ZodType.prototype[modifier] = function(...args) {
      const result = zodModifier.apply(this, args);
      result._def.openapi = this._def.openapi;
      return result;
    };
  }
  function extendZodWithOpenApi(zod) {
    if (typeof zod.ZodType.prototype.openapi !== "undefined") {
      return;
    }
    zod.ZodType.prototype.openapi = function(refOrOpenapi, metadata) {
      var _a, _b, _c, _d, _e, _f;
      const openapi = typeof refOrOpenapi === "string" ? metadata : refOrOpenapi;
      const _g = openapi !== null && openapi !== undefined ? openapi : {}, { param } = _g, restOfOpenApi = __rest(_g, ["param"]);
      const _internal = Object.assign(Object.assign({}, (_a = this._def.openapi) === null || _a === undefined ? undefined : _a._internal), typeof refOrOpenapi === "string" ? { refId: refOrOpenapi } : undefined);
      const resultMetadata = Object.assign(Object.assign(Object.assign({}, (_b = this._def.openapi) === null || _b === undefined ? undefined : _b.metadata), restOfOpenApi), ((_d = (_c = this._def.openapi) === null || _c === undefined ? undefined : _c.metadata) === null || _d === undefined ? undefined : _d.param) || param ? {
        param: Object.assign(Object.assign({}, (_f = (_e = this._def.openapi) === null || _e === undefined ? undefined : _e.metadata) === null || _f === undefined ? undefined : _f.param), param)
      } : undefined);
      const result = new this.constructor(Object.assign(Object.assign({}, this._def), { openapi: Object.assign(Object.assign({}, Object.keys(_internal).length > 0 ? { _internal } : undefined), Object.keys(resultMetadata).length > 0 ? { metadata: resultMetadata } : undefined) }));
      if (isZodType(this, "ZodObject")) {
        const originalExtend = this.extend;
        result.extend = function(...args) {
          var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
          const extendedResult = originalExtend.apply(this, args);
          extendedResult._def.openapi = {
            _internal: {
              extendedFrom: ((_b2 = (_a2 = this._def.openapi) === null || _a2 === undefined ? undefined : _a2._internal) === null || _b2 === undefined ? undefined : _b2.refId) ? { refId: (_d2 = (_c2 = this._def.openapi) === null || _c2 === undefined ? undefined : _c2._internal) === null || _d2 === undefined ? undefined : _d2.refId, schema: this } : (_f2 = (_e2 = this._def.openapi) === null || _e2 === undefined ? undefined : _e2._internal) === null || _f2 === undefined ? undefined : _f2.extendedFrom
            },
            metadata: (_g2 = extendedResult._def.openapi) === null || _g2 === undefined ? undefined : _g2.metadata
          };
          return extendedResult;
        };
      }
      return result;
    };
    preserveMetadataFromModifier(zod, "optional");
    preserveMetadataFromModifier(zod, "nullable");
    preserveMetadataFromModifier(zod, "default");
    preserveMetadataFromModifier(zod, "transform");
    preserveMetadataFromModifier(zod, "refine");
    const zodDeepPartial = zod.ZodObject.prototype.deepPartial;
    zod.ZodObject.prototype.deepPartial = function() {
      const initialShape = this._def.shape();
      const result = zodDeepPartial.apply(this);
      const resultShape = result._def.shape();
      Object.entries(resultShape).forEach(([key, value]) => {
        var _a, _b;
        value._def.openapi = (_b = (_a = initialShape[key]) === null || _a === undefined ? undefined : _a._def) === null || _b === undefined ? undefined : _b.openapi;
      });
      result._def.openapi = undefined;
      return result;
    };
    const zodPick = zod.ZodObject.prototype.pick;
    zod.ZodObject.prototype.pick = function(...args) {
      const result = zodPick.apply(this, args);
      result._def.openapi = undefined;
      return result;
    };
    const zodOmit = zod.ZodObject.prototype.omit;
    zod.ZodObject.prototype.omit = function(...args) {
      const result = zodOmit.apply(this, args);
      result._def.openapi = undefined;
      return result;
    };
  }
  function isEqual(x, y) {
    if (x === null || x === undefined || y === null || y === undefined) {
      return x === y;
    }
    if (x === y || x.valueOf() === y.valueOf()) {
      return true;
    }
    if (Array.isArray(x)) {
      if (!Array.isArray(y)) {
        return false;
      }
      if (x.length !== y.length) {
        return false;
      }
    }
    if (!(x instanceof Object) || !(y instanceof Object)) {
      return false;
    }
    const keysX = Object.keys(x);
    return Object.keys(y).every((keyY) => keysX.indexOf(keyY) !== -1) && keysX.every((key) => isEqual(x[key], y[key]));
  }

  class ObjectSet {
    constructor() {
      this.buckets = new Map;
    }
    put(value) {
      const hashCode = this.hashCodeOf(value);
      const itemsByCode = this.buckets.get(hashCode);
      if (!itemsByCode) {
        this.buckets.set(hashCode, [value]);
        return;
      }
      const alreadyHasItem = itemsByCode.some((_) => isEqual(_, value));
      if (!alreadyHasItem) {
        itemsByCode.push(value);
      }
    }
    contains(value) {
      const hashCode = this.hashCodeOf(value);
      const itemsByCode = this.buckets.get(hashCode);
      if (!itemsByCode) {
        return false;
      }
      return itemsByCode.some((_) => isEqual(_, value));
    }
    values() {
      return [...this.buckets.values()].flat();
    }
    stats() {
      let totalBuckets = 0;
      let totalValues = 0;
      let collisions = 0;
      for (const bucket of this.buckets.values()) {
        totalBuckets += 1;
        totalValues += bucket.length;
        if (bucket.length > 1) {
          collisions += 1;
        }
      }
      const hashEffectiveness = totalBuckets / totalValues;
      return { totalBuckets, collisions, totalValues, hashEffectiveness };
    }
    hashCodeOf(object) {
      let hashCode = 0;
      if (Array.isArray(object)) {
        for (let i = 0;i < object.length; i++) {
          hashCode ^= this.hashCodeOf(object[i]) * i;
        }
        return hashCode;
      }
      if (typeof object === "string") {
        for (let i = 0;i < object.length; i++) {
          hashCode ^= object.charCodeAt(i) * i;
        }
        return hashCode;
      }
      if (typeof object === "number") {
        return object;
      }
      if (typeof object === "object") {
        for (const [key, value] of Object.entries(object)) {
          hashCode ^= this.hashCodeOf(key) + this.hashCodeOf(value !== null && value !== undefined ? value : "");
        }
      }
      return hashCode;
    }
  }
  function isUndefined(value) {
    return value === undefined;
  }
  function mapValues(object, mapper) {
    const result = {};
    Object.entries(object).forEach(([key, value]) => {
      result[key] = mapper(value);
    });
    return result;
  }
  function omit(object, keys) {
    const result = {};
    Object.entries(object).forEach(([key, value]) => {
      if (!keys.some((keyToOmit) => keyToOmit === key)) {
        result[key] = value;
      }
    });
    return result;
  }
  function omitBy(object, predicate) {
    const result = {};
    Object.entries(object).forEach(([key, value]) => {
      if (!predicate(value, key)) {
        result[key] = value;
      }
    });
    return result;
  }
  function compact(arr) {
    return arr.filter((elem) => !isUndefined(elem));
  }
  var objectEquals = isEqual;
  function uniq(values) {
    const set = new ObjectSet;
    values.forEach((value) => set.put(value));
    return [...set.values()];
  }
  function isString(val) {
    return typeof val === "string";
  }
  function getOpenApiMetadata(zodSchema) {
    var _a, _b;
    return omitBy((_b = (_a = zodSchema._def.openapi) === null || _a === undefined ? undefined : _a.metadata) !== null && _b !== undefined ? _b : {}, isUndefined);
  }

  class OpenAPIRegistry {
    constructor(parents) {
      this.parents = parents;
      this._definitions = [];
    }
    get definitions() {
      var _a, _b;
      const parentDefinitions = (_b = (_a = this.parents) === null || _a === undefined ? undefined : _a.flatMap((par) => par.definitions)) !== null && _b !== undefined ? _b : [];
      return [...parentDefinitions, ...this._definitions];
    }
    register(refId, zodSchema) {
      const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
      this._definitions.push({ type: "schema", schema: schemaWithRefId });
      return schemaWithRefId;
    }
    registerParameter(refId, zodSchema) {
      var _a, _b, _c;
      const schemaWithRefId = this.schemaWithRefId(refId, zodSchema);
      const currentMetadata = (_a = schemaWithRefId._def.openapi) === null || _a === undefined ? undefined : _a.metadata;
      const schemaWithMetadata = schemaWithRefId.openapi(Object.assign(Object.assign({}, currentMetadata), { param: Object.assign(Object.assign({}, currentMetadata === null || currentMetadata === undefined ? undefined : currentMetadata.param), { name: (_c = (_b = currentMetadata === null || currentMetadata === undefined ? undefined : currentMetadata.param) === null || _b === undefined ? undefined : _b.name) !== null && _c !== undefined ? _c : refId }) }));
      this._definitions.push({
        type: "parameter",
        schema: schemaWithMetadata
      });
      return schemaWithMetadata;
    }
    registerPath(route) {
      this._definitions.push({
        type: "route",
        route
      });
    }
    registerWebhook(webhook) {
      this._definitions.push({
        type: "webhook",
        webhook
      });
    }
    registerComponent(type, name, component) {
      this._definitions.push({
        type: "component",
        componentType: type,
        name,
        component
      });
      return {
        name,
        ref: { $ref: `#/components/${type}/${name}` }
      };
    }
    schemaWithRefId(refId, zodSchema) {
      return zodSchema.openapi(refId);
    }
  }

  class ZodToOpenAPIError {
    constructor(message) {
      this.message = message;
    }
  }

  class ConflictError extends ZodToOpenAPIError {
    constructor(message, data) {
      super(message);
      this.data = data;
    }
  }

  class MissingParameterDataError extends ZodToOpenAPIError {
    constructor(data) {
      super(`Missing parameter data, please specify \`${data.missingField}\` and other OpenAPI parameter props using the \`param\` field of \`ZodSchema.openapi\``);
      this.data = data;
    }
  }
  function enhanceMissingParametersError(action, paramsToAdd) {
    try {
      return action();
    } catch (error) {
      if (error instanceof MissingParameterDataError) {
        throw new MissingParameterDataError(Object.assign(Object.assign({}, error.data), paramsToAdd));
      }
      throw error;
    }
  }

  class UnknownZodTypeError extends ZodToOpenAPIError {
    constructor(data) {
      super(`Unknown zod object type, please specify \`type\` and other OpenAPI props using \`ZodSchema.openapi\`.`);
      this.data = data;
    }
  }

  class Metadata {
    static getMetadata(zodSchema) {
      var _a;
      const innerSchema = this.unwrapChained(zodSchema);
      const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
      const zodDescription = (_a = zodSchema.description) !== null && _a !== undefined ? _a : innerSchema.description;
      return {
        _internal: metadata === null || metadata === undefined ? undefined : metadata._internal,
        metadata: Object.assign({ description: zodDescription }, metadata === null || metadata === undefined ? undefined : metadata.metadata)
      };
    }
    static getInternalMetadata(zodSchema) {
      const innerSchema = this.unwrapChained(zodSchema);
      const openapi = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
      return openapi === null || openapi === undefined ? undefined : openapi._internal;
    }
    static getParamMetadata(zodSchema) {
      var _a, _b;
      const innerSchema = this.unwrapChained(zodSchema);
      const metadata = zodSchema._def.openapi ? zodSchema._def.openapi : innerSchema._def.openapi;
      const zodDescription = (_a = zodSchema.description) !== null && _a !== undefined ? _a : innerSchema.description;
      return {
        _internal: metadata === null || metadata === undefined ? undefined : metadata._internal,
        metadata: Object.assign(Object.assign({}, metadata === null || metadata === undefined ? undefined : metadata.metadata), {
          param: Object.assign({ description: zodDescription }, (_b = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _b === undefined ? undefined : _b.param)
        })
      };
    }
    static buildSchemaMetadata(metadata) {
      return omitBy(omit(metadata, ["param"]), isUndefined);
    }
    static buildParameterMetadata(metadata) {
      return omitBy(metadata, isUndefined);
    }
    static applySchemaMetadata(initialData, metadata) {
      return omitBy(Object.assign(Object.assign({}, initialData), this.buildSchemaMetadata(metadata)), isUndefined);
    }
    static getRefId(zodSchema) {
      var _a;
      return (_a = this.getInternalMetadata(zodSchema)) === null || _a === undefined ? undefined : _a.refId;
    }
    static unwrapChained(schema) {
      return this.unwrapUntil(schema);
    }
    static getDefaultValue(zodSchema) {
      const unwrapped = this.unwrapUntil(zodSchema, "ZodDefault");
      return unwrapped === null || unwrapped === undefined ? undefined : unwrapped._def.defaultValue();
    }
    static unwrapUntil(schema, typeName) {
      if (typeName && isZodType(schema, typeName)) {
        return schema;
      }
      if (isZodType(schema, "ZodOptional") || isZodType(schema, "ZodNullable") || isZodType(schema, "ZodBranded")) {
        return this.unwrapUntil(schema.unwrap(), typeName);
      }
      if (isZodType(schema, "ZodDefault") || isZodType(schema, "ZodReadonly")) {
        return this.unwrapUntil(schema._def.innerType, typeName);
      }
      if (isZodType(schema, "ZodEffects")) {
        return this.unwrapUntil(schema._def.schema, typeName);
      }
      if (isZodType(schema, "ZodPipeline")) {
        return this.unwrapUntil(schema._def.in, typeName);
      }
      return typeName ? undefined : schema;
    }
    static isOptionalSchema(zodSchema) {
      return zodSchema.isOptional();
    }
  }

  class ArrayTransformer {
    transform(zodSchema, mapNullableType, mapItems) {
      var _a, _b;
      const itemType = zodSchema._def.type;
      return Object.assign(Object.assign({}, mapNullableType("array")), { items: mapItems(itemType), minItems: (_a = zodSchema._def.minLength) === null || _a === undefined ? undefined : _a.value, maxItems: (_b = zodSchema._def.maxLength) === null || _b === undefined ? undefined : _b.value });
    }
  }

  class BigIntTransformer {
    transform(mapNullableType) {
      return Object.assign(Object.assign({}, mapNullableType("string")), { pattern: `^d+$` });
    }
  }

  class DiscriminatedUnionTransformer {
    transform(zodSchema, isNullable, mapNullableOfArray, mapItem, generateSchemaRef) {
      const options = [...zodSchema.options.values()];
      const optionSchema = options.map(mapItem);
      if (isNullable) {
        return {
          oneOf: mapNullableOfArray(optionSchema, isNullable)
        };
      }
      return {
        oneOf: optionSchema,
        discriminator: this.mapDiscriminator(options, zodSchema.discriminator, generateSchemaRef)
      };
    }
    mapDiscriminator(zodObjects, discriminator, generateSchemaRef) {
      if (zodObjects.some((obj) => Metadata.getRefId(obj) === undefined)) {
        return;
      }
      const mapping = {};
      zodObjects.forEach((obj) => {
        var _a;
        const refId = Metadata.getRefId(obj);
        const value = (_a = obj.shape) === null || _a === undefined ? undefined : _a[discriminator];
        if (isZodType(value, "ZodEnum") || isZodType(value, "ZodNativeEnum")) {
          const keys = Object.values(value.enum).filter(isString);
          keys.forEach((enumValue) => {
            mapping[enumValue] = generateSchemaRef(refId);
          });
          return;
        }
        const literalValue = value === null || value === undefined ? undefined : value._def.value;
        if (typeof literalValue !== "string") {
          throw new Error(`Discriminator ${discriminator} could not be found in one of the values of a discriminated union`);
        }
        mapping[literalValue] = generateSchemaRef(refId);
      });
      return {
        propertyName: discriminator,
        mapping
      };
    }
  }

  class EnumTransformer {
    transform(zodSchema, mapNullableType) {
      return Object.assign(Object.assign({}, mapNullableType("string")), { enum: zodSchema._def.values });
    }
  }

  class IntersectionTransformer {
    transform(zodSchema, isNullable, mapNullableOfArray, mapItem) {
      const subtypes = this.flattenIntersectionTypes(zodSchema);
      const allOfSchema = {
        allOf: subtypes.map(mapItem)
      };
      if (isNullable) {
        return {
          anyOf: mapNullableOfArray([allOfSchema], isNullable)
        };
      }
      return allOfSchema;
    }
    flattenIntersectionTypes(schema) {
      if (!isZodType(schema, "ZodIntersection")) {
        return [schema];
      }
      const leftSubTypes = this.flattenIntersectionTypes(schema._def.left);
      const rightSubTypes = this.flattenIntersectionTypes(schema._def.right);
      return [...leftSubTypes, ...rightSubTypes];
    }
  }

  class LiteralTransformer {
    transform(zodSchema, mapNullableType) {
      return Object.assign(Object.assign({}, mapNullableType(typeof zodSchema._def.value)), { enum: [zodSchema._def.value] });
    }
  }
  function enumInfo(enumObject) {
    const keysExceptReverseMappings = Object.keys(enumObject).filter((key) => typeof enumObject[enumObject[key]] !== "number");
    const values = keysExceptReverseMappings.map((key) => enumObject[key]);
    const numericCount = values.filter((_) => typeof _ === "number").length;
    const type = numericCount === 0 ? "string" : numericCount === values.length ? "numeric" : "mixed";
    return { values, type };
  }

  class NativeEnumTransformer {
    transform(zodSchema, mapNullableType) {
      const { type, values } = enumInfo(zodSchema._def.values);
      if (type === "mixed") {
        throw new ZodToOpenAPIError("Enum has mixed string and number values, please specify the OpenAPI type manually");
      }
      return Object.assign(Object.assign({}, mapNullableType(type === "numeric" ? "integer" : "string")), { enum: values });
    }
  }

  class NumberTransformer {
    transform(zodSchema, mapNullableType, getNumberChecks) {
      return Object.assign(Object.assign({}, mapNullableType(zodSchema.isInt ? "integer" : "number")), getNumberChecks(zodSchema._def.checks));
    }
  }

  class ObjectTransformer {
    transform(zodSchema, defaultValue, mapNullableType, mapItem) {
      var _a;
      const extendedFrom = (_a = Metadata.getInternalMetadata(zodSchema)) === null || _a === undefined ? undefined : _a.extendedFrom;
      const required = this.requiredKeysOf(zodSchema);
      const properties = mapValues(zodSchema._def.shape(), mapItem);
      if (!extendedFrom) {
        return Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { properties, default: defaultValue }), required.length > 0 ? { required } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
      }
      const parent = extendedFrom.schema;
      mapItem(parent);
      const keysRequiredByParent = this.requiredKeysOf(parent);
      const propsOfParent = mapValues(parent === null || parent === undefined ? undefined : parent._def.shape(), mapItem);
      const propertiesToAdd = Object.fromEntries(Object.entries(properties).filter(([key, type]) => {
        return !objectEquals(propsOfParent[key], type);
      }));
      const additionallyRequired = required.filter((prop) => !keysRequiredByParent.includes(prop));
      const objectData = Object.assign(Object.assign(Object.assign(Object.assign({}, mapNullableType("object")), { default: defaultValue, properties: propertiesToAdd }), additionallyRequired.length > 0 ? { required: additionallyRequired } : {}), this.generateAdditionalProperties(zodSchema, mapItem));
      return {
        allOf: [
          { $ref: `#/components/schemas/${extendedFrom.refId}` },
          objectData
        ]
      };
    }
    generateAdditionalProperties(zodSchema, mapItem) {
      const unknownKeysOption = zodSchema._def.unknownKeys;
      const catchallSchema = zodSchema._def.catchall;
      if (isZodType(catchallSchema, "ZodNever")) {
        if (unknownKeysOption === "strict") {
          return { additionalProperties: false };
        }
        return {};
      }
      return { additionalProperties: mapItem(catchallSchema) };
    }
    requiredKeysOf(objectSchema) {
      return Object.entries(objectSchema._def.shape()).filter(([_key, type]) => !Metadata.isOptionalSchema(type)).map(([key, _type]) => key);
    }
  }

  class RecordTransformer {
    transform(zodSchema, mapNullableType, mapItem) {
      const propertiesType = zodSchema._def.valueType;
      const keyType = zodSchema._def.keyType;
      const propertiesSchema = mapItem(propertiesType);
      if (isZodType(keyType, "ZodEnum") || isZodType(keyType, "ZodNativeEnum")) {
        const keys = Object.values(keyType.enum).filter(isString);
        const properties = keys.reduce((acc, curr) => Object.assign(Object.assign({}, acc), { [curr]: propertiesSchema }), {});
        return Object.assign(Object.assign({}, mapNullableType("object")), { properties });
      }
      return Object.assign(Object.assign({}, mapNullableType("object")), { additionalProperties: propertiesSchema });
    }
  }

  class StringTransformer {
    transform(zodSchema, mapNullableType) {
      var _a, _b, _c;
      const regexCheck = this.getZodStringCheck(zodSchema, "regex");
      const length = (_a = this.getZodStringCheck(zodSchema, "length")) === null || _a === undefined ? undefined : _a.value;
      const maxLength = Number.isFinite(zodSchema.minLength) ? (_b = zodSchema.minLength) !== null && _b !== undefined ? _b : undefined : undefined;
      const minLength = Number.isFinite(zodSchema.maxLength) ? (_c = zodSchema.maxLength) !== null && _c !== undefined ? _c : undefined : undefined;
      return Object.assign(Object.assign({}, mapNullableType("string")), {
        minLength: length !== null && length !== undefined ? length : maxLength,
        maxLength: length !== null && length !== undefined ? length : minLength,
        format: this.mapStringFormat(zodSchema),
        pattern: regexCheck === null || regexCheck === undefined ? undefined : regexCheck.regex.source
      });
    }
    mapStringFormat(zodString) {
      if (zodString.isUUID)
        return "uuid";
      if (zodString.isEmail)
        return "email";
      if (zodString.isURL)
        return "uri";
      if (zodString.isDate)
        return "date";
      if (zodString.isDatetime)
        return "date-time";
      if (zodString.isCUID)
        return "cuid";
      if (zodString.isCUID2)
        return "cuid2";
      if (zodString.isULID)
        return "ulid";
      if (zodString.isIP)
        return "ip";
      if (zodString.isEmoji)
        return "emoji";
      return;
    }
    getZodStringCheck(zodString, kind) {
      return zodString._def.checks.find((check) => {
        return check.kind === kind;
      });
    }
  }

  class TupleTransformer {
    constructor(versionSpecifics) {
      this.versionSpecifics = versionSpecifics;
    }
    transform(zodSchema, mapNullableType, mapItem) {
      const { items } = zodSchema._def;
      const schemas = items.map(mapItem);
      return Object.assign(Object.assign({}, mapNullableType("array")), this.versionSpecifics.mapTupleItems(schemas));
    }
  }

  class UnionTransformer {
    transform(zodSchema, mapNullableOfArray, mapItem) {
      const options = this.flattenUnionTypes(zodSchema);
      const schemas = options.map((schema) => {
        const optionToGenerate = this.unwrapNullable(schema);
        return mapItem(optionToGenerate);
      });
      return {
        anyOf: mapNullableOfArray(schemas)
      };
    }
    flattenUnionTypes(schema) {
      if (!isZodType(schema, "ZodUnion")) {
        return [schema];
      }
      const options = schema._def.options;
      return options.flatMap((option) => this.flattenUnionTypes(option));
    }
    unwrapNullable(schema) {
      if (isZodType(schema, "ZodNullable")) {
        return this.unwrapNullable(schema.unwrap());
      }
      return schema;
    }
  }

  class OpenApiTransformer {
    constructor(versionSpecifics) {
      this.versionSpecifics = versionSpecifics;
      this.objectTransformer = new ObjectTransformer;
      this.stringTransformer = new StringTransformer;
      this.numberTransformer = new NumberTransformer;
      this.bigIntTransformer = new BigIntTransformer;
      this.literalTransformer = new LiteralTransformer;
      this.enumTransformer = new EnumTransformer;
      this.nativeEnumTransformer = new NativeEnumTransformer;
      this.arrayTransformer = new ArrayTransformer;
      this.unionTransformer = new UnionTransformer;
      this.discriminatedUnionTransformer = new DiscriminatedUnionTransformer;
      this.intersectionTransformer = new IntersectionTransformer;
      this.recordTransformer = new RecordTransformer;
      this.tupleTransformer = new TupleTransformer(versionSpecifics);
    }
    transform(zodSchema, isNullable, mapItem, generateSchemaRef, defaultValue) {
      if (isZodType(zodSchema, "ZodNull")) {
        return this.versionSpecifics.nullType;
      }
      if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
        return this.versionSpecifics.mapNullableType(undefined, isNullable);
      }
      if (isZodType(zodSchema, "ZodObject")) {
        return this.objectTransformer.transform(zodSchema, defaultValue, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
      }
      const schema = this.transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef);
      return Object.assign(Object.assign({}, schema), { default: defaultValue });
    }
    transformSchemaWithoutDefault(zodSchema, isNullable, mapItem, generateSchemaRef) {
      if (isZodType(zodSchema, "ZodUnknown") || isZodType(zodSchema, "ZodAny")) {
        return this.versionSpecifics.mapNullableType(undefined, isNullable);
      }
      if (isZodType(zodSchema, "ZodString")) {
        return this.stringTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
      }
      if (isZodType(zodSchema, "ZodNumber")) {
        return this.numberTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable), (_) => this.versionSpecifics.getNumberChecks(_));
      }
      if (isZodType(zodSchema, "ZodBigInt")) {
        return this.bigIntTransformer.transform((schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
      }
      if (isZodType(zodSchema, "ZodBoolean")) {
        return this.versionSpecifics.mapNullableType("boolean", isNullable);
      }
      if (isZodType(zodSchema, "ZodLiteral")) {
        return this.literalTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
      }
      if (isZodType(zodSchema, "ZodEnum")) {
        return this.enumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
      }
      if (isZodType(zodSchema, "ZodNativeEnum")) {
        return this.nativeEnumTransformer.transform(zodSchema, (schema) => this.versionSpecifics.mapNullableType(schema, isNullable));
      }
      if (isZodType(zodSchema, "ZodArray")) {
        return this.arrayTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
      }
      if (isZodType(zodSchema, "ZodTuple")) {
        return this.tupleTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
      }
      if (isZodType(zodSchema, "ZodUnion")) {
        return this.unionTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
      }
      if (isZodType(zodSchema, "ZodDiscriminatedUnion")) {
        return this.discriminatedUnionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem, generateSchemaRef);
      }
      if (isZodType(zodSchema, "ZodIntersection")) {
        return this.intersectionTransformer.transform(zodSchema, isNullable, (_) => this.versionSpecifics.mapNullableOfArray(_, isNullable), mapItem);
      }
      if (isZodType(zodSchema, "ZodRecord")) {
        return this.recordTransformer.transform(zodSchema, (_) => this.versionSpecifics.mapNullableType(_, isNullable), mapItem);
      }
      if (isZodType(zodSchema, "ZodDate")) {
        return this.versionSpecifics.mapNullableType("string", isNullable);
      }
      const refId = Metadata.getRefId(zodSchema);
      throw new UnknownZodTypeError({
        currentSchema: zodSchema._def,
        schemaName: refId
      });
    }
  }

  class OpenAPIGenerator {
    constructor(definitions, versionSpecifics) {
      this.definitions = definitions;
      this.versionSpecifics = versionSpecifics;
      this.schemaRefs = {};
      this.paramRefs = {};
      this.pathRefs = {};
      this.rawComponents = [];
      this.openApiTransformer = new OpenApiTransformer(versionSpecifics);
      this.sortDefinitions();
    }
    generateDocumentData() {
      this.definitions.forEach((definition) => this.generateSingle(definition));
      return {
        components: this.buildComponents(),
        paths: this.pathRefs
      };
    }
    generateComponents() {
      this.definitions.forEach((definition) => this.generateSingle(definition));
      return {
        components: this.buildComponents()
      };
    }
    buildComponents() {
      var _a, _b;
      const rawComponents = {};
      this.rawComponents.forEach(({ componentType, name, component }) => {
        var _a2;
        (_a2 = rawComponents[componentType]) !== null && _a2 !== undefined || (rawComponents[componentType] = {});
        rawComponents[componentType][name] = component;
      });
      return Object.assign(Object.assign({}, rawComponents), { schemas: Object.assign(Object.assign({}, (_a = rawComponents.schemas) !== null && _a !== undefined ? _a : {}), this.schemaRefs), parameters: Object.assign(Object.assign({}, (_b = rawComponents.parameters) !== null && _b !== undefined ? _b : {}), this.paramRefs) });
    }
    sortDefinitions() {
      const generationOrder = [
        "schema",
        "parameter",
        "component",
        "route"
      ];
      this.definitions.sort((left, right) => {
        if (!("type" in left)) {
          if (!("type" in right)) {
            return 0;
          }
          return -1;
        }
        if (!("type" in right)) {
          return 1;
        }
        const leftIndex = generationOrder.findIndex((type) => type === left.type);
        const rightIndex = generationOrder.findIndex((type) => type === right.type);
        return leftIndex - rightIndex;
      });
    }
    generateSingle(definition) {
      if (!("type" in definition)) {
        this.generateSchemaWithRef(definition);
        return;
      }
      switch (definition.type) {
        case "parameter":
          this.generateParameterDefinition(definition.schema);
          return;
        case "schema":
          this.generateSchemaWithRef(definition.schema);
          return;
        case "route":
          this.generateSingleRoute(definition.route);
          return;
        case "component":
          this.rawComponents.push(definition);
          return;
      }
    }
    generateParameterDefinition(zodSchema) {
      const refId = Metadata.getRefId(zodSchema);
      const result = this.generateParameter(zodSchema);
      if (refId) {
        this.paramRefs[refId] = result;
      }
      return result;
    }
    getParameterRef(schemaMetadata, external) {
      var _a, _b, _c, _d, _e;
      const parameterMetadata = (_a = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata.metadata) === null || _a === undefined ? undefined : _a.param;
      const existingRef = ((_b = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata._internal) === null || _b === undefined ? undefined : _b.refId) ? this.paramRefs[(_c = schemaMetadata._internal) === null || _c === undefined ? undefined : _c.refId] : undefined;
      if (!((_d = schemaMetadata === null || schemaMetadata === undefined ? undefined : schemaMetadata._internal) === null || _d === undefined ? undefined : _d.refId) || !existingRef) {
        return;
      }
      if (parameterMetadata && existingRef.in !== parameterMetadata.in || (external === null || external === undefined ? undefined : external.in) && existingRef.in !== external.in) {
        throw new ConflictError(`Conflicting location for parameter ${existingRef.name}`, {
          key: "in",
          values: compact([
            existingRef.in,
            external === null || external === undefined ? undefined : external.in,
            parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.in
          ])
        });
      }
      if (parameterMetadata && existingRef.name !== parameterMetadata.name || (external === null || external === undefined ? undefined : external.name) && existingRef.name !== (external === null || external === undefined ? undefined : external.name)) {
        throw new ConflictError(`Conflicting names for parameter`, {
          key: "name",
          values: compact([
            existingRef.name,
            external === null || external === undefined ? undefined : external.name,
            parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.name
          ])
        });
      }
      return {
        $ref: `#/components/parameters/${(_e = schemaMetadata._internal) === null || _e === undefined ? undefined : _e.refId}`
      };
    }
    generateInlineParameters(zodSchema, location) {
      var _a;
      const metadata = Metadata.getMetadata(zodSchema);
      const parameterMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
      const referencedSchema = this.getParameterRef(metadata, { in: location });
      if (referencedSchema) {
        return [referencedSchema];
      }
      if (isZodType(zodSchema, "ZodObject")) {
        const propTypes = zodSchema._def.shape();
        const parameters = Object.entries(propTypes).map(([key, schema]) => {
          var _a2, _b;
          const innerMetadata = Metadata.getMetadata(schema);
          const referencedSchema2 = this.getParameterRef(innerMetadata, {
            in: location,
            name: key
          });
          if (referencedSchema2) {
            return referencedSchema2;
          }
          const innerParameterMetadata = (_a2 = innerMetadata === null || innerMetadata === undefined ? undefined : innerMetadata.metadata) === null || _a2 === undefined ? undefined : _a2.param;
          if ((innerParameterMetadata === null || innerParameterMetadata === undefined ? undefined : innerParameterMetadata.name) && innerParameterMetadata.name !== key) {
            throw new ConflictError(`Conflicting names for parameter`, {
              key: "name",
              values: [key, innerParameterMetadata.name]
            });
          }
          if ((innerParameterMetadata === null || innerParameterMetadata === undefined ? undefined : innerParameterMetadata.in) && innerParameterMetadata.in !== location) {
            throw new ConflictError(`Conflicting location for parameter ${(_b = innerParameterMetadata.name) !== null && _b !== undefined ? _b : key}`, {
              key: "in",
              values: [location, innerParameterMetadata.in]
            });
          }
          return this.generateParameter(schema.openapi({ param: { name: key, in: location } }));
        });
        return parameters;
      }
      if ((parameterMetadata === null || parameterMetadata === undefined ? undefined : parameterMetadata.in) && parameterMetadata.in !== location) {
        throw new ConflictError(`Conflicting location for parameter ${parameterMetadata.name}`, {
          key: "in",
          values: [location, parameterMetadata.in]
        });
      }
      return [
        this.generateParameter(zodSchema.openapi({ param: { in: location } }))
      ];
    }
    generateSimpleParameter(zodSchema) {
      var _a;
      const metadata = Metadata.getParamMetadata(zodSchema);
      const paramMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
      const required = !Metadata.isOptionalSchema(zodSchema) && !zodSchema.isNullable();
      const schema = this.generateSchemaWithRef(zodSchema);
      return Object.assign({
        schema,
        required
      }, paramMetadata ? Metadata.buildParameterMetadata(paramMetadata) : {});
    }
    generateParameter(zodSchema) {
      var _a;
      const metadata = Metadata.getMetadata(zodSchema);
      const paramMetadata = (_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.param;
      const paramName = paramMetadata === null || paramMetadata === undefined ? undefined : paramMetadata.name;
      const paramLocation = paramMetadata === null || paramMetadata === undefined ? undefined : paramMetadata.in;
      if (!paramName) {
        throw new MissingParameterDataError({ missingField: "name" });
      }
      if (!paramLocation) {
        throw new MissingParameterDataError({
          missingField: "in",
          paramName
        });
      }
      const baseParameter = this.generateSimpleParameter(zodSchema);
      return Object.assign(Object.assign({}, baseParameter), { in: paramLocation, name: paramName });
    }
    generateSchemaWithMetadata(zodSchema) {
      var _a;
      const innerSchema = Metadata.unwrapChained(zodSchema);
      const metadata = Metadata.getMetadata(zodSchema);
      const defaultValue = Metadata.getDefaultValue(zodSchema);
      const result = ((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.type) ? { type: metadata === null || metadata === undefined ? undefined : metadata.metadata.type } : this.toOpenAPISchema(innerSchema, zodSchema.isNullable(), defaultValue);
      return (metadata === null || metadata === undefined ? undefined : metadata.metadata) ? Metadata.applySchemaMetadata(result, metadata.metadata) : omitBy(result, isUndefined);
    }
    constructReferencedOpenAPISchema(zodSchema) {
      var _a;
      const metadata = Metadata.getMetadata(zodSchema);
      const innerSchema = Metadata.unwrapChained(zodSchema);
      const defaultValue = Metadata.getDefaultValue(zodSchema);
      const isNullableSchema = zodSchema.isNullable();
      if ((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) === null || _a === undefined ? undefined : _a.type) {
        return this.versionSpecifics.mapNullableType(metadata.metadata.type, isNullableSchema);
      }
      return this.toOpenAPISchema(innerSchema, isNullableSchema, defaultValue);
    }
    generateSimpleSchema(zodSchema) {
      var _a;
      const metadata = Metadata.getMetadata(zodSchema);
      const refId = Metadata.getRefId(zodSchema);
      if (!refId || !this.schemaRefs[refId]) {
        return this.generateSchemaWithMetadata(zodSchema);
      }
      const schemaRef = this.schemaRefs[refId];
      const referenceObject = {
        $ref: this.generateSchemaRef(refId)
      };
      const newMetadata = omitBy(Metadata.buildSchemaMetadata((_a = metadata === null || metadata === undefined ? undefined : metadata.metadata) !== null && _a !== undefined ? _a : {}), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));
      if (newMetadata.type) {
        return {
          allOf: [referenceObject, newMetadata]
        };
      }
      const newSchemaMetadata = omitBy(this.constructReferencedOpenAPISchema(zodSchema), (value, key) => value === undefined || objectEquals(value, schemaRef[key]));
      const appliedMetadata = Metadata.applySchemaMetadata(newSchemaMetadata, newMetadata);
      if (Object.keys(appliedMetadata).length > 0) {
        return {
          allOf: [referenceObject, appliedMetadata]
        };
      }
      return referenceObject;
    }
    generateSchemaWithRef(zodSchema) {
      const refId = Metadata.getRefId(zodSchema);
      const result = this.generateSimpleSchema(zodSchema);
      if (refId && this.schemaRefs[refId] === undefined) {
        this.schemaRefs[refId] = result;
        return { $ref: this.generateSchemaRef(refId) };
      }
      return result;
    }
    generateSchemaRef(refId) {
      return `#/components/schemas/${refId}`;
    }
    getRequestBody(requestBody) {
      if (!requestBody) {
        return;
      }
      const { content } = requestBody, rest = __rest(requestBody, ["content"]);
      const requestBodyContent = this.getBodyContent(content);
      return Object.assign(Object.assign({}, rest), { content: requestBodyContent });
    }
    getParameters(request) {
      if (!request) {
        return [];
      }
      const { headers } = request;
      const query = this.cleanParameter(request.query);
      const params = this.cleanParameter(request.params);
      const cookies = this.cleanParameter(request.cookies);
      const queryParameters = enhanceMissingParametersError(() => query ? this.generateInlineParameters(query, "query") : [], { location: "query" });
      const pathParameters = enhanceMissingParametersError(() => params ? this.generateInlineParameters(params, "path") : [], { location: "path" });
      const cookieParameters = enhanceMissingParametersError(() => cookies ? this.generateInlineParameters(cookies, "cookie") : [], { location: "cookie" });
      const headerParameters = enhanceMissingParametersError(() => {
        if (Array.isArray(headers)) {
          return headers.flatMap((header) => this.generateInlineParameters(header, "header"));
        }
        const cleanHeaders = this.cleanParameter(headers);
        return cleanHeaders ? this.generateInlineParameters(cleanHeaders, "header") : [];
      }, { location: "header" });
      return [
        ...pathParameters,
        ...queryParameters,
        ...headerParameters,
        ...cookieParameters
      ];
    }
    cleanParameter(schema) {
      if (!schema) {
        return;
      }
      return isZodType(schema, "ZodEffects") ? this.cleanParameter(schema._def.schema) : schema;
    }
    generatePath(route) {
      const { method, path, request, responses } = route, pathItemConfig = __rest(route, ["method", "path", "request", "responses"]);
      const generatedResponses = mapValues(responses, (response) => {
        return this.getResponse(response);
      });
      const parameters = enhanceMissingParametersError(() => this.getParameters(request), { route: `${method} ${path}` });
      const requestBody = this.getRequestBody(request === null || request === undefined ? undefined : request.body);
      const routeDoc = {
        [method]: Object.assign(Object.assign(Object.assign(Object.assign({}, pathItemConfig), parameters.length > 0 ? {
          parameters: [...pathItemConfig.parameters || [], ...parameters]
        } : {}), requestBody ? { requestBody } : {}), { responses: generatedResponses })
      };
      return routeDoc;
    }
    generateSingleRoute(route) {
      const routeDoc = this.generatePath(route);
      this.pathRefs[route.path] = Object.assign(Object.assign({}, this.pathRefs[route.path]), routeDoc);
      return routeDoc;
    }
    getResponse(response) {
      if (this.isReferenceObject(response)) {
        return response;
      }
      const { content, headers } = response, rest = __rest(response, ["content", "headers"]);
      const responseContent = content ? { content: this.getBodyContent(content) } : {};
      if (!headers) {
        return Object.assign(Object.assign({}, rest), responseContent);
      }
      const responseHeaders = isZodType(headers, "ZodObject") ? this.getResponseHeaders(headers) : headers;
      return Object.assign(Object.assign(Object.assign({}, rest), { headers: responseHeaders }), responseContent);
    }
    isReferenceObject(schema) {
      return "$ref" in schema;
    }
    getResponseHeaders(headers) {
      const schemaShape = headers._def.shape();
      const responseHeaders = mapValues(schemaShape, (_) => this.generateSimpleParameter(_));
      return responseHeaders;
    }
    getBodyContent(content) {
      return mapValues(content, (config) => {
        if (!config || !isAnyZodType(config.schema)) {
          return config;
        }
        const { schema: configSchema } = config, rest = __rest(config, ["schema"]);
        const schema = this.generateSchemaWithRef(configSchema);
        return Object.assign({ schema }, rest);
      });
    }
    toOpenAPISchema(zodSchema, isNullable, defaultValue) {
      return this.openApiTransformer.transform(zodSchema, isNullable, (_) => this.generateSchemaWithRef(_), (_) => this.generateSchemaRef(_), defaultValue);
    }
  }

  class OpenApiGeneratorV30Specifics {
    get nullType() {
      return { nullable: true };
    }
    mapNullableOfArray(objects, isNullable) {
      if (isNullable) {
        return [...objects, this.nullType];
      }
      return objects;
    }
    mapNullableType(type, isNullable) {
      return Object.assign(Object.assign({}, type ? { type } : undefined), isNullable ? this.nullType : undefined);
    }
    mapTupleItems(schemas) {
      const uniqueSchemas = uniq(schemas);
      return {
        items: uniqueSchemas.length === 1 ? uniqueSchemas[0] : { anyOf: uniqueSchemas },
        minItems: schemas.length,
        maxItems: schemas.length
      };
    }
    getNumberChecks(checks) {
      return Object.assign({}, ...checks.map((check) => {
        switch (check.kind) {
          case "min":
            return check.inclusive ? { minimum: Number(check.value) } : { minimum: Number(check.value), exclusiveMinimum: true };
          case "max":
            return check.inclusive ? { maximum: Number(check.value) } : { maximum: Number(check.value), exclusiveMaximum: true };
          default:
            return {};
        }
      }));
    }
  }

  class OpenApiGeneratorV3 {
    constructor(definitions) {
      const specifics = new OpenApiGeneratorV30Specifics;
      this.generator = new OpenAPIGenerator(definitions, specifics);
    }
    generateDocument(config) {
      const baseData = this.generator.generateDocumentData();
      return Object.assign(Object.assign({}, config), baseData);
    }
    generateComponents() {
      return this.generator.generateComponents();
    }
  }

  class OpenApiGeneratorV31Specifics {
    get nullType() {
      return { type: "null" };
    }
    mapNullableOfArray(objects, isNullable) {
      if (isNullable) {
        return [...objects, this.nullType];
      }
      return objects;
    }
    mapNullableType(type, isNullable) {
      if (!type) {
        return {};
      }
      if (isNullable) {
        return {
          type: Array.isArray(type) ? [...type, "null"] : [type, "null"]
        };
      }
      return {
        type
      };
    }
    mapTupleItems(schemas) {
      return {
        prefixItems: schemas
      };
    }
    getNumberChecks(checks) {
      return Object.assign({}, ...checks.map((check) => {
        switch (check.kind) {
          case "min":
            return check.inclusive ? { minimum: Number(check.value) } : { exclusiveMinimum: Number(check.value) };
          case "max":
            return check.inclusive ? { maximum: Number(check.value) } : { exclusiveMaximum: Number(check.value) };
          default:
            return {};
        }
      }));
    }
  }
  function isWebhookDefinition(definition) {
    return "type" in definition && definition.type === "webhook";
  }

  class OpenApiGeneratorV31 {
    constructor(definitions) {
      this.definitions = definitions;
      this.webhookRefs = {};
      const specifics = new OpenApiGeneratorV31Specifics;
      this.generator = new OpenAPIGenerator(this.definitions, specifics);
    }
    generateDocument(config) {
      const baseDocument = this.generator.generateDocumentData();
      this.definitions.filter(isWebhookDefinition).forEach((definition) => this.generateSingleWebhook(definition.webhook));
      return Object.assign(Object.assign(Object.assign({}, config), baseDocument), { webhooks: this.webhookRefs });
    }
    generateComponents() {
      return this.generator.generateComponents();
    }
    generateSingleWebhook(route) {
      const routeDoc = this.generator.generatePath(route);
      this.webhookRefs[route.path] = Object.assign(Object.assign({}, this.webhookRefs[route.path]), routeDoc);
      return routeDoc;
    }
  }
  exports2.OpenAPIRegistry = OpenAPIRegistry;
  exports2.OpenApiGeneratorV3 = OpenApiGeneratorV3;
  exports2.OpenApiGeneratorV31 = OpenApiGeneratorV31;
  exports2.extendZodWithOpenApi = extendZodWithOpenApi;
  exports2.getOpenApiMetadata = getOpenApiMetadata;
});

// node_modules/cookie/dist/index.js
var require_dist2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.parse = parse3;
  exports2.serialize = serialize2;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C = function() {};
    C.prototype = Object.create(null);
    return C;
  })();
  function parse3(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize2(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports2) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (;nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (;nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (;mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {}
    e = e << mLen | m;
    eLen += mLen;
    for (;eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {}
    buffer[offset + i - d] |= s * 128;
  };
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse4(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i2 = 0;i2 < namespace.length; i2++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i2);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
          if (match2 === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match2 = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self, args);
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error2) {}
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
    } catch (error2) {}
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {}
  }
  module2.exports = require_common()(exports2);
  var { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  module2.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  var os = require("os");
  var tty = require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== undefined) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util3 = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.destroy = util3.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {}
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i2 = 0;i2 < keys.length; i2++) {
      debug.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
    }
  }
  module2.exports = require_common()(exports2);
  var { formatters } = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util3.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isFunction.js
var require_isFunction = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isFunction = undefined;
  function isFunction(value) {
    return typeof value === "function";
  }
  exports2.isFunction = isFunction;
});

// node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
var require_createErrorClass = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createErrorClass = undefined;
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  exports2.createErrorClass = createErrorClass;
});

// node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UnsubscriptionError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors2) {
      _super(this);
      this.message = errors2 ? errors2.length + ` errors occurred during unsubscription:
` + errors2.map(function(err2, i2) {
        return i2 + 1 + ") " + err2.toString();
      }).join(`
  `) : "";
      this.name = "UnsubscriptionError";
      this.errors = errors2;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
var require_arrRemove = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.arrRemove = undefined;
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }
  exports2.arrRemove = arrRemove;
});

// node_modules/rxjs/dist/cjs/internal/Subscription.js
var require_Subscription = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isSubscription = exports2.EMPTY_SUBSCRIPTION = exports2.Subscription = undefined;
  var isFunction_1 = require_isFunction();
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  var arrRemove_1 = require_arrRemove();
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a2, e_2, _b2;
      var errors2;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next();!_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                  _a2.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction_1.isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors2 = e instanceof UnsubscriptionError_1.UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next();!_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err2) {
                errors2 = errors2 !== null && errors2 !== undefined ? errors2 : [];
                if (err2 instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors2 = __spreadArray(__spreadArray([], __read(errors2)), __read(err2.errors));
                } else {
                  errors2.push(err2);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return))
                _b2.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors2) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors2);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a2;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== undefined ? _a2 : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove_1.arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2;
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  exports2.Subscription = Subscription;
  exports2.EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
  }
  exports2.isSubscription = isSubscription;
  function execFinalizer(finalizer) {
    if (isFunction_1.isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/config.js
var require_config = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.config = undefined;
  exports2.config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
var require_timeoutProvider = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timeoutProvider = undefined;
  exports2.timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports2.timeoutProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setTimeout.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = exports2.timeoutProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
var require_reportUnhandledError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.reportUnhandledError = undefined;
  var config_1 = require_config();
  var timeoutProvider_1 = require_timeoutProvider();
  function reportUnhandledError(err2) {
    timeoutProvider_1.timeoutProvider.setTimeout(function() {
      var onUnhandledError = config_1.config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err2);
      } else {
        throw err2;
      }
    });
  }
  exports2.reportUnhandledError = reportUnhandledError;
});

// node_modules/rxjs/dist/cjs/internal/util/noop.js
var require_noop = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.noop = undefined;
  function noop() {}
  exports2.noop = noop;
});

// node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
var require_NotificationFactories = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createNotification = exports2.nextNotification = exports2.errorNotification = exports2.COMPLETE_NOTIFICATION = undefined;
  exports2.COMPLETE_NOTIFICATION = function() {
    return createNotification("C", undefined, undefined);
  }();
  function errorNotification(error2) {
    return createNotification("E", undefined, error2);
  }
  exports2.errorNotification = errorNotification;
  function nextNotification(value) {
    return createNotification("N", value, undefined);
  }
  exports2.nextNotification = nextNotification;
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }
  exports2.createNotification = createNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/errorContext.js
var require_errorContext = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.captureError = exports2.errorContext = undefined;
  var config_1 = require_config();
  var context = null;
  function errorContext(cb) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a2 = context, errorThrown = _a2.errorThrown, error2 = _a2.error;
        context = null;
        if (errorThrown) {
          throw error2;
        }
      }
    } else {
      cb();
    }
  }
  exports2.errorContext = errorContext;
  function captureError(err2) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err2;
    }
  }
  exports2.captureError = captureError;
});

// node_modules/rxjs/dist/cjs/internal/Subscriber.js
var require_Subscriber = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.EMPTY_OBSERVER = exports2.SafeSubscriber = exports2.Subscriber = undefined;
  var isFunction_1 = require_isFunction();
  var Subscription_1 = require_Subscription();
  var config_1 = require_config();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var noop_1 = require_noop();
  var NotificationFactories_1 = require_NotificationFactories();
  var timeoutProvider_1 = require_timeoutProvider();
  var errorContext_1 = require_errorContext();
  var Subscriber = function(_super) {
    __extends(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (Subscription_1.isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = exports2.EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error2, complete) {
      return new SafeSubscriber(next, error2, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err2) {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.errorNotification(err2), this);
      } else {
        this.isStopped = true;
        this._error(err2);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err2) {
      try {
        this.destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription_1.Subscription);
  exports2.Subscriber = Subscriber;
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err2) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err2);
        } catch (error2) {
          handleUnhandledError(error2);
        }
      } else {
        handleUnhandledError(err2);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error2) {
          handleUnhandledError(error2);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error2, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== undefined ? observerOrNext : undefined,
          error: error2 !== null && error2 !== undefined ? error2 : undefined,
          complete: complete !== null && complete !== undefined ? complete : undefined
        };
      } else {
        var context_1;
        if (_this && config_1.config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  exports2.SafeSubscriber = SafeSubscriber;
  function handleUnhandledError(error2) {
    if (config_1.config.useDeprecatedSynchronousErrorHandling) {
      errorContext_1.captureError(error2);
    } else {
      reportUnhandledError_1.reportUnhandledError(error2);
    }
  }
  function defaultErrorHandler(err2) {
    throw err2;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config_1.config.onStoppedNotification;
    onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  exports2.EMPTY_OBSERVER = {
    closed: true,
    next: noop_1.noop,
    error: defaultErrorHandler,
    complete: noop_1.noop
  };
});

// node_modules/rxjs/dist/cjs/internal/symbol/observable.js
var require_observable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.observable = undefined;
  exports2.observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
});

// node_modules/rxjs/dist/cjs/internal/util/identity.js
var require_identity = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.identity = undefined;
  function identity(x2) {
    return x2;
  }
  exports2.identity = identity;
});

// node_modules/rxjs/dist/cjs/internal/util/pipe.js
var require_pipe = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pipeFromArray = exports2.pipe = undefined;
  var identity_1 = require_identity();
  function pipe() {
    var fns = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
  }
  exports2.pipe = pipe;
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity_1.identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }
  exports2.pipeFromArray = pipeFromArray;
});

// node_modules/rxjs/dist/cjs/internal/Observable.js
var require_Observable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Observable = undefined;
  var Subscriber_1 = require_Subscriber();
  var Subscription_1 = require_Subscription();
  var observable_1 = require_observable();
  var pipe_1 = require_pipe();
  var config_1 = require_config();
  var isFunction_1 = require_isFunction();
  var errorContext_1 = require_errorContext();
  var Observable = function() {
    function Observable2(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable2.prototype.lift = function(operator) {
      var observable = new Observable2;
      observable.source = this;
      observable.operator = operator;
      return observable;
    };
    Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
      errorContext_1.errorContext(function() {
        var _a2 = _this, operator = _a2.operator, source = _a2.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable2.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err2) {
        sink.error(err2);
      }
    };
    Observable2.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new Subscriber_1.SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err2) {
              reject(err2);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable2.prototype._subscribe = function(subscriber) {
      var _a2;
      return (_a2 = this.source) === null || _a2 === undefined ? undefined : _a2.subscribe(subscriber);
    };
    Observable2.prototype[observable_1.observable] = function() {
      return this;
    };
    Observable2.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipe_1.pipeFromArray(operations)(this);
    };
    Observable2.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x2) {
          return value = x2;
        }, function(err2) {
          return reject(err2);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable2.create = function(subscribe) {
      return new Observable2(subscribe);
    };
    return Observable2;
  }();
  exports2.Observable = Observable;
  function getPromiseCtor(promiseCtor) {
    var _a2;
    return (_a2 = promiseCtor !== null && promiseCtor !== undefined ? promiseCtor : config_1.config.Promise) !== null && _a2 !== undefined ? _a2 : Promise;
  }
  function isObserver(value) {
    return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
  }
});

// node_modules/rxjs/dist/cjs/internal/util/lift.js
var require_lift = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.operate = exports2.hasLift = undefined;
  var isFunction_1 = require_isFunction();
  function hasLift(source) {
    return isFunction_1.isFunction(source === null || source === undefined ? undefined : source.lift);
  }
  exports2.hasLift = hasLift;
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err2) {
            this.error(err2);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  exports2.operate = operate;
});

// node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
var require_OperatorSubscriber = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.OperatorSubscriber = exports2.createOperatorSubscriber = undefined;
  var Subscriber_1 = require_Subscriber();
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  exports2.createOperatorSubscriber = createOperatorSubscriber;
  var OperatorSubscriber = function(_super) {
    __extends(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err2) {
          destination.error(err2);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err2) {
        try {
          onError(err2);
        } catch (err3) {
          destination.error(err3);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a2;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === undefined || _a2.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber_1.Subscriber);
  exports2.OperatorSubscriber = OperatorSubscriber;
});

// node_modules/rxjs/dist/cjs/internal/operators/refCount.js
var require_refCount = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.refCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function refCount() {
    return lift_1.operate(function(source, subscriber) {
      var connection = null;
      source._refCount++;
      var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, undefined, function() {
        if (!source || source._refCount <= 0 || 0 < --source._refCount) {
          connection = null;
          return;
        }
        var sharedConnection = source._connection;
        var conn = connection;
        connection = null;
        if (sharedConnection && (!conn || sharedConnection === conn)) {
          sharedConnection.unsubscribe();
        }
        subscriber.unsubscribe();
      });
      source.subscribe(refCounter);
      if (!refCounter.closed) {
        connection = source.connect();
      }
    });
  }
  exports2.refCount = refCount;
});

// node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
var require_ConnectableObservable = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ConnectableObservable = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var refCount_1 = require_refCount();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  var ConnectableObservable = function(_super) {
    __extends(ConnectableObservable2, _super);
    function ConnectableObservable2(source, subjectFactory) {
      var _this = _super.call(this) || this;
      _this.source = source;
      _this.subjectFactory = subjectFactory;
      _this._subject = null;
      _this._refCount = 0;
      _this._connection = null;
      if (lift_1.hasLift(source)) {
        _this.lift = source.lift;
      }
      return _this;
    }
    ConnectableObservable2.prototype._subscribe = function(subscriber) {
      return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable2.prototype.getSubject = function() {
      var subject = this._subject;
      if (!subject || subject.isStopped) {
        this._subject = this.subjectFactory();
      }
      return this._subject;
    };
    ConnectableObservable2.prototype._teardown = function() {
      this._refCount = 0;
      var _connection = this._connection;
      this._subject = this._connection = null;
      _connection === null || _connection === undefined || _connection.unsubscribe();
    };
    ConnectableObservable2.prototype.connect = function() {
      var _this = this;
      var connection = this._connection;
      if (!connection) {
        connection = this._connection = new Subscription_1.Subscription;
        var subject_1 = this.getSubject();
        connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, undefined, function() {
          _this._teardown();
          subject_1.complete();
        }, function(err2) {
          _this._teardown();
          subject_1.error(err2);
        }, function() {
          return _this._teardown();
        })));
        if (connection.closed) {
          this._connection = null;
          connection = Subscription_1.Subscription.EMPTY;
        }
      }
      return connection;
    };
    ConnectableObservable2.prototype.refCount = function() {
      return refCount_1.refCount()(this);
    };
    return ConnectableObservable2;
  }(Observable_1.Observable);
  exports2.ConnectableObservable = ConnectableObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
var require_performanceTimestampProvider = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.performanceTimestampProvider = undefined;
  exports2.performanceTimestampProvider = {
    now: function() {
      return (exports2.performanceTimestampProvider.delegate || performance).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
var require_animationFrameProvider = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.animationFrameProvider = undefined;
  var Subscription_1 = require_Subscription();
  exports2.animationFrameProvider = {
    schedule: function(callback) {
      var request = requestAnimationFrame;
      var cancel = cancelAnimationFrame;
      var delegate = exports2.animationFrameProvider.delegate;
      if (delegate) {
        request = delegate.requestAnimationFrame;
        cancel = delegate.cancelAnimationFrame;
      }
      var handle = request(function(timestamp) {
        cancel = undefined;
        callback(timestamp);
      });
      return new Subscription_1.Subscription(function() {
        return cancel === null || cancel === undefined ? undefined : cancel(handle);
      });
    },
    requestAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports2.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.requestAnimationFrame) || requestAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    cancelAnimationFrame: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports2.animationFrameProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(undefined, __spreadArray([], __read(args)));
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
var require_animationFrames = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.animationFrames = undefined;
  var Observable_1 = require_Observable();
  var performanceTimestampProvider_1 = require_performanceTimestampProvider();
  var animationFrameProvider_1 = require_animationFrameProvider();
  function animationFrames(timestampProvider) {
    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
  }
  exports2.animationFrames = animationFrames;
  function animationFramesFactory(timestampProvider) {
    return new Observable_1.Observable(function(subscriber) {
      var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
      var start = provider.now();
      var id = 0;
      var run = function() {
        if (!subscriber.closed) {
          id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
            id = 0;
            var now = provider.now();
            subscriber.next({
              timestamp: timestampProvider ? now : timestamp,
              elapsed: now - start
            });
            run();
          });
        }
      };
      run();
      return function() {
        if (id) {
          animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        }
      };
    });
  }
  var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
});

// node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ObjectUnsubscribedError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/Subject.js
var require_Subject = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AnonymousSubject = exports2.Subject = undefined;
  var Observable_1 = require_Observable();
  var Subscription_1 = require_Subscription();
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  var arrRemove_1 = require_arrRemove();
  var errorContext_1 = require_errorContext();
  var Subject = function(_super) {
    __extends(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext_1.errorContext(function() {
        var e_1, _a2;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b2 = __values(_this.currentObservers), _c = _b2.next();!_c.done; _c = _b2.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b2.return))
                _a2.call(_b2);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err2) {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err2;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err2);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext_1.errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === undefined ? undefined : _a2.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
      if (hasError || isStopped) {
        return Subscription_1.EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription_1.Subscription(function() {
        _this.currentObservers = null;
        arrRemove_1.arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable = new Observable_1.Observable;
      observable.source = this;
      return observable;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable_1.Observable);
  exports2.Subject = Subject;
  var AnonymousSubject = function(_super) {
    __extends(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.next) === null || _b2 === undefined || _b2.call(_a2, value);
    };
    AnonymousSubject2.prototype.error = function(err2) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.error) === null || _b2 === undefined || _b2.call(_a2, err2);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === undefined ? undefined : _a2.complete) === null || _b2 === undefined || _b2.call(_a2);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a2, _b2;
      return (_b2 = (_a2 = this.source) === null || _a2 === undefined ? undefined : _a2.subscribe(subscriber)) !== null && _b2 !== undefined ? _b2 : Subscription_1.EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);
  exports2.AnonymousSubject = AnonymousSubject;
});

// node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
var require_BehaviorSubject = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.BehaviorSubject = undefined;
  var Subject_1 = require_Subject();
  var BehaviorSubject = function(_super) {
    __extends(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject_1.Subject);
  exports2.BehaviorSubject = BehaviorSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
var require_dateTimestampProvider = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.dateTimestampProvider = undefined;
  exports2.dateTimestampProvider = {
    now: function() {
      return (exports2.dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
var require_ReplaySubject = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ReplaySubject = undefined;
  var Subject_1 = require_Subject();
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var ReplaySubject = function(_super) {
    __extends(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === undefined) {
        _bufferSize = Infinity;
      }
      if (_windowTime === undefined) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === undefined) {
        _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a2 = this, isStopped = _a2.isStopped, _buffer2 = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
      if (!isStopped) {
        _buffer2.push(value);
        !_infiniteTimeWindow && _buffer2.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer2 = _a2._buffer;
      var copy = _buffer2.slice();
      for (var i2 = 0;i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i2]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer2 = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer2.length && _buffer2.splice(0, _buffer2.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last = 0;
        for (var i2 = 1;i2 < _buffer2.length && _buffer2[i2] <= now; i2 += 2) {
          last = i2;
        }
        last && _buffer2.splice(0, last + 1);
      }
    };
    return ReplaySubject2;
  }(Subject_1.Subject);
  exports2.ReplaySubject = ReplaySubject;
});

// node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
var require_AsyncSubject = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsyncSubject = undefined;
  var Subject_1 = require_Subject();
  var AsyncSubject = function(_super) {
    __extends(AsyncSubject2, _super);
    function AsyncSubject2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._value = null;
      _this._hasValue = false;
      _this._isComplete = false;
      return _this;
    }
    AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, _hasValue = _a2._hasValue, _value = _a2._value, thrownError = _a2.thrownError, isStopped = _a2.isStopped, _isComplete = _a2._isComplete;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped || _isComplete) {
        _hasValue && subscriber.next(_value);
        subscriber.complete();
      }
    };
    AsyncSubject2.prototype.next = function(value) {
      if (!this.isStopped) {
        this._value = value;
        this._hasValue = true;
      }
    };
    AsyncSubject2.prototype.complete = function() {
      var _a2 = this, _hasValue = _a2._hasValue, _value = _a2._value, _isComplete = _a2._isComplete;
      if (!_isComplete) {
        this._isComplete = true;
        _hasValue && _super.prototype.next.call(this, _value);
        _super.prototype.complete.call(this);
      }
    };
    return AsyncSubject2;
  }(Subject_1.Subject);
  exports2.AsyncSubject = AsyncSubject;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
var require_Action = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Action = undefined;
  var Subscription_1 = require_Subscription();
  var Action = function(_super) {
    __extends(Action2, _super);
    function Action2(scheduler, work) {
      return _super.call(this) || this;
    }
    Action2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return this;
    };
    return Action2;
  }(Subscription_1.Subscription);
  exports2.Action = Action;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
var require_intervalProvider = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.intervalProvider = undefined;
  exports2.intervalProvider = {
    setInterval: function(handler, timeout) {
      var args = [];
      for (var _i = 2;_i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = exports2.intervalProvider.delegate;
      if (delegate === null || delegate === undefined ? undefined : delegate.setInterval) {
        return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout], __read(args)));
      }
      return setInterval.apply(undefined, __spreadArray([handler, timeout], __read(args)));
    },
    clearInterval: function(handle) {
      var delegate = exports2.intervalProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
var require_AsyncAction = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsyncAction = undefined;
  var Action_1 = require_Action();
  var intervalProvider_1 = require_intervalProvider();
  var arrRemove_1 = require_arrRemove();
  var AsyncAction = function(_super) {
    __extends(AsyncAction2, _super);
    function AsyncAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }
    AsyncAction2.prototype.schedule = function(state, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (this.closed) {
        return this;
      }
      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }
      this.pending = true;
      this.delay = delay;
      this.id = (_a2 = this.id) !== null && _a2 !== undefined ? _a2 : this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };
    AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }
      if (id != null) {
        intervalProvider_1.intervalProvider.clearInterval(id);
      }
      return;
    };
    AsyncAction2.prototype.execute = function(state, delay) {
      if (this.closed) {
        return new Error("executing a cancelled action");
      }
      this.pending = false;
      var error2 = this._execute(state, delay);
      if (error2) {
        return error2;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };
    AsyncAction2.prototype._execute = function(state, _delay) {
      var errored = false;
      var errorValue;
      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error("Scheduled action threw falsy error");
      }
      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };
    AsyncAction2.prototype.unsubscribe = function() {
      if (!this.closed) {
        var _a2 = this, id = _a2.id, scheduler = _a2.scheduler;
        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove_1.arrRemove(actions, this);
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
        _super.prototype.unsubscribe.call(this);
      }
    };
    return AsyncAction2;
  }(Action_1.Action);
  exports2.AsyncAction = AsyncAction;
});

// node_modules/rxjs/dist/cjs/internal/util/Immediate.js
var require_Immediate = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TestTools = exports2.Immediate = undefined;
  var nextHandle = 1;
  var resolved;
  var activeHandles = {};
  function findAndClearHandle(handle) {
    if (handle in activeHandles) {
      delete activeHandles[handle];
      return true;
    }
    return false;
  }
  exports2.Immediate = {
    setImmediate: function(cb) {
      var handle = nextHandle++;
      activeHandles[handle] = true;
      if (!resolved) {
        resolved = Promise.resolve();
      }
      resolved.then(function() {
        return findAndClearHandle(handle) && cb();
      });
      return handle;
    },
    clearImmediate: function(handle) {
      findAndClearHandle(handle);
    }
  };
  exports2.TestTools = {
    pending: function() {
      return Object.keys(activeHandles).length;
    }
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
var require_immediateProvider = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.immediateProvider = undefined;
  var Immediate_1 = require_Immediate();
  var setImmediate2 = Immediate_1.Immediate.setImmediate;
  var clearImmediate2 = Immediate_1.Immediate.clearImmediate;
  exports2.immediateProvider = {
    setImmediate: function() {
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var delegate = exports2.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.setImmediate) || setImmediate2).apply(undefined, __spreadArray([], __read(args)));
    },
    clearImmediate: function(handle) {
      var delegate = exports2.immediateProvider.delegate;
      return ((delegate === null || delegate === undefined ? undefined : delegate.clearImmediate) || clearImmediate2)(handle);
    },
    delegate: undefined
  };
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
var require_AsapAction = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsapAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var immediateProvider_1 = require_immediateProvider();
  var AsapAction = function(_super) {
    __extends(AsapAction2, _super);
    function AsapAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));
    };
    AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && ((_a2 = actions[actions.length - 1]) === null || _a2 === undefined ? undefined : _a2.id) !== id) {
        immediateProvider_1.immediateProvider.clearImmediate(id);
        if (scheduler._scheduled === id) {
          scheduler._scheduled = undefined;
        }
      }
      return;
    };
    return AsapAction2;
  }(AsyncAction_1.AsyncAction);
  exports2.AsapAction = AsapAction;
});

// node_modules/rxjs/dist/cjs/internal/Scheduler.js
var require_Scheduler = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Scheduler = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var Scheduler = function() {
    function Scheduler2(schedulerActionCtor, now) {
      if (now === undefined) {
        now = Scheduler2.now;
      }
      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }
    Scheduler2.prototype.schedule = function(work, delay, state) {
      if (delay === undefined) {
        delay = 0;
      }
      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
    return Scheduler2;
  }();
  exports2.Scheduler = Scheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
var require_AsyncScheduler = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsyncScheduler = undefined;
  var Scheduler_1 = require_Scheduler();
  var AsyncScheduler = function(_super) {
    __extends(AsyncScheduler2, _super);
    function AsyncScheduler2(SchedulerAction, now) {
      if (now === undefined) {
        now = Scheduler_1.Scheduler.now;
      }
      var _this = _super.call(this, SchedulerAction, now) || this;
      _this.actions = [];
      _this._active = false;
      return _this;
    }
    AsyncScheduler2.prototype.flush = function(action) {
      var actions = this.actions;
      if (this._active) {
        actions.push(action);
        return;
      }
      var error2;
      this._active = true;
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());
      this._active = false;
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsyncScheduler2;
  }(Scheduler_1.Scheduler);
  exports2.AsyncScheduler = AsyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
var require_AsapScheduler = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsapScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AsapScheduler = function(_super) {
    __extends(AsapScheduler2, _super);
    function AsapScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId = this._scheduled;
      this._scheduled = undefined;
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AsapScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports2.AsapScheduler = AsapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
var require_asap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.asap = exports2.asapScheduler = undefined;
  var AsapAction_1 = require_AsapAction();
  var AsapScheduler_1 = require_AsapScheduler();
  exports2.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
  exports2.asap = exports2.asapScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/async.js
var require_async = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.async = exports2.asyncScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var AsyncScheduler_1 = require_AsyncScheduler();
  exports2.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
  exports2.async = exports2.asyncScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
var require_QueueAction = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.QueueAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var QueueAction = function(_super) {
    __extends(QueueAction2, _super);
    function QueueAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    QueueAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }
      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };
    QueueAction2.prototype.execute = function(state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };
    QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.flush(this);
      return 0;
    };
    return QueueAction2;
  }(AsyncAction_1.AsyncAction);
  exports2.QueueAction = QueueAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
var require_QueueScheduler = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.QueueScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var QueueScheduler = function(_super) {
    __extends(QueueScheduler2, _super);
    function QueueScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports2.QueueScheduler = QueueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
var require_queue = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.queue = exports2.queueScheduler = undefined;
  var QueueAction_1 = require_QueueAction();
  var QueueScheduler_1 = require_QueueScheduler();
  exports2.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
  exports2.queue = exports2.queueScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
var require_AnimationFrameAction = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AnimationFrameAction = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var animationFrameProvider_1 = require_animationFrameProvider();
  var AnimationFrameAction = function(_super) {
    __extends(AnimationFrameAction2, _super);
    function AnimationFrameAction2(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }
    AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (delay !== null && delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }
      scheduler.actions.push(this);
      return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
        return scheduler.flush(undefined);
      }));
    };
    AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      var _a2;
      if (delay === undefined) {
        delay = 0;
      }
      if (delay != null ? delay > 0 : this.delay > 0) {
        return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
      }
      var actions = scheduler.actions;
      if (id != null && id === scheduler._scheduled && ((_a2 = actions[actions.length - 1]) === null || _a2 === undefined ? undefined : _a2.id) !== id) {
        animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
        scheduler._scheduled = undefined;
      }
      return;
    };
    return AnimationFrameAction2;
  }(AsyncAction_1.AsyncAction);
  exports2.AnimationFrameAction = AnimationFrameAction;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
var require_AnimationFrameScheduler = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AnimationFrameScheduler = undefined;
  var AsyncScheduler_1 = require_AsyncScheduler();
  var AnimationFrameScheduler = function(_super) {
    __extends(AnimationFrameScheduler2, _super);
    function AnimationFrameScheduler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler2.prototype.flush = function(action) {
      this._active = true;
      var flushId;
      if (action) {
        flushId = action.id;
      } else {
        flushId = this._scheduled;
        this._scheduled = undefined;
      }
      var actions = this.actions;
      var error2;
      action = action || actions.shift();
      do {
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      } while ((action = actions[0]) && action.id === flushId && actions.shift());
      this._active = false;
      if (error2) {
        while ((action = actions[0]) && action.id === flushId && actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    return AnimationFrameScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports2.AnimationFrameScheduler = AnimationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
var require_animationFrame = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.animationFrame = exports2.animationFrameScheduler = undefined;
  var AnimationFrameAction_1 = require_AnimationFrameAction();
  var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
  exports2.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
  exports2.animationFrame = exports2.animationFrameScheduler;
});

// node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
var require_VirtualTimeScheduler = __commonJS((exports2) => {
  var __extends = exports2 && exports2.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.VirtualAction = exports2.VirtualTimeScheduler = undefined;
  var AsyncAction_1 = require_AsyncAction();
  var Subscription_1 = require_Subscription();
  var AsyncScheduler_1 = require_AsyncScheduler();
  var VirtualTimeScheduler = function(_super) {
    __extends(VirtualTimeScheduler2, _super);
    function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
      if (schedulerActionCtor === undefined) {
        schedulerActionCtor = VirtualAction;
      }
      if (maxFrames === undefined) {
        maxFrames = Infinity;
      }
      var _this = _super.call(this, schedulerActionCtor, function() {
        return _this.frame;
      }) || this;
      _this.maxFrames = maxFrames;
      _this.frame = 0;
      _this.index = -1;
      return _this;
    }
    VirtualTimeScheduler2.prototype.flush = function() {
      var _a2 = this, actions = _a2.actions, maxFrames = _a2.maxFrames;
      var error2;
      var action;
      while ((action = actions[0]) && action.delay <= maxFrames) {
        actions.shift();
        this.frame = action.delay;
        if (error2 = action.execute(action.state, action.delay)) {
          break;
        }
      }
      if (error2) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }
        throw error2;
      }
    };
    VirtualTimeScheduler2.frameTimeFactor = 10;
    return VirtualTimeScheduler2;
  }(AsyncScheduler_1.AsyncScheduler);
  exports2.VirtualTimeScheduler = VirtualTimeScheduler;
  var VirtualAction = function(_super) {
    __extends(VirtualAction2, _super);
    function VirtualAction2(scheduler, work, index) {
      if (index === undefined) {
        index = scheduler.index += 1;
      }
      var _this = _super.call(this, scheduler, work) || this;
      _this.scheduler = scheduler;
      _this.work = work;
      _this.index = index;
      _this.active = true;
      _this.index = scheduler.index = index;
      return _this;
    }
    VirtualAction2.prototype.schedule = function(state, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      if (Number.isFinite(delay)) {
        if (!this.id) {
          return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction2(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      } else {
        return Subscription_1.Subscription.EMPTY;
      }
    };
    VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      this.delay = scheduler.frame + delay;
      var actions = scheduler.actions;
      actions.push(this);
      actions.sort(VirtualAction2.sortActions);
      return 1;
    };
    VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
      if (delay === undefined) {
        delay = 0;
      }
      return;
    };
    VirtualAction2.prototype._execute = function(state, delay) {
      if (this.active === true) {
        return _super.prototype._execute.call(this, state, delay);
      }
    };
    VirtualAction2.sortActions = function(a, b) {
      if (a.delay === b.delay) {
        if (a.index === b.index) {
          return 0;
        } else if (a.index > b.index) {
          return 1;
        } else {
          return -1;
        }
      } else if (a.delay > b.delay) {
        return 1;
      } else {
        return -1;
      }
    };
    return VirtualAction2;
  }(AsyncAction_1.AsyncAction);
  exports2.VirtualAction = VirtualAction;
});

// node_modules/rxjs/dist/cjs/internal/observable/empty.js
var require_empty = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.empty = exports2.EMPTY = undefined;
  var Observable_1 = require_Observable();
  exports2.EMPTY = new Observable_1.Observable(function(subscriber) {
    return subscriber.complete();
  });
  function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports2.EMPTY;
  }
  exports2.empty = empty;
  function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      return scheduler.schedule(function() {
        return subscriber.complete();
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
var require_isScheduler = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isScheduler = undefined;
  var isFunction_1 = require_isFunction();
  function isScheduler(value) {
    return value && isFunction_1.isFunction(value.schedule);
  }
  exports2.isScheduler = isScheduler;
});

// node_modules/rxjs/dist/cjs/internal/util/args.js
var require_args = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.popNumber = exports2.popScheduler = exports2.popResultSelector = undefined;
  var isFunction_1 = require_isFunction();
  var isScheduler_1 = require_isScheduler();
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction_1.isFunction(last(args)) ? args.pop() : undefined;
  }
  exports2.popResultSelector = popResultSelector;
  function popScheduler(args) {
    return isScheduler_1.isScheduler(last(args)) ? args.pop() : undefined;
  }
  exports2.popScheduler = popScheduler;
  function popNumber(args, defaultValue) {
    return typeof last(args) === "number" ? args.pop() : defaultValue;
  }
  exports2.popNumber = popNumber;
});

// node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isArrayLike = undefined;
  exports2.isArrayLike = function(x2) {
    return x2 && typeof x2.length === "number" && typeof x2 !== "function";
  };
});

// node_modules/rxjs/dist/cjs/internal/util/isPromise.js
var require_isPromise = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isPromise = undefined;
  var isFunction_1 = require_isFunction();
  function isPromise(value) {
    return isFunction_1.isFunction(value === null || value === undefined ? undefined : value.then);
  }
  exports2.isPromise = isPromise;
});

// node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isInteropObservable = undefined;
  var observable_1 = require_observable();
  var isFunction_1 = require_isFunction();
  function isInteropObservable(input) {
    return isFunction_1.isFunction(input[observable_1.observable]);
  }
  exports2.isInteropObservable = isInteropObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
var require_isAsyncIterable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isAsyncIterable = undefined;
  var isFunction_1 = require_isFunction();
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj[Symbol.asyncIterator]);
  }
  exports2.isAsyncIterable = isAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
var require_throwUnobservableError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createInvalidObservableTypeError = undefined;
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  exports2.createInvalidObservableTypeError = createInvalidObservableTypeError;
});

// node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
var require_iterator = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.iterator = exports2.getSymbolIterator = undefined;
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  exports2.getSymbolIterator = getSymbolIterator;
  exports2.iterator = getSymbolIterator();
});

// node_modules/rxjs/dist/cjs/internal/util/isIterable.js
var require_isIterable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isIterable = undefined;
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  function isIterable(input) {
    return isFunction_1.isFunction(input === null || input === undefined ? undefined : input[iterator_1.iterator]);
  }
  exports2.isIterable = isIterable;
});

// node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
var require_isReadableStreamLike = __commonJS((exports2) => {
  var __generator = exports2 && exports2.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __await = exports2 && exports2.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  };
  var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i2, q = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n) {
      if (g[n])
        i2[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isReadableStreamLike = exports2.readableStreamLikeToAsyncGenerator = undefined;
  var isFunction_1 = require_isFunction();
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a2, value, done;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            reader = readableStream.getReader();
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, , 9, 10]);
            _b2.label = 2;
          case 2:
            if (false)
              ;
            return [4, __await(reader.read())];
          case 3:
            _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
            if (!done)
              return [3, 5];
            return [4, __await(undefined)];
          case 4:
            return [2, _b2.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b2.sent()];
          case 7:
            _b2.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  exports2.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
  function isReadableStreamLike(obj) {
    return isFunction_1.isFunction(obj === null || obj === undefined ? undefined : obj.getReader);
  }
  exports2.isReadableStreamLike = isReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
var require_innerFrom = __commonJS((exports2) => {
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports2 && exports2.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i2;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n) {
      i2[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  };
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.fromReadableStreamLike = exports2.fromAsyncIterable = exports2.fromIterable = exports2.fromPromise = exports2.fromArrayLike = exports2.fromInteropObservable = exports2.innerFrom = undefined;
  var isArrayLike_1 = require_isArrayLike();
  var isPromise_1 = require_isPromise();
  var Observable_1 = require_Observable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isIterable_1 = require_isIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var isFunction_1 = require_isFunction();
  var reportUnhandledError_1 = require_reportUnhandledError();
  var observable_1 = require_observable();
  function innerFrom(input) {
    if (input instanceof Observable_1.Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise_1.isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable_1.isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports2.innerFrom = innerFrom;
  function fromInteropObservable(obj) {
    return new Observable_1.Observable(function(subscriber) {
      var obs = obj[observable_1.observable]();
      if (isFunction_1.isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  exports2.fromInteropObservable = fromInteropObservable;
  function fromArrayLike(array) {
    return new Observable_1.Observable(function(subscriber) {
      for (var i2 = 0;i2 < array.length && !subscriber.closed; i2++) {
        subscriber.next(array[i2]);
      }
      subscriber.complete();
    });
  }
  exports2.fromArrayLike = fromArrayLike;
  function fromPromise(promise) {
    return new Observable_1.Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err2) {
        return subscriber.error(err2);
      }).then(null, reportUnhandledError_1.reportUnhandledError);
    });
  }
  exports2.fromPromise = fromPromise;
  function fromIterable(iterable) {
    return new Observable_1.Observable(function(subscriber) {
      var e_1, _a2;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next();!iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
            _a2.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  exports2.fromIterable = fromIterable;
  function fromAsyncIterable(asyncIterable) {
    return new Observable_1.Observable(function(subscriber) {
      process2(asyncIterable, subscriber).catch(function(err2) {
        return subscriber.error(err2);
      });
    });
  }
  exports2.fromAsyncIterable = fromAsyncIterable;
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
  }
  exports2.fromReadableStreamLike = fromReadableStreamLike;
  function process2(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a2;
    return __awaiter(this, undefined, undefined, function() {
      var value, e_2_1;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b2.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b2.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b2.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b2.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a2.call(asyncIterable_1)];
          case 7:
            _b2.sent();
            _b2.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }
});

// node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
var require_executeSchedule = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.executeSchedule = undefined;
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === undefined) {
      delay = 0;
    }
    if (repeat === undefined) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }
  exports2.executeSchedule = executeSchedule;
});

// node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
var require_observeOn = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.observeOn = undefined;
  var executeSchedule_1 = require_executeSchedule();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function observeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err2) {
        return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err2);
        }, delay);
      }));
    });
  }
  exports2.observeOn = observeOn;
});

// node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
var require_subscribeOn = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.subscribeOn = undefined;
  var lift_1 = require_lift();
  function subscribeOn(scheduler, delay) {
    if (delay === undefined) {
      delay = 0;
    }
    return lift_1.operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }
  exports2.subscribeOn = subscribeOn;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduleObservable = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function scheduleObservable(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports2.scheduleObservable = scheduleObservable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.schedulePromise = undefined;
  var innerFrom_1 = require_innerFrom();
  var observeOn_1 = require_observeOn();
  var subscribeOn_1 = require_subscribeOn();
  function schedulePromise(input, scheduler) {
    return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
  }
  exports2.schedulePromise = schedulePromise;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduleArray = undefined;
  var Observable_1 = require_Observable();
  function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var i2 = 0;
      return scheduler.schedule(function() {
        if (i2 === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i2++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }
  exports2.scheduleArray = scheduleArray;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduleIterable = undefined;
  var Observable_1 = require_Observable();
  var iterator_1 = require_iterator();
  var isFunction_1 = require_isFunction();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleIterable(input, scheduler) {
    return new Observable_1.Observable(function(subscriber) {
      var iterator;
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        iterator = input[iterator_1.iterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          var _a2;
          var value;
          var done;
          try {
            _a2 = iterator.next(), value = _a2.value, done = _a2.done;
          } catch (err2) {
            subscriber.error(err2);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction_1.isFunction(iterator === null || iterator === undefined ? undefined : iterator.return) && iterator.return();
      };
    });
  }
  exports2.scheduleIterable = scheduleIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
var require_scheduleAsyncIterable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduleAsyncIterable = undefined;
  var Observable_1 = require_Observable();
  var executeSchedule_1 = require_executeSchedule();
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable_1.Observable(function(subscriber) {
      executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          iterator.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }
  exports2.scheduleAsyncIterable = scheduleAsyncIterable;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
var require_scheduleReadableStreamLike = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduleReadableStreamLike = undefined;
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
  }
  exports2.scheduleReadableStreamLike = scheduleReadableStreamLike;
});

// node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scheduled = undefined;
  var scheduleObservable_1 = require_scheduleObservable();
  var schedulePromise_1 = require_schedulePromise();
  var scheduleArray_1 = require_scheduleArray();
  var scheduleIterable_1 = require_scheduleIterable();
  var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
  var isInteropObservable_1 = require_isInteropObservable();
  var isPromise_1 = require_isPromise();
  var isArrayLike_1 = require_isArrayLike();
  var isIterable_1 = require_isIterable();
  var isAsyncIterable_1 = require_isAsyncIterable();
  var throwUnobservableError_1 = require_throwUnobservableError();
  var isReadableStreamLike_1 = require_isReadableStreamLike();
  var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable_1.isInteropObservable(input)) {
        return scheduleObservable_1.scheduleObservable(input, scheduler);
      }
      if (isArrayLike_1.isArrayLike(input)) {
        return scheduleArray_1.scheduleArray(input, scheduler);
      }
      if (isPromise_1.isPromise(input)) {
        return schedulePromise_1.schedulePromise(input, scheduler);
      }
      if (isAsyncIterable_1.isAsyncIterable(input)) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable_1.isIterable(input)) {
        return scheduleIterable_1.scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike_1.isReadableStreamLike(input)) {
        return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw throwUnobservableError_1.createInvalidObservableTypeError(input);
  }
  exports2.scheduled = scheduled;
});

// node_modules/rxjs/dist/cjs/internal/observable/from.js
var require_from = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.from = undefined;
  var scheduled_1 = require_scheduled();
  var innerFrom_1 = require_innerFrom();
  function from(input, scheduler) {
    return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
  }
  exports2.from = from;
});

// node_modules/rxjs/dist/cjs/internal/observable/of.js
var require_of = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.of = undefined;
  var args_1 = require_args();
  var from_1 = require_from();
  function of() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return from_1.from(args, scheduler);
  }
  exports2.of = of;
});

// node_modules/rxjs/dist/cjs/internal/observable/throwError.js
var require_throwError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.throwError = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function throwError(errorOrErrorFactory, scheduler) {
    var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
      return errorOrErrorFactory;
    };
    var init = function(subscriber) {
      return subscriber.error(errorFactory());
    };
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      return scheduler.schedule(init, 0, subscriber);
    } : init);
  }
  exports2.throwError = throwError;
});

// node_modules/rxjs/dist/cjs/internal/Notification.js
var require_Notification = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.observeNotification = exports2.Notification = exports2.NotificationKind = undefined;
  var empty_1 = require_empty();
  var of_1 = require_of();
  var throwError_1 = require_throwError();
  var isFunction_1 = require_isFunction();
  var NotificationKind;
  (function(NotificationKind2) {
    NotificationKind2["NEXT"] = "N";
    NotificationKind2["ERROR"] = "E";
    NotificationKind2["COMPLETE"] = "C";
  })(NotificationKind = exports2.NotificationKind || (exports2.NotificationKind = {}));
  var Notification = function() {
    function Notification2(kind, value, error2) {
      this.kind = kind;
      this.value = value;
      this.error = error2;
      this.hasValue = kind === "N";
    }
    Notification2.prototype.observe = function(observer) {
      return observeNotification(this, observer);
    };
    Notification2.prototype.do = function(nextHandler, errorHandler2, completeHandler) {
      var _a2 = this, kind = _a2.kind, value = _a2.value, error2 = _a2.error;
      return kind === "N" ? nextHandler === null || nextHandler === undefined ? undefined : nextHandler(value) : kind === "E" ? errorHandler2 === null || errorHandler2 === undefined ? undefined : errorHandler2(error2) : completeHandler === null || completeHandler === undefined ? undefined : completeHandler();
    };
    Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
      var _a2;
      return isFunction_1.isFunction((_a2 = nextOrObserver) === null || _a2 === undefined ? undefined : _a2.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
    };
    Notification2.prototype.toObservable = function() {
      var _a2 = this, kind = _a2.kind, value = _a2.value, error2 = _a2.error;
      var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
        return error2;
      }) : kind === "C" ? empty_1.EMPTY : 0;
      if (!result) {
        throw new TypeError("Unexpected notification kind " + kind);
      }
      return result;
    };
    Notification2.createNext = function(value) {
      return new Notification2("N", value);
    };
    Notification2.createError = function(err2) {
      return new Notification2("E", undefined, err2);
    };
    Notification2.createComplete = function() {
      return Notification2.completeNotification;
    };
    Notification2.completeNotification = new Notification2("C");
    return Notification2;
  }();
  exports2.Notification = Notification;
  function observeNotification(notification, observer) {
    var _a2, _b2, _c;
    var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
    if (typeof kind !== "string") {
      throw new TypeError('Invalid notification, missing "kind"');
    }
    kind === "N" ? (_a2 = observer.next) === null || _a2 === undefined || _a2.call(observer, value) : kind === "E" ? (_b2 = observer.error) === null || _b2 === undefined || _b2.call(observer, error2) : (_c = observer.complete) === null || _c === undefined || _c.call(observer);
  }
  exports2.observeNotification = observeNotification;
});

// node_modules/rxjs/dist/cjs/internal/util/isObservable.js
var require_isObservable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isObservable = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
  }
  exports2.isObservable = isObservable;
});

// node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
var require_EmptyError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.EmptyError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
var require_lastValueFrom = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.lastValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  function lastValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var _hasValue = false;
      var _value;
      source.subscribe({
        next: function(value) {
          _value = value;
          _hasValue = true;
        },
        error: reject,
        complete: function() {
          if (_hasValue) {
            resolve(_value);
          } else if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
    });
  }
  exports2.lastValueFrom = lastValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
var require_firstValueFrom = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.firstValueFrom = undefined;
  var EmptyError_1 = require_EmptyError();
  var Subscriber_1 = require_Subscriber();
  function firstValueFrom(source, config) {
    var hasConfig = typeof config === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new Subscriber_1.SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config.defaultValue);
          } else {
            reject(new EmptyError_1.EmptyError);
          }
        }
      });
      source.subscribe(subscriber);
    });
  }
  exports2.firstValueFrom = firstValueFrom;
});

// node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
var require_ArgumentOutOfRangeError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ArgumentOutOfRangeError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
    return function ArgumentOutOfRangeErrorImpl() {
      _super(this);
      this.name = "ArgumentOutOfRangeError";
      this.message = "argument out of range";
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
var require_NotFoundError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NotFoundError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
    return function NotFoundErrorImpl(message) {
      _super(this);
      this.name = "NotFoundError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
var require_SequenceError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SequenceError = undefined;
  var createErrorClass_1 = require_createErrorClass();
  exports2.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
    return function SequenceErrorImpl(message) {
      _super(this);
      this.name = "SequenceError";
      this.message = message;
    };
  });
});

// node_modules/rxjs/dist/cjs/internal/util/isDate.js
var require_isDate = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isValidDate = undefined;
  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }
  exports2.isValidDate = isValidDate;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeout.js
var require_timeout = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timeout = exports2.TimeoutError = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var createErrorClass_1 = require_createErrorClass();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  exports2.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
    return function TimeoutErrorImpl(info) {
      if (info === undefined) {
        info = null;
      }
      _super(this);
      this.message = "Timeout has occurred";
      this.name = "TimeoutError";
      this.info = info;
    };
  });
  function timeout(config, schedulerArg) {
    var _a2 = isDate_1.isValidDate(config) ? { first: config } : typeof config === "number" ? { each: config } : config, first = _a2.first, each = _a2.each, _b2 = _a2.with, _with = _b2 === undefined ? timeoutErrorFactory : _b2, _c = _a2.scheduler, scheduler = _c === undefined ? schedulerArg !== null && schedulerArg !== undefined ? schedulerArg : async_1.asyncScheduler : _c, _d = _a2.meta, meta = _d === undefined ? null : _d;
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return lift_1.operate(function(source, subscriber) {
      var originalSourceSubscription;
      var timerSubscription;
      var lastValue = null;
      var seen = 0;
      var startTimer = function(delay) {
        timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
          try {
            originalSourceSubscription.unsubscribe();
            innerFrom_1.innerFrom(_with({
              meta,
              lastValue,
              seen
            })).subscribe(subscriber);
          } catch (err2) {
            subscriber.error(err2);
          }
        }, delay);
      };
      originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        seen++;
        subscriber.next(lastValue = value);
        each > 0 && startTimer(each);
      }, undefined, undefined, function() {
        if (!(timerSubscription === null || timerSubscription === undefined ? undefined : timerSubscription.closed)) {
          timerSubscription === null || timerSubscription === undefined || timerSubscription.unsubscribe();
        }
        lastValue = null;
      }));
      !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
    });
  }
  exports2.timeout = timeout;
  function timeoutErrorFactory(info) {
    throw new exports2.TimeoutError(info);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/map.js
var require_map = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.map = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function map(project, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }
  exports2.map = map;
});

// node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
var require_mapOneOrManyArgs = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mapOneOrManyArgs = undefined;
  var map_1 = require_map();
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(undefined, __spreadArray([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map_1.map(function(args) {
      return callOrApply(fn, args);
    });
  }
  exports2.mapOneOrManyArgs = mapOneOrManyArgs;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
var require_bindCallbackInternals = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bindCallbackInternals = undefined;
  var isScheduler_1 = require_isScheduler();
  var Observable_1 = require_Observable();
  var subscribeOn_1 = require_subscribeOn();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var observeOn_1 = require_observeOn();
  var AsyncSubject_1 = require_AsyncSubject();
  function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
      if (isScheduler_1.isScheduler(resultSelector)) {
        scheduler = resultSelector;
      } else {
        return function() {
          var args = [];
          for (var _i = 0;_i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        };
      }
    }
    if (scheduler) {
      return function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      };
    }
    return function() {
      var _this = this;
      var args = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var subject = new AsyncSubject_1.AsyncSubject;
      var uninitialized = true;
      return new Observable_1.Observable(function(subscriber) {
        var subs = subject.subscribe(subscriber);
        if (uninitialized) {
          uninitialized = false;
          var isAsync_1 = false;
          var isComplete_1 = false;
          callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [
            function() {
              var results = [];
              for (var _i2 = 0;_i2 < arguments.length; _i2++) {
                results[_i2] = arguments[_i2];
              }
              if (isNodeStyle) {
                var err2 = results.shift();
                if (err2 != null) {
                  subject.error(err2);
                  return;
                }
              }
              subject.next(1 < results.length ? results : results[0]);
              isComplete_1 = true;
              if (isAsync_1) {
                subject.complete();
              }
            }
          ]));
          if (isComplete_1) {
            subject.complete();
          }
          isAsync_1 = true;
        }
        return subs;
      });
    };
  }
  exports2.bindCallbackInternals = bindCallbackInternals;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
var require_bindCallback = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bindCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
  }
  exports2.bindCallback = bindCallback;
});

// node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
var require_bindNodeCallback = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bindNodeCallback = undefined;
  var bindCallbackInternals_1 = require_bindCallbackInternals();
  function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
  }
  exports2.bindNodeCallback = bindNodeCallback;
});

// node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
var require_argsArgArrayOrObject = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.argsArgArrayOrObject = undefined;
  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  exports2.argsArgArrayOrObject = argsArgArrayOrObject;
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }
});

// node_modules/rxjs/dist/cjs/internal/util/createObject.js
var require_createObject = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createObject = undefined;
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i2) {
      return result[key] = values[i2], result;
    }, {});
  }
  exports2.createObject = createObject;
});

// node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
var require_combineLatest = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.combineLatestInit = exports2.combineLatest = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var from_1 = require_from();
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var args_1 = require_args();
  var createObject_1 = require_createObject();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var executeSchedule_1 = require_executeSchedule();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var resultSelector = args_1.popResultSelector(args);
    var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
    if (observables.length === 0) {
      return from_1.from([], scheduler);
    }
    var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject_1.createObject(keys, values);
    } : identity_1.identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports2.combineLatest = combineLatest;
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === undefined) {
      valueTransform = identity_1.identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i3) {
          maybeSchedule(scheduler, function() {
            var source = from_1.from(observables[i3], scheduler);
            var hasFirstValue = false;
            source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              values[i3] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i2 = 0;i2 < length; i2++) {
          _loop_1(i2);
        }
      }, subscriber);
    };
  }
  exports2.combineLatestInit = combineLatestInit;
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule_1.executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
var require_mergeInternals = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeInternals = undefined;
  var innerFrom_1 = require_innerFrom();
  var executeSchedule_1 = require_executeSchedule();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom_1.innerFrom(project(value, index++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === undefined || onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, undefined, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err2) {
            subscriber.error(err2);
          }
        }
      }));
    };
    source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === undefined || additionalFinalizer();
    };
  }
  exports2.mergeInternals = mergeInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
var require_mergeMap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  var isFunction_1 = require_isFunction();
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap(function(a, i2) {
        return map_1.map(function(b, ii) {
          return resultSelector(a, b, i2, ii);
        })(innerFrom_1.innerFrom(project(a, i2)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
    });
  }
  exports2.mergeMap = mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
var require_mergeAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeAll = undefined;
  var mergeMap_1 = require_mergeMap();
  var identity_1 = require_identity();
  function mergeAll(concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
  }
  exports2.mergeAll = mergeAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
var require_concatAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concatAll = undefined;
  var mergeAll_1 = require_mergeAll();
  function concatAll() {
    return mergeAll_1.mergeAll(1);
  }
  exports2.concatAll = concatAll;
});

// node_modules/rxjs/dist/cjs/internal/observable/concat.js
var require_concat = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concat = undefined;
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
  }
  exports2.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/observable/defer.js
var require_defer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.defer = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  function defer(observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
    });
  }
  exports2.defer = defer;
});

// node_modules/rxjs/dist/cjs/internal/observable/connectable.js
var require_connectable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.connectable = undefined;
  var Subject_1 = require_Subject();
  var Observable_1 = require_Observable();
  var defer_1 = require_defer();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    },
    resetOnDisconnect: true
  };
  function connectable(source, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connection = null;
    var { connector, resetOnDisconnect: _a2 } = config, resetOnDisconnect = _a2 === undefined ? true : _a2;
    var subject = connector();
    var result = new Observable_1.Observable(function(subscriber) {
      return subject.subscribe(subscriber);
    });
    result.connect = function() {
      if (!connection || connection.closed) {
        connection = defer_1.defer(function() {
          return source;
        }).subscribe(subject);
        if (resetOnDisconnect) {
          connection.add(function() {
            return subject = connector();
          });
        }
      }
      return connection;
    };
    return result;
  }
  exports2.connectable = connectable;
});

// node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
var require_forkJoin = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.forkJoin = undefined;
  var Observable_1 = require_Observable();
  var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
  var innerFrom_1 = require_innerFrom();
  var args_1 = require_args();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var createObject_1 = require_createObject();
  function forkJoin() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var _a2 = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a2.args, keys = _a2.keys;
    var result = new Observable_1.Observable(function(subscriber) {
      var length = sources.length;
      if (!length) {
        subscriber.complete();
        return;
      }
      var values = new Array(length);
      var remainingCompletions = length;
      var remainingEmissions = length;
      var _loop_1 = function(sourceIndex2) {
        var hasValue = false;
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (!hasValue) {
            hasValue = true;
            remainingEmissions--;
          }
          values[sourceIndex2] = value;
        }, function() {
          return remainingCompletions--;
        }, undefined, function() {
          if (!remainingCompletions || !hasValue) {
            if (!remainingEmissions) {
              subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
            }
            subscriber.complete();
          }
        }));
      };
      for (var sourceIndex = 0;sourceIndex < length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
    });
    return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
  }
  exports2.forkJoin = forkJoin;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
var require_fromEvent = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.fromEvent = undefined;
  var innerFrom_1 = require_innerFrom();
  var Observable_1 = require_Observable();
  var mergeMap_1 = require_mergeMap();
  var isArrayLike_1 = require_isArrayLike();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a2[0], remove = _a2[1];
    if (!add) {
      if (isArrayLike_1.isArrayLike(target)) {
        return mergeMap_1.mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom_1.innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove(handler);
      };
    });
  }
  exports2.fromEvent = fromEvent;
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
  }
});

// node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
var require_fromEventPattern = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.fromEventPattern = undefined;
  var Observable_1 = require_Observable();
  var isFunction_1 = require_isFunction();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
      return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
    }
    return new Observable_1.Observable(function(subscriber) {
      var handler = function() {
        var e = [];
        for (var _i = 0;_i < arguments.length; _i++) {
          e[_i] = arguments[_i];
        }
        return subscriber.next(e.length === 1 ? e[0] : e);
      };
      var retValue = addHandler(handler);
      return isFunction_1.isFunction(removeHandler) ? function() {
        return removeHandler(handler, retValue);
      } : undefined;
    });
  }
  exports2.fromEventPattern = fromEventPattern;
});

// node_modules/rxjs/dist/cjs/internal/observable/generate.js
var require_generate = __commonJS((exports2) => {
  var __generator = exports2 && exports2.__generator || function(thisArg, body) {
    var _ = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (_)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2])
                _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.generate = undefined;
  var identity_1 = require_identity();
  var isScheduler_1 = require_isScheduler();
  var defer_1 = require_defer();
  var scheduleIterable_1 = require_scheduleIterable();
  function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
    var _a2, _b2;
    var resultSelector;
    var initialState;
    if (arguments.length === 1) {
      _a2 = initialStateOrOptions, initialState = _a2.initialState, condition = _a2.condition, iterate = _a2.iterate, _b2 = _a2.resultSelector, resultSelector = _b2 === undefined ? identity_1.identity : _b2, scheduler = _a2.scheduler;
    } else {
      initialState = initialStateOrOptions;
      if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrScheduler;
      } else {
        resultSelector = resultSelectorOrScheduler;
      }
    }
    function gen() {
      var state;
      return __generator(this, function(_a3) {
        switch (_a3.label) {
          case 0:
            state = initialState;
            _a3.label = 1;
          case 1:
            if (!(!condition || condition(state)))
              return [3, 4];
            return [4, resultSelector(state)];
          case 2:
            _a3.sent();
            _a3.label = 3;
          case 3:
            state = iterate(state);
            return [3, 1];
          case 4:
            return [2];
        }
      });
    }
    return defer_1.defer(scheduler ? function() {
      return scheduleIterable_1.scheduleIterable(gen(), scheduler);
    } : gen);
  }
  exports2.generate = generate;
});

// node_modules/rxjs/dist/cjs/internal/observable/iif.js
var require_iif = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.iif = undefined;
  var defer_1 = require_defer();
  function iif(condition, trueResult, falseResult) {
    return defer_1.defer(function() {
      return condition() ? trueResult : falseResult;
    });
  }
  exports2.iif = iif;
});

// node_modules/rxjs/dist/cjs/internal/observable/timer.js
var require_timer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timer = undefined;
  var Observable_1 = require_Observable();
  var async_1 = require_async();
  var isScheduler_1 = require_isScheduler();
  var isDate_1 = require_isDate();
  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === undefined) {
      dueTime = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.async;
    }
    var intervalDuration = -1;
    if (intervalOrScheduler != null) {
      if (isScheduler_1.isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }
    return new Observable_1.Observable(function(subscriber) {
      var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
      if (due < 0) {
        due = 0;
      }
      var n = 0;
      return scheduler.schedule(function() {
        if (!subscriber.closed) {
          subscriber.next(n++);
          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }
  exports2.timer = timer;
});

// node_modules/rxjs/dist/cjs/internal/observable/interval.js
var require_interval = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.interval = undefined;
  var async_1 = require_async();
  var timer_1 = require_timer();
  function interval(period, scheduler) {
    if (period === undefined) {
      period = 0;
    }
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    if (period < 0) {
      period = 0;
    }
    return timer_1.timer(period, period, scheduler);
  }
  exports2.interval = interval;
});

// node_modules/rxjs/dist/cjs/internal/observable/merge.js
var require_merge = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.merge = undefined;
  var mergeAll_1 = require_mergeAll();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
  }
  exports2.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/observable/never.js
var require_never = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.never = exports2.NEVER = undefined;
  var Observable_1 = require_Observable();
  var noop_1 = require_noop();
  exports2.NEVER = new Observable_1.Observable(noop_1.noop);
  function never() {
    return exports2.NEVER;
  }
  exports2.never = never;
});

// node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
var require_argsOrArgArray = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.argsOrArgArray = undefined;
  var isArray = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  }
  exports2.argsOrArgArray = argsOrArgArray;
});

// node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
var require_onErrorResumeNext = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.onErrorResumeNext = undefined;
  var Observable_1 = require_Observable();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return new Observable_1.Observable(function(subscriber) {
      var sourceIndex = 0;
      var subscribeNext = function() {
        if (sourceIndex < nextSources.length) {
          var nextSource = undefined;
          try {
            nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
          } catch (err2) {
            subscribeNext();
            return;
          }
          var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, undefined, noop_1.noop, noop_1.noop);
          nextSource.subscribe(innerSubscriber);
          innerSubscriber.add(subscribeNext);
        } else {
          subscriber.complete();
        }
      };
      subscribeNext();
    });
  }
  exports2.onErrorResumeNext = onErrorResumeNext;
});

// node_modules/rxjs/dist/cjs/internal/observable/pairs.js
var require_pairs = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pairs = undefined;
  var from_1 = require_from();
  function pairs(obj, scheduler) {
    return from_1.from(Object.entries(obj), scheduler);
  }
  exports2.pairs = pairs;
});

// node_modules/rxjs/dist/cjs/internal/util/not.js
var require_not = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.not = undefined;
  function not(pred, thisArg) {
    return function(value, index) {
      return !pred.call(thisArg, value, index);
    };
  }
  exports2.not = not;
});

// node_modules/rxjs/dist/cjs/internal/operators/filter.js
var require_filter = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.filter = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function filter(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }
  exports2.filter = filter;
});

// node_modules/rxjs/dist/cjs/internal/observable/partition.js
var require_partition = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.partition = undefined;
  var not_1 = require_not();
  var filter_1 = require_filter();
  var innerFrom_1 = require_innerFrom();
  function partition(source, predicate, thisArg) {
    return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
  }
  exports2.partition = partition;
});

// node_modules/rxjs/dist/cjs/internal/observable/race.js
var require_race = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.raceInit = exports2.race = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function race() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    sources = argsOrArgArray_1.argsOrArgArray(sources);
    return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
  }
  exports2.race = race;
  function raceInit(sources) {
    return function(subscriber) {
      var subscriptions = [];
      var _loop_1 = function(i3) {
        subscriptions.push(innerFrom_1.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (subscriptions) {
            for (var s = 0;s < subscriptions.length; s++) {
              s !== i3 && subscriptions[s].unsubscribe();
            }
            subscriptions = null;
          }
          subscriber.next(value);
        })));
      };
      for (var i2 = 0;subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
        _loop_1(i2);
      }
    };
  }
  exports2.raceInit = raceInit;
});

// node_modules/rxjs/dist/cjs/internal/observable/range.js
var require_range = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.range = undefined;
  var Observable_1 = require_Observable();
  var empty_1 = require_empty();
  function range(start, count, scheduler) {
    if (count == null) {
      count = start;
      start = 0;
    }
    if (count <= 0) {
      return empty_1.EMPTY;
    }
    var end = count + start;
    return new Observable_1.Observable(scheduler ? function(subscriber) {
      var n = start;
      return scheduler.schedule(function() {
        if (n < end) {
          subscriber.next(n++);
          this.schedule();
        } else {
          subscriber.complete();
        }
      });
    } : function(subscriber) {
      var n = start;
      while (n < end && !subscriber.closed) {
        subscriber.next(n++);
      }
      subscriber.complete();
    });
  }
  exports2.range = range;
});

// node_modules/rxjs/dist/cjs/internal/observable/using.js
var require_using = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.using = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var empty_1 = require_empty();
  function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function(subscriber) {
      var resource = resourceFactory();
      var result = observableFactory(resource);
      var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
      source.subscribe(subscriber);
      return function() {
        if (resource) {
          resource.unsubscribe();
        }
      };
    });
  }
  exports2.using = using;
});

// node_modules/rxjs/dist/cjs/internal/observable/zip.js
var require_zip = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.zip = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var empty_1 = require_empty();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var args_1 = require_args();
  function zip() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    var sources = argsOrArgArray_1.argsOrArgArray(args);
    return sources.length ? new Observable_1.Observable(function(subscriber) {
      var buffers = sources.map(function() {
        return [];
      });
      var completed = sources.map(function() {
        return false;
      });
      subscriber.add(function() {
        buffers = completed = null;
      });
      var _loop_1 = function(sourceIndex2) {
        innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          buffers[sourceIndex2].push(value);
          if (buffers.every(function(buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function(buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(undefined, __spreadArray([], __read(result))) : result);
            if (buffers.some(function(buffer, i2) {
              return !buffer.length && completed[i2];
            })) {
              subscriber.complete();
            }
          }
        }, function() {
          completed[sourceIndex2] = true;
          !buffers[sourceIndex2].length && subscriber.complete();
        }));
      };
      for (var sourceIndex = 0;!subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }
      return function() {
        buffers = completed = null;
      };
    }) : empty_1.EMPTY;
  }
  exports2.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/types.js
var require_types = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
});

// node_modules/rxjs/dist/cjs/internal/operators/audit.js
var require_audit = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.audit = undefined;
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function audit(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var isComplete = false;
      var endDuration = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
        isComplete && subscriber.complete();
      };
      var cleanupDuration = function() {
        durationSubscriber = null;
        isComplete && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
        if (!durationSubscriber) {
          innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
        }
      }, function() {
        isComplete = true;
        (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
      }));
    });
  }
  exports2.audit = audit;
});

// node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
var require_auditTime = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.auditTime = undefined;
  var async_1 = require_async();
  var audit_1 = require_audit();
  var timer_1 = require_timer();
  function auditTime(duration, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return audit_1.audit(function() {
      return timer_1.timer(duration, scheduler);
    });
  }
  exports2.auditTime = auditTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/buffer.js
var require_buffer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.buffer = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function buffer(closingNotifier) {
    return lift_1.operate(function(source, subscriber) {
      var currentBuffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return currentBuffer.push(value);
      }, function() {
        subscriber.next(currentBuffer);
        subscriber.complete();
      }));
      innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        var b = currentBuffer;
        currentBuffer = [];
        subscriber.next(b);
      }, noop_1.noop));
      return function() {
        currentBuffer = null;
      };
    });
  }
  exports2.buffer = buffer;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
var require_bufferCount = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bufferCount = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === undefined) {
      startBufferEvery = null;
    }
    startBufferEvery = startBufferEvery !== null && startBufferEvery !== undefined ? startBufferEvery : bufferSize;
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      var count = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2, e_2, _b2;
        var toEmit = null;
        if (count++ % startBufferEvery === 0) {
          buffers.push([]);
        }
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
            if (bufferSize <= buffer.length) {
              toEmit = toEmit !== null && toEmit !== undefined ? toEmit : [];
              toEmit.push(buffer);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return))
              _a2.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        if (toEmit) {
          try {
            for (var toEmit_1 = __values(toEmit), toEmit_1_1 = toEmit_1.next();!toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
              var buffer = toEmit_1_1.value;
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (toEmit_1_1 && !toEmit_1_1.done && (_b2 = toEmit_1.return))
                _b2.call(toEmit_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }, function() {
        var e_3, _a2;
        try {
          for (var buffers_2 = __values(buffers), buffers_2_1 = buffers_2.next();!buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
            var buffer = buffers_2_1.value;
            subscriber.next(buffer);
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (buffers_2_1 && !buffers_2_1.done && (_a2 = buffers_2.return))
              _a2.call(buffers_2);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffers = null;
      }));
    });
  }
  exports2.bufferCount = bufferCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
var require_bufferTime = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bufferTime = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var async_1 = require_async();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function bufferTime(bufferTimeSpan) {
    var _a2, _b2;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== undefined ? _a2 : async_1.asyncScheduler;
    var bufferCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== undefined ? _b2 : null;
    var maxBufferSize2 = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var bufferRecords = [];
      var restartOnEmit = false;
      var emit = function(record) {
        var { buffer, subs } = record;
        subs.unsubscribe();
        arrRemove_1.arrRemove(bufferRecords, record);
        subscriber.next(buffer);
        restartOnEmit && startBuffer();
      };
      var startBuffer = function() {
        if (bufferRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var buffer = [];
          var record_1 = {
            buffer,
            subs
          };
          bufferRecords.push(record_1);
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return emit(record_1);
          }, bufferTimeSpan);
        }
      };
      if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
      } else {
        restartOnEmit = true;
      }
      startBuffer();
      var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a3;
        var recordsCopy = bufferRecords.slice();
        try {
          for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next();!recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
            var record = recordsCopy_1_1.value;
            var buffer = record.buffer;
            buffer.push(value);
            maxBufferSize2 <= buffer.length && emit(record);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a3 = recordsCopy_1.return))
              _a3.call(recordsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (bufferRecords === null || bufferRecords === undefined ? undefined : bufferRecords.length) {
          subscriber.next(bufferRecords.shift().buffer);
        }
        bufferTimeSubscriber === null || bufferTimeSubscriber === undefined || bufferTimeSubscriber.unsubscribe();
        subscriber.complete();
        subscriber.unsubscribe();
      }, undefined, function() {
        return bufferRecords = null;
      });
      source.subscribe(bufferTimeSubscriber);
    });
  }
  exports2.bufferTime = bufferTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
var require_bufferToggle = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bufferToggle = undefined;
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function bufferToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffers = [];
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var buffer = [];
        buffers.push(buffer);
        var closingSubscription = new Subscription_1.Subscription;
        var emitBuffer = function() {
          arrRemove_1.arrRemove(buffers, buffer);
          subscriber.next(buffer);
          closingSubscription.unsubscribe();
        };
        closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        try {
          for (var buffers_1 = __values(buffers), buffers_1_1 = buffers_1.next();!buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
            var buffer = buffers_1_1.value;
            buffer.push(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffers_1_1 && !buffers_1_1.done && (_a2 = buffers_1.return))
              _a2.call(buffers_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (buffers.length > 0) {
          subscriber.next(buffers.shift());
        }
        subscriber.complete();
      }));
    });
  }
  exports2.bufferToggle = bufferToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
var require_bufferWhen = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.bufferWhen = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function bufferWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var buffer = null;
      var closingSubscriber = null;
      var openBuffer = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        var b = buffer;
        buffer = [];
        b && subscriber.next(b);
        innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
      };
      openBuffer();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return buffer === null || buffer === undefined ? undefined : buffer.push(value);
      }, function() {
        buffer && subscriber.next(buffer);
        subscriber.complete();
      }, undefined, function() {
        return buffer = closingSubscriber = null;
      }));
    });
  }
  exports2.bufferWhen = bufferWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/catchError.js
var require_catchError = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.catchError = undefined;
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var lift_1 = require_lift();
  function catchError(selector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub = null;
      var syncUnsub = false;
      var handledResult;
      innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err2) {
        handledResult = innerFrom_1.innerFrom(selector(err2, catchError(selector)(source)));
        if (innerSub) {
          innerSub.unsubscribe();
          innerSub = null;
          handledResult.subscribe(subscriber);
        } else {
          syncUnsub = true;
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      }
    });
  }
  exports2.catchError = catchError;
});

// node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
var require_scanInternals = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scanInternals = undefined;
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i2 = index++;
        state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      }));
    };
  }
  exports2.scanInternals = scanInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/reduce.js
var require_reduce = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.reduce = undefined;
  var scanInternals_1 = require_scanInternals();
  var lift_1 = require_lift();
  function reduce(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  exports2.reduce = reduce;
});

// node_modules/rxjs/dist/cjs/internal/operators/toArray.js
var require_toArray = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.toArray = undefined;
  var reduce_1 = require_reduce();
  var lift_1 = require_lift();
  var arrReducer = function(arr, value) {
    return arr.push(value), arr;
  };
  function toArray() {
    return lift_1.operate(function(source, subscriber) {
      reduce_1.reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  }
  exports2.toArray = toArray;
});

// node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
var require_joinAllInternals = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.joinAllInternals = undefined;
  var identity_1 = require_identity();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var mergeMap_1 = require_mergeMap();
  var toArray_1 = require_toArray();
  function joinAllInternals(joinFn, project) {
    return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
      return joinFn(sources);
    }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
  }
  exports2.joinAllInternals = joinAllInternals;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
var require_combineLatestAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.combineLatestAll = undefined;
  var combineLatest_1 = require_combineLatest();
  var joinAllInternals_1 = require_joinAllInternals();
  function combineLatestAll(project) {
    return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
  }
  exports2.combineLatestAll = combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
var require_combineAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.combineAll = undefined;
  var combineLatestAll_1 = require_combineLatestAll();
  exports2.combineAll = combineLatestAll_1.combineLatestAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
var require_combineLatest2 = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.combineLatest = undefined;
  var combineLatest_1 = require_combineLatest();
  var lift_1 = require_lift();
  var argsOrArgArray_1 = require_argsOrArgArray();
  var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
  var pipe_1 = require_pipe();
  var args_1 = require_args();
  function combineLatest() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var resultSelector = args_1.popResultSelector(args);
    return resultSelector ? pipe_1.pipe(combineLatest.apply(undefined, __spreadArray([], __read(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
      combineLatest_1.combineLatestInit(__spreadArray([source], __read(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
    });
  }
  exports2.combineLatest = combineLatest;
});

// node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
var require_combineLatestWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.combineLatestWith = undefined;
  var combineLatest_1 = require_combineLatest2();
  function combineLatestWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return combineLatest_1.combineLatest.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports2.combineLatestWith = combineLatestWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
var require_concatMap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function concatMap(project, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
  }
  exports2.concatMap = concatMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
var require_concatMapTo = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concatMapTo = undefined;
  var concatMap_1 = require_concatMap();
  var isFunction_1 = require_isFunction();
  function concatMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
      return innerObservable;
    }, resultSelector) : concatMap_1.concatMap(function() {
      return innerObservable;
    });
  }
  exports2.concatMapTo = concatMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/concat.js
var require_concat2 = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concat = undefined;
  var lift_1 = require_lift();
  var concatAll_1 = require_concatAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function concat() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    return lift_1.operate(function(source, subscriber) {
      concatAll_1.concatAll()(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports2.concat = concat;
});

// node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
var require_concatWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.concatWith = undefined;
  var concat_1 = require_concat2();
  function concatWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return concat_1.concat.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports2.concatWith = concatWith;
});

// node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
var require_fromSubscribable = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.fromSubscribable = undefined;
  var Observable_1 = require_Observable();
  function fromSubscribable(subscribable) {
    return new Observable_1.Observable(function(subscriber) {
      return subscribable.subscribe(subscriber);
    });
  }
  exports2.fromSubscribable = fromSubscribable;
});

// node_modules/rxjs/dist/cjs/internal/operators/connect.js
var require_connect = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.connect = undefined;
  var Subject_1 = require_Subject();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var fromSubscribable_1 = require_fromSubscribable();
  var DEFAULT_CONFIG = {
    connector: function() {
      return new Subject_1.Subject;
    }
  };
  function connect(selector, config) {
    if (config === undefined) {
      config = DEFAULT_CONFIG;
    }
    var connector = config.connector;
    return lift_1.operate(function(source, subscriber) {
      var subject = connector();
      innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
      subscriber.add(source.subscribe(subject));
    });
  }
  exports2.connect = connect;
});

// node_modules/rxjs/dist/cjs/internal/operators/count.js
var require_count = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.count = undefined;
  var reduce_1 = require_reduce();
  function count(predicate) {
    return reduce_1.reduce(function(total, value, i2) {
      return !predicate || predicate(value, i2) ? total + 1 : total;
    }, 0);
  }
  exports2.count = count;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounce.js
var require_debounce = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.debounce = undefined;
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function debounce(durationSelector) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      var durationSubscriber = null;
      var emit = function() {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        durationSubscriber = null;
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        durationSubscriber === null || durationSubscriber === undefined || durationSubscriber.unsubscribe();
        hasValue = true;
        lastValue = value;
        durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
        innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = durationSubscriber = null;
      }));
    });
  }
  exports2.debounce = debounce;
});

// node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
var require_debounceTime = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.debounceTime = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function debounceTime(dueTime, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;
      var emit = function() {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };
      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();
        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }
        emit();
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        lastValue = value;
        lastTime = scheduler.now();
        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function() {
        emit();
        subscriber.complete();
      }, undefined, function() {
        lastValue = activeTask = null;
      }));
    });
  }
  exports2.debounceTime = debounceTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
var require_defaultIfEmpty = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.defaultIfEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function defaultIfEmpty(defaultValue) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        if (!hasValue) {
          subscriber.next(defaultValue);
        }
        subscriber.complete();
      }));
    });
  }
  exports2.defaultIfEmpty = defaultIfEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/take.js
var require_take = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.take = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function take(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }
  exports2.take = take;
});

// node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
var require_ignoreElements = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ignoreElements = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  function ignoreElements() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
    });
  }
  exports2.ignoreElements = ignoreElements;
});

// node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
var require_mapTo = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mapTo = undefined;
  var map_1 = require_map();
  function mapTo(value) {
    return map_1.map(function() {
      return value;
    });
  }
  exports2.mapTo = mapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
var require_delayWhen = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.delayWhen = undefined;
  var concat_1 = require_concat();
  var take_1 = require_take();
  var ignoreElements_1 = require_ignoreElements();
  var mapTo_1 = require_mapTo();
  var mergeMap_1 = require_mergeMap();
  var innerFrom_1 = require_innerFrom();
  function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
      return function(source) {
        return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
      };
    }
    return mergeMap_1.mergeMap(function(value, index) {
      return innerFrom_1.innerFrom(delayDurationSelector(value, index)).pipe(take_1.take(1), mapTo_1.mapTo(value));
    });
  }
  exports2.delayWhen = delayWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/delay.js
var require_delay = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.delay = undefined;
  var async_1 = require_async();
  var delayWhen_1 = require_delayWhen();
  var timer_1 = require_timer();
  function delay(due, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration = timer_1.timer(due, scheduler);
    return delayWhen_1.delayWhen(function() {
      return duration;
    });
  }
  exports2.delay = delay;
});

// node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
var require_dematerialize = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.dematerialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function dematerialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
        return Notification_1.observeNotification(notification, subscriber);
      }));
    });
  }
  exports2.dematerialize = dematerialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinct.js
var require_distinct = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.distinct = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function distinct(keySelector, flushes) {
    return lift_1.operate(function(source, subscriber) {
      var distinctKeys = new Set;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var key = keySelector ? keySelector(value) : value;
        if (!distinctKeys.has(key)) {
          distinctKeys.add(key);
          subscriber.next(value);
        }
      }));
      flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return distinctKeys.clear();
      }, noop_1.noop));
    });
  }
  exports2.distinct = distinct;
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
var require_distinctUntilChanged = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.distinctUntilChanged = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === undefined) {
      keySelector = identity_1.identity;
    }
    comparator = comparator !== null && comparator !== undefined ? comparator : defaultCompare;
    return lift_1.operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  exports2.distinctUntilChanged = distinctUntilChanged;
  function defaultCompare(a, b) {
    return a === b;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
var require_distinctUntilKeyChanged = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.distinctUntilKeyChanged = undefined;
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged(function(x2, y) {
      return compare ? compare(x2[key], y[key]) : x2[key] === y[key];
    });
  }
  exports2.distinctUntilKeyChanged = distinctUntilKeyChanged;
});

// node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
var require_throwIfEmpty = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.throwIfEmpty = undefined;
  var EmptyError_1 = require_EmptyError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function throwIfEmpty(errorFactory) {
    if (errorFactory === undefined) {
      errorFactory = defaultErrorFactory;
    }
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        subscriber.next(value);
      }, function() {
        return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
      }));
    });
  }
  exports2.throwIfEmpty = throwIfEmpty;
  function defaultErrorFactory() {
    return new EmptyError_1.EmptyError;
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
var require_elementAt = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.elementAt = undefined;
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  var filter_1 = require_filter();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var take_1 = require_take();
  function elementAt(index, defaultValue) {
    if (index < 0) {
      throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
    }
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(filter_1.filter(function(v, i2) {
        return i2 === index;
      }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      }));
    };
  }
  exports2.elementAt = elementAt;
});

// node_modules/rxjs/dist/cjs/internal/operators/endWith.js
var require_endWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.endWith = undefined;
  var concat_1 = require_concat();
  var of_1 = require_of();
  function endWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    return function(source) {
      return concat_1.concat(source, of_1.of.apply(undefined, __spreadArray([], __read(values))));
    };
  }
  exports2.endWith = endWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/every.js
var require_every = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.every = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function every(predicate, thisArg) {
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (!predicate.call(thisArg, value, index++, source)) {
          subscriber.next(false);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports2.every = every;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
var require_exhaustMap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.exhaustMap = undefined;
  var map_1 = require_map();
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function exhaustMap(project, resultSelector) {
    if (resultSelector) {
      return function(source) {
        return source.pipe(exhaustMap(function(a, i2) {
          return innerFrom_1.innerFrom(project(a, i2)).pipe(map_1.map(function(b, ii) {
            return resultSelector(a, b, i2, ii);
          }));
        }));
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      var innerSub = null;
      var isComplete = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
        if (!innerSub) {
          innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
            innerSub = null;
            isComplete && subscriber.complete();
          });
          innerFrom_1.innerFrom(project(outerValue, index++)).subscribe(innerSub);
        }
      }, function() {
        isComplete = true;
        !innerSub && subscriber.complete();
      }));
    });
  }
  exports2.exhaustMap = exhaustMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
var require_exhaustAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.exhaustAll = undefined;
  var exhaustMap_1 = require_exhaustMap();
  var identity_1 = require_identity();
  function exhaustAll() {
    return exhaustMap_1.exhaustMap(identity_1.identity);
  }
  exports2.exhaustAll = exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
var require_exhaust = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.exhaust = undefined;
  var exhaustAll_1 = require_exhaustAll();
  exports2.exhaust = exhaustAll_1.exhaustAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/expand.js
var require_expand = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.expand = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function expand(project, concurrent, scheduler) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
    return lift_1.operate(function(source, subscriber) {
      return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, undefined, true, scheduler);
    });
  }
  exports2.expand = expand;
});

// node_modules/rxjs/dist/cjs/internal/operators/finalize.js
var require_finalize = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.finalize = undefined;
  var lift_1 = require_lift();
  function finalize(callback) {
    return lift_1.operate(function(source, subscriber) {
      try {
        source.subscribe(subscriber);
      } finally {
        subscriber.add(callback);
      }
    });
  }
  exports2.finalize = finalize;
});

// node_modules/rxjs/dist/cjs/internal/operators/find.js
var require_find = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.createFind = exports2.find = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function find(predicate, thisArg) {
    return lift_1.operate(createFind(predicate, thisArg, "value"));
  }
  exports2.find = find;
  function createFind(predicate, thisArg, emit) {
    var findIndex = emit === "index";
    return function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var i2 = index++;
        if (predicate.call(thisArg, value, i2, source)) {
          subscriber.next(findIndex ? i2 : value);
          subscriber.complete();
        }
      }, function() {
        subscriber.next(findIndex ? -1 : undefined);
        subscriber.complete();
      }));
    };
  }
  exports2.createFind = createFind;
});

// node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
var require_findIndex = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.findIndex = undefined;
  var lift_1 = require_lift();
  var find_1 = require_find();
  function findIndex(predicate, thisArg) {
    return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
  }
  exports2.findIndex = findIndex;
});

// node_modules/rxjs/dist/cjs/internal/operators/first.js
var require_first = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.first = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var take_1 = require_take();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var identity_1 = require_identity();
  function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports2.first = first;
});

// node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
var require_groupBy = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.groupBy = undefined;
  var Observable_1 = require_Observable();
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function groupBy(keySelector, elementOrOptions, duration, connector) {
    return lift_1.operate(function(source, subscriber) {
      var element;
      if (!elementOrOptions || typeof elementOrOptions === "function") {
        element = elementOrOptions;
      } else {
        duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
      }
      var groups = new Map;
      var notify = function(cb) {
        groups.forEach(cb);
        cb(subscriber);
      };
      var handleError = function(err2) {
        return notify(function(consumer) {
          return consumer.error(err2);
        });
      };
      var activeGroups = 0;
      var teardownAttempted = false;
      var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
        try {
          var key_1 = keySelector(value);
          var group_1 = groups.get(key_1);
          if (!group_1) {
            groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject);
            var grouped = createGroupedObservable(key_1, group_1);
            subscriber.next(grouped);
            if (duration) {
              var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                group_1.complete();
                durationSubscriber_1 === null || durationSubscriber_1 === undefined || durationSubscriber_1.unsubscribe();
              }, undefined, undefined, function() {
                return groups.delete(key_1);
              });
              groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
            }
          }
          group_1.next(element ? element(value) : value);
        } catch (err2) {
          handleError(err2);
        }
      }, function() {
        return notify(function(consumer) {
          return consumer.complete();
        });
      }, handleError, function() {
        return groups.clear();
      }, function() {
        teardownAttempted = true;
        return activeGroups === 0;
      });
      source.subscribe(groupBySourceSubscriber);
      function createGroupedObservable(key, groupSubject) {
        var result = new Observable_1.Observable(function(groupSubscriber) {
          activeGroups++;
          var innerSub = groupSubject.subscribe(groupSubscriber);
          return function() {
            innerSub.unsubscribe();
            --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
          };
        });
        result.key = key;
        return result;
      }
    });
  }
  exports2.groupBy = groupBy;
});

// node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
var require_isEmpty = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.isEmpty = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function isEmpty() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        subscriber.next(false);
        subscriber.complete();
      }, function() {
        subscriber.next(true);
        subscriber.complete();
      }));
    });
  }
  exports2.isEmpty = isEmpty;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
var require_takeLast = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.takeLast = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeLast(count) {
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var buffer = [];
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        buffer.push(value);
        count < buffer.length && buffer.shift();
      }, function() {
        var e_1, _a2;
        try {
          for (var buffer_1 = __values(buffer), buffer_1_1 = buffer_1.next();!buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
            var value = buffer_1_1.value;
            subscriber.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (buffer_1_1 && !buffer_1_1.done && (_a2 = buffer_1.return))
              _a2.call(buffer_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        subscriber.complete();
      }, undefined, function() {
        buffer = null;
      }));
    });
  }
  exports2.takeLast = takeLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/last.js
var require_last = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.last = undefined;
  var EmptyError_1 = require_EmptyError();
  var filter_1 = require_filter();
  var takeLast_1 = require_takeLast();
  var throwIfEmpty_1 = require_throwIfEmpty();
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  var identity_1 = require_identity();
  function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function(source) {
      return source.pipe(predicate ? filter_1.filter(function(v, i2) {
        return predicate(v, i2, source);
      }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
        return new EmptyError_1.EmptyError;
      }));
    };
  }
  exports2.last = last;
});

// node_modules/rxjs/dist/cjs/internal/operators/materialize.js
var require_materialize = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.materialize = undefined;
  var Notification_1 = require_Notification();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function materialize() {
    return lift_1.operate(function(source, subscriber) {
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(Notification_1.Notification.createNext(value));
      }, function() {
        subscriber.next(Notification_1.Notification.createComplete());
        subscriber.complete();
      }, function(err2) {
        subscriber.next(Notification_1.Notification.createError(err2));
        subscriber.complete();
      }));
    });
  }
  exports2.materialize = materialize;
});

// node_modules/rxjs/dist/cjs/internal/operators/max.js
var require_max = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.max = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function max2(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
      return comparer(x2, y) > 0 ? x2 : y;
    } : function(x2, y) {
      return x2 > y ? x2 : y;
    });
  }
  exports2.max = max2;
});

// node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
var require_flatMap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.flatMap = undefined;
  var mergeMap_1 = require_mergeMap();
  exports2.flatMap = mergeMap_1.mergeMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
var require_mergeMapTo = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeMapTo = undefined;
  var mergeMap_1 = require_mergeMap();
  var isFunction_1 = require_isFunction();
  function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    if (isFunction_1.isFunction(resultSelector)) {
      return mergeMap_1.mergeMap(function() {
        return innerObservable;
      }, resultSelector, concurrent);
    }
    if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return mergeMap_1.mergeMap(function() {
      return innerObservable;
    }, concurrent);
  }
  exports2.mergeMapTo = mergeMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
var require_mergeScan = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeScan = undefined;
  var lift_1 = require_lift();
  var mergeInternals_1 = require_mergeInternals();
  function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === undefined) {
      concurrent = Infinity;
    }
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      return mergeInternals_1.mergeInternals(source, subscriber, function(value, index) {
        return accumulator(state, value, index);
      }, concurrent, function(value) {
        state = value;
      }, false, undefined, function() {
        return state = null;
      });
    });
  }
  exports2.mergeScan = mergeScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/merge.js
var require_merge2 = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.merge = undefined;
  var lift_1 = require_lift();
  var mergeAll_1 = require_mergeAll();
  var args_1 = require_args();
  var from_1 = require_from();
  function merge() {
    var args = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(args);
    var concurrent = args_1.popNumber(args, Infinity);
    return lift_1.operate(function(source, subscriber) {
      mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
    });
  }
  exports2.merge = merge;
});

// node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
var require_mergeWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.mergeWith = undefined;
  var merge_1 = require_merge2();
  function mergeWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return merge_1.merge.apply(undefined, __spreadArray([], __read(otherSources)));
  }
  exports2.mergeWith = mergeWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/min.js
var require_min = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.min = undefined;
  var reduce_1 = require_reduce();
  var isFunction_1 = require_isFunction();
  function min(comparer) {
    return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y) {
      return comparer(x2, y) < 0 ? x2 : y;
    } : function(x2, y) {
      return x2 < y ? x2 : y;
    });
  }
  exports2.min = min;
});

// node_modules/rxjs/dist/cjs/internal/operators/multicast.js
var require_multicast = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.multicast = undefined;
  var ConnectableObservable_1 = require_ConnectableObservable();
  var isFunction_1 = require_isFunction();
  var connect_1 = require_connect();
  function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
      return subjectOrSubjectFactory;
    };
    if (isFunction_1.isFunction(selector)) {
      return connect_1.connect(selector, {
        connector: subjectFactory
      });
    }
    return function(source) {
      return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
    };
  }
  exports2.multicast = multicast;
});

// node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
var require_onErrorResumeNextWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.onErrorResumeNext = exports2.onErrorResumeNextWith = undefined;
  var argsOrArgArray_1 = require_argsOrArgArray();
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  function onErrorResumeNextWith() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
    return function(source) {
      return onErrorResumeNext_1.onErrorResumeNext.apply(undefined, __spreadArray([source], __read(nextSources)));
    };
  }
  exports2.onErrorResumeNextWith = onErrorResumeNextWith;
  exports2.onErrorResumeNext = onErrorResumeNextWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
var require_pairwise = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pairwise = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function pairwise() {
    return lift_1.operate(function(source, subscriber) {
      var prev;
      var hasPrev = false;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var p = prev;
        prev = value;
        hasPrev && subscriber.next([p, value]);
        hasPrev = true;
      }));
    });
  }
  exports2.pairwise = pairwise;
});

// node_modules/rxjs/dist/cjs/internal/operators/pluck.js
var require_pluck = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.pluck = undefined;
  var map_1 = require_map();
  function pluck() {
    var properties = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
      throw new Error("list of properties cannot be empty.");
    }
    return map_1.map(function(x2) {
      var currentProp = x2;
      for (var i2 = 0;i2 < length; i2++) {
        var p = currentProp === null || currentProp === undefined ? undefined : currentProp[properties[i2]];
        if (typeof p !== "undefined") {
          currentProp = p;
        } else {
          return;
        }
      }
      return currentProp;
    });
  }
  exports2.pluck = pluck;
});

// node_modules/rxjs/dist/cjs/internal/operators/publish.js
var require_publish = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.publish = undefined;
  var Subject_1 = require_Subject();
  var multicast_1 = require_multicast();
  var connect_1 = require_connect();
  function publish(selector) {
    return selector ? function(source) {
      return connect_1.connect(selector)(source);
    } : function(source) {
      return multicast_1.multicast(new Subject_1.Subject)(source);
    };
  }
  exports2.publish = publish;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
var require_publishBehavior = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.publishBehavior = undefined;
  var BehaviorSubject_1 = require_BehaviorSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishBehavior(initialValue) {
    return function(source) {
      var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports2.publishBehavior = publishBehavior;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
var require_publishLast = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.publishLast = undefined;
  var AsyncSubject_1 = require_AsyncSubject();
  var ConnectableObservable_1 = require_ConnectableObservable();
  function publishLast() {
    return function(source) {
      var subject = new AsyncSubject_1.AsyncSubject;
      return new ConnectableObservable_1.ConnectableObservable(source, function() {
        return subject;
      });
    };
  }
  exports2.publishLast = publishLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
var require_publishReplay = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.publishReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var multicast_1 = require_multicast();
  var isFunction_1 = require_isFunction();
  function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
    if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
      timestampProvider = selectorOrScheduler;
    }
    var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : undefined;
    return function(source) {
      return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
    };
  }
  exports2.publishReplay = publishReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
var require_raceWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.raceWith = undefined;
  var race_1 = require_race();
  var lift_1 = require_lift();
  var identity_1 = require_identity();
  function raceWith() {
    var otherSources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherSources[_i] = arguments[_i];
    }
    return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      race_1.raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
    });
  }
  exports2.raceWith = raceWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeat.js
var require_repeat = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.repeat = undefined;
  var empty_1 = require_empty();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var timer_1 = require_timer();
  function repeat(countOrConfig) {
    var _a2;
    var count = Infinity;
    var delay;
    if (countOrConfig != null) {
      if (typeof countOrConfig === "object") {
        _a2 = countOrConfig.count, count = _a2 === undefined ? Infinity : _a2, delay = countOrConfig.delay;
      } else {
        count = countOrConfig;
      }
    }
    return count <= 0 ? function() {
      return empty_1.EMPTY;
    } : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var sourceSub;
      var resubscribe = function() {
        sourceSub === null || sourceSub === undefined || sourceSub.unsubscribe();
        sourceSub = null;
        if (delay != null) {
          var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
          var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            notifierSubscriber_1.unsubscribe();
            subscribeToSource();
          });
          notifier.subscribe(notifierSubscriber_1);
        } else {
          subscribeToSource();
        }
      };
      var subscribeToSource = function() {
        var syncUnsub = false;
        sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          if (++soFar < count) {
            if (sourceSub) {
              resubscribe();
            } else {
              syncUnsub = true;
            }
          } else {
            subscriber.complete();
          }
        }));
        if (syncUnsub) {
          resubscribe();
        }
      };
      subscribeToSource();
    });
  }
  exports2.repeat = repeat;
});

// node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
var require_repeatWhen = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.repeatWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function repeatWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var completions$;
      var isNotifierComplete = false;
      var isMainComplete = false;
      var checkComplete = function() {
        return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
      };
      var getCompletionSubject = function() {
        if (!completions$) {
          completions$ = new Subject_1.Subject;
          innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (innerSub) {
              subscribeForRepeatWhen();
            } else {
              syncResub = true;
            }
          }, function() {
            isNotifierComplete = true;
            checkComplete();
          }));
        }
        return completions$;
      };
      var subscribeForRepeatWhen = function() {
        isMainComplete = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, function() {
          isMainComplete = true;
          !checkComplete() && getCompletionSubject().next();
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRepeatWhen();
        }
      };
      subscribeForRepeatWhen();
    });
  }
  exports2.repeatWhen = repeatWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/retry.js
var require_retry = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.retry = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  var timer_1 = require_timer();
  var innerFrom_1 = require_innerFrom();
  function retry2(configOrCount) {
    if (configOrCount === undefined) {
      configOrCount = Infinity;
    }
    var config;
    if (configOrCount && typeof configOrCount === "object") {
      config = configOrCount;
    } else {
      config = {
        count: configOrCount
      };
    }
    var _a2 = config.count, count = _a2 === undefined ? Infinity : _a2, delay = config.delay, _b2 = config.resetOnSuccess, resetOnSuccess = _b2 === undefined ? false : _b2;
    return count <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var soFar = 0;
      var innerSub;
      var subscribeForRetry = function() {
        var syncUnsub = false;
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          if (resetOnSuccess) {
            soFar = 0;
          }
          subscriber.next(value);
        }, undefined, function(err2) {
          if (soFar++ < count) {
            var resub_1 = function() {
              if (innerSub) {
                innerSub.unsubscribe();
                innerSub = null;
                subscribeForRetry();
              } else {
                syncUnsub = true;
              }
            };
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err2, soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                resub_1();
              }, function() {
                subscriber.complete();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              resub_1();
            }
          } else {
            subscriber.error(err2);
          }
        }));
        if (syncUnsub) {
          innerSub.unsubscribe();
          innerSub = null;
          subscribeForRetry();
        }
      };
      subscribeForRetry();
    });
  }
  exports2.retry = retry2;
});

// node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
var require_retryWhen = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.retryWhen = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function retryWhen(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var innerSub;
      var syncResub = false;
      var errors$;
      var subscribeForRetryWhen = function() {
        innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, undefined, undefined, function(err2) {
          if (!errors$) {
            errors$ = new Subject_1.Subject;
            innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
              return innerSub ? subscribeForRetryWhen() : syncResub = true;
            }));
          }
          if (errors$) {
            errors$.next(err2);
          }
        }));
        if (syncResub) {
          innerSub.unsubscribe();
          innerSub = null;
          syncResub = false;
          subscribeForRetryWhen();
        }
      };
      subscribeForRetryWhen();
    });
  }
  exports2.retryWhen = retryWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/sample.js
var require_sample = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.sample = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var noop_1 = require_noop();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function sample(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var lastValue = null;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        lastValue = value;
      }));
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        if (hasValue) {
          hasValue = false;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      }, noop_1.noop));
    });
  }
  exports2.sample = sample;
});

// node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
var require_sampleTime = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.sampleTime = undefined;
  var async_1 = require_async();
  var sample_1 = require_sample();
  var interval_1 = require_interval();
  function sampleTime(period, scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return sample_1.sample(interval_1.interval(period, scheduler));
  }
  exports2.sampleTime = sampleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/scan.js
var require_scan = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.scan = undefined;
  var lift_1 = require_lift();
  var scanInternals_1 = require_scanInternals();
  function scan(accumulator, seed) {
    return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
  }
  exports2.scan = scan;
});

// node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
var require_sequenceEqual = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.sequenceEqual = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function sequenceEqual(compareTo, comparator) {
    if (comparator === undefined) {
      comparator = function(a, b) {
        return a === b;
      };
    }
    return lift_1.operate(function(source, subscriber) {
      var aState = createState();
      var bState = createState();
      var emit = function(isEqual) {
        subscriber.next(isEqual);
        subscriber.complete();
      };
      var createSubscriber = function(selfState, otherState) {
        var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a) {
          var { buffer, complete } = otherState;
          if (buffer.length === 0) {
            complete ? emit(false) : selfState.buffer.push(a);
          } else {
            !comparator(a, buffer.shift()) && emit(false);
          }
        }, function() {
          selfState.complete = true;
          var { complete, buffer } = otherState;
          complete && emit(buffer.length === 0);
          sequenceEqualSubscriber === null || sequenceEqualSubscriber === undefined || sequenceEqualSubscriber.unsubscribe();
        });
        return sequenceEqualSubscriber;
      };
      source.subscribe(createSubscriber(aState, bState));
      innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
    });
  }
  exports2.sequenceEqual = sequenceEqual;
  function createState() {
    return {
      buffer: [],
      complete: false
    };
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/share.js
var require_share = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.share = undefined;
  var innerFrom_1 = require_innerFrom();
  var Subject_1 = require_Subject();
  var Subscriber_1 = require_Subscriber();
  var lift_1 = require_lift();
  function share(options) {
    if (options === undefined) {
      options = {};
    }
    var _a2 = options.connector, connector = _a2 === undefined ? function() {
      return new Subject_1.Subject;
    } : _a2, _b2 = options.resetOnError, resetOnError = _b2 === undefined ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === undefined ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === undefined ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === undefined || resetConnection.unsubscribe();
        resetConnection = undefined;
      };
      var reset = function() {
        cancelReset();
        connection = subject = undefined;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === undefined || conn.unsubscribe();
      };
      return lift_1.operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== undefined ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err2) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err2);
              dest.error(err2);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom_1.innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  exports2.share = share;
  function handleReset(reset, on) {
    var args = [];
    for (var _i = 2;_i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new Subscriber_1.SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom_1.innerFrom(on.apply(undefined, __spreadArray([], __read(args)))).subscribe(onSubscriber);
  }
});

// node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
var require_shareReplay = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.shareReplay = undefined;
  var ReplaySubject_1 = require_ReplaySubject();
  var share_1 = require_share();
  function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a2, _b2, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === undefined ? Infinity : _a2, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === undefined ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === undefined ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== undefined ? configOrBufferSize : Infinity;
    }
    return share_1.share({
      connector: function() {
        return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  }
  exports2.shareReplay = shareReplay;
});

// node_modules/rxjs/dist/cjs/internal/operators/single.js
var require_single = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.single = undefined;
  var EmptyError_1 = require_EmptyError();
  var SequenceError_1 = require_SequenceError();
  var NotFoundError_1 = require_NotFoundError();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function single(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var hasValue = false;
      var singleValue;
      var seenValue = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        seenValue = true;
        if (!predicate || predicate(value, index++, source)) {
          hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
          hasValue = true;
          singleValue = value;
        }
      }, function() {
        if (hasValue) {
          subscriber.next(singleValue);
          subscriber.complete();
        } else {
          subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError);
        }
      }));
    });
  }
  exports2.single = single;
});

// node_modules/rxjs/dist/cjs/internal/operators/skip.js
var require_skip = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.skip = undefined;
  var filter_1 = require_filter();
  function skip(count) {
    return filter_1.filter(function(_, index) {
      return count <= index;
    });
  }
  exports2.skip = skip;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
var require_skipLast = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.skipLast = undefined;
  var identity_1 = require_identity();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipLast(skipCount) {
    return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
      var ring = new Array(skipCount);
      var seen = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var valueIndex = seen++;
        if (valueIndex < skipCount) {
          ring[valueIndex] = value;
        } else {
          var index = valueIndex % skipCount;
          var oldValue = ring[index];
          ring[index] = value;
          subscriber.next(oldValue);
        }
      }));
      return function() {
        ring = null;
      };
    });
  }
  exports2.skipLast = skipLast;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
var require_skipUntil = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.skipUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function skipUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        skipSubscriber === null || skipSubscriber === undefined || skipSubscriber.unsubscribe();
        taking = true;
      }, noop_1.noop);
      innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return taking && subscriber.next(value);
      }));
    });
  }
  exports2.skipUntil = skipUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
var require_skipWhile = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.skipWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function skipWhile(predicate) {
    return lift_1.operate(function(source, subscriber) {
      var taking = false;
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return (taking || (taking = !predicate(value, index++))) && subscriber.next(value);
      }));
    });
  }
  exports2.skipWhile = skipWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/startWith.js
var require_startWith = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.startWith = undefined;
  var concat_1 = require_concat();
  var args_1 = require_args();
  var lift_1 = require_lift();
  function startWith() {
    var values = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = args_1.popScheduler(values);
    return lift_1.operate(function(source, subscriber) {
      (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
    });
  }
  exports2.startWith = startWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
var require_switchMap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.switchMap = undefined;
  var innerFrom_1 = require_innerFrom();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function switchMap(project, resultSelector) {
    return lift_1.operate(function(source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;
      var checkComplete = function() {
        return isComplete && !innerSubscriber && subscriber.complete();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        innerSubscriber === null || innerSubscriber === undefined || innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function() {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function() {
        isComplete = true;
        checkComplete();
      }));
    });
  }
  exports2.switchMap = switchMap;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
var require_switchAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.switchAll = undefined;
  var switchMap_1 = require_switchMap();
  var identity_1 = require_identity();
  function switchAll() {
    return switchMap_1.switchMap(identity_1.identity);
  }
  exports2.switchAll = switchAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
var require_switchMapTo = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.switchMapTo = undefined;
  var switchMap_1 = require_switchMap();
  var isFunction_1 = require_isFunction();
  function switchMapTo(innerObservable, resultSelector) {
    return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
      return innerObservable;
    }, resultSelector) : switchMap_1.switchMap(function() {
      return innerObservable;
    });
  }
  exports2.switchMapTo = switchMapTo;
});

// node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
var require_switchScan = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.switchScan = undefined;
  var switchMap_1 = require_switchMap();
  var lift_1 = require_lift();
  function switchScan(accumulator, seed) {
    return lift_1.operate(function(source, subscriber) {
      var state = seed;
      switchMap_1.switchMap(function(value, index) {
        return accumulator(state, value, index);
      }, function(_, innerValue) {
        return state = innerValue, innerValue;
      })(source).subscribe(subscriber);
      return function() {
        state = null;
      };
    });
  }
  exports2.switchScan = switchScan;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
var require_takeUntil = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.takeUntil = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var noop_1 = require_noop();
  function takeUntil(notifier) {
    return lift_1.operate(function(source, subscriber) {
      innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop_1.noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }
  exports2.takeUntil = takeUntil;
});

// node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
var require_takeWhile = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.takeWhile = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function takeWhile(predicate, inclusive) {
    if (inclusive === undefined) {
      inclusive = false;
    }
    return lift_1.operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var result = predicate(value, index++);
        (result || inclusive) && subscriber.next(value);
        !result && subscriber.complete();
      }));
    });
  }
  exports2.takeWhile = takeWhile;
});

// node_modules/rxjs/dist/cjs/internal/operators/tap.js
var require_tap = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.tap = undefined;
  var isFunction_1 = require_isFunction();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var identity_1 = require_identity();
  function tap(observerOrNext, error2, complete) {
    var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
    return tapObserver ? lift_1.operate(function(source, subscriber) {
      var _a2;
      (_a2 = tapObserver.subscribe) === null || _a2 === undefined || _a2.call(tapObserver);
      var isUnsub = true;
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var _a3;
        (_a3 = tapObserver.next) === null || _a3 === undefined || _a3.call(tapObserver, value);
        subscriber.next(value);
      }, function() {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.complete) === null || _a3 === undefined || _a3.call(tapObserver);
        subscriber.complete();
      }, function(err2) {
        var _a3;
        isUnsub = false;
        (_a3 = tapObserver.error) === null || _a3 === undefined || _a3.call(tapObserver, err2);
        subscriber.error(err2);
      }, function() {
        var _a3, _b2;
        if (isUnsub) {
          (_a3 = tapObserver.unsubscribe) === null || _a3 === undefined || _a3.call(tapObserver);
        }
        (_b2 = tapObserver.finalize) === null || _b2 === undefined || _b2.call(tapObserver);
      }));
    }) : identity_1.identity;
  }
  exports2.tap = tap;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttle.js
var require_throttle = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.throttle = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function throttle(durationSelector, config) {
    return lift_1.operate(function(source, subscriber) {
      var _a2 = config !== null && config !== undefined ? config : {}, _b2 = _a2.leading, leading = _b2 === undefined ? true : _b2, _c = _a2.trailing, trailing = _c === undefined ? false : _c;
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;
      var endThrottling = function() {
        throttled === null || throttled === undefined || throttled.unsubscribe();
        throttled = null;
        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };
      var cleanupThrottling = function() {
        throttled = null;
        isComplete && subscriber.complete();
      };
      var startThrottle = function(value) {
        return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };
      var send = function() {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function() {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }
  exports2.throttle = throttle;
});

// node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
var require_throttleTime = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.throttleTime = undefined;
  var async_1 = require_async();
  var throttle_1 = require_throttle();
  var timer_1 = require_timer();
  function throttleTime(duration, scheduler, config) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    var duration$ = timer_1.timer(duration, scheduler);
    return throttle_1.throttle(function() {
      return duration$;
    }, config);
  }
  exports2.throttleTime = throttleTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
var require_timeInterval = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TimeInterval = exports2.timeInterval = undefined;
  var async_1 = require_async();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function timeInterval(scheduler) {
    if (scheduler === undefined) {
      scheduler = async_1.asyncScheduler;
    }
    return lift_1.operate(function(source, subscriber) {
      var last = scheduler.now();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var now = scheduler.now();
        var interval = now - last;
        last = now;
        subscriber.next(new TimeInterval(value, interval));
      }));
    });
  }
  exports2.timeInterval = timeInterval;
  var TimeInterval = function() {
    function TimeInterval2(value, interval) {
      this.value = value;
      this.interval = interval;
    }
    return TimeInterval2;
  }();
  exports2.TimeInterval = TimeInterval;
});

// node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
var require_timeoutWith = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timeoutWith = undefined;
  var async_1 = require_async();
  var isDate_1 = require_isDate();
  var timeout_1 = require_timeout();
  function timeoutWith(due, withObservable, scheduler) {
    var first;
    var each;
    var _with;
    scheduler = scheduler !== null && scheduler !== undefined ? scheduler : async_1.async;
    if (isDate_1.isValidDate(due)) {
      first = due;
    } else if (typeof due === "number") {
      each = due;
    }
    if (withObservable) {
      _with = function() {
        return withObservable;
      };
    } else {
      throw new TypeError("No observable provided to switch to");
    }
    if (first == null && each == null) {
      throw new TypeError("No timeout provided.");
    }
    return timeout_1.timeout({
      first,
      each,
      scheduler,
      with: _with
    });
  }
  exports2.timeoutWith = timeoutWith;
});

// node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
var require_timestamp = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.timestamp = undefined;
  var dateTimestampProvider_1 = require_dateTimestampProvider();
  var map_1 = require_map();
  function timestamp(timestampProvider) {
    if (timestampProvider === undefined) {
      timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
    }
    return map_1.map(function(value) {
      return { value, timestamp: timestampProvider.now() };
    });
  }
  exports2.timestamp = timestamp;
});

// node_modules/rxjs/dist/cjs/internal/operators/window.js
var require_window = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.window = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var innerFrom_1 = require_innerFrom();
  function window2(windowBoundaries) {
    return lift_1.operate(function(source, subscriber) {
      var windowSubject = new Subject_1.Subject;
      subscriber.next(windowSubject.asObservable());
      var errorHandler2 = function(err2) {
        windowSubject.error(err2);
        subscriber.error(err2);
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return windowSubject === null || windowSubject === undefined ? undefined : windowSubject.next(value);
      }, function() {
        windowSubject.complete();
        subscriber.complete();
      }, errorHandler2));
      innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
        windowSubject.complete();
        subscriber.next(windowSubject = new Subject_1.Subject);
      }, noop_1.noop, errorHandler2));
      return function() {
        windowSubject === null || windowSubject === undefined || windowSubject.unsubscribe();
        windowSubject = null;
      };
    });
  }
  exports2.window = window2;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
var require_windowCount = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.windowCount = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === undefined) {
      startWindowEvery = 0;
    }
    var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
    return lift_1.operate(function(source, subscriber) {
      var windows = [new Subject_1.Subject];
      var starts = [];
      var count = 0;
      subscriber.next(windows[0].asObservable());
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        try {
          for (var windows_1 = __values(windows), windows_1_1 = windows_1.next();!windows_1_1.done; windows_1_1 = windows_1.next()) {
            var window_1 = windows_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windows_1_1 && !windows_1_1.done && (_a2 = windows_1.return))
              _a2.call(windows_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var c = count - windowSize + 1;
        if (c >= 0 && c % startEvery === 0) {
          windows.shift().complete();
        }
        if (++count % startEvery === 0) {
          var window_2 = new Subject_1.Subject;
          windows.push(window_2);
          subscriber.next(window_2.asObservable());
        }
      }, function() {
        while (windows.length > 0) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, function(err2) {
        while (windows.length > 0) {
          windows.shift().error(err2);
        }
        subscriber.error(err2);
      }, function() {
        starts = null;
        windows = null;
      }));
    });
  }
  exports2.windowCount = windowCount;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
var require_windowTime = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.windowTime = undefined;
  var Subject_1 = require_Subject();
  var async_1 = require_async();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var arrRemove_1 = require_arrRemove();
  var args_1 = require_args();
  var executeSchedule_1 = require_executeSchedule();
  function windowTime(windowTimeSpan) {
    var _a2, _b2;
    var otherArgs = [];
    for (var _i = 1;_i < arguments.length; _i++) {
      otherArgs[_i - 1] = arguments[_i];
    }
    var scheduler = (_a2 = args_1.popScheduler(otherArgs)) !== null && _a2 !== undefined ? _a2 : async_1.asyncScheduler;
    var windowCreationInterval = (_b2 = otherArgs[0]) !== null && _b2 !== undefined ? _b2 : null;
    var maxWindowSize = otherArgs[1] || Infinity;
    return lift_1.operate(function(source, subscriber) {
      var windowRecords = [];
      var restartOnClose = false;
      var closeWindow = function(record) {
        var { window: window2, subs } = record;
        window2.complete();
        subs.unsubscribe();
        arrRemove_1.arrRemove(windowRecords, record);
        restartOnClose && startWindow();
      };
      var startWindow = function() {
        if (windowRecords) {
          var subs = new Subscription_1.Subscription;
          subscriber.add(subs);
          var window_1 = new Subject_1.Subject;
          var record_1 = {
            window: window_1,
            subs,
            seen: 0
          };
          windowRecords.push(record_1);
          subscriber.next(window_1.asObservable());
          executeSchedule_1.executeSchedule(subs, scheduler, function() {
            return closeWindow(record_1);
          }, windowTimeSpan);
        }
      };
      if (windowCreationInterval !== null && windowCreationInterval >= 0) {
        executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
      } else {
        restartOnClose = true;
      }
      startWindow();
      var loop = function(cb) {
        return windowRecords.slice().forEach(cb);
      };
      var terminate = function(cb) {
        loop(function(_a3) {
          var window2 = _a3.window;
          return cb(window2);
        });
        cb(subscriber);
        subscriber.unsubscribe();
      };
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        loop(function(record) {
          record.window.next(value);
          maxWindowSize <= ++record.seen && closeWindow(record);
        });
      }, function() {
        return terminate(function(consumer) {
          return consumer.complete();
        });
      }, function(err2) {
        return terminate(function(consumer) {
          return consumer.error(err2);
        });
      }));
      return function() {
        windowRecords = null;
      };
    });
  }
  exports2.windowTime = windowTime;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
var require_windowToggle = __commonJS((exports2) => {
  var __values = exports2 && exports2.__values || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i2 >= o.length)
            o = undefined;
          return { value: o && o[i2++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.windowToggle = undefined;
  var Subject_1 = require_Subject();
  var Subscription_1 = require_Subscription();
  var lift_1 = require_lift();
  var innerFrom_1 = require_innerFrom();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var noop_1 = require_noop();
  var arrRemove_1 = require_arrRemove();
  function windowToggle(openings, closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var windows = [];
      var handleError = function(err2) {
        while (0 < windows.length) {
          windows.shift().error(err2);
        }
        subscriber.error(err2);
      };
      innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
        var window2 = new Subject_1.Subject;
        windows.push(window2);
        var closingSubscription = new Subscription_1.Subscription;
        var closeWindow = function() {
          arrRemove_1.arrRemove(windows, window2);
          window2.complete();
          closingSubscription.unsubscribe();
        };
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
        } catch (err2) {
          handleError(err2);
          return;
        }
        subscriber.next(window2.asObservable());
        closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
      }, noop_1.noop));
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        var e_1, _a2;
        var windowsCopy = windows.slice();
        try {
          for (var windowsCopy_1 = __values(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next();!windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
            var window_1 = windowsCopy_1_1.value;
            window_1.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a2 = windowsCopy_1.return))
              _a2.call(windowsCopy_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }, function() {
        while (0 < windows.length) {
          windows.shift().complete();
        }
        subscriber.complete();
      }, handleError, function() {
        while (0 < windows.length) {
          windows.shift().unsubscribe();
        }
      }));
    });
  }
  exports2.windowToggle = windowToggle;
});

// node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
var require_windowWhen = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.windowWhen = undefined;
  var Subject_1 = require_Subject();
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  function windowWhen(closingSelector) {
    return lift_1.operate(function(source, subscriber) {
      var window2;
      var closingSubscriber;
      var handleError = function(err2) {
        window2.error(err2);
        subscriber.error(err2);
      };
      var openWindow = function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 === null || window2 === undefined || window2.complete();
        window2 = new Subject_1.Subject;
        subscriber.next(window2.asObservable());
        var closingNotifier;
        try {
          closingNotifier = innerFrom_1.innerFrom(closingSelector());
        } catch (err2) {
          handleError(err2);
          return;
        }
        closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
      };
      openWindow();
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        return window2.next(value);
      }, function() {
        window2.complete();
        subscriber.complete();
      }, handleError, function() {
        closingSubscriber === null || closingSubscriber === undefined || closingSubscriber.unsubscribe();
        window2 = null;
      }));
    });
  }
  exports2.windowWhen = windowWhen;
});

// node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
var require_withLatestFrom = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.withLatestFrom = undefined;
  var lift_1 = require_lift();
  var OperatorSubscriber_1 = require_OperatorSubscriber();
  var innerFrom_1 = require_innerFrom();
  var identity_1 = require_identity();
  var noop_1 = require_noop();
  var args_1 = require_args();
  function withLatestFrom() {
    var inputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }
    var project = args_1.popResultSelector(inputs);
    return lift_1.operate(function(source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function() {
        return false;
      });
      var ready = false;
      var _loop_1 = function(i3) {
        innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
          otherValues[i3] = value;
          if (!ready && !hasValue[i3]) {
            hasValue[i3] = true;
            (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
          }
        }, noop_1.noop));
      };
      for (var i2 = 0;i2 < len; i2++) {
        _loop_1(i2);
      }
      source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
        if (ready) {
          var values = __spreadArray([value], __read(otherValues));
          subscriber.next(project ? project.apply(undefined, __spreadArray([], __read(values))) : values);
        }
      }));
    });
  }
  exports2.withLatestFrom = withLatestFrom;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
var require_zipAll = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.zipAll = undefined;
  var zip_1 = require_zip();
  var joinAllInternals_1 = require_joinAllInternals();
  function zipAll(project) {
    return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
  }
  exports2.zipAll = zipAll;
});

// node_modules/rxjs/dist/cjs/internal/operators/zip.js
var require_zip2 = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.zip = undefined;
  var zip_1 = require_zip();
  var lift_1 = require_lift();
  function zip() {
    var sources = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      sources[_i] = arguments[_i];
    }
    return lift_1.operate(function(source, subscriber) {
      zip_1.zip.apply(undefined, __spreadArray([source], __read(sources))).subscribe(subscriber);
    });
  }
  exports2.zip = zip;
});

// node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
var require_zipWith = __commonJS((exports2) => {
  var __read = exports2 && exports2.__read || function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i2 = m.call(o), r, ar = [], e;
    try {
      while ((n === undefined || n-- > 0) && !(r = i2.next()).done)
        ar.push(r.value);
    } catch (error2) {
      e = { error: error2 };
    } finally {
      try {
        if (r && !r.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = exports2 && exports2.__spreadArray || function(to, from) {
    for (var i2 = 0, il = from.length, j = to.length;i2 < il; i2++, j++)
      to[j] = from[i2];
    return to;
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.zipWith = undefined;
  var zip_1 = require_zip2();
  function zipWith() {
    var otherInputs = [];
    for (var _i = 0;_i < arguments.length; _i++) {
      otherInputs[_i] = arguments[_i];
    }
    return zip_1.zip.apply(undefined, __spreadArray([], __read(otherInputs)));
  }
  exports2.zipWith = zipWith;
});

// node_modules/rxjs/dist/cjs/index.js
var require_cjs = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.interval = exports2.iif = exports2.generate = exports2.fromEventPattern = exports2.fromEvent = exports2.from = exports2.forkJoin = exports2.empty = exports2.defer = exports2.connectable = exports2.concat = exports2.combineLatest = exports2.bindNodeCallback = exports2.bindCallback = exports2.UnsubscriptionError = exports2.TimeoutError = exports2.SequenceError = exports2.ObjectUnsubscribedError = exports2.NotFoundError = exports2.EmptyError = exports2.ArgumentOutOfRangeError = exports2.firstValueFrom = exports2.lastValueFrom = exports2.isObservable = exports2.identity = exports2.noop = exports2.pipe = exports2.NotificationKind = exports2.Notification = exports2.Subscriber = exports2.Subscription = exports2.Scheduler = exports2.VirtualAction = exports2.VirtualTimeScheduler = exports2.animationFrameScheduler = exports2.animationFrame = exports2.queueScheduler = exports2.queue = exports2.asyncScheduler = exports2.async = exports2.asapScheduler = exports2.asap = exports2.AsyncSubject = exports2.ReplaySubject = exports2.BehaviorSubject = exports2.Subject = exports2.animationFrames = exports2.observable = exports2.ConnectableObservable = exports2.Observable = undefined;
  exports2.filter = exports2.expand = exports2.exhaustMap = exports2.exhaustAll = exports2.exhaust = exports2.every = exports2.endWith = exports2.elementAt = exports2.distinctUntilKeyChanged = exports2.distinctUntilChanged = exports2.distinct = exports2.dematerialize = exports2.delayWhen = exports2.delay = exports2.defaultIfEmpty = exports2.debounceTime = exports2.debounce = exports2.count = exports2.connect = exports2.concatWith = exports2.concatMapTo = exports2.concatMap = exports2.concatAll = exports2.combineLatestWith = exports2.combineLatestAll = exports2.combineAll = exports2.catchError = exports2.bufferWhen = exports2.bufferToggle = exports2.bufferTime = exports2.bufferCount = exports2.buffer = exports2.auditTime = exports2.audit = exports2.config = exports2.NEVER = exports2.EMPTY = exports2.scheduled = exports2.zip = exports2.using = exports2.timer = exports2.throwError = exports2.range = exports2.race = exports2.partition = exports2.pairs = exports2.onErrorResumeNext = exports2.of = exports2.never = exports2.merge = undefined;
  exports2.switchMap = exports2.switchAll = exports2.subscribeOn = exports2.startWith = exports2.skipWhile = exports2.skipUntil = exports2.skipLast = exports2.skip = exports2.single = exports2.shareReplay = exports2.share = exports2.sequenceEqual = exports2.scan = exports2.sampleTime = exports2.sample = exports2.refCount = exports2.retryWhen = exports2.retry = exports2.repeatWhen = exports2.repeat = exports2.reduce = exports2.raceWith = exports2.publishReplay = exports2.publishLast = exports2.publishBehavior = exports2.publish = exports2.pluck = exports2.pairwise = exports2.onErrorResumeNextWith = exports2.observeOn = exports2.multicast = exports2.min = exports2.mergeWith = exports2.mergeScan = exports2.mergeMapTo = exports2.mergeMap = exports2.flatMap = exports2.mergeAll = exports2.max = exports2.materialize = exports2.mapTo = exports2.map = exports2.last = exports2.isEmpty = exports2.ignoreElements = exports2.groupBy = exports2.first = exports2.findIndex = exports2.find = exports2.finalize = undefined;
  exports2.zipWith = exports2.zipAll = exports2.withLatestFrom = exports2.windowWhen = exports2.windowToggle = exports2.windowTime = exports2.windowCount = exports2.window = exports2.toArray = exports2.timestamp = exports2.timeoutWith = exports2.timeout = exports2.timeInterval = exports2.throwIfEmpty = exports2.throttleTime = exports2.throttle = exports2.tap = exports2.takeWhile = exports2.takeUntil = exports2.takeLast = exports2.take = exports2.switchScan = exports2.switchMapTo = undefined;
  var Observable_1 = require_Observable();
  Object.defineProperty(exports2, "Observable", { enumerable: true, get: function() {
    return Observable_1.Observable;
  } });
  var ConnectableObservable_1 = require_ConnectableObservable();
  Object.defineProperty(exports2, "ConnectableObservable", { enumerable: true, get: function() {
    return ConnectableObservable_1.ConnectableObservable;
  } });
  var observable_1 = require_observable();
  Object.defineProperty(exports2, "observable", { enumerable: true, get: function() {
    return observable_1.observable;
  } });
  var animationFrames_1 = require_animationFrames();
  Object.defineProperty(exports2, "animationFrames", { enumerable: true, get: function() {
    return animationFrames_1.animationFrames;
  } });
  var Subject_1 = require_Subject();
  Object.defineProperty(exports2, "Subject", { enumerable: true, get: function() {
    return Subject_1.Subject;
  } });
  var BehaviorSubject_1 = require_BehaviorSubject();
  Object.defineProperty(exports2, "BehaviorSubject", { enumerable: true, get: function() {
    return BehaviorSubject_1.BehaviorSubject;
  } });
  var ReplaySubject_1 = require_ReplaySubject();
  Object.defineProperty(exports2, "ReplaySubject", { enumerable: true, get: function() {
    return ReplaySubject_1.ReplaySubject;
  } });
  var AsyncSubject_1 = require_AsyncSubject();
  Object.defineProperty(exports2, "AsyncSubject", { enumerable: true, get: function() {
    return AsyncSubject_1.AsyncSubject;
  } });
  var asap_1 = require_asap();
  Object.defineProperty(exports2, "asap", { enumerable: true, get: function() {
    return asap_1.asap;
  } });
  Object.defineProperty(exports2, "asapScheduler", { enumerable: true, get: function() {
    return asap_1.asapScheduler;
  } });
  var async_1 = require_async();
  Object.defineProperty(exports2, "async", { enumerable: true, get: function() {
    return async_1.async;
  } });
  Object.defineProperty(exports2, "asyncScheduler", { enumerable: true, get: function() {
    return async_1.asyncScheduler;
  } });
  var queue_1 = require_queue();
  Object.defineProperty(exports2, "queue", { enumerable: true, get: function() {
    return queue_1.queue;
  } });
  Object.defineProperty(exports2, "queueScheduler", { enumerable: true, get: function() {
    return queue_1.queueScheduler;
  } });
  var animationFrame_1 = require_animationFrame();
  Object.defineProperty(exports2, "animationFrame", { enumerable: true, get: function() {
    return animationFrame_1.animationFrame;
  } });
  Object.defineProperty(exports2, "animationFrameScheduler", { enumerable: true, get: function() {
    return animationFrame_1.animationFrameScheduler;
  } });
  var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
  Object.defineProperty(exports2, "VirtualTimeScheduler", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualTimeScheduler;
  } });
  Object.defineProperty(exports2, "VirtualAction", { enumerable: true, get: function() {
    return VirtualTimeScheduler_1.VirtualAction;
  } });
  var Scheduler_1 = require_Scheduler();
  Object.defineProperty(exports2, "Scheduler", { enumerable: true, get: function() {
    return Scheduler_1.Scheduler;
  } });
  var Subscription_1 = require_Subscription();
  Object.defineProperty(exports2, "Subscription", { enumerable: true, get: function() {
    return Subscription_1.Subscription;
  } });
  var Subscriber_1 = require_Subscriber();
  Object.defineProperty(exports2, "Subscriber", { enumerable: true, get: function() {
    return Subscriber_1.Subscriber;
  } });
  var Notification_1 = require_Notification();
  Object.defineProperty(exports2, "Notification", { enumerable: true, get: function() {
    return Notification_1.Notification;
  } });
  Object.defineProperty(exports2, "NotificationKind", { enumerable: true, get: function() {
    return Notification_1.NotificationKind;
  } });
  var pipe_1 = require_pipe();
  Object.defineProperty(exports2, "pipe", { enumerable: true, get: function() {
    return pipe_1.pipe;
  } });
  var noop_1 = require_noop();
  Object.defineProperty(exports2, "noop", { enumerable: true, get: function() {
    return noop_1.noop;
  } });
  var identity_1 = require_identity();
  Object.defineProperty(exports2, "identity", { enumerable: true, get: function() {
    return identity_1.identity;
  } });
  var isObservable_1 = require_isObservable();
  Object.defineProperty(exports2, "isObservable", { enumerable: true, get: function() {
    return isObservable_1.isObservable;
  } });
  var lastValueFrom_1 = require_lastValueFrom();
  Object.defineProperty(exports2, "lastValueFrom", { enumerable: true, get: function() {
    return lastValueFrom_1.lastValueFrom;
  } });
  var firstValueFrom_1 = require_firstValueFrom();
  Object.defineProperty(exports2, "firstValueFrom", { enumerable: true, get: function() {
    return firstValueFrom_1.firstValueFrom;
  } });
  var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
  Object.defineProperty(exports2, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
    return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
  } });
  var EmptyError_1 = require_EmptyError();
  Object.defineProperty(exports2, "EmptyError", { enumerable: true, get: function() {
    return EmptyError_1.EmptyError;
  } });
  var NotFoundError_1 = require_NotFoundError();
  Object.defineProperty(exports2, "NotFoundError", { enumerable: true, get: function() {
    return NotFoundError_1.NotFoundError;
  } });
  var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
  Object.defineProperty(exports2, "ObjectUnsubscribedError", { enumerable: true, get: function() {
    return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
  } });
  var SequenceError_1 = require_SequenceError();
  Object.defineProperty(exports2, "SequenceError", { enumerable: true, get: function() {
    return SequenceError_1.SequenceError;
  } });
  var timeout_1 = require_timeout();
  Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
    return timeout_1.TimeoutError;
  } });
  var UnsubscriptionError_1 = require_UnsubscriptionError();
  Object.defineProperty(exports2, "UnsubscriptionError", { enumerable: true, get: function() {
    return UnsubscriptionError_1.UnsubscriptionError;
  } });
  var bindCallback_1 = require_bindCallback();
  Object.defineProperty(exports2, "bindCallback", { enumerable: true, get: function() {
    return bindCallback_1.bindCallback;
  } });
  var bindNodeCallback_1 = require_bindNodeCallback();
  Object.defineProperty(exports2, "bindNodeCallback", { enumerable: true, get: function() {
    return bindNodeCallback_1.bindNodeCallback;
  } });
  var combineLatest_1 = require_combineLatest();
  Object.defineProperty(exports2, "combineLatest", { enumerable: true, get: function() {
    return combineLatest_1.combineLatest;
  } });
  var concat_1 = require_concat();
  Object.defineProperty(exports2, "concat", { enumerable: true, get: function() {
    return concat_1.concat;
  } });
  var connectable_1 = require_connectable();
  Object.defineProperty(exports2, "connectable", { enumerable: true, get: function() {
    return connectable_1.connectable;
  } });
  var defer_1 = require_defer();
  Object.defineProperty(exports2, "defer", { enumerable: true, get: function() {
    return defer_1.defer;
  } });
  var empty_1 = require_empty();
  Object.defineProperty(exports2, "empty", { enumerable: true, get: function() {
    return empty_1.empty;
  } });
  var forkJoin_1 = require_forkJoin();
  Object.defineProperty(exports2, "forkJoin", { enumerable: true, get: function() {
    return forkJoin_1.forkJoin;
  } });
  var from_1 = require_from();
  Object.defineProperty(exports2, "from", { enumerable: true, get: function() {
    return from_1.from;
  } });
  var fromEvent_1 = require_fromEvent();
  Object.defineProperty(exports2, "fromEvent", { enumerable: true, get: function() {
    return fromEvent_1.fromEvent;
  } });
  var fromEventPattern_1 = require_fromEventPattern();
  Object.defineProperty(exports2, "fromEventPattern", { enumerable: true, get: function() {
    return fromEventPattern_1.fromEventPattern;
  } });
  var generate_1 = require_generate();
  Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
    return generate_1.generate;
  } });
  var iif_1 = require_iif();
  Object.defineProperty(exports2, "iif", { enumerable: true, get: function() {
    return iif_1.iif;
  } });
  var interval_1 = require_interval();
  Object.defineProperty(exports2, "interval", { enumerable: true, get: function() {
    return interval_1.interval;
  } });
  var merge_1 = require_merge();
  Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
    return merge_1.merge;
  } });
  var never_1 = require_never();
  Object.defineProperty(exports2, "never", { enumerable: true, get: function() {
    return never_1.never;
  } });
  var of_1 = require_of();
  Object.defineProperty(exports2, "of", { enumerable: true, get: function() {
    return of_1.of;
  } });
  var onErrorResumeNext_1 = require_onErrorResumeNext();
  Object.defineProperty(exports2, "onErrorResumeNext", { enumerable: true, get: function() {
    return onErrorResumeNext_1.onErrorResumeNext;
  } });
  var pairs_1 = require_pairs();
  Object.defineProperty(exports2, "pairs", { enumerable: true, get: function() {
    return pairs_1.pairs;
  } });
  var partition_1 = require_partition();
  Object.defineProperty(exports2, "partition", { enumerable: true, get: function() {
    return partition_1.partition;
  } });
  var race_1 = require_race();
  Object.defineProperty(exports2, "race", { enumerable: true, get: function() {
    return race_1.race;
  } });
  var range_1 = require_range();
  Object.defineProperty(exports2, "range", { enumerable: true, get: function() {
    return range_1.range;
  } });
  var throwError_1 = require_throwError();
  Object.defineProperty(exports2, "throwError", { enumerable: true, get: function() {
    return throwError_1.throwError;
  } });
  var timer_1 = require_timer();
  Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
    return timer_1.timer;
  } });
  var using_1 = require_using();
  Object.defineProperty(exports2, "using", { enumerable: true, get: function() {
    return using_1.using;
  } });
  var zip_1 = require_zip();
  Object.defineProperty(exports2, "zip", { enumerable: true, get: function() {
    return zip_1.zip;
  } });
  var scheduled_1 = require_scheduled();
  Object.defineProperty(exports2, "scheduled", { enumerable: true, get: function() {
    return scheduled_1.scheduled;
  } });
  var empty_2 = require_empty();
  Object.defineProperty(exports2, "EMPTY", { enumerable: true, get: function() {
    return empty_2.EMPTY;
  } });
  var never_2 = require_never();
  Object.defineProperty(exports2, "NEVER", { enumerable: true, get: function() {
    return never_2.NEVER;
  } });
  __exportStar(require_types(), exports2);
  var config_1 = require_config();
  Object.defineProperty(exports2, "config", { enumerable: true, get: function() {
    return config_1.config;
  } });
  var audit_1 = require_audit();
  Object.defineProperty(exports2, "audit", { enumerable: true, get: function() {
    return audit_1.audit;
  } });
  var auditTime_1 = require_auditTime();
  Object.defineProperty(exports2, "auditTime", { enumerable: true, get: function() {
    return auditTime_1.auditTime;
  } });
  var buffer_1 = require_buffer();
  Object.defineProperty(exports2, "buffer", { enumerable: true, get: function() {
    return buffer_1.buffer;
  } });
  var bufferCount_1 = require_bufferCount();
  Object.defineProperty(exports2, "bufferCount", { enumerable: true, get: function() {
    return bufferCount_1.bufferCount;
  } });
  var bufferTime_1 = require_bufferTime();
  Object.defineProperty(exports2, "bufferTime", { enumerable: true, get: function() {
    return bufferTime_1.bufferTime;
  } });
  var bufferToggle_1 = require_bufferToggle();
  Object.defineProperty(exports2, "bufferToggle", { enumerable: true, get: function() {
    return bufferToggle_1.bufferToggle;
  } });
  var bufferWhen_1 = require_bufferWhen();
  Object.defineProperty(exports2, "bufferWhen", { enumerable: true, get: function() {
    return bufferWhen_1.bufferWhen;
  } });
  var catchError_1 = require_catchError();
  Object.defineProperty(exports2, "catchError", { enumerable: true, get: function() {
    return catchError_1.catchError;
  } });
  var combineAll_1 = require_combineAll();
  Object.defineProperty(exports2, "combineAll", { enumerable: true, get: function() {
    return combineAll_1.combineAll;
  } });
  var combineLatestAll_1 = require_combineLatestAll();
  Object.defineProperty(exports2, "combineLatestAll", { enumerable: true, get: function() {
    return combineLatestAll_1.combineLatestAll;
  } });
  var combineLatestWith_1 = require_combineLatestWith();
  Object.defineProperty(exports2, "combineLatestWith", { enumerable: true, get: function() {
    return combineLatestWith_1.combineLatestWith;
  } });
  var concatAll_1 = require_concatAll();
  Object.defineProperty(exports2, "concatAll", { enumerable: true, get: function() {
    return concatAll_1.concatAll;
  } });
  var concatMap_1 = require_concatMap();
  Object.defineProperty(exports2, "concatMap", { enumerable: true, get: function() {
    return concatMap_1.concatMap;
  } });
  var concatMapTo_1 = require_concatMapTo();
  Object.defineProperty(exports2, "concatMapTo", { enumerable: true, get: function() {
    return concatMapTo_1.concatMapTo;
  } });
  var concatWith_1 = require_concatWith();
  Object.defineProperty(exports2, "concatWith", { enumerable: true, get: function() {
    return concatWith_1.concatWith;
  } });
  var connect_1 = require_connect();
  Object.defineProperty(exports2, "connect", { enumerable: true, get: function() {
    return connect_1.connect;
  } });
  var count_1 = require_count();
  Object.defineProperty(exports2, "count", { enumerable: true, get: function() {
    return count_1.count;
  } });
  var debounce_1 = require_debounce();
  Object.defineProperty(exports2, "debounce", { enumerable: true, get: function() {
    return debounce_1.debounce;
  } });
  var debounceTime_1 = require_debounceTime();
  Object.defineProperty(exports2, "debounceTime", { enumerable: true, get: function() {
    return debounceTime_1.debounceTime;
  } });
  var defaultIfEmpty_1 = require_defaultIfEmpty();
  Object.defineProperty(exports2, "defaultIfEmpty", { enumerable: true, get: function() {
    return defaultIfEmpty_1.defaultIfEmpty;
  } });
  var delay_1 = require_delay();
  Object.defineProperty(exports2, "delay", { enumerable: true, get: function() {
    return delay_1.delay;
  } });
  var delayWhen_1 = require_delayWhen();
  Object.defineProperty(exports2, "delayWhen", { enumerable: true, get: function() {
    return delayWhen_1.delayWhen;
  } });
  var dematerialize_1 = require_dematerialize();
  Object.defineProperty(exports2, "dematerialize", { enumerable: true, get: function() {
    return dematerialize_1.dematerialize;
  } });
  var distinct_1 = require_distinct();
  Object.defineProperty(exports2, "distinct", { enumerable: true, get: function() {
    return distinct_1.distinct;
  } });
  var distinctUntilChanged_1 = require_distinctUntilChanged();
  Object.defineProperty(exports2, "distinctUntilChanged", { enumerable: true, get: function() {
    return distinctUntilChanged_1.distinctUntilChanged;
  } });
  var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
  Object.defineProperty(exports2, "distinctUntilKeyChanged", { enumerable: true, get: function() {
    return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
  } });
  var elementAt_1 = require_elementAt();
  Object.defineProperty(exports2, "elementAt", { enumerable: true, get: function() {
    return elementAt_1.elementAt;
  } });
  var endWith_1 = require_endWith();
  Object.defineProperty(exports2, "endWith", { enumerable: true, get: function() {
    return endWith_1.endWith;
  } });
  var every_1 = require_every();
  Object.defineProperty(exports2, "every", { enumerable: true, get: function() {
    return every_1.every;
  } });
  var exhaust_1 = require_exhaust();
  Object.defineProperty(exports2, "exhaust", { enumerable: true, get: function() {
    return exhaust_1.exhaust;
  } });
  var exhaustAll_1 = require_exhaustAll();
  Object.defineProperty(exports2, "exhaustAll", { enumerable: true, get: function() {
    return exhaustAll_1.exhaustAll;
  } });
  var exhaustMap_1 = require_exhaustMap();
  Object.defineProperty(exports2, "exhaustMap", { enumerable: true, get: function() {
    return exhaustMap_1.exhaustMap;
  } });
  var expand_1 = require_expand();
  Object.defineProperty(exports2, "expand", { enumerable: true, get: function() {
    return expand_1.expand;
  } });
  var filter_1 = require_filter();
  Object.defineProperty(exports2, "filter", { enumerable: true, get: function() {
    return filter_1.filter;
  } });
  var finalize_1 = require_finalize();
  Object.defineProperty(exports2, "finalize", { enumerable: true, get: function() {
    return finalize_1.finalize;
  } });
  var find_1 = require_find();
  Object.defineProperty(exports2, "find", { enumerable: true, get: function() {
    return find_1.find;
  } });
  var findIndex_1 = require_findIndex();
  Object.defineProperty(exports2, "findIndex", { enumerable: true, get: function() {
    return findIndex_1.findIndex;
  } });
  var first_1 = require_first();
  Object.defineProperty(exports2, "first", { enumerable: true, get: function() {
    return first_1.first;
  } });
  var groupBy_1 = require_groupBy();
  Object.defineProperty(exports2, "groupBy", { enumerable: true, get: function() {
    return groupBy_1.groupBy;
  } });
  var ignoreElements_1 = require_ignoreElements();
  Object.defineProperty(exports2, "ignoreElements", { enumerable: true, get: function() {
    return ignoreElements_1.ignoreElements;
  } });
  var isEmpty_1 = require_isEmpty();
  Object.defineProperty(exports2, "isEmpty", { enumerable: true, get: function() {
    return isEmpty_1.isEmpty;
  } });
  var last_1 = require_last();
  Object.defineProperty(exports2, "last", { enumerable: true, get: function() {
    return last_1.last;
  } });
  var map_1 = require_map();
  Object.defineProperty(exports2, "map", { enumerable: true, get: function() {
    return map_1.map;
  } });
  var mapTo_1 = require_mapTo();
  Object.defineProperty(exports2, "mapTo", { enumerable: true, get: function() {
    return mapTo_1.mapTo;
  } });
  var materialize_1 = require_materialize();
  Object.defineProperty(exports2, "materialize", { enumerable: true, get: function() {
    return materialize_1.materialize;
  } });
  var max_1 = require_max();
  Object.defineProperty(exports2, "max", { enumerable: true, get: function() {
    return max_1.max;
  } });
  var mergeAll_1 = require_mergeAll();
  Object.defineProperty(exports2, "mergeAll", { enumerable: true, get: function() {
    return mergeAll_1.mergeAll;
  } });
  var flatMap_1 = require_flatMap();
  Object.defineProperty(exports2, "flatMap", { enumerable: true, get: function() {
    return flatMap_1.flatMap;
  } });
  var mergeMap_1 = require_mergeMap();
  Object.defineProperty(exports2, "mergeMap", { enumerable: true, get: function() {
    return mergeMap_1.mergeMap;
  } });
  var mergeMapTo_1 = require_mergeMapTo();
  Object.defineProperty(exports2, "mergeMapTo", { enumerable: true, get: function() {
    return mergeMapTo_1.mergeMapTo;
  } });
  var mergeScan_1 = require_mergeScan();
  Object.defineProperty(exports2, "mergeScan", { enumerable: true, get: function() {
    return mergeScan_1.mergeScan;
  } });
  var mergeWith_1 = require_mergeWith();
  Object.defineProperty(exports2, "mergeWith", { enumerable: true, get: function() {
    return mergeWith_1.mergeWith;
  } });
  var min_1 = require_min();
  Object.defineProperty(exports2, "min", { enumerable: true, get: function() {
    return min_1.min;
  } });
  var multicast_1 = require_multicast();
  Object.defineProperty(exports2, "multicast", { enumerable: true, get: function() {
    return multicast_1.multicast;
  } });
  var observeOn_1 = require_observeOn();
  Object.defineProperty(exports2, "observeOn", { enumerable: true, get: function() {
    return observeOn_1.observeOn;
  } });
  var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
  Object.defineProperty(exports2, "onErrorResumeNextWith", { enumerable: true, get: function() {
    return onErrorResumeNextWith_1.onErrorResumeNextWith;
  } });
  var pairwise_1 = require_pairwise();
  Object.defineProperty(exports2, "pairwise", { enumerable: true, get: function() {
    return pairwise_1.pairwise;
  } });
  var pluck_1 = require_pluck();
  Object.defineProperty(exports2, "pluck", { enumerable: true, get: function() {
    return pluck_1.pluck;
  } });
  var publish_1 = require_publish();
  Object.defineProperty(exports2, "publish", { enumerable: true, get: function() {
    return publish_1.publish;
  } });
  var publishBehavior_1 = require_publishBehavior();
  Object.defineProperty(exports2, "publishBehavior", { enumerable: true, get: function() {
    return publishBehavior_1.publishBehavior;
  } });
  var publishLast_1 = require_publishLast();
  Object.defineProperty(exports2, "publishLast", { enumerable: true, get: function() {
    return publishLast_1.publishLast;
  } });
  var publishReplay_1 = require_publishReplay();
  Object.defineProperty(exports2, "publishReplay", { enumerable: true, get: function() {
    return publishReplay_1.publishReplay;
  } });
  var raceWith_1 = require_raceWith();
  Object.defineProperty(exports2, "raceWith", { enumerable: true, get: function() {
    return raceWith_1.raceWith;
  } });
  var reduce_1 = require_reduce();
  Object.defineProperty(exports2, "reduce", { enumerable: true, get: function() {
    return reduce_1.reduce;
  } });
  var repeat_1 = require_repeat();
  Object.defineProperty(exports2, "repeat", { enumerable: true, get: function() {
    return repeat_1.repeat;
  } });
  var repeatWhen_1 = require_repeatWhen();
  Object.defineProperty(exports2, "repeatWhen", { enumerable: true, get: function() {
    return repeatWhen_1.repeatWhen;
  } });
  var retry_1 = require_retry();
  Object.defineProperty(exports2, "retry", { enumerable: true, get: function() {
    return retry_1.retry;
  } });
  var retryWhen_1 = require_retryWhen();
  Object.defineProperty(exports2, "retryWhen", { enumerable: true, get: function() {
    return retryWhen_1.retryWhen;
  } });
  var refCount_1 = require_refCount();
  Object.defineProperty(exports2, "refCount", { enumerable: true, get: function() {
    return refCount_1.refCount;
  } });
  var sample_1 = require_sample();
  Object.defineProperty(exports2, "sample", { enumerable: true, get: function() {
    return sample_1.sample;
  } });
  var sampleTime_1 = require_sampleTime();
  Object.defineProperty(exports2, "sampleTime", { enumerable: true, get: function() {
    return sampleTime_1.sampleTime;
  } });
  var scan_1 = require_scan();
  Object.defineProperty(exports2, "scan", { enumerable: true, get: function() {
    return scan_1.scan;
  } });
  var sequenceEqual_1 = require_sequenceEqual();
  Object.defineProperty(exports2, "sequenceEqual", { enumerable: true, get: function() {
    return sequenceEqual_1.sequenceEqual;
  } });
  var share_1 = require_share();
  Object.defineProperty(exports2, "share", { enumerable: true, get: function() {
    return share_1.share;
  } });
  var shareReplay_1 = require_shareReplay();
  Object.defineProperty(exports2, "shareReplay", { enumerable: true, get: function() {
    return shareReplay_1.shareReplay;
  } });
  var single_1 = require_single();
  Object.defineProperty(exports2, "single", { enumerable: true, get: function() {
    return single_1.single;
  } });
  var skip_1 = require_skip();
  Object.defineProperty(exports2, "skip", { enumerable: true, get: function() {
    return skip_1.skip;
  } });
  var skipLast_1 = require_skipLast();
  Object.defineProperty(exports2, "skipLast", { enumerable: true, get: function() {
    return skipLast_1.skipLast;
  } });
  var skipUntil_1 = require_skipUntil();
  Object.defineProperty(exports2, "skipUntil", { enumerable: true, get: function() {
    return skipUntil_1.skipUntil;
  } });
  var skipWhile_1 = require_skipWhile();
  Object.defineProperty(exports2, "skipWhile", { enumerable: true, get: function() {
    return skipWhile_1.skipWhile;
  } });
  var startWith_1 = require_startWith();
  Object.defineProperty(exports2, "startWith", { enumerable: true, get: function() {
    return startWith_1.startWith;
  } });
  var subscribeOn_1 = require_subscribeOn();
  Object.defineProperty(exports2, "subscribeOn", { enumerable: true, get: function() {
    return subscribeOn_1.subscribeOn;
  } });
  var switchAll_1 = require_switchAll();
  Object.defineProperty(exports2, "switchAll", { enumerable: true, get: function() {
    return switchAll_1.switchAll;
  } });
  var switchMap_1 = require_switchMap();
  Object.defineProperty(exports2, "switchMap", { enumerable: true, get: function() {
    return switchMap_1.switchMap;
  } });
  var switchMapTo_1 = require_switchMapTo();
  Object.defineProperty(exports2, "switchMapTo", { enumerable: true, get: function() {
    return switchMapTo_1.switchMapTo;
  } });
  var switchScan_1 = require_switchScan();
  Object.defineProperty(exports2, "switchScan", { enumerable: true, get: function() {
    return switchScan_1.switchScan;
  } });
  var take_1 = require_take();
  Object.defineProperty(exports2, "take", { enumerable: true, get: function() {
    return take_1.take;
  } });
  var takeLast_1 = require_takeLast();
  Object.defineProperty(exports2, "takeLast", { enumerable: true, get: function() {
    return takeLast_1.takeLast;
  } });
  var takeUntil_1 = require_takeUntil();
  Object.defineProperty(exports2, "takeUntil", { enumerable: true, get: function() {
    return takeUntil_1.takeUntil;
  } });
  var takeWhile_1 = require_takeWhile();
  Object.defineProperty(exports2, "takeWhile", { enumerable: true, get: function() {
    return takeWhile_1.takeWhile;
  } });
  var tap_1 = require_tap();
  Object.defineProperty(exports2, "tap", { enumerable: true, get: function() {
    return tap_1.tap;
  } });
  var throttle_1 = require_throttle();
  Object.defineProperty(exports2, "throttle", { enumerable: true, get: function() {
    return throttle_1.throttle;
  } });
  var throttleTime_1 = require_throttleTime();
  Object.defineProperty(exports2, "throttleTime", { enumerable: true, get: function() {
    return throttleTime_1.throttleTime;
  } });
  var throwIfEmpty_1 = require_throwIfEmpty();
  Object.defineProperty(exports2, "throwIfEmpty", { enumerable: true, get: function() {
    return throwIfEmpty_1.throwIfEmpty;
  } });
  var timeInterval_1 = require_timeInterval();
  Object.defineProperty(exports2, "timeInterval", { enumerable: true, get: function() {
    return timeInterval_1.timeInterval;
  } });
  var timeout_2 = require_timeout();
  Object.defineProperty(exports2, "timeout", { enumerable: true, get: function() {
    return timeout_2.timeout;
  } });
  var timeoutWith_1 = require_timeoutWith();
  Object.defineProperty(exports2, "timeoutWith", { enumerable: true, get: function() {
    return timeoutWith_1.timeoutWith;
  } });
  var timestamp_1 = require_timestamp();
  Object.defineProperty(exports2, "timestamp", { enumerable: true, get: function() {
    return timestamp_1.timestamp;
  } });
  var toArray_1 = require_toArray();
  Object.defineProperty(exports2, "toArray", { enumerable: true, get: function() {
    return toArray_1.toArray;
  } });
  var window_1 = require_window();
  Object.defineProperty(exports2, "window", { enumerable: true, get: function() {
    return window_1.window;
  } });
  var windowCount_1 = require_windowCount();
  Object.defineProperty(exports2, "windowCount", { enumerable: true, get: function() {
    return windowCount_1.windowCount;
  } });
  var windowTime_1 = require_windowTime();
  Object.defineProperty(exports2, "windowTime", { enumerable: true, get: function() {
    return windowTime_1.windowTime;
  } });
  var windowToggle_1 = require_windowToggle();
  Object.defineProperty(exports2, "windowToggle", { enumerable: true, get: function() {
    return windowToggle_1.windowToggle;
  } });
  var windowWhen_1 = require_windowWhen();
  Object.defineProperty(exports2, "windowWhen", { enumerable: true, get: function() {
    return windowWhen_1.windowWhen;
  } });
  var withLatestFrom_1 = require_withLatestFrom();
  Object.defineProperty(exports2, "withLatestFrom", { enumerable: true, get: function() {
    return withLatestFrom_1.withLatestFrom;
  } });
  var zipAll_1 = require_zipAll();
  Object.defineProperty(exports2, "zipAll", { enumerable: true, get: function() {
    return zipAll_1.zipAll;
  } });
  var zipWith_1 = require_zipWith();
  Object.defineProperty(exports2, "zipWith", { enumerable: true, get: function() {
    return zipWith_1.zipWith;
  } });
});

// node_modules/@flowcore/sdk-transformer-core/dist/contracts/constants.js
var require_constants = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "TIME_BUCKET_FORMAT", {
    enumerable: true,
    get: function() {
      return TIME_BUCKET_FORMAT;
    }
  });
  var TIME_BUCKET_FORMAT = "YYYYMMDDHHmmss";
});

// node_modules/@flowcore/sdk-transformer-core/dist/contracts/index.js
var require_contracts = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_constants(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/exceptions.js
var require_exceptions = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "TransformerError", {
    enumerable: true,
    get: function() {
      return TransformerError;
    }
  });
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class TransformerError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception.message})` : message;
      super(errorMessage);
      _define_property(this, "name", "TransformerError");
      _define_property(this, "exception", undefined);
      _define_property(this, "errors", undefined);
      this.exception = options?.exception;
      this.errors = options?.errors;
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IsAsyncIterator = IsAsyncIterator;
  exports2.IsIterator = IsIterator;
  exports2.IsStandardObject = IsStandardObject;
  exports2.IsInstanceObject = IsInstanceObject;
  exports2.IsPromise = IsPromise;
  exports2.IsDate = IsDate;
  exports2.IsMap = IsMap;
  exports2.IsSet = IsSet;
  exports2.IsRegExp = IsRegExp;
  exports2.IsTypedArray = IsTypedArray;
  exports2.IsInt8Array = IsInt8Array;
  exports2.IsUint8Array = IsUint8Array;
  exports2.IsUint8ClampedArray = IsUint8ClampedArray;
  exports2.IsInt16Array = IsInt16Array;
  exports2.IsUint16Array = IsUint16Array;
  exports2.IsInt32Array = IsInt32Array;
  exports2.IsUint32Array = IsUint32Array;
  exports2.IsFloat32Array = IsFloat32Array;
  exports2.IsFloat64Array = IsFloat64Array;
  exports2.IsBigInt64Array = IsBigInt64Array;
  exports2.IsBigUint64Array = IsBigUint64Array;
  exports2.HasPropertyKey = HasPropertyKey;
  exports2.IsObject = IsObject;
  exports2.IsArray = IsArray;
  exports2.IsUndefined = IsUndefined;
  exports2.IsNull = IsNull;
  exports2.IsBoolean = IsBoolean;
  exports2.IsNumber = IsNumber;
  exports2.IsInteger = IsInteger;
  exports2.IsBigInt = IsBigInt;
  exports2.IsString = IsString;
  exports2.IsFunction = IsFunction;
  exports2.IsSymbol = IsSymbol;
  exports2.IsValueType = IsValueType;
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  function IsStandardObject(value) {
    return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
  }
  function IsInstanceObject(value) {
    return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== "Object";
  }
  function IsPromise(value) {
    return value instanceof Promise;
  }
  function IsDate(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  }
  function IsMap(value) {
    return value instanceof globalThis.Map;
  }
  function IsSet(value) {
    return value instanceof globalThis.Set;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  function IsInt8Array(value) {
    return value instanceof globalThis.Int8Array;
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUint8ClampedArray(value) {
    return value instanceof globalThis.Uint8ClampedArray;
  }
  function IsInt16Array(value) {
    return value instanceof globalThis.Int16Array;
  }
  function IsUint16Array(value) {
    return value instanceof globalThis.Uint16Array;
  }
  function IsInt32Array(value) {
    return value instanceof globalThis.Int32Array;
  }
  function IsUint32Array(value) {
    return value instanceof globalThis.Uint32Array;
  }
  function IsFloat32Array(value) {
    return value instanceof globalThis.Float32Array;
  }
  function IsFloat64Array(value) {
    return value instanceof globalThis.Float64Array;
  }
  function IsBigInt64Array(value) {
    return value instanceof globalThis.BigInt64Array;
  }
  function IsBigUint64Array(value) {
    return value instanceof globalThis.BigUint64Array;
  }
  function HasPropertyKey(value, key) {
    return key in value;
  }
  function IsObject(value) {
    return value !== null && typeof value === "object";
  }
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  function IsUndefined(value) {
    return value === undefined;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsInteger(value) {
    return Number.isInteger(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_guard(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeSystemPolicy = undefined;
  var index_1 = require_guard2();
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject = (0, index_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, index_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return TypeSystemPolicy2.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, index_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (exports2.TypeSystemPolicy = TypeSystemPolicy = {}));
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Entries = Entries;
  exports2.Clear = Clear;
  exports2.Delete = Delete;
  exports2.Has = Has;
  exports2.Set = Set2;
  exports2.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(format) {
    return map.delete(format);
  }
  function Has(format) {
    return map.has(format);
  }
  function Set2(format, func) {
    map.set(format, func);
  }
  function Get(format) {
    return map.get(format);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Entries = Entries;
  exports2.Clear = Clear;
  exports2.Delete = Delete;
  exports2.Has = Has;
  exports2.Set = Set2;
  exports2.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(kind) {
    return map.delete(kind);
  }
  function Has(kind) {
    return map.has(kind);
  }
  function Set2(kind, func) {
    map.set(kind, func);
  }
  function Get(kind) {
    return map.get(kind);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeRegistry = exports2.FormatRegistry = undefined;
  exports2.FormatRegistry = require_format();
  exports2.TypeRegistry = require_type();
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Kind = exports2.Hint = exports2.OptionalKind = exports2.ReadonlyKind = exports2.TransformKind = undefined;
  exports2.TransformKind = Symbol.for("TypeBox.Transform");
  exports2.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  exports2.OptionalKind = Symbol.for("TypeBox.Optional");
  exports2.Hint = Symbol.for("TypeBox.Hint");
  exports2.Kind = Symbol.for("TypeBox.Kind");
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_symbols(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Unsafe = Unsafe;
  var index_1 = require_symbols2();
  function Unsafe(options = {}) {
    return {
      ...options,
      [index_1.Kind]: options[index_1.Kind] ?? "Unsafe"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_unsafe(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeBoxError = undefined;

  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports2.TypeBoxError = TypeBoxError;
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_error(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeSystem = exports2.TypeSystemDuplicateFormat = exports2.TypeSystemDuplicateTypeKind = undefined;
  var index_1 = require_registry();
  var index_2 = require_unsafe2();
  var index_3 = require_symbols2();
  var index_4 = require_error2();

  class TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports2.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;

  class TypeSystemDuplicateFormat extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports2.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (index_1.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      index_1.TypeRegistry.Set(kind, check);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check) {
      if (index_1.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      index_1.FormatRegistry.Set(format, check);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (exports2.TypeSystem = TypeSystem = {}));
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_policy(), exports2);
  __exportStar(require_system(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MappedKey = MappedKey;
  var index_1 = require_symbols2();
  function MappedKey(T) {
    return {
      [index_1.Kind]: "MappedKey",
      keys: T
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MappedResult = MappedResult;
  var index_1 = require_symbols2();
  function MappedResult(properties) {
    return {
      [index_1.Kind]: "MappedResult",
      properties
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IsAsyncIterator = IsAsyncIterator;
  exports2.IsArray = IsArray;
  exports2.IsBigInt = IsBigInt;
  exports2.IsBoolean = IsBoolean;
  exports2.IsDate = IsDate;
  exports2.IsFunction = IsFunction;
  exports2.IsIterator = IsIterator;
  exports2.IsNull = IsNull;
  exports2.IsNumber = IsNumber;
  exports2.IsObject = IsObject;
  exports2.IsRegExp = IsRegExp;
  exports2.IsString = IsString;
  exports2.IsSymbol = IsSymbol;
  exports2.IsUint8Array = IsUint8Array;
  exports2.IsUndefined = IsUndefined;
  function IsAsyncIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
  }
  function IsArray(value) {
    return Array.isArray(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsDate(value) {
    return value instanceof globalThis.Date;
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsObject(value) {
    return typeof value === "object" && value !== null;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUndefined(value) {
    return value === undefined;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Clone = Clone;
  var ValueGuard = require_value();
  function ArrayType(value) {
    return value.map((value2) => Visit(value2));
  }
  function DateType(value) {
    return new Date(value.getTime());
  }
  function Uint8ArrayType(value) {
    return new Uint8Array(value);
  }
  function RegExpType(value) {
    return new RegExp(value.source, value.flags);
  }
  function ObjectType(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      result[key] = Visit(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      result[key] = Visit(value[key]);
    }
    return result;
  }
  function Visit(value) {
    return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsRegExp(value) ? RegExpType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
  }
  function Clone(value) {
    return Visit(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.CloneRest = CloneRest;
  exports2.CloneType = CloneType;
  var value_1 = require_value2();
  function CloneRest(schemas) {
    return schemas.map((schema) => CloneType(schema));
  }
  function CloneType(schema, options = {}) {
    return { ...(0, value_1.Clone)(schema), ...options };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Discard = Discard;
  function DiscardKey(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
  }
  function Discard(value, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_discard(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Array = Array2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Array2(schema, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Array",
      type: "array",
      items: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_array(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.AsyncIterator = AsyncIterator;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  function AsyncIterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "AsyncIterator",
      type: "AsyncIterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_async_iterator(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Constructor = Constructor;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Constructor(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Constructor",
      type: "Constructor",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_constructor(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Function = Function2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Function2(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Function",
      type: "Function",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_function(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Never = Never;
  var index_1 = require_symbols2();
  function Never(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Never",
      not: {}
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never3 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_never2(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IsReadonly = IsReadonly;
  exports2.IsOptional = IsOptional;
  exports2.IsAny = IsAny;
  exports2.IsArray = IsArray;
  exports2.IsAsyncIterator = IsAsyncIterator;
  exports2.IsBigInt = IsBigInt;
  exports2.IsBoolean = IsBoolean;
  exports2.IsConstructor = IsConstructor;
  exports2.IsDate = IsDate;
  exports2.IsFunction = IsFunction;
  exports2.IsInteger = IsInteger;
  exports2.IsProperties = IsProperties;
  exports2.IsIntersect = IsIntersect;
  exports2.IsIterator = IsIterator;
  exports2.IsKindOf = IsKindOf;
  exports2.IsLiteralString = IsLiteralString;
  exports2.IsLiteralNumber = IsLiteralNumber;
  exports2.IsLiteralBoolean = IsLiteralBoolean;
  exports2.IsLiteral = IsLiteral;
  exports2.IsMappedKey = IsMappedKey;
  exports2.IsMappedResult = IsMappedResult;
  exports2.IsNever = IsNever;
  exports2.IsNot = IsNot;
  exports2.IsNull = IsNull;
  exports2.IsNumber = IsNumber;
  exports2.IsObject = IsObject;
  exports2.IsPromise = IsPromise;
  exports2.IsRecord = IsRecord;
  exports2.IsRecursive = IsRecursive;
  exports2.IsRef = IsRef;
  exports2.IsRegExp = IsRegExp;
  exports2.IsString = IsString;
  exports2.IsSymbol = IsSymbol;
  exports2.IsTemplateLiteral = IsTemplateLiteral;
  exports2.IsThis = IsThis;
  exports2.IsTransform = IsTransform;
  exports2.IsTuple = IsTuple;
  exports2.IsUndefined = IsUndefined;
  exports2.IsUnion = IsUnion;
  exports2.IsUint8Array = IsUint8Array;
  exports2.IsUnknown = IsUnknown;
  exports2.IsUnsafe = IsUnsafe;
  exports2.IsVoid = IsVoid;
  exports2.IsKind = IsKind;
  exports2.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any");
  }
  function IsArray(value) {
    return IsKindOf(value, "Array");
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator");
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt");
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean");
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor");
  }
  function IsDate(value) {
    return IsKindOf(value, "Date");
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function");
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer");
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value);
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect");
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator");
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal");
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey");
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult");
  }
  function IsNever(value) {
    return IsKindOf(value, "Never");
  }
  function IsNot(value) {
    return IsKindOf(value, "Not");
  }
  function IsNull(value) {
    return IsKindOf(value, "Null");
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number");
  }
  function IsObject(value) {
    return IsKindOf(value, "Object");
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise");
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record");
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref");
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp");
  }
  function IsString(value) {
    return IsKindOf(value, "String");
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol");
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral");
  }
  function IsThis(value) {
    return IsKindOf(value, "This");
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple");
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined");
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union");
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array");
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown");
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void");
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Optional = Optional;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var optional_from_mapped_result_1 = require_optional_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveOptional(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.OptionalKind]);
  }
  function AddOptional(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.OptionalKind]: "Optional" };
  }
  function OptionalWithFlag(schema, F) {
    return F === false ? RemoveOptional(schema) : AddOptional(schema);
  }
  function Optional(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.OptionalFromMappedResult = OptionalFromMappedResult;
  var index_1 = require_mapped2();
  var optional_1 = require_optional();
  function FromProperties(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_optional_from_mapped_result(), exports2);
  __exportStar(require_optional(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IntersectCreate = IntersectCreate;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function IntersectCreate(T, options) {
    const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: (0, type_1.CloneType)(options.unevaluatedProperties) } : {};
    return options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: (0, type_1.CloneRest)(T) } : { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IntersectEvaluated = IntersectEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never3();
  var index_4 = require_optional2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function IsIntersectOptional(T) {
    return T.every((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function ResolveIntersect(T, options) {
    return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);
  }
  function IntersectEvaluated(T, options = {}) {
    if (T.length === 0)
      return (0, index_3.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Intersect = Intersect;
  var type_1 = require_type2();
  var index_1 = require_never3();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function Intersect(T, options = {}) {
    if (T.length === 0)
      return (0, index_1.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_intersect_evaluated(), exports2);
  __exportStar(require_intersect_type(), exports2);
  __exportStar(require_intersect(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UnionCreate = UnionCreate;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function UnionCreate(T, options) {
    return { ...options, [index_1.Kind]: "Union", anyOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.UnionEvaluated = UnionEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never3();
  var index_4 = require_optional2();
  var union_create_1 = require_union_create();
  var kind_1 = require_kind();
  function IsUnionOptional(T) {
    return T.some((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function ResolveUnion(T, options) {
    return IsUnionOptional(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options);
  }
  function UnionEvaluated(T, options = {}) {
    return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : ResolveUnion(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Union = Union;
  var index_1 = require_never3();
  var type_1 = require_type2();
  var union_create_1 = require_union_create();
  function Union(T, options = {}) {
    return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_union_evaluated(), exports2);
  __exportStar(require_union_type(), exports2);
  __exportStar(require_union(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralParserError = undefined;
  exports2.TemplateLiteralParse = TemplateLiteralParse;
  exports2.TemplateLiteralParseExact = TemplateLiteralParseExact;
  var index_1 = require_error2();

  class TemplateLiteralParserError extends index_1.TypeBoxError {
  }
  exports2.TemplateLiteralParserError = TemplateLiteralParserError;
  function Unescape(pattern) {
    return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }
  function IsNonEscaped(pattern, index, char) {
    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
  }
  function IsOpenParen(pattern, index) {
    return IsNonEscaped(pattern, index, "(");
  }
  function IsCloseParen(pattern, index) {
    return IsNonEscaped(pattern, index, ")");
  }
  function IsSeparator(pattern, index) {
    return IsNonEscaped(pattern, index, "|");
  }
  function IsGroup(pattern) {
    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
      return false;
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (count === 0 && index !== pattern.length - 1)
        return false;
    }
    return true;
  }
  function InGroup(pattern) {
    return pattern.slice(1, pattern.length - 1);
  }
  function IsPrecedenceOr(pattern) {
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0)
        return true;
    }
    return false;
  }
  function IsPrecedenceAnd(pattern) {
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        return true;
    }
    return false;
  }
  function Or(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0) {
        const range2 = pattern.slice(start, index);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse(range2));
        start = index + 1;
      }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  }
  function And(pattern) {
    function Group(value, index) {
      if (!IsOpenParen(value, index))
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index;scan < value.length; scan++) {
        if (IsOpenParen(value, scan))
          count += 1;
        if (IsCloseParen(value, scan))
          count -= 1;
        if (count === 0)
          return [index, scan];
      }
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern2, index) {
      for (let scan = index;scan < pattern2.length; scan++) {
        if (IsOpenParen(pattern2, scan))
          return [index, scan];
      }
      return [index, pattern2.length];
    }
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index)) {
        const [start, end] = Group(pattern, index);
        const range = pattern.slice(start, end + 1);
        expressions.push(TemplateLiteralParse(range));
        index = end;
      } else {
        const [start, end] = Range(pattern, index);
        const range = pattern.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse(range));
        index = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  }
  function TemplateLiteralParse(pattern) {
    return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
  }
  function TemplateLiteralParseExact(pattern) {
    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralFiniteError = undefined;
  exports2.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
  exports2.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralFiniteError extends index_1.TypeBoxError {
  }
  exports2.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  function IsNumberExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  }
  function IsBooleanExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  }
  function IsStringExpression(expression) {
    return expression.type === "const" && expression.const === ".*";
  }
  function IsTemplateLiteralExpressionFinite(expression) {
    return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError(`Unknown expression type`);
    })();
  }
  function IsTemplateLiteralFinite(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralGenerateError = undefined;
  exports2.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
  exports2.TemplateLiteralGenerate = TemplateLiteralGenerate;
  var finite_1 = require_finite();
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralGenerateError extends index_1.TypeBoxError {
  }
  exports2.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
  function* GenerateReduce(buffer) {
    if (buffer.length === 1)
      return yield* buffer[0];
    for (const left of buffer[0]) {
      for (const right of GenerateReduce(buffer.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
  }
  function* GenerateOr(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate(expr);
  }
  function* GenerateConst(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
      throw new TemplateLiteralGenerateError("Unknown expression");
    })();
  }
  function TemplateLiteralGenerate(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Literal = Literal;
  var index_1 = require_symbols2();
  function Literal(value, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Literal",
      const: value,
      type: typeof value
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_literal(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Boolean = Boolean2;
  var index_1 = require_symbols2();
  function Boolean2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Boolean",
      type: "boolean"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_boolean(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.BigInt = BigInt2;
  var index_1 = require_symbols2();
  function BigInt2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "BigInt",
      type: "bigint"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_bigint(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Number = Number2;
  var index_1 = require_symbols2();
  function Number2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Number",
      type: "number"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_number(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.String = String2;
  var index_1 = require_symbols2();
  function String2(options = {}) {
    return { ...options, [index_1.Kind]: "String", type: "string" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_string(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralSyntax = TemplateLiteralSyntax;
  var index_1 = require_literal2();
  var index_2 = require_boolean2();
  var index_3 = require_bigint2();
  var index_4 = require_number2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_never3();
  function* FromUnion(syntax) {
    const trim = syntax.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal(syntax) {
    if (syntax[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax(syntax.slice(1));
      return yield* [L, ...R];
    }
    for (let i2 = 2;i2 < syntax.length; i2++) {
      if (syntax[i2] === "}") {
        const L = FromUnion(syntax.slice(2, i2));
        const R = FromSyntax(syntax.slice(i2 + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function* FromSyntax(syntax) {
    for (let i2 = 0;i2 < syntax.length; i2++) {
      if (syntax[i2] === "$") {
        const L = (0, index_1.Literal)(syntax.slice(0, i2));
        const R = FromTerminal(syntax.slice(i2));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function TemplateLiteralSyntax(syntax) {
    return [...FromSyntax(syntax)];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PatternNeverExact = exports2.PatternStringExact = exports2.PatternNumberExact = exports2.PatternBooleanExact = exports2.PatternNever = exports2.PatternString = exports2.PatternNumber = exports2.PatternBoolean = undefined;
  exports2.PatternBoolean = "(true|false)";
  exports2.PatternNumber = "(0|[1-9][0-9]*)";
  exports2.PatternString = "(.*)";
  exports2.PatternNever = "(?!.*)";
  exports2.PatternBooleanExact = `^${exports2.PatternBoolean}$`;
  exports2.PatternNumberExact = `^${exports2.PatternNumber}$`;
  exports2.PatternStringExact = `^${exports2.PatternString}$`;
  exports2.PatternNeverExact = `^${exports2.PatternNever}$`;
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_patterns(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralPatternError = undefined;
  exports2.TemplateLiteralPattern = TemplateLiteralPattern;
  var index_1 = require_patterns2();
  var index_2 = require_symbols2();
  var index_3 = require_error2();
  var kind_1 = require_kind();

  class TemplateLiteralPatternError extends index_3.TypeBoxError {
  }
  exports2.TemplateLiteralPatternError = TemplateLiteralPatternError;
  function Escape(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Visit(schema, acc) {
    return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[index_2.Kind]}'`);
    })();
  }
  function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteralToUnion = TemplateLiteralToUnion;
  var index_1 = require_union2();
  var index_2 = require_literal2();
  var generate_1 = require_generate2();
  function TemplateLiteralToUnion(schema) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TemplateLiteral = TemplateLiteral;
  var syntax_1 = require_syntax();
  var pattern_1 = require_pattern();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function TemplateLiteral(unresolved, options = {}) {
    const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return { ...options, [index_1.Kind]: "TemplateLiteral", type: "string", pattern };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_finite(), exports2);
  __exportStar(require_generate2(), exports2);
  __exportStar(require_syntax(), exports2);
  __exportStar(require_parse(), exports2);
  __exportStar(require_pattern(), exports2);
  __exportStar(require_union3(), exports2);
  __exportStar(require_template_literal(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IndexPropertyKeys = IndexPropertyKeys;
  var index_1 = require_template_literal2();
  var kind_1 = require_kind();
  function FromTemplateLiteral(T) {
    const R = (0, index_1.TemplateLiteralGenerate)(T);
    return R.map((S) => S.toString());
  }
  function FromUnion(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...IndexPropertyKeys(L));
    return Acc;
  }
  function FromLiteral(T) {
    return [T.toString()];
  }
  function IndexPropertyKeys(T) {
    return [...new Set((0, kind_1.IsTemplateLiteral)(T) ? FromTemplateLiteral(T) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsLiteral)(T) ? FromLiteral(T.const) : (0, kind_1.IsNumber)(T) ? ["[number]"] : (0, kind_1.IsInteger)(T) ? ["[number]"] : [])];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IndexFromMappedResult = IndexFromMappedResult;
  var index_1 = require_mapped2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var index_2 = require_indexed2();
  function FromProperties(T, P, options) {
    const Acc = {};
    for (const K2 of Object.getOwnPropertyNames(P)) {
      Acc[K2] = (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options);
    }
    return Acc;
  }
  function FromMappedResult(T, R, options) {
    return FromProperties(T, R.properties, options);
  }
  function IndexFromMappedResult(T, R, options) {
    const P = FromMappedResult(T, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IndexFromPropertyKey = IndexFromPropertyKey;
  exports2.IndexFromPropertyKeys = IndexFromPropertyKeys;
  exports2.Index = Index;
  var index_1 = require_never3();
  var index_2 = require_intersect2();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
  var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T, K) {
    return T.map((L) => IndexFromPropertyKey(L, K));
  }
  function FromIntersectRest(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function FromIntersect(T, K) {
    return (0, index_2.IntersectEvaluated)(FromIntersectRest(FromRest(T, K)));
  }
  function FromUnionRest(T) {
    return T.some((L) => (0, kind_1.IsNever)(L)) ? [] : T;
  }
  function FromUnion(T, K) {
    return (0, index_3.UnionEvaluated)(FromUnionRest(FromRest(T, K)));
  }
  function FromTuple(T, K) {
    return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
  }
  function FromArray(T, K) {
    return K === "[number]" ? T : (0, index_1.Never)();
  }
  function FromProperty(T, K) {
    return K in T ? T[K] : (0, index_1.Never)();
  }
  function IndexFromPropertyKey(T, K) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf, K) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf, K) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? [], K) : (0, kind_1.IsArray)(T) ? FromArray(T.items, K) : (0, kind_1.IsObject)(T) ? FromProperty(T.properties, K) : (0, index_1.Never)();
  }
  function IndexFromPropertyKeys(T, K) {
    return K.map((L) => IndexFromPropertyKey(T, L));
  }
  function FromSchema(T, K) {
    return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys(T, K));
  }
  function Index(T, K, options = {}) {
    return (0, kind_1.IsMappedResult)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options)) : (0, kind_1.IsMappedKey)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options)) : (0, kind_1.IsSchema)(K) ? (0, type_1.CloneType)(FromSchema(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)), options) : (0, type_1.CloneType)(FromSchema(T, K), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IndexFromMappedKey = IndexFromMappedKey;
  var indexed_1 = require_indexed();
  var index_1 = require_mapped2();
  function MappedIndexPropertyKey(T, K, options) {
    return { [K]: (0, indexed_1.Index)(T, [K], options) };
  }
  function MappedIndexPropertyKeys(T, K, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
    }, {});
  }
  function MappedIndexProperties(T, K, options) {
    return MappedIndexPropertyKeys(T, K.keys, options);
  }
  function IndexFromMappedKey(T, K, options) {
    const P = MappedIndexProperties(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_indexed_from_mapped_key(), exports2);
  __exportStar(require_indexed_from_mapped_result(), exports2);
  __exportStar(require_indexed_property_keys(), exports2);
  __exportStar(require_indexed(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Iterator = Iterator;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Iterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Iterator",
      type: "Iterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator3 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_iterator2(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Object = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var kind_1 = require_kind();
  function _Object(properties, options = {}) {
    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
    const optionalKeys = propertyKeys.filter((key) => (0, kind_1.IsOptional)(properties[key]));
    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
    const clonedAdditionalProperties = (0, kind_1.IsSchema)(options.additionalProperties) ? { additionalProperties: (0, type_1.CloneType)(options.additionalProperties) } : {};
    const clonedProperties = {};
    for (const key of propertyKeys)
      clonedProperties[key] = (0, type_1.CloneType)(properties[key]);
    return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties };
  }
  exports2.Object = _Object;
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_object(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Promise = Promise2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Promise2(item, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Promise",
      type: "Promise",
      item: (0, type_1.CloneType)(item)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_promise(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Readonly = Readonly;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveReadonly(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.ReadonlyKind]);
  }
  function AddReadonly(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.ReadonlyKind]: "Readonly" };
  }
  function ReadonlyWithFlag(schema, F) {
    return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
  }
  function Readonly(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
  var index_1 = require_mapped2();
  var readonly_1 = require_readonly();
  function FromProperties(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_readonly_from_mapped_result(), exports2);
  __exportStar(require_readonly(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Tuple = Tuple;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Tuple(items, options = {}) {
    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
    return items.length > 0 ? { ...options, [index_1.Kind]: "Tuple", type: "array", items: (0, type_1.CloneRest)(items), additionalItems, minItems, maxItems } : { ...options, [index_1.Kind]: "Tuple", type: "array", minItems, maxItems };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_tuple(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.SetIncludes = SetIncludes;
  exports2.SetIsSubset = SetIsSubset;
  exports2.SetDistinct = SetDistinct;
  exports2.SetIntersect = SetIntersect;
  exports2.SetUnion = SetUnion;
  exports2.SetComplement = SetComplement;
  exports2.SetIntersectMany = SetIntersectMany;
  exports2.SetUnionMany = SetUnionMany;
  function SetIncludes(T, S) {
    return T.includes(S);
  }
  function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes(S, L));
  }
  function SetDistinct(T) {
    return [...new Set(T)];
  }
  function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
  }
  function SetUnion(T, S) {
    return [...T, ...S];
  }
  function SetComplement(T, S) {
    return T.filter((L) => !S.includes(L));
  }
  function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect(Acc, L);
    }, Init);
  }
  function SetIntersectMany(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
  }
  function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...L);
    return Acc;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_set(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.MappedFunctionReturnType = MappedFunctionReturnType;
  exports2.Mapped = Mapped;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_array2();
  var index_4 = require_async_iterator2();
  var index_5 = require_constructor2();
  var index_6 = require_function2();
  var index_7 = require_indexed2();
  var index_8 = require_intersect2();
  var index_9 = require_iterator3();
  var index_10 = require_literal2();
  var index_11 = require_object2();
  var index_12 = require_optional2();
  var index_13 = require_promise2();
  var index_14 = require_readonly2();
  var index_15 = require_tuple2();
  var index_16 = require_union2();
  var index_17 = require_sets();
  var mapped_result_1 = require_mapped_result();
  var kind_1 = require_kind();
  function FromMappedResult(K, P) {
    return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  }
  function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
  }
  function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
      Acc[L] = (0, index_10.Literal)(L);
    return Acc;
  }
  function MappedKeyToMappedResultProperties(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
  }
  function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
  }
  function FromRest(K, T) {
    return T.map((L) => FromSchemaType(K, L));
  }
  function FromProperties(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
      Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
  }
  function FromSchemaType(K, T) {
    return (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) : (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf)) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? [])) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties)) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items)) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item)) : T;
  }
  function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
      Acc[L] = FromSchemaType(L, T);
    return Acc;
  }
  function Mapped(key, map, options = {}) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, type_1.CloneType)((0, index_11.Object)(R), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_mapped_key(), exports2);
  __exportStar(require_mapped_result(), exports2);
  __exportStar(require_mapped(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.KeyOfPropertyKeys = KeyOfPropertyKeys;
  exports2.KeyOfPattern = KeyOfPattern;
  var index_1 = require_sets();
  var kind_1 = require_kind();
  function FromRest(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(KeyOfPropertyKeys(L));
    return Acc;
  }
  function FromIntersect(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetUnionMany)(C);
    return R;
  }
  function FromUnion(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetIntersectMany)(C);
    return R;
  }
  function FromTuple(T) {
    return T.map((_, I) => I.toString());
  }
  function FromArray(_) {
    return ["[number]"];
  }
  function FromProperties(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  }
  function FromPatternProperties(patternProperties) {
    if (!includePatternProperties)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  }
  function KeyOfPropertyKeys(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? []) : (0, kind_1.IsArray)(T) ? FromArray(T.items) : (0, kind_1.IsObject)(T) ? FromProperties(T.properties) : (0, kind_1.IsRecord)(T) ? FromPatternProperties(T.patternProperties) : [];
  }
  var includePatternProperties = false;
  function KeyOfPattern(schema) {
    includePatternProperties = true;
    const keys = KeyOfPropertyKeys(schema);
    includePatternProperties = false;
    const pattern = keys.map((key) => `(${key})`);
    return `^(${pattern.join("|")})$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
  exports2.KeyOf = KeyOf;
  var index_1 = require_literal2();
  var index_2 = require_number2();
  var keyof_property_keys_1 = require_keyof_property_keys();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
  var kind_1 = require_kind();
  function KeyOfPropertyKeysToRest(T) {
    return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  }
  function KeyOf(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
    } else {
      const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
      const S = KeyOfPropertyKeysToRest(K);
      const U = (0, index_3.UnionEvaluated)(S);
      return (0, type_1.CloneType)(U, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.KeyOfFromMappedResult = KeyOfFromMappedResult;
  var index_1 = require_mapped2();
  var keyof_1 = require_keyof();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, keyof_1.KeyOf)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function KeyOfFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.KeyOfPropertyEntries = KeyOfPropertyEntries;
  var indexed_1 = require_indexed();
  var keyof_property_keys_1 = require_keyof_property_keys();
  function KeyOfPropertyEntries(schema) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
    return keys.map((_, index) => [keys[index], schemas[index]]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_keyof_from_mapped_result(), exports2);
  __exportStar(require_keyof_property_entries(), exports2);
  __exportStar(require_keyof_property_keys(), exports2);
  __exportStar(require_keyof(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
  var index_1 = require_symbols2();
  function Intersect(schema) {
    return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Union(schema) {
    return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Not(schema) {
    return !ExtendsUndefinedCheck(schema.not);
  }
  function ExtendsUndefinedCheck(schema) {
    return schema[index_1.Kind] === "Intersect" ? Intersect(schema) : schema[index_1.Kind] === "Union" ? Union(schema) : schema[index_1.Kind] === "Not" ? Not(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DefaultErrorFunction = DefaultErrorFunction;
  exports2.SetErrorFunction = SetErrorFunction;
  exports2.GetErrorFunction = GetErrorFunction;
  var index_1 = require_symbols2();
  var errors_1 = require_errors();
  function DefaultErrorFunction(error2) {
    switch (error2.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error2.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error2.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error2.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error2.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Expected required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error2.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error2.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error2.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error2.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error2.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error2.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  var errorFunction = DefaultErrorFunction;
  function SetErrorFunction(callback) {
    errorFunction = callback;
  }
  function GetErrorFunction() {
    return errorFunction;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeDereferenceError = undefined;
  exports2.Deref = Deref;
  var index_1 = require_error2();
  var index_2 = require_symbols2();

  class TypeDereferenceError extends index_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with $id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  exports2.TypeDereferenceError = TypeDereferenceError;
  function Resolve(schema, references) {
    const target = references.find((target2) => target2.$id === schema.$ref);
    if (target === undefined)
      throw new TypeDereferenceError(schema);
    return Deref(target, references);
  }
  function Deref(schema, references) {
    return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve(schema, references) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_deref(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueHashError = undefined;
  exports2.Hash = Hash;
  var index_1 = require_guard2();
  var index_2 = require_error2();

  class ValueHashError extends index_2.TypeBoxError {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports2.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037");
  var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
  var F64 = new Float64Array(1);
  var F64In = new DataView(F64.buffer);
  var F64Out = new Uint8Array(F64.buffer);
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i2 = 0;i2 < byteCount; i2++) {
      yield value >> 8 * (byteCount - 1 - i2) & 255;
    }
  }
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  }
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  }
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  }
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  }
  function StringType2(value) {
    FNV1A64(ByteMarker.String);
    for (let i2 = 0;i2 < value.length; i2++) {
      for (const byte of NumberToBytes(value.charCodeAt(i2))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  }
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i2 = 0;i2 < value.length; i2++) {
      FNV1A64(value[i2]);
    }
  }
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, index_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsNull)(value))
      return NullType(value);
    if ((0, index_1.IsNumber)(value))
      return NumberType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsString)(value))
      return StringType2(value);
    if ((0, index_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, index_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, index_1.IsUndefined)(value))
      return UndefinedType(value);
    throw new ValueHashError(value);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_hash(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueErrorIterator = exports2.ValueErrorsUnknownTypeError = exports2.ValueErrorType = undefined;
  exports2.Errors = Errors;
  var index_1 = require_system2();
  var index_2 = require_keyof2();
  var index_3 = require_registry();
  var extends_undefined_1 = require_extends_undefined();
  var function_1 = require_function3();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_never3();
  var index_9 = require_guard2();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
  })(ValueErrorType || (exports2.ValueErrorType = ValueErrorType = {}));

  class ValueErrorsUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports2.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined(value) {
    return value !== undefined;
  }

  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports2.ValueErrorIterator = ValueErrorIterator;
  function Create(errorType, schema, path, value) {
    return { type: errorType, schema, path, value, message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value }) };
  }
  function* FromAny(schema, references, path, value) {}
  function* FromArray(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i2 = 0;i2 < value.length; i2++) {
      yield* Visit(schema.items, references, `${path}/${i2}`, value[i2]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_6.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_8.Never)();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
  }
  function* FromAsyncIterator(schema, references, path, value) {
    if (!(0, index_9.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path, value);
  }
  function* FromBigInt(schema, references, path, value) {
    if (!(0, index_9.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
  }
  function* FromBoolean(schema, references, path, value) {
    if (!(0, index_9.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path, value);
  }
  function* FromConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  function* FromDate(schema, references, path, value) {
    if (!(0, index_9.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* FromFunction(schema, references, path, value) {
    if (!(0, index_9.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path, value);
  }
  function* FromInteger(schema, references, path, value) {
    if (!(0, index_9.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
  }
  function* FromIntersect(schema, references, path, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* FromIterator(schema, references, path, value) {
    if (!(0, index_9.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path, value);
  }
  function* FromLiteral(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path, value);
  }
  function* FromNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
  }
  function* FromNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path, value);
  }
  function* FromNull(schema, references, path, value) {
    if (!(0, index_9.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path, value);
  }
  function* FromNumber(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
  }
  function* FromObject(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* FromPromise(schema, references, path, value) {
    if (!(0, index_9.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path, value);
  }
  function* FromRecord(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromRegExp(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    const regex = new RegExp(schema.source, schema.flags);
    if (!regex.test(value)) {
      return yield Create(ValueErrorType.RegExp, schema, path, value);
    }
  }
  function* FromString(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, index_9.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    if ((0, index_9.IsString)(schema.format)) {
      if (!index_3.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
      } else {
        const format = index_3.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* FromSymbol(schema, references, path, value) {
    if (!(0, index_9.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path, value);
  }
  function* FromTemplateLiteral(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  function* FromThis(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromTuple(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i2 = 0;i2 < schema.items.length; i2++) {
      yield* Visit(schema.items[i2], references, `${path}/${i2}`, value[i2]);
    }
  }
  function* FromUndefined(schema, references, path, value) {
    if (!(0, index_9.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path, value);
  }
  function* FromUnion(schema, references, path, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors2 = [...Visit(subschema, references, path, value)];
      if (errors2.length === 0)
        return;
      count += errors2.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path, value);
    }
  }
  function* FromUint8Array(schema, references, path, value) {
    if (!(0, index_9.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* FromUnknown(schema, references, path, value) {}
  function* FromVoid(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path, value);
  }
  function* FromKind(schema, references, path, value) {
    const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path, value);
  }
  function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_7.Kind]) {
      case "Any":
        return yield* FromAny(schema_, references_, path, value);
      case "Array":
        return yield* FromArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* FromBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* FromBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* FromConstructor(schema_, references_, path, value);
      case "Date":
        return yield* FromDate(schema_, references_, path, value);
      case "Function":
        return yield* FromFunction(schema_, references_, path, value);
      case "Integer":
        return yield* FromInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* FromIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* FromIterator(schema_, references_, path, value);
      case "Literal":
        return yield* FromLiteral(schema_, references_, path, value);
      case "Never":
        return yield* FromNever(schema_, references_, path, value);
      case "Not":
        return yield* FromNot(schema_, references_, path, value);
      case "Null":
        return yield* FromNull(schema_, references_, path, value);
      case "Number":
        return yield* FromNumber(schema_, references_, path, value);
      case "Object":
        return yield* FromObject(schema_, references_, path, value);
      case "Promise":
        return yield* FromPromise(schema_, references_, path, value);
      case "Record":
        return yield* FromRecord(schema_, references_, path, value);
      case "Ref":
        return yield* FromRef(schema_, references_, path, value);
      case "RegExp":
        return yield* FromRegExp(schema_, references_, path, value);
      case "String":
        return yield* FromString(schema_, references_, path, value);
      case "Symbol":
        return yield* FromSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* FromThis(schema_, references_, path, value);
      case "Tuple":
        return yield* FromTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* FromUndefined(schema_, references_, path, value);
      case "Union":
        return yield* FromUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* FromUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* FromUnknown(schema_, references_, path, value);
      case "Void":
        return yield* FromVoid(schema_, references_, path, value);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* FromKind(schema_, references_, path, value);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_errors(), exports2);
  __exportStar(require_function3(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Any = Any;
  var index_1 = require_symbols2();
  function Any(options = {}) {
    return { ...options, [index_1.Kind]: "Any" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_any(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Unknown = Unknown;
  var index_1 = require_symbols2();
  function Unknown(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Unknown"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_unknown(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TypeGuardUnknownTypeError = undefined;
  exports2.IsReadonly = IsReadonly;
  exports2.IsOptional = IsOptional;
  exports2.IsAny = IsAny;
  exports2.IsArray = IsArray;
  exports2.IsAsyncIterator = IsAsyncIterator;
  exports2.IsBigInt = IsBigInt;
  exports2.IsBoolean = IsBoolean;
  exports2.IsConstructor = IsConstructor;
  exports2.IsDate = IsDate;
  exports2.IsFunction = IsFunction;
  exports2.IsInteger = IsInteger;
  exports2.IsProperties = IsProperties;
  exports2.IsIntersect = IsIntersect;
  exports2.IsIterator = IsIterator;
  exports2.IsKindOf = IsKindOf;
  exports2.IsLiteralString = IsLiteralString;
  exports2.IsLiteralNumber = IsLiteralNumber;
  exports2.IsLiteralBoolean = IsLiteralBoolean;
  exports2.IsLiteral = IsLiteral;
  exports2.IsLiteralValue = IsLiteralValue;
  exports2.IsMappedKey = IsMappedKey;
  exports2.IsMappedResult = IsMappedResult;
  exports2.IsNever = IsNever;
  exports2.IsNot = IsNot;
  exports2.IsNull = IsNull;
  exports2.IsNumber = IsNumber;
  exports2.IsObject = IsObject;
  exports2.IsPromise = IsPromise;
  exports2.IsRecord = IsRecord;
  exports2.IsRecursive = IsRecursive;
  exports2.IsRef = IsRef;
  exports2.IsRegExp = IsRegExp;
  exports2.IsString = IsString;
  exports2.IsSymbol = IsSymbol;
  exports2.IsTemplateLiteral = IsTemplateLiteral;
  exports2.IsThis = IsThis;
  exports2.IsTransform = IsTransform;
  exports2.IsTuple = IsTuple;
  exports2.IsUndefined = IsUndefined;
  exports2.IsUnionLiteral = IsUnionLiteral;
  exports2.IsUnion = IsUnion;
  exports2.IsUint8Array = IsUint8Array;
  exports2.IsUnknown = IsUnknown;
  exports2.IsUnsafe = IsUnsafe;
  exports2.IsVoid = IsVoid;
  exports2.IsKind = IsKind;
  exports2.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  var index_2 = require_error2();

  class TypeGuardUnknownTypeError extends index_2.TypeBoxError {
  }
  exports2.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var KnownTypes = [
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  function IsPattern(value) {
    try {
      new RegExp(value);
      return true;
    } catch {
      return false;
    }
  }
  function IsControlCharacterFree(value) {
    if (!ValueGuard.IsString(value))
      return false;
    for (let i2 = 0;i2 < value.length; i2++) {
      const code = value.charCodeAt(i2);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  }
  function IsAdditionalProperties(value) {
    return IsOptionalBoolean(value) || IsSchema(value);
  }
  function IsOptionalBigInt(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
  }
  function IsOptionalNumber(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
  }
  function IsOptionalBoolean(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
  }
  function IsOptionalString(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
  }
  function IsOptionalPattern(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
  }
  function IsOptionalFormat(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
  }
  function IsOptionalSchema(value) {
    return ValueGuard.IsUndefined(value) || IsSchema(value);
  }
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any") && IsOptionalString(value.$id);
  }
  function IsArray(value) {
    return IsKindOf(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsDate(value) {
    return IsKindOf(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
  }
  function IsLiteralValue(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult") && IsProperties(value.properties);
  }
  function IsNever(value) {
    return IsKindOf(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
  }
  function IsNot(value) {
    return IsKindOf(value, "Not") && IsSchema(value.not);
  }
  function IsNull(value) {
    return IsKindOf(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsObject(value) {
    return IsKindOf(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema(value.item);
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
      const keys = Object.getOwnPropertyNames(schema.patternProperties);
      return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
    })(value);
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp") && IsOptionalString(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
  }
  function IsString(value) {
    return IsKindOf(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
  }
  function IsThis(value) {
    return IsKindOf(value, "This") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema(schema)));
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
  }
  function IsUnionLiteral(value) {
    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union") && IsOptionalString(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema(schema));
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown") && IsOptionalString(value.$id);
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes.includes(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return ValueGuard.IsObject(value) && (IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueGuard = exports2.TypeGuard = exports2.KindGuard = undefined;
  exports2.KindGuard = require_kind();
  exports2.TypeGuard = require_type3();
  exports2.ValueGuard = require_value();
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtendsResult = exports2.ExtendsResolverError = undefined;
  exports2.ExtendsCheck = ExtendsCheck;
  var index_1 = require_any2();
  var index_2 = require_function2();
  var index_3 = require_number2();
  var index_4 = require_string2();
  var index_5 = require_unknown2();
  var index_6 = require_template_literal2();
  var index_7 = require_patterns2();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var index_10 = require_guard3();

  class ExtendsResolverError extends index_9.TypeBoxError {
  }
  exports2.ExtendsResolverError = ExtendsResolverError;
  var ExtendsResult;
  (function(ExtendsResult2) {
    ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
    ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
    ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
  })(ExtendsResult || (exports2.ExtendsResult = ExtendsResult = {}));
  function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
  }
  function Throw(message) {
    throw new ExtendsResolverError(message);
  }
  function IsStructuralRight(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  }
  function StructuralRight(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
  }
  function FromAnyRight(left, right) {
    return ExtendsResult.True;
  }
  function FromAny(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
  }
  function FromArrayRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromArray(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromAsyncIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromBigInt(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBooleanRight(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBoolean(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromConstructor(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromDate(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromFunction(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromIntegerRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromInteger(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
  }
  function FromIntersectRight(left, right) {
    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIntersect(left, right) {
    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromLiteral(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
  }
  function FromNeverRight(left, right) {
    return ExtendsResult.False;
  }
  function FromNever(left, right) {
    return ExtendsResult.True;
  }
  function UnwrapTNot(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  }
  function FromNot(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
  }
  function FromNull(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumberRight(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumber(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function IsObjectPropertyCount(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
  }
  function IsObjectStringLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectSymbolLike(schema) {
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
  }
  function IsObjectNumberLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBooleanLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBigIntLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectDateLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectUint8ArrayLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectFunctionLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectConstructorLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectArrayLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectPromiseLike(schema) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === ExtendsResult.True;
  }
  function Property(left, right) {
    return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
  }
  function FromObjectRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left)) ? (() => {
      return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
    })() : ExtendsResult.False;
  }
  function FromObject(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.True;
        }
        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })();
  }
  function FromPromise(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
  }
  function RecordKey(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : (index_7.PatternStringExact in schema.patternProperties) ? (0, index_4.String)() : Throw("Unknown record key pattern");
  }
  function RecordValue(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : (index_7.PatternStringExact in schema.patternProperties) ? schema.patternProperties[index_7.PatternStringExact] : Throw("Unable to get record value schema");
  }
  function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property(Value, left.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })() : ExtendsResult.False;
  }
  function FromRecord(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
  }
  function FromRegExp(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit(L, R);
  }
  function FromStringRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromString(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromSymbol(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromTemplateLiteral(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw("Invalid fallthrough for TemplateLiteral");
  }
  function IsArrayOfTuple(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True);
  }
  function FromTupleRight(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
  }
  function FromTuple(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUint8Array(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUndefined(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnionRight(left, right) {
    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnion(left, right) {
    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnknownRight(left, right) {
    return ExtendsResult.True;
  }
  function FromUnknown(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoidRight(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoid(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function Visit(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot(left, right) : index_10.TypeGuard.IsAny(left) ? FromAny(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) : index_10.TypeGuard.IsString(left) ? FromString(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[index_8.Kind]}'`);
  }
  function ExtendsCheck(left, right) {
    return Visit(left, right);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtendsFromMappedResult = ExtendsFromMappedResult;
  var index_1 = require_mapped2();
  var extends_1 = require_extends();
  function FromProperties(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, options);
    return Acc;
  }
  function FromMappedResult(Left, Right, True, False, options) {
    return FromProperties(Left.properties, Right, True, False, options);
  }
  function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Extends = Extends;
  var index_1 = require_union2();
  var extends_check_1 = require_extends_check();
  var type_1 = require_type2();
  var extends_from_mapped_key_1 = require_extends_from_mapped_key();
  var extends_from_mapped_result_1 = require_extends_from_mapped_result();
  var kind_1 = require_kind();
  function ExtendsResolve(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  }
  function Extends(L, R, T, F, options = {}) {
    return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CloneType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CloneType)(ExtendsResolve(L, R, T, F), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtendsFromMappedKey = ExtendsFromMappedKey;
  var index_1 = require_mapped2();
  var index_2 = require_literal2();
  var extends_1 = require_extends();
  function FromPropertyKey(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, options)
    };
  }
  function FromPropertyKeys(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
    }, {});
  }
  function FromMappedKey(K, U, L, R, options) {
    return FromPropertyKeys(K.keys, U, L, R, options);
  }
  function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_extends_check(), exports2);
  __exportStar(require_extends_from_mapped_key(), exports2);
  __exportStar(require_extends_from_mapped_result(), exports2);
  __exportStar(require_extends_undefined(), exports2);
  __exportStar(require_extends(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueCheckUnknownTypeError = undefined;
  exports2.Check = Check;
  var index_1 = require_system2();
  var index_2 = require_deref2();
  var index_3 = require_hash2();
  var index_4 = require_symbols2();
  var index_5 = require_keyof2();
  var index_6 = require_extends2();
  var index_7 = require_registry();
  var index_8 = require_error2();
  var index_9 = require_never3();
  var index_10 = require_guard2();
  var type_1 = require_type3();

  class ValueCheckUnknownTypeError extends index_8.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports2.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  function IsAnyOrUnknown(schema) {
    return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
  }
  function IsDefined(value) {
    return value !== undefined;
  }
  function FromAny(schema, references, value) {
    return true;
  }
  function FromArray(schema, references, value) {
    if (!(0, index_10.IsArray)(value))
      return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_3.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  }
  function FromAsyncIterator(schema, references, value) {
    return (0, index_10.IsAsyncIterator)(value);
  }
  function FromBigInt(schema, references, value) {
    if (!(0, index_10.IsBigInt)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function FromBoolean(schema, references, value) {
    return (0, index_10.IsBoolean)(value);
  }
  function FromConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  }
  function FromDate(schema, references, value) {
    if (!(0, index_10.IsDate)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function FromFunction(schema, references, value) {
    return (0, index_10.IsFunction)(value);
  }
  function FromInteger(schema, references, value) {
    if (!(0, index_10.IsInteger)(value)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromIntersect(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function FromIterator(schema, references, value) {
    return (0, index_10.IsIterator)(value);
  }
  function FromLiteral(schema, references, value) {
    return value === schema.const;
  }
  function FromNever(schema, references, value) {
    return false;
  }
  function FromNot(schema, references, value) {
    return !Visit(schema.not, references, value);
  }
  function FromNull(schema, references, value) {
    return (0, index_10.IsNull)(value);
  }
  function FromNumber(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromObject(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  }
  function FromPromise(schema, references, value) {
    return (0, index_10.IsPromise)(value);
  }
  function FromRecord(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex.test(key) ? Visit(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromRegExp(schema, references, value) {
    const regex = new RegExp(schema.source, schema.flags);
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    return regex.test(value);
  }
  function FromString(schema, references, value) {
    if (!(0, index_10.IsString)(value)) {
      return false;
    }
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value))
        return false;
    }
    if (IsDefined(schema.format)) {
      if (!index_7.FormatRegistry.Has(schema.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  }
  function FromSymbol(schema, references, value) {
    return (0, index_10.IsSymbol)(value);
  }
  function FromTemplateLiteral(schema, references, value) {
    return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_10.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i2 = 0;i2 < schema.items.length; i2++) {
      if (!Visit(schema.items[i2], references, value[i2]))
        return false;
    }
    return true;
  }
  function FromUndefined(schema, references, value) {
    return (0, index_10.IsUndefined)(value);
  }
  function FromUnion(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
  }
  function FromUint8Array(schema, references, value) {
    if (!(0, index_10.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  }
  function FromUnknown(schema, references, value) {
    return true;
  }
  function FromVoid(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  }
  function FromKind(schema, references, value) {
    if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
    return func(schema, value);
  }
  function Visit(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny(schema_, references_, value);
      case "Array":
        return FromArray(schema_, references_, value);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Function":
        return FromFunction(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Iterator":
        return FromIterator(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Not":
        return FromNot(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Promise":
        return FromPromise(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "RegExp":
        return FromRegExp(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Uint8Array":
        return FromUint8Array(schema_, references_, value);
      case "Unknown":
        return FromUnknown(schema_, references_, value);
      case "Void":
        return FromVoid(schema_, references_, value);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return FromKind(schema_, references_, value);
    }
  }
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_check(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js
var require_clone = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Clone = Clone;
  var index_1 = require_guard2();
  function ObjectType(value) {
    const Acc = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      Acc[key] = Clone(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      Acc[key] = Clone(value[key]);
    }
    return Acc;
  }
  function ArrayType(value) {
    return value.map((element) => Clone(element));
  }
  function TypedArrayType(value) {
    return value.slice();
  }
  function DateType(value) {
    return new Date(value.toISOString());
  }
  function ValueType(value) {
    return value;
  }
  function Clone(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsTypedArray)(value))
      return TypedArrayType(value);
    if ((0, index_1.IsValueType)(value))
      return ValueType(value);
    throw new Error("ValueClone: Unable to clone value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/index.js
var require_clone2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_clone(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/create/create.js
var require_create = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueCreateError = undefined;
  exports2.Create = Create;
  var index_1 = require_guard2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_template_literal2();
  var index_6 = require_patterns2();
  var index_7 = require_registry();
  var index_8 = require_symbols2();
  var index_9 = require_error2();

  class ValueCreateError extends index_9.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports2.ValueCreateError = ValueCreateError;
  function FromDefault(value) {
    return typeof value === "function" ? value : (0, index_3.Clone)(value);
  }
  function FromAny(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromArray(schema, references) {
    if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return FromDefault(schema.default);
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit(schema.items, references);
      });
    } else {
      return [];
    }
  }
  function FromAsyncIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return async function* () {}();
    }
  }
  function FromBigInt(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return BigInt(0);
    }
  }
  function FromBoolean(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return false;
    }
  }
  function FromConstructor(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = Visit(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self = this;
              self[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  }
  function FromDate(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date;
    }
  }
  function FromFunction(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return () => Visit(schema.returns, references);
    }
  }
  function FromInteger(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromIntersect(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next = Visit(schema2, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, index_2.Check)(schema, references, value))
        throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
      return value;
    }
  }
  function FromIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return function* () {}();
    }
  }
  function FromLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return schema.const;
    }
  }
  function FromNever(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
    }
  }
  function FromNot(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Not types must have a default value");
    }
  }
  function FromNull(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return null;
    }
  }
  function FromNumber(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromObject(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const required = new Set(schema.required);
      const Acc = {};
      for (const [key, subschema] of Object.entries(schema.properties)) {
        if (!required.has(key))
          continue;
        Acc[key] = Visit(subschema, references);
      }
      return Acc;
    }
  }
  function FromPromise(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Promise.resolve(Visit(schema.item, references));
    }
  }
  function FromRecord(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      const Acc = {};
      for (const key of propertyKeys)
        Acc[key] = Visit(valueSchema, references);
      return Acc;
    } else {
      return {};
    }
  }
  function FromRef(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromRegExp(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
    }
  }
  function FromString(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with patterns must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else if (schema.format !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with formats must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault(schema.default);
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => " ").join("");
      } else {
        return "";
      }
    }
  }
  function FromSymbol(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  }
  function FromTemplateLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema))
      throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
    const generated = (0, index_5.TemplateLiteralGenerate)(schema);
    return generated[0];
  }
  function FromThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
      throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromTuple(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
  }
  function FromUndefined(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromUnion(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit(schema.anyOf[0], references);
    }
  }
  function FromUint8Array(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  }
  function FromUnknown(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromVoid(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromKind(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new Error("User defined types must specify a default value");
    }
  }
  function Visit(schema, references) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return FromAny(schema_, references_);
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "BigInt":
        return FromBigInt(schema_, references_);
      case "Boolean":
        return FromBoolean(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Date":
        return FromDate(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Integer":
        return FromInteger(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Literal":
        return FromLiteral(schema_, references_);
      case "Never":
        return FromNever(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Null":
        return FromNull(schema_, references_);
      case "Number":
        return FromNumber(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "RegExp":
        return FromRegExp(schema_, references_);
      case "String":
        return FromString(schema_, references_);
      case "Symbol":
        return FromSymbol(schema_, references_);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Undefined":
        return FromUndefined(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      case "Uint8Array":
        return FromUint8Array(schema_, references_);
      case "Unknown":
        return FromUnknown(schema_, references_);
      case "Void":
        return FromVoid(schema_, references_);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueCreateError(schema_, "Unknown type");
        return FromKind(schema_, references_);
    }
  }
  var recursiveMaxDepth = 512;
  var recursiveDepth = 0;
  function Create(...args) {
    recursiveDepth = 0;
    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/index.js
var require_create2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_create(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js
var require_cast = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueCastError = undefined;
  exports2.Cast = Cast;
  var index_1 = require_guard2();
  var index_2 = require_error2();
  var index_3 = require_symbols2();
  var index_4 = require_create2();
  var index_5 = require_check2();
  var index_6 = require_clone2();
  var index_7 = require_deref2();

  class ValueCastError extends index_2.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports2.ValueCastError = ValueCastError;
  function ScoreUnion(schema, references, value) {
    if (schema[index_3.Kind] === "Object" && typeof value === "object" && !(0, index_1.IsNull)(value)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value);
      const entries = Object.entries(object.properties);
      const [point, max2] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[index_3.Kind] === "Literal" && schema2.const === value[key] ? max2 : 0;
        const checks = (0, index_5.Check)(schema2, references, value[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal + checks + exists);
      }, 0);
    } else {
      return (0, index_5.Check)(schema, references, value) ? 1 : 0;
    }
  }
  function SelectUnion(union, references, value) {
    const schemas = union.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
    let [select, best] = [schemas[0], 0];
    for (const schema of schemas) {
      const score = ScoreUnion(schema, references, value);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function CastUnion(union, references, value) {
    if ("default" in union) {
      return typeof value === "function" ? union.default : (0, index_6.Clone)(union.default);
    } else {
      const schema = SelectUnion(union, references, value);
      return Cast(schema, references, value);
    }
  }
  function DefaultClone(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
  }
  function Default(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
  }
  function FromArray(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema, references, unique))
      throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
    return unique;
  }
  function FromConstructor(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {};
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
  }
  function FromIntersect(schema, references, value) {
    const created = (0, index_4.Create)(schema, references);
    const mapped = (0, index_1.IsStandardObject)(created) && (0, index_1.IsStandardObject)(value) ? { ...created, ...value } : value;
    return (0, index_5.Check)(schema, references, mapped) ? mapped : (0, index_4.Create)(schema, references);
  }
  function FromNever(schema, references, value) {
    throw new ValueCastError(schema, "Never types cannot be cast");
  }
  function FromObject(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, index_4.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (!(0, index_1.IsArray)(value))
      return (0, index_4.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
  }
  function FromUnion(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion(schema, references, value);
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_3.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone(schema, references, value);
      default:
        return Default(schema_, references_, value);
    }
  }
  function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/index.js
var require_cast2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_cast(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js
var require_clean = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Clean = Clean;
  var index_1 = require_keyof2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_symbols2();
  var index_6 = require_guard2();
  var type_1 = require_type3();
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_5.Kind] !== "Unsafe";
  }
  function FromArray(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    return value.map((value2) => Visit(schema.items, references, value2));
  }
  function FromIntersect(schema, references, value) {
    const unevaluatedProperties = schema.unevaluatedProperties;
    const intersections = schema.allOf.map((schema2) => Visit(schema2, references, (0, index_3.Clone)(value)));
    const composite = intersections.reduce((acc, value2) => (0, index_6.IsObject)(value2) ? { ...acc, ...value2 } : value2, {});
    if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, type_1.IsSchema)(unevaluatedProperties))
      return composite;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
    for (const key of Object.getOwnPropertyNames(value)) {
      if (knownkeys.includes(key))
        continue;
      if ((0, index_2.Check)(unevaluatedProperties, references, value[key])) {
        composite[key] = Visit(unevaluatedProperties, references, value[key]);
      }
    }
    return composite;
  }
  function FromObject(schema, references, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value)) {
      if (key in schema.properties) {
        value[key] = Visit(schema.properties[key], references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRecord(schema, references, value) {
    if (!(0, index_6.IsObject)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    const propertyKeys = Object.getOwnPropertyNames(value);
    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
      if (propertyKeyTest.test(key)) {
        value[key] = Visit(propertySchema, references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    if ((0, index_6.IsUndefined)(schema.items))
      return [];
    const length = Math.min(value.length, schema.items.length);
    for (let i2 = 0;i2 < length; i2++) {
      value[i2] = Visit(schema.items[i2], references, value[i2]);
    }
    return value.length > length ? value.slice(0, length) : value;
  }
  function FromUnion(schema, references, value) {
    for (const inner of schema.anyOf) {
      if (IsCheckable(inner) && (0, index_2.Check)(inner, references, value)) {
        return Visit(inner, references, value);
      }
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_6.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_5.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return value;
    }
  }
  function Clean(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/index.js
var require_clean2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_clean(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js
var require_convert = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Convert = Convert;
  var index_1 = require_clone2();
  var index_2 = require_check2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  function IsStringNumeric(value) {
    return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  function IsValueToString(value) {
    return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
  }
  function IsValueTrue(value) {
    return value === true || (0, index_5.IsNumber)(value) && value === 1 || (0, index_5.IsBigInt)(value) && value === BigInt("1") || (0, index_5.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  }
  function IsValueFalse(value) {
    return value === false || (0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, index_5.IsBigInt)(value) && value === BigInt("0") || (0, index_5.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  }
  function IsTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsDateTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateString(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  function TryConvertLiteralString(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralNumber(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralBoolean(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteral(schema, value) {
    return (0, index_5.IsString)(schema.const) ? TryConvertLiteralString(value, schema.const) : (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber(value, schema.const) : (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : (0, index_1.Clone)(value);
  }
  function TryConvertBoolean(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
  }
  function TryConvertBigInt(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, index_5.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
  }
  function TryConvertString(value) {
    return IsValueToString(value) ? value.toString() : (0, index_5.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;
  }
  function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertNull(value) {
    return (0, index_5.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  }
  function TryConvertUndefined(value) {
    return (0, index_5.IsString)(value) && value === "undefined" ? undefined : value;
  }
  function TryConvertDate(value) {
    return (0, index_5.IsDate)(value) ? value : (0, index_5.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  function Default(value) {
    return value;
  }
  function FromArray(schema, references, value) {
    const elements = (0, index_5.IsArray)(value) ? value : [value];
    return elements.map((element) => Visit(schema.items, references, element));
  }
  function FromBigInt(schema, references, value) {
    return TryConvertBigInt(value);
  }
  function FromBoolean(schema, references, value) {
    return TryConvertBoolean(value);
  }
  function FromDate(schema, references, value) {
    return TryConvertDate(value);
  }
  function FromInteger(schema, references, value) {
    return TryConvertInteger(value);
  }
  function FromIntersect(schema, references, value) {
    return schema.allOf.reduce((value2, schema2) => Visit(schema2, references, value2), value);
  }
  function FromLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
  }
  function FromNull(schema, references, value) {
    return TryConvertNull(value);
  }
  function FromNumber(schema, references, value) {
    return TryConvertNumber(value);
  }
  function FromObject(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const result = {};
    for (const key of Object.keys(value)) {
      result[key] = (0, index_5.HasPropertyKey)(schema.properties, key) ? Visit(schema.properties[key], references, value[key]) : value[key];
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(property, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromString(schema, references, value) {
    return TryConvertString(value);
  }
  function FromSymbol(schema, references, value) {
    return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
    if (!isConvertable)
      return value;
    return value.map((value2, index) => {
      return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
    });
  }
  function FromUndefined(schema, references, value) {
    return TryConvertUndefined(value);
  }
  function FromUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit(subschema, references, value);
      if (!(0, index_2.Check)(subschema, references, converted))
        continue;
      return converted;
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return Default(value);
    }
  }
  function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/index.js
var require_convert2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_convert(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/default/default.js
var require_default = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Default = Default;
  var index_1 = require_check2();
  var index_2 = require_clone2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  var type_1 = require_type3();
  function ValueOrDefault(schema, value) {
    return value === undefined && "default" in schema ? (0, index_2.Clone)(schema.default) : value;
  }
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_4.Kind] !== "Unsafe";
  }
  function IsDefaultSchema(value) {
    return (0, type_1.IsSchema)(value) && "default" in value;
  }
  function FromArray(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted))
      return defaulted;
    for (let i2 = 0;i2 < defaulted.length; i2++) {
      defaulted[i2] = Visit(schema.items, references, defaulted[i2]);
    }
    return defaulted;
  }
  function FromIntersect(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    return schema.allOf.reduce((acc, schema2) => {
      const next = Visit(schema2, references, defaulted);
      return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
    }, {});
  }
  function FromObject(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
    for (const key of knownPropertyKeys) {
      if (!IsDefaultSchema(schema.properties[key]))
        continue;
      defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKeys.includes(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRecord(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
        continue;
      defaulted[key] = Visit(propertySchema, references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKey.test(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, ValueOrDefault(schema, value));
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
      return defaulted;
    const [items, max2] = [schema.items, Math.max(schema.items.length, defaulted.length)];
    for (let i2 = 0;i2 < max2; i2++) {
      if (i2 < items.length)
        defaulted[i2] = Visit(items[i2], references, defaulted[i2]);
    }
    return defaulted;
  }
  function FromUnion(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    for (const inner of schema.anyOf) {
      const result = Visit(inner, references, defaulted);
      if (IsCheckable(inner) && (0, index_1.Check)(inner, result)) {
        return result;
      }
    }
    return defaulted;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return ValueOrDefault(schema_, value);
    }
  }
  function Default(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/index.js
var require_default2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_default(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js
var require_pointer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValuePointerRootDeleteError = exports2.ValuePointerRootSetError = undefined;
  exports2.Format = Format;
  exports2.Set = Set2;
  exports2.Delete = Delete;
  exports2.Has = Has;
  exports2.Get = Get;
  var index_1 = require_error2();

  class ValuePointerRootSetError extends index_1.TypeBoxError {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports2.ValuePointerRootSetError = ValuePointerRootSetError;

  class ValuePointerRootDeleteError extends index_1.TypeBoxError {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports2.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  function Escape(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format(pointer) {
    if (pointer === "")
      return;
    let [start, end] = [0, 0];
    for (let i2 = 0;i2 < pointer.length; i2++) {
      const char = pointer.charAt(i2);
      if (char === "/") {
        if (i2 === 0) {
          start = i2 + 1;
        } else {
          end = i2;
          yield Escape(pointer.slice(start, end));
          start = i2 + 1;
        }
      } else {
        end = i2;
      }
    }
    yield Escape(pointer.slice(start));
  }
  function Set2(value, pointer, update) {
    if (pointer === "")
      throw new ValuePointerRootSetError(value, pointer, update);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  }
  function Delete(value, pointer) {
    if (pointer === "")
      throw new ValuePointerRootDeleteError(value, pointer);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  function Has(value, pointer) {
    if (pointer === "")
      return true;
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  function Get(value, pointer) {
    if (pointer === "")
      return value;
    let current = value;
    for (const component of Format(pointer)) {
      if (current[component] === undefined)
        return;
      current = current[component];
    }
    return current;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js
var require_pointer2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValuePointer = undefined;
  exports2.ValuePointer = require_pointer();
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js
var require_delta = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueDeltaSymbolError = exports2.ValueDeltaError = exports2.Edit = exports2.Delete = exports2.Update = exports2.Insert = undefined;
  exports2.Diff = Diff;
  exports2.Patch = Patch;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();
  var index_5 = require_literal2();
  var index_6 = require_object2();
  var index_7 = require_string2();
  var index_8 = require_unknown2();
  var index_9 = require_union2();
  exports2.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)("insert"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports2.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)("update"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports2.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)("delete"),
    path: (0, index_7.String)()
  });
  exports2.Edit = (0, index_9.Union)([exports2.Insert, exports2.Update, exports2.Delete]);

  class ValueDeltaError extends index_4.TypeBoxError {
    constructor(value, message) {
      super(message);
      this.value = value;
    }
  }
  exports2.ValueDeltaError = ValueDeltaError;

  class ValueDeltaSymbolError extends ValueDeltaError {
    constructor(value) {
      super(value, "Cannot diff objects with symbol keys");
      this.value = value;
    }
  }
  exports2.ValueDeltaSymbolError = ValueDeltaSymbolError;
  function CreateUpdate(path, value) {
    return { type: "update", path, value };
  }
  function CreateInsert(path, value) {
    return { type: "insert", path, value };
  }
  function CreateDelete(path) {
    return { type: "delete", path };
  }
  function* ObjectType(path, current, next) {
    if (!(0, index_1.IsStandardObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
    const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsUndefined)(current[key]) || (0, index_1.IsUndefined)(next[key]))
        continue;
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      yield* Visit(`${path}/${globalThis.String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${globalThis.String(key)}`);
    }
  }
  function* ArrayType(path, current, next) {
    if (!(0, index_1.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i2 = 0;i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
    }
    for (let i2 = 0;i2 < next.length; i2++) {
      if (i2 < current.length)
        continue;
      yield CreateInsert(`${path}/${i2}`, next[i2]);
    }
    for (let i2 = current.length - 1;i2 >= 0; i2--) {
      if (i2 < next.length)
        continue;
      yield CreateDelete(`${path}/${i2}`);
    }
  }
  function* TypedArrayType(path, current, next) {
    if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i2 = 0;i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit(`${path}/${i2}`, current[i2], next[i2]);
    }
  }
  function* ValueType(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit(path, current, next) {
    if ((0, index_1.IsStandardObject)(current))
      return yield* ObjectType(path, current, next);
    if ((0, index_1.IsArray)(current))
      return yield* ArrayType(path, current, next);
    if ((0, index_1.IsTypedArray)(current))
      return yield* TypedArrayType(path, current, next);
    if ((0, index_1.IsValueType)(current))
      return yield* ValueType(path, current, next);
    throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
  }
  function Diff(current, next) {
    return [...Visit("", current, next)];
  }
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, index_3.Clone)(current);
    }
    const clone = (0, index_3.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "update": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "delete": {
          index_2.ValuePointer.Delete(clone, edit.path);
          break;
        }
      }
    }
    return clone;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/index.js
var require_delta2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_delta(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js
var require_equal = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Equal = Equal;
  var index_1 = require_guard2();
  function ObjectType(left, right) {
    if (!(0, index_1.IsStandardObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
  }
  function DateType(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
  }
  function ArrayType(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function TypedArrayType(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function ValueType(left, right) {
    return left === right;
  }
  function Equal(left, right) {
    if ((0, index_1.IsStandardObject)(left))
      return ObjectType(left, right);
    if ((0, index_1.IsDate)(left))
      return DateType(left, right);
    if ((0, index_1.IsTypedArray)(left))
      return TypedArrayType(left, right);
    if ((0, index_1.IsArray)(left))
      return ArrayType(left, right);
    if ((0, index_1.IsValueType)(left))
      return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/index.js
var require_equal2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_equal(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js
var require_mutate = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ValueMutateError = undefined;
  exports2.Mutate = Mutate;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();

  class ValueMutateError extends index_4.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports2.ValueMutateError = ValueMutateError;
  function ObjectType(root, path, current, next) {
    if (!(0, index_1.IsStandardObject)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      const currentKeys = Object.getOwnPropertyNames(current);
      const nextKeys = Object.getOwnPropertyNames(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  }
  function ArrayType(root, path, current, next) {
    if (!(0, index_1.IsArray)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  }
  function TypedArrayType(root, path, current, next) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i2 = 0;i2 < current.length; i2++) {
        current[i2] = next[i2];
      }
    } else {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
  }
  function ValueType(root, path, current, next) {
    if (current === next)
      return;
    index_2.ValuePointer.Set(root, path, next);
  }
  function Visit(root, path, current, next) {
    if ((0, index_1.IsArray)(next))
      return ArrayType(root, path, current, next);
    if ((0, index_1.IsTypedArray)(next))
      return TypedArrayType(root, path, current, next);
    if ((0, index_1.IsStandardObject)(next))
      return ObjectType(root, path, current, next);
    if ((0, index_1.IsValueType)(next))
      return ValueType(root, path, current, next);
  }
  function IsNonMutableValue(value) {
    return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
  }
  function IsMismatchedValue(current, next) {
    return (0, index_1.IsStandardObject)(current) && (0, index_1.IsArray)(next) || (0, index_1.IsArray)(current) && (0, index_1.IsStandardObject)(next);
  }
  function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
      throw new ValueMutateError("Only object and array types can be mutated at the root level");
    if (IsMismatchedValue(current, next))
      throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
    Visit(current, "", current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js
var require_mutate2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_mutate(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js
var require_decode = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TransformDecodeError = exports2.TransformDecodeCheckError = undefined;
  exports2.TransformDecode = TransformDecode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformDecodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error2) {
      super(`Unable to decode value as it does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error2;
    }
  }
  exports2.TransformDecodeCheckError = TransformDecodeCheckError;

  class TransformDecodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error2) {
      super(error2 instanceof Error ? error2.message : "Unknown error");
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error2;
    }
  }
  exports2.TransformDecodeError = TransformDecodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
    } catch (error2) {
      throw new TransformDecodeError(schema, path, value, error2);
    }
  }
  function FromArray(schema, references, path, value) {
    return (0, index_6.IsArray)(value) ? Default(schema, path, value.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
  }
  function FromIntersect(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return Default(schema, path, value);
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...value };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromNot(schema, references, path, value) {
    return Default(schema, path, Visit(schema.not, references, path, value));
  }
  function FromObject(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...value };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRecord(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...value };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromTuple(schema, references, path, value) {
    return (0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const decoded = Visit(subschema, references, path, value);
      return Default(schema, path, decoded);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "Symbol":
        return Default(schema_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformDecode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js
var require_encode = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TransformEncodeError = exports2.TransformEncodeCheckError = undefined;
  exports2.TransformEncode = TransformEncode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformEncodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error2) {
      super(`The encoded value does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error2;
    }
  }
  exports2.TransformEncodeCheckError = TransformEncodeCheckError;

  class TransformEncodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error2) {
      super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error2;
    }
  }
  exports2.TransformEncodeError = TransformEncodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    } catch (error2) {
      throw new TransformEncodeError(schema, path, value, error2);
    }
  }
  function FromArray(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    return (0, index_6.IsArray)(defaulted) ? defaulted.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2)) : defaulted;
  }
  function FromIntersect(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return defaulted;
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...defaulted };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromNot(schema, references, path, value) {
    return Default(schema.not, path, Default(schema, path, value));
  }
  function FromObject(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(defaulted))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...defaulted };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRecord(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value))
      return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...defaulted };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromTuple(schema, references, path, value) {
    const value1 = Default(schema, path, value);
    return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value1[index])) : [];
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const value1 = Visit(subschema, references, path, value);
      return Default(schema, path, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit(subschema, references, path, value);
      if (!(0, index_5.Check)(schema, references, value1))
        continue;
      return Default(schema, path, value1);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformEncode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/has.js
var require_has = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.HasTransform = HasTransform;
  var index_1 = require_deref2();
  var index_2 = require_symbols2();
  var type_1 = require_type3();
  var index_3 = require_guard2();
  function FromArray(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromAsyncIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromConstructor(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromFunction(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromIntersect(schema, references) {
    return (0, type_1.IsTransform)(schema) || (0, type_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
  }
  function FromIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromNot(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.not, references);
  }
  function FromObject(schema, references) {
    return (0, type_1.IsTransform)(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || (0, type_1.IsSchema)(schema.additionalProperties) && Visit(schema.additionalProperties, references);
  }
  function FromPromise(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.item, references);
  }
  function FromRecord(schema, references) {
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern];
    return (0, type_1.IsTransform)(schema) || Visit(property, references) || (0, type_1.IsSchema)(schema.additionalProperties) && (0, type_1.IsTransform)(schema.additionalProperties);
  }
  function FromRef(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromThis(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromTuple(schema, references) {
    return (0, type_1.IsTransform)(schema) || !(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
  }
  function FromUnion(schema, references) {
    return (0, type_1.IsTransform)(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
  }
  function Visit(schema, references) {
    const references_ = (0, index_3.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
      return false;
    if (schema.$id)
      visited.add(schema.$id);
    switch (schema[index_2.Kind]) {
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      default:
        return (0, type_1.IsTransform)(schema);
    }
  }
  var visited = new Set;
  function HasTransform(schema, references) {
    visited.clear();
    return Visit(schema, references);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/index.js
var require_transform = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_decode(), exports2);
  __exportStar(require_encode(), exports2);
  __exportStar(require_has(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/value/value/value.js
var require_value3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Cast = Cast;
  exports2.Create = Create;
  exports2.Check = Check;
  exports2.Clean = Clean;
  exports2.Convert = Convert;
  exports2.Clone = Clone;
  exports2.Decode = Decode;
  exports2.Default = Default;
  exports2.Encode = Encode;
  exports2.Errors = Errors;
  exports2.Equal = Equal;
  exports2.Diff = Diff;
  exports2.Hash = Hash;
  exports2.Patch = Patch;
  exports2.Mutate = Mutate;
  var index_1 = require_transform();
  var index_2 = require_mutate2();
  var index_3 = require_hash2();
  var index_4 = require_equal2();
  var index_5 = require_cast2();
  var index_6 = require_clone2();
  var index_7 = require_convert2();
  var index_8 = require_create2();
  var index_9 = require_clean2();
  var index_10 = require_check2();
  var index_11 = require_default2();
  var index_12 = require_delta2();
  var index_13 = require_errors2();
  function Cast(...args) {
    return index_5.Cast.apply(index_5.Cast, args);
  }
  function Create(...args) {
    return index_8.Create.apply(index_8.Create, args);
  }
  function Check(...args) {
    return index_10.Check.apply(index_10.Check, args);
  }
  function Clean(...args) {
    return index_9.Clean.apply(index_9.Clean, args);
  }
  function Convert(...args) {
    return index_7.Convert.apply(index_7.Convert, args);
  }
  function Clone(value) {
    return (0, index_6.Clone)(value);
  }
  function Decode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check(schema, references, value))
      throw new index_1.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
    return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
  }
  function Default(...args) {
    return index_11.Default.apply(index_11.Default, args);
  }
  function Encode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
    if (!Check(schema, references, encoded))
      throw new index_1.TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
    return encoded;
  }
  function Errors(...args) {
    return index_13.Errors.apply(index_13.Errors, args);
  }
  function Equal(left, right) {
    return (0, index_4.Equal)(left, right);
  }
  function Diff(current, next) {
    return (0, index_12.Diff)(current, next);
  }
  function Hash(value) {
    return (0, index_3.Hash)(value);
  }
  function Patch(current, edits) {
    return (0, index_12.Patch)(current, edits);
  }
  function Mutate(current, next) {
    (0, index_2.Mutate)(current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/value/index.js
var require_value4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Value = undefined;
  exports2.Value = require_value3();
});

// node_modules/@sinclair/typebox/build/cjs/value/index.js
var require_value5 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Value = exports2.ValueErrorIterator = exports2.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports2, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports2, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_guard2(), exports2);
  __exportStar(require_cast2(), exports2);
  __exportStar(require_check2(), exports2);
  __exportStar(require_clean2(), exports2);
  __exportStar(require_clone2(), exports2);
  __exportStar(require_convert2(), exports2);
  __exportStar(require_create2(), exports2);
  __exportStar(require_default2(), exports2);
  __exportStar(require_delta2(), exports2);
  __exportStar(require_equal2(), exports2);
  __exportStar(require_hash2(), exports2);
  __exportStar(require_mutate2(), exports2);
  __exportStar(require_pointer2(), exports2);
  __exportStar(require_transform(), exports2);
  var index_2 = require_value4();
  Object.defineProperty(exports2, "Value", { enumerable: true, get: function() {
    return index_2.Value;
  } });
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/safe-parse-type.js
var require_safe_parse_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "safeParseType", {
    enumerable: true,
    get: function() {
      return safeParseType;
    }
  });
  var _value = require_value5();
  function safeParseType(schema, value) {
    const parsedValue = _value.Value.Convert(schema, _value.Value.Clean(schema, _value.Value.Default(schema, structuredClone(value))));
    if (!_value.Value.Check(schema, parsedValue)) {
      const typeboxErrors = _value.Value.Errors(schema, parsedValue);
      const errors2 = {};
      for (const typeboxError of typeboxErrors) {
        errors2[typeboxError.path] = typeboxError.message;
      }
      return {
        success: false,
        errors: errors2
      };
    }
    return {
      success: true,
      data: parsedValue
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone3 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_type2(), exports2);
  __exportStar(require_value2(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Increment = Increment;
  function Increment(T) {
    return (parseInt(T) + 1).toString();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_helpers(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Awaited = Awaited;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => AwaitedResolve(L));
  }
  function FromIntersect(T) {
    return (0, index_1.Intersect)(FromRest(T));
  }
  function FromUnion(T) {
    return (0, index_2.Union)(FromRest(T));
  }
  function FromPromise(T) {
    return AwaitedResolve(T);
  }
  function AwaitedResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsPromise)(T) ? FromPromise(T.item) : T;
  }
  function Awaited(T, options = {}) {
    return (0, type_1.CloneType)(AwaitedResolve(T), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_awaited(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Composite = Composite;
  var index_1 = require_intersect2();
  var index_2 = require_indexed2();
  var index_3 = require_keyof2();
  var index_4 = require_object2();
  var index_5 = require_sets();
  var kind_1 = require_kind();
  function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
  }
  function FilterNever(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever(Acc);
  }
  function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
      Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
    }
    return Acc;
  }
  function Composite(T, options = {}) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_composite(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Date = Date2;
  var index_1 = require_symbols2();
  function Date2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Date",
      type: "Date"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_date(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Null = Null;
  var index_1 = require_symbols2();
  function Null(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Null",
      type: "null"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_null(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Symbol = Symbol2;
  var index_1 = require_symbols2();
  function Symbol2(options) {
    return { ...options, [index_1.Kind]: "Symbol", type: "symbol" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_symbol(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Undefined = Undefined;
  var index_1 = require_symbols2();
  function Undefined(options = {}) {
    return { ...options, [index_1.Kind]: "Undefined", type: "undefined" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_undefined(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Uint8Array = Uint8Array2;
  var index_1 = require_symbols2();
  function Uint8Array2(options = {}) {
    return { ...options, [index_1.Kind]: "Uint8Array", type: "Uint8Array" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_uint8array(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Const = Const;
  var index_1 = require_any2();
  var index_2 = require_bigint2();
  var index_3 = require_date2();
  var index_4 = require_function2();
  var index_5 = require_literal2();
  var index_6 = require_null2();
  var index_7 = require_object2();
  var index_8 = require_symbol2();
  var index_9 = require_tuple2();
  var index_10 = require_readonly2();
  var index_11 = require_undefined2();
  var index_12 = require_uint8array2();
  var index_13 = require_unknown2();
  var index_14 = require_clone3();
  var value_1 = require_value();
  function FromArray(T) {
    return T.map((L) => FromValue(L, false));
  }
  function FromProperties(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
      Acc[K] = (0, index_10.Readonly)(FromValue(value[K], false));
    return Acc;
  }
  function ConditionalReadonly(T, root) {
    return root === true ? T : (0, index_10.Readonly)(T);
  }
  function FromValue(value, root) {
    return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value)), root) : (0, value_1.IsFunction)(value) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
  }
  function Const(T, options = {}) {
    return (0, index_14.CloneType)(FromValue(T, true), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_const(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ConstructorParameters = ConstructorParameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function ConstructorParameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_constructor_parameters(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js
var require_deref3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Deref = Deref;
  var type_1 = require_type2();
  var index_1 = require_discard2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function FromRest(schema, references) {
    return schema.map((schema2) => Deref(schema2, references));
  }
  function FromProperties(properties, references) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
      Acc[K] = Deref(properties[K], references);
    }
    return Acc;
  }
  function FromConstructor(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromFunction(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromIntersect(schema, references) {
    schema.allOf = FromRest(schema.allOf, references);
    return schema;
  }
  function FromUnion(schema, references) {
    schema.anyOf = FromRest(schema.anyOf, references);
    return schema;
  }
  function FromTuple(schema, references) {
    if ((0, value_1.IsUndefined)(schema.items))
      return schema;
    schema.items = FromRest(schema.items, references);
    return schema;
  }
  function FromArray(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromObject(schema, references) {
    schema.properties = FromProperties(schema.properties, references);
    return schema;
  }
  function FromPromise(schema, references) {
    schema.item = Deref(schema.item, references);
    return schema;
  }
  function FromAsyncIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromRef(schema, references) {
    const target = references.find((remote) => remote.$id === schema.$ref);
    if (target === undefined)
      throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
    const discard = (0, index_1.Discard)(target, ["$id"]);
    return Deref(discard, references);
  }
  function DerefResolve(schema, references) {
    return (0, kind_1.IsConstructor)(schema) ? FromConstructor(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef(schema, references) : schema;
  }
  function Deref(schema, references) {
    return DerefResolve((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/index.js
var require_deref4 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_deref3(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Enum = Enum;
  var index_1 = require_literal2();
  var index_2 = require_symbols2();
  var index_3 = require_union2();
  var value_1 = require_value();
  function Enum(item, options = {}) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => (0, index_1.Literal)(value));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_enum(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
  var exclude_1 = require_exclude();
  var index_1 = require_template_literal2();
  function ExcludeFromTemplateLiteral(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Exclude = Exclude;
  var index_1 = require_union2();
  var index_2 = require_never3();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
  var exclude_from_template_literal_1 = require_exclude_from_template_literal();
  var kind_1 = require_kind();
  function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  }
  function Exclude(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExcludeFromMappedResult = ExcludeFromMappedResult;
  var index_1 = require_mapped2();
  var exclude_1 = require_exclude();
  function FromProperties(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_exclude_from_mapped_result(), exports2);
  __exportStar(require_exclude_from_template_literal(), exports2);
  __exportStar(require_exclude(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
  var extract_1 = require_extract();
  var index_1 = require_template_literal2();
  function ExtractFromTemplateLiteral(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Extract = Extract;
  var index_1 = require_union2();
  var index_2 = require_never3();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var extract_from_mapped_result_1 = require_extract_from_mapped_result();
  var extract_from_template_literal_1 = require_extract_from_template_literal();
  var kind_1 = require_kind();
  function ExtractRest(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  }
  function Extract(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ExtractFromMappedResult = ExtractFromMappedResult;
  var index_1 = require_mapped2();
  var extract_1 = require_extract();
  function FromProperties(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_extract_from_mapped_result(), exports2);
  __exportStar(require_extract_from_template_literal(), exports2);
  __exportStar(require_extract(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.InstanceType = InstanceType;
  var type_1 = require_type2();
  function InstanceType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_instance_type(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Integer = Integer;
  var index_1 = require_symbols2();
  function Integer(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Integer",
      type: "integer"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_integer(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
  var index_1 = require_mapped2();
  var intrinsic_1 = require_intrinsic();
  var index_2 = require_literal2();
  function MappedIntrinsicPropertyKey(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, options)
    };
  }
  function MappedIntrinsicPropertyKeys(K, M, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
  }
  function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T["keys"], M, options);
  }
  function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Intrinsic = Intrinsic;
  var index_1 = require_template_literal2();
  var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
  var index_2 = require_literal2();
  var index_3 = require_union2();
  var kind_1 = require_kind();
  function ApplyUncapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join("");
  }
  function ApplyCapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join("");
  }
  function ApplyUppercase(value) {
    return value.toUpperCase();
  }
  function ApplyLowercase(value) {
    return value.toLowerCase();
  }
  function FromTemplateLiteral(schema, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
    const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite)
      return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value) => (0, index_2.Literal)(value));
    const mapped = FromRest(literals, mode);
    const union = (0, index_3.Union)(mapped);
    return (0, index_1.TemplateLiteral)([union], options);
  }
  function FromLiteralValue(value, mode) {
    return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
  }
  function FromRest(T, M) {
    return T.map((L) => Intrinsic(L, M));
  }
  function Intrinsic(schema, mode, options = {}) {
    return (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, schema) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Capitalize = Capitalize;
  var intrinsic_1 = require_intrinsic();
  function Capitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Lowercase = Lowercase;
  var intrinsic_1 = require_intrinsic();
  function Lowercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Uncapitalize = Uncapitalize;
  var intrinsic_1 = require_intrinsic();
  function Uncapitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Uppercase = Uppercase;
  var intrinsic_1 = require_intrinsic();
  function Uppercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_capitalize(), exports2);
  __exportStar(require_intrinsic_from_mapped_key(), exports2);
  __exportStar(require_intrinsic(), exports2);
  __exportStar(require_lowercase(), exports2);
  __exportStar(require_uncapitalize(), exports2);
  __exportStar(require_uppercase(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Not = Not;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Not(schema, options) {
    return {
      ...options,
      [index_1.Kind]: "Not",
      not: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not3 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_not2(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.OmitFromMappedResult = OmitFromMappedResult;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, omit_1.Omit)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function OmitFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Omit = Omit;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var omit_from_mapped_key_1 = require_omit_from_mapped_key();
  var omit_from_mapped_result_1 = require_omit_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromProperty(T, K) {
    const { [K]: _, ...R } = T;
    return R;
  }
  function FromProperties(T, K) {
    return K.reduce((T2, K2) => FromProperty(T2, K2), T);
  }
  function OmitResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Omit(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(OmitResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.OmitFromMappedKey = OmitFromMappedKey;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, omit_1.Omit)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function OmitFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_omit_from_mapped_key(), exports2);
  __exportStar(require_omit_from_mapped_result(), exports2);
  __exportStar(require_omit(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Parameters = Parameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function Parameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_parameters(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Partial = Partial;
  var index_1 = require_optional2();
  var index_2 = require_object2();
  var index_3 = require_intersect2();
  var index_4 = require_union2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var partial_from_mapped_result_1 = require_partial_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => PartialResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_1.Optional)(T[K]);
    return Acc;
  }
  function PartialResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_4.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_2.Object)(FromProperties(T.properties)) : (0, index_2.Object)({});
  }
  function Partial(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T))
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PartialResolve(T), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PartialFromMappedResult = PartialFromMappedResult;
  var index_1 = require_mapped2();
  var partial_1 = require_partial();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, partial_1.Partial)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function PartialFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_partial_from_mapped_result(), exports2);
  __exportStar(require_partial(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PickFromMappedResult = PickFromMappedResult;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, pick_1.Pick)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function PickFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Pick = Pick;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var pick_from_mapped_key_1 = require_pick_from_mapped_key();
  var pick_from_mapped_result_1 = require_pick_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromProperties(T, K) {
    const Acc = {};
    for (const K2 of K)
      if (K2 in T)
        Acc[K2] = T[K2];
    return Acc;
  }
  function PickResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Pick(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PickResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.PickFromMappedKey = PickFromMappedKey;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, pick_1.Pick)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function PickFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_pick_from_mapped_key(), exports2);
  __exportStar(require_pick_from_mapped_result(), exports2);
  __exportStar(require_pick(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ReadonlyOptional = ReadonlyOptional;
  var index_1 = require_readonly2();
  var index_2 = require_optional2();
  function ReadonlyOptional(schema) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_readonly_optional(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Record = Record;
  var index_1 = require_object2();
  var index_2 = require_never3();
  var index_3 = require_union2();
  var index_4 = require_template_literal2();
  var index_5 = require_patterns2();
  var index_6 = require_indexed2();
  var index_7 = require_symbols2();
  var type_1 = require_type2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function RecordCreateFromPattern(pattern, T, options) {
    return {
      ...options,
      [index_7.Kind]: "Record",
      type: "object",
      patternProperties: { [pattern]: (0, type_1.CloneType)(T) }
    };
  }
  function RecordCreateFromKeys(K, T, options) {
    const Acc = {};
    for (const K2 of K)
      Acc[K2] = (0, type_1.CloneType)(T);
    return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
  }
  function FromTemplateLiteralKey(K, T, options) {
    return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
  }
  function FromUnionKey(K, T, options) {
    return RecordCreateFromKeys((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
  }
  function FromLiteralKey(K, T, options) {
    return RecordCreateFromKeys([K.toString()], T, options);
  }
  function FromRegExpKey(K, T, options) {
    return RecordCreateFromPattern(K.source, T, options);
  }
  function FromStringKey(K, T, options) {
    const pattern = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
    return RecordCreateFromPattern(pattern, T, options);
  }
  function FromAnyKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternStringExact, T, options);
  }
  function FromNeverKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternNeverExact, T, options);
  }
  function FromIntegerKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function FromNumberKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function Record(K, T, options = {}) {
    return (0, kind_1.IsUnion)(K) ? FromUnionKey(K.anyOf, T, options) : (0, kind_1.IsTemplateLiteral)(K) ? FromTemplateLiteralKey(K, T, options) : (0, kind_1.IsLiteral)(K) ? FromLiteralKey(K.const, T, options) : (0, kind_1.IsInteger)(K) ? FromIntegerKey(K, T, options) : (0, kind_1.IsNumber)(K) ? FromNumberKey(K, T, options) : (0, kind_1.IsRegExp)(K) ? FromRegExpKey(K, T, options) : (0, kind_1.IsString)(K) ? FromStringKey(K, T, options) : (0, kind_1.IsAny)(K) ? FromAnyKey(K, T, options) : (0, kind_1.IsNever)(K) ? FromNeverKey(K, T, options) : (0, index_2.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_record(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Recursive = Recursive;
  var type_1 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  var Ordinal = 0;
  function Recursive(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal++}`;
    const thisType = callback({ [index_1.Kind]: "This", $ref: `${options.$id}` });
    thisType.$id = options.$id;
    return (0, type_1.CloneType)({ ...options, [index_1.Hint]: "Recursive", ...thisType });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_recursive(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Ref = Ref;
  var index_1 = require_symbols2();
  var value_1 = require_value();
  function Ref(unresolved, options = {}) {
    if ((0, value_1.IsString)(unresolved))
      return { ...options, [index_1.Kind]: "Ref", $ref: unresolved };
    if ((0, value_1.IsUndefined)(unresolved.$id))
      throw new Error("Reference target type must specify an $id");
    return {
      ...options,
      [index_1.Kind]: "Ref",
      $ref: unresolved.$id
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_ref(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RegExp = RegExp2;
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function RegExp2(unresolved, options = {}) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return { ...options, [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_regexp(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Required = Required;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_symbols2();
  var type_1 = require_type2();
  var index_5 = require_discard2();
  var required_from_mapped_result_1 = require_required_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => RequiredResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_5.Discard)(T[K], [index_4.OptionalKind]);
    return Acc;
  }
  function RequiredResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties)) : (0, index_3.Object)({});
  }
  function Required(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
    } else {
      const D = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required"]);
      const R = (0, type_1.CloneType)(RequiredResolve(T), options);
      return { ...D, ...R };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.RequiredFromMappedResult = RequiredFromMappedResult;
  var index_1 = require_mapped2();
  var required_1 = require_required();
  function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_required_from_mapped_result(), exports2);
  __exportStar(require_required(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Rest = Rest;
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function RestResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, type_1.CloneRest)(T.allOf) : (0, kind_1.IsUnion)(T) ? (0, type_1.CloneRest)(T.anyOf) : (0, kind_1.IsTuple)(T) ? (0, type_1.CloneRest)(T.items ?? []) : [];
  }
  function Rest(T) {
    return (0, type_1.CloneRest)(RestResolve(T));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_rest(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.ReturnType = ReturnType;
  var type_1 = require_type2();
  function ReturnType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_return_type(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_anyschema(), exports2);
  __exportStar(require_schema(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_static(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js
var require_strict = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Strict = Strict;
  function Strict(schema) {
    return JSON.parse(JSON.stringify(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/index.js
var require_strict2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_strict(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.TransformEncodeBuilder = exports2.TransformDecodeBuilder = undefined;
  exports2.Transform = Transform;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();

  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports2.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    EncodeTransform(encode, schema) {
      const Encode = (value) => schema[index_1.TransformKind].Encode(encode(value));
      const Decode = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
      const Codec = { Encode, Decode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode, schema) {
      const Codec = { Decode: this.decode, Encode: encode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    Encode(encode) {
      const schema = (0, type_1.CloneType)(this.schema);
      return (0, kind_1.IsTransform)(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema);
    }
  }
  exports2.TransformEncodeBuilder = TransformEncodeBuilder;
  function Transform(schema) {
    return new TransformDecodeBuilder(schema);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform3 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_transform2(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Void = Void;
  var index_1 = require_symbols2();
  function Void(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Void",
      type: "void"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_void(), exports2);
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.JsonTypeBuilder = undefined;
  var index_1 = require_any2();
  var index_2 = require_array2();
  var index_3 = require_boolean2();
  var index_4 = require_composite2();
  var index_5 = require_const2();
  var index_6 = require_deref4();
  var index_7 = require_enum2();
  var index_8 = require_exclude2();
  var index_9 = require_extends2();
  var index_10 = require_extract2();
  var index_11 = require_indexed2();
  var index_12 = require_integer2();
  var index_13 = require_intersect2();
  var index_14 = require_intrinsic2();
  var index_15 = require_keyof2();
  var index_16 = require_literal2();
  var index_17 = require_mapped2();
  var index_18 = require_never3();
  var index_19 = require_not3();
  var index_20 = require_null2();
  var index_21 = require_number2();
  var index_22 = require_object2();
  var index_23 = require_omit2();
  var index_24 = require_optional2();
  var index_25 = require_partial2();
  var index_26 = require_pick2();
  var index_27 = require_readonly2();
  var index_28 = require_readonly_optional2();
  var index_29 = require_record2();
  var index_30 = require_recursive2();
  var index_31 = require_ref2();
  var index_32 = require_required2();
  var index_33 = require_rest2();
  var index_34 = require_strict2();
  var index_35 = require_string2();
  var index_36 = require_template_literal2();
  var index_37 = require_transform3();
  var index_38 = require_tuple2();
  var index_39 = require_union2();
  var index_40 = require_unknown2();
  var index_41 = require_unsafe2();

  class JsonTypeBuilder {
    Strict(schema) {
      return (0, index_34.Strict)(schema);
    }
    ReadonlyOptional(schema) {
      return (0, index_28.ReadonlyOptional)(schema);
    }
    Readonly(schema, enable) {
      return (0, index_27.Readonly)(schema, enable ?? true);
    }
    Optional(schema, enable) {
      return (0, index_24.Optional)(schema, enable ?? true);
    }
    Any(options = {}) {
      return (0, index_1.Any)(options);
    }
    Array(schema, options = {}) {
      return (0, index_2.Array)(schema, options);
    }
    Boolean(options = {}) {
      return (0, index_3.Boolean)(options);
    }
    Capitalize(schema, options = {}) {
      return (0, index_14.Capitalize)(schema, options);
    }
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    Const(value, options = {}) {
      return (0, index_5.Const)(value, options);
    }
    Deref(schema, references) {
      return (0, index_6.Deref)(schema, references);
    }
    Enum(item, options = {}) {
      return (0, index_7.Enum)(item, options);
    }
    Exclude(unionType2, excludedMembers, options = {}) {
      return (0, index_8.Exclude)(unionType2, excludedMembers, options);
    }
    Extends(L, R, T, F, options = {}) {
      return (0, index_9.Extends)(L, R, T, F, options);
    }
    Extract(type, union, options = {}) {
      return (0, index_10.Extract)(type, union, options);
    }
    Index(schema, unresolved, options = {}) {
      return (0, index_11.Index)(schema, unresolved, options);
    }
    Integer(options = {}) {
      return (0, index_12.Integer)(options);
    }
    Intersect(T, options = {}) {
      return (0, index_13.Intersect)(T, options);
    }
    KeyOf(schema, options = {}) {
      return (0, index_15.KeyOf)(schema, options);
    }
    Literal(value, options = {}) {
      return (0, index_16.Literal)(value, options);
    }
    Lowercase(schema, options = {}) {
      return (0, index_14.Lowercase)(schema, options);
    }
    Mapped(key, map, options = {}) {
      return (0, index_17.Mapped)(key, map, options);
    }
    Never(options = {}) {
      return (0, index_18.Never)(options);
    }
    Not(schema, options) {
      return (0, index_19.Not)(schema, options);
    }
    Null(options = {}) {
      return (0, index_20.Null)(options);
    }
    Number(options = {}) {
      return (0, index_21.Number)(options);
    }
    Object(properties, options = {}) {
      return (0, index_22.Object)(properties, options);
    }
    Omit(schema, unresolved, options = {}) {
      return (0, index_23.Omit)(schema, unresolved, options);
    }
    Partial(schema, options = {}) {
      return (0, index_25.Partial)(schema, options);
    }
    Pick(schema, unresolved, options = {}) {
      return (0, index_26.Pick)(schema, unresolved, options);
    }
    Record(key, schema, options = {}) {
      return (0, index_29.Record)(key, schema, options);
    }
    Recursive(callback, options = {}) {
      return (0, index_30.Recursive)(callback, options);
    }
    Ref(unresolved, options = {}) {
      return (0, index_31.Ref)(unresolved, options);
    }
    Required(schema, options = {}) {
      return (0, index_32.Required)(schema, options);
    }
    Rest(schema) {
      return (0, index_33.Rest)(schema);
    }
    String(options = {}) {
      return (0, index_35.String)(options);
    }
    TemplateLiteral(unresolved, options = {}) {
      return (0, index_36.TemplateLiteral)(unresolved, options);
    }
    Transform(schema) {
      return (0, index_37.Transform)(schema);
    }
    Tuple(items, options = {}) {
      return (0, index_38.Tuple)(items, options);
    }
    Uncapitalize(schema, options = {}) {
      return (0, index_14.Uncapitalize)(schema, options);
    }
    Union(schemas, options = {}) {
      return (0, index_39.Union)(schemas, options);
    }
    Unknown(options = {}) {
      return (0, index_40.Unknown)(options);
    }
    Unsafe(options = {}) {
      return (0, index_41.Unsafe)(options);
    }
    Uppercase(schema, options = {}) {
      return (0, index_14.Uppercase)(schema, options);
    }
  }
  exports2.JsonTypeBuilder = JsonTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Strict = exports2.ReturnType = exports2.Rest = exports2.Required = exports2.RegExp = exports2.Ref = exports2.Recursive = exports2.Record = exports2.ReadonlyOptional = exports2.Readonly = exports2.Promise = exports2.Pick = exports2.Partial = exports2.Parameters = exports2.Optional = exports2.Omit = exports2.Object = exports2.Number = exports2.Null = exports2.Not = exports2.Never = exports2.Mapped = exports2.Literal = exports2.KeyOf = exports2.Iterator = exports2.Uppercase = exports2.Lowercase = exports2.Uncapitalize = exports2.Capitalize = exports2.Intersect = exports2.Integer = exports2.InstanceType = exports2.Index = exports2.Function = exports2.Extract = exports2.Extends = exports2.Exclude = exports2.Enum = exports2.Deref = exports2.Date = exports2.ConstructorParameters = exports2.Constructor = exports2.Const = exports2.Composite = exports2.Boolean = exports2.BigInt = exports2.Awaited = exports2.AsyncIterator = exports2.Array = exports2.Any = undefined;
  exports2.Void = exports2.Unsafe = exports2.Unknown = exports2.Union = exports2.Undefined = exports2.Uint8Array = exports2.Tuple = exports2.Transform = exports2.TemplateLiteral = exports2.Symbol = exports2.String = undefined;
  var index_1 = require_any2();
  Object.defineProperty(exports2, "Any", { enumerable: true, get: function() {
    return index_1.Any;
  } });
  var index_2 = require_array2();
  Object.defineProperty(exports2, "Array", { enumerable: true, get: function() {
    return index_2.Array;
  } });
  var index_3 = require_async_iterator2();
  Object.defineProperty(exports2, "AsyncIterator", { enumerable: true, get: function() {
    return index_3.AsyncIterator;
  } });
  var index_4 = require_awaited2();
  Object.defineProperty(exports2, "Awaited", { enumerable: true, get: function() {
    return index_4.Awaited;
  } });
  var index_5 = require_bigint2();
  Object.defineProperty(exports2, "BigInt", { enumerable: true, get: function() {
    return index_5.BigInt;
  } });
  var index_6 = require_boolean2();
  Object.defineProperty(exports2, "Boolean", { enumerable: true, get: function() {
    return index_6.Boolean;
  } });
  var index_7 = require_composite2();
  Object.defineProperty(exports2, "Composite", { enumerable: true, get: function() {
    return index_7.Composite;
  } });
  var index_8 = require_const2();
  Object.defineProperty(exports2, "Const", { enumerable: true, get: function() {
    return index_8.Const;
  } });
  var index_9 = require_constructor2();
  Object.defineProperty(exports2, "Constructor", { enumerable: true, get: function() {
    return index_9.Constructor;
  } });
  var index_10 = require_constructor_parameters2();
  Object.defineProperty(exports2, "ConstructorParameters", { enumerable: true, get: function() {
    return index_10.ConstructorParameters;
  } });
  var index_11 = require_date2();
  Object.defineProperty(exports2, "Date", { enumerable: true, get: function() {
    return index_11.Date;
  } });
  var index_12 = require_deref4();
  Object.defineProperty(exports2, "Deref", { enumerable: true, get: function() {
    return index_12.Deref;
  } });
  var index_13 = require_enum2();
  Object.defineProperty(exports2, "Enum", { enumerable: true, get: function() {
    return index_13.Enum;
  } });
  var index_14 = require_exclude2();
  Object.defineProperty(exports2, "Exclude", { enumerable: true, get: function() {
    return index_14.Exclude;
  } });
  var index_15 = require_extends2();
  Object.defineProperty(exports2, "Extends", { enumerable: true, get: function() {
    return index_15.Extends;
  } });
  var index_16 = require_extract2();
  Object.defineProperty(exports2, "Extract", { enumerable: true, get: function() {
    return index_16.Extract;
  } });
  var index_17 = require_function2();
  Object.defineProperty(exports2, "Function", { enumerable: true, get: function() {
    return index_17.Function;
  } });
  var index_18 = require_indexed2();
  Object.defineProperty(exports2, "Index", { enumerable: true, get: function() {
    return index_18.Index;
  } });
  var index_19 = require_instance_type2();
  Object.defineProperty(exports2, "InstanceType", { enumerable: true, get: function() {
    return index_19.InstanceType;
  } });
  var index_20 = require_integer2();
  Object.defineProperty(exports2, "Integer", { enumerable: true, get: function() {
    return index_20.Integer;
  } });
  var index_21 = require_intersect2();
  Object.defineProperty(exports2, "Intersect", { enumerable: true, get: function() {
    return index_21.Intersect;
  } });
  var index_22 = require_intrinsic2();
  Object.defineProperty(exports2, "Capitalize", { enumerable: true, get: function() {
    return index_22.Capitalize;
  } });
  Object.defineProperty(exports2, "Uncapitalize", { enumerable: true, get: function() {
    return index_22.Uncapitalize;
  } });
  Object.defineProperty(exports2, "Lowercase", { enumerable: true, get: function() {
    return index_22.Lowercase;
  } });
  Object.defineProperty(exports2, "Uppercase", { enumerable: true, get: function() {
    return index_22.Uppercase;
  } });
  var index_23 = require_iterator3();
  Object.defineProperty(exports2, "Iterator", { enumerable: true, get: function() {
    return index_23.Iterator;
  } });
  var index_24 = require_keyof2();
  Object.defineProperty(exports2, "KeyOf", { enumerable: true, get: function() {
    return index_24.KeyOf;
  } });
  var index_25 = require_literal2();
  Object.defineProperty(exports2, "Literal", { enumerable: true, get: function() {
    return index_25.Literal;
  } });
  var index_26 = require_mapped2();
  Object.defineProperty(exports2, "Mapped", { enumerable: true, get: function() {
    return index_26.Mapped;
  } });
  var index_27 = require_never3();
  Object.defineProperty(exports2, "Never", { enumerable: true, get: function() {
    return index_27.Never;
  } });
  var index_28 = require_not3();
  Object.defineProperty(exports2, "Not", { enumerable: true, get: function() {
    return index_28.Not;
  } });
  var index_29 = require_null2();
  Object.defineProperty(exports2, "Null", { enumerable: true, get: function() {
    return index_29.Null;
  } });
  var index_30 = require_number2();
  Object.defineProperty(exports2, "Number", { enumerable: true, get: function() {
    return index_30.Number;
  } });
  var index_31 = require_object2();
  Object.defineProperty(exports2, "Object", { enumerable: true, get: function() {
    return index_31.Object;
  } });
  var index_32 = require_omit2();
  Object.defineProperty(exports2, "Omit", { enumerable: true, get: function() {
    return index_32.Omit;
  } });
  var index_33 = require_optional2();
  Object.defineProperty(exports2, "Optional", { enumerable: true, get: function() {
    return index_33.Optional;
  } });
  var index_34 = require_parameters2();
  Object.defineProperty(exports2, "Parameters", { enumerable: true, get: function() {
    return index_34.Parameters;
  } });
  var index_35 = require_partial2();
  Object.defineProperty(exports2, "Partial", { enumerable: true, get: function() {
    return index_35.Partial;
  } });
  var index_36 = require_pick2();
  Object.defineProperty(exports2, "Pick", { enumerable: true, get: function() {
    return index_36.Pick;
  } });
  var index_37 = require_promise2();
  Object.defineProperty(exports2, "Promise", { enumerable: true, get: function() {
    return index_37.Promise;
  } });
  var index_38 = require_readonly2();
  Object.defineProperty(exports2, "Readonly", { enumerable: true, get: function() {
    return index_38.Readonly;
  } });
  var index_39 = require_readonly_optional2();
  Object.defineProperty(exports2, "ReadonlyOptional", { enumerable: true, get: function() {
    return index_39.ReadonlyOptional;
  } });
  var index_40 = require_record2();
  Object.defineProperty(exports2, "Record", { enumerable: true, get: function() {
    return index_40.Record;
  } });
  var index_41 = require_recursive2();
  Object.defineProperty(exports2, "Recursive", { enumerable: true, get: function() {
    return index_41.Recursive;
  } });
  var index_42 = require_ref2();
  Object.defineProperty(exports2, "Ref", { enumerable: true, get: function() {
    return index_42.Ref;
  } });
  var index_43 = require_regexp2();
  Object.defineProperty(exports2, "RegExp", { enumerable: true, get: function() {
    return index_43.RegExp;
  } });
  var index_44 = require_required2();
  Object.defineProperty(exports2, "Required", { enumerable: true, get: function() {
    return index_44.Required;
  } });
  var index_45 = require_rest2();
  Object.defineProperty(exports2, "Rest", { enumerable: true, get: function() {
    return index_45.Rest;
  } });
  var index_46 = require_return_type2();
  Object.defineProperty(exports2, "ReturnType", { enumerable: true, get: function() {
    return index_46.ReturnType;
  } });
  var index_47 = require_strict2();
  Object.defineProperty(exports2, "Strict", { enumerable: true, get: function() {
    return index_47.Strict;
  } });
  var index_48 = require_string2();
  Object.defineProperty(exports2, "String", { enumerable: true, get: function() {
    return index_48.String;
  } });
  var index_49 = require_symbol2();
  Object.defineProperty(exports2, "Symbol", { enumerable: true, get: function() {
    return index_49.Symbol;
  } });
  var index_50 = require_template_literal2();
  Object.defineProperty(exports2, "TemplateLiteral", { enumerable: true, get: function() {
    return index_50.TemplateLiteral;
  } });
  var index_51 = require_transform3();
  Object.defineProperty(exports2, "Transform", { enumerable: true, get: function() {
    return index_51.Transform;
  } });
  var index_52 = require_tuple2();
  Object.defineProperty(exports2, "Tuple", { enumerable: true, get: function() {
    return index_52.Tuple;
  } });
  var index_53 = require_uint8array2();
  Object.defineProperty(exports2, "Uint8Array", { enumerable: true, get: function() {
    return index_53.Uint8Array;
  } });
  var index_54 = require_undefined2();
  Object.defineProperty(exports2, "Undefined", { enumerable: true, get: function() {
    return index_54.Undefined;
  } });
  var index_55 = require_union2();
  Object.defineProperty(exports2, "Union", { enumerable: true, get: function() {
    return index_55.Union;
  } });
  var index_56 = require_unknown2();
  Object.defineProperty(exports2, "Unknown", { enumerable: true, get: function() {
    return index_56.Unknown;
  } });
  var index_57 = require_unsafe2();
  Object.defineProperty(exports2, "Unsafe", { enumerable: true, get: function() {
    return index_57.Unsafe;
  } });
  var index_58 = require_void2();
  Object.defineProperty(exports2, "Void", { enumerable: true, get: function() {
    return index_58.Void;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.JavaScriptTypeBuilder = undefined;
  var json_1 = require_json();
  var index_1 = require_async_iterator2();
  var index_2 = require_awaited2();
  var index_3 = require_bigint2();
  var index_4 = require_constructor2();
  var index_5 = require_constructor_parameters2();
  var index_6 = require_date2();
  var index_7 = require_function2();
  var index_8 = require_instance_type2();
  var index_9 = require_iterator3();
  var index_10 = require_parameters2();
  var index_11 = require_promise2();
  var index_12 = require_regexp2();
  var index_13 = require_return_type2();
  var index_14 = require_symbol2();
  var index_15 = require_uint8array2();
  var index_16 = require_undefined2();
  var index_17 = require_void2();

  class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return (0, index_1.AsyncIterator)(items, options);
    }
    Awaited(schema, options = {}) {
      return (0, index_2.Awaited)(schema, options);
    }
    BigInt(options = {}) {
      return (0, index_3.BigInt)(options);
    }
    ConstructorParameters(schema, options = {}) {
      return (0, index_5.ConstructorParameters)(schema, options);
    }
    Constructor(parameters, returns, options) {
      return (0, index_4.Constructor)(parameters, returns, options);
    }
    Date(options = {}) {
      return (0, index_6.Date)(options);
    }
    Function(parameters, returns, options) {
      return (0, index_7.Function)(parameters, returns, options);
    }
    InstanceType(schema, options = {}) {
      return (0, index_8.InstanceType)(schema, options);
    }
    Iterator(items, options = {}) {
      return (0, index_9.Iterator)(items, options);
    }
    Parameters(schema, options = {}) {
      return (0, index_10.Parameters)(schema, options);
    }
    Promise(item, options = {}) {
      return (0, index_11.Promise)(item, options);
    }
    RegExp(unresolved, options = {}) {
      return (0, index_12.RegExp)(unresolved, options);
    }
    ReturnType(schema, options = {}) {
      return (0, index_13.ReturnType)(schema, options);
    }
    Symbol(options) {
      return (0, index_14.Symbol)(options);
    }
    Undefined(options = {}) {
      return (0, index_16.Undefined)(options);
    }
    Uint8Array(options = {}) {
      return (0, index_15.Uint8Array)(options);
    }
    Void(options = {}) {
      return (0, index_17.Void)(options);
    }
  }
  exports2.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type5 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Type = exports2.JavaScriptTypeBuilder = exports2.JsonTypeBuilder = undefined;
  var json_1 = require_json();
  Object.defineProperty(exports2, "JsonTypeBuilder", { enumerable: true, get: function() {
    return json_1.JsonTypeBuilder;
  } });
  var TypeBuilder = require_type4();
  var javascript_1 = require_javascript();
  Object.defineProperty(exports2, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
    return javascript_1.JavaScriptTypeBuilder;
  } });
  var Type = TypeBuilder;
  exports2.Type = Type;
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs2 = __commonJS((exports2) => {
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", { value: true });
  __exportStar(require_clone3(), exports2);
  __exportStar(require_error2(), exports2);
  __exportStar(require_guard3(), exports2);
  __exportStar(require_helpers2(), exports2);
  __exportStar(require_patterns2(), exports2);
  __exportStar(require_registry(), exports2);
  __exportStar(require_sets(), exports2);
  __exportStar(require_symbols2(), exports2);
  __exportStar(require_any2(), exports2);
  __exportStar(require_array2(), exports2);
  __exportStar(require_async_iterator2(), exports2);
  __exportStar(require_awaited2(), exports2);
  __exportStar(require_bigint2(), exports2);
  __exportStar(require_boolean2(), exports2);
  __exportStar(require_composite2(), exports2);
  __exportStar(require_const2(), exports2);
  __exportStar(require_constructor2(), exports2);
  __exportStar(require_constructor_parameters2(), exports2);
  __exportStar(require_date2(), exports2);
  __exportStar(require_deref4(), exports2);
  __exportStar(require_enum2(), exports2);
  __exportStar(require_exclude2(), exports2);
  __exportStar(require_extends2(), exports2);
  __exportStar(require_extract2(), exports2);
  __exportStar(require_function2(), exports2);
  __exportStar(require_indexed2(), exports2);
  __exportStar(require_instance_type2(), exports2);
  __exportStar(require_integer2(), exports2);
  __exportStar(require_intersect2(), exports2);
  __exportStar(require_iterator3(), exports2);
  __exportStar(require_intrinsic2(), exports2);
  __exportStar(require_keyof2(), exports2);
  __exportStar(require_literal2(), exports2);
  __exportStar(require_mapped2(), exports2);
  __exportStar(require_never3(), exports2);
  __exportStar(require_not3(), exports2);
  __exportStar(require_null2(), exports2);
  __exportStar(require_number2(), exports2);
  __exportStar(require_object2(), exports2);
  __exportStar(require_omit2(), exports2);
  __exportStar(require_optional2(), exports2);
  __exportStar(require_parameters2(), exports2);
  __exportStar(require_partial2(), exports2);
  __exportStar(require_pick2(), exports2);
  __exportStar(require_promise2(), exports2);
  __exportStar(require_readonly2(), exports2);
  __exportStar(require_readonly_optional2(), exports2);
  __exportStar(require_record2(), exports2);
  __exportStar(require_recursive2(), exports2);
  __exportStar(require_ref2(), exports2);
  __exportStar(require_regexp2(), exports2);
  __exportStar(require_required2(), exports2);
  __exportStar(require_rest2(), exports2);
  __exportStar(require_return_type2(), exports2);
  __exportStar(require_schema2(), exports2);
  __exportStar(require_static2(), exports2);
  __exportStar(require_strict2(), exports2);
  __exportStar(require_string2(), exports2);
  __exportStar(require_symbol2(), exports2);
  __exportStar(require_template_literal2(), exports2);
  __exportStar(require_transform3(), exports2);
  __exportStar(require_tuple2(), exports2);
  __exportStar(require_uint8array2(), exports2);
  __exportStar(require_undefined2(), exports2);
  __exportStar(require_union2(), exports2);
  __exportStar(require_unknown2(), exports2);
  __exportStar(require_unsafe2(), exports2);
  __exportStar(require_void2(), exports2);
  __exportStar(require_type5(), exports2);
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/types.js
var require_types2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports2, {
    FlowcoreEventSchema: function() {
      return FlowcoreEventSchema;
    },
    TransformerHeadersSchema: function() {
      return TransformerHeadersSchema;
    },
    TransformerResponseSchema: function() {
      return TransformerResponseSchema;
    }
  });
  var _typebox = require_cjs2();
  var FlowcoreEventSchema = _typebox.Type.Object({
    eventId: _typebox.Type.String(),
    aggregator: _typebox.Type.String(),
    eventType: _typebox.Type.String(),
    validTime: _typebox.Type.String({
      pattern: "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,3})?Z$"
    }),
    payload: _typebox.Type.Unknown(),
    metadata: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()))
  }, {
    $id: "FlowcoreEvent"
  });
  var TransformerHeadersSchema = _typebox.Type.Object({
    "x-secret": _typebox.Type.Optional(_typebox.Type.String())
  }, {
    $id: "TransformerHeaders"
  });
  var TransformerResponseSchema = _typebox.Type.Union([
    _typebox.Type.Object({
      status: _typebox.Type.Literal("ok"),
      statusCode: _typebox.Type.Literal(200)
    }),
    _typebox.Type.Object({
      status: _typebox.Type.Literal("error"),
      statusCode: _typebox.Type.Number(),
      message: _typebox.Type.String()
    }),
    _typebox.Type.Object({
      status: _typebox.Type.Literal("error"),
      statusCode: _typebox.Type.Literal(400),
      message: _typebox.Type.String(),
      errors: _typebox.Type.Optional(_typebox.Type.Record(_typebox.Type.String(), _typebox.Type.String()))
    })
  ], {
    $id: "TransformerResponse"
  });
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/transformer-builder.js
var require_transformer_builder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "TransformerBuilder", {
    enumerable: true,
    get: function() {
      return TransformerBuilder;
    }
  });
  var _value = require_value5();
  var _safeparsetype = require_safe_parse_type();
  var _exceptions = require_exceptions();
  var _types = require_types2();
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class TransformerBuilder {
    withSecret(secret) {
      this.secret = secret;
      return this;
    }
    withSuccessHandler(successHandler) {
      this.successHandler = successHandler;
      return this;
    }
    withErrorHandler(errorHandler2) {
      this.errorHandler = errorHandler2;
      return this;
    }
    onEventType(eventType, schema, handler) {
      if (!eventType) {
        throw new _exceptions.TransformerError("Event type is required to construct a transformer");
      }
      if (!this.eventTypes[eventType]) {
        this.eventTypes[eventType] = {
          handlers: [],
          schema
        };
      }
      this.eventTypes[eventType].handlers.push(handler);
      return this;
    }
    getHandler() {
      return (event2, secret, context) => {
        if (!_value.Value.Check(_types.FlowcoreEventSchema, event2)) {
          const errors2 = {};
          const typeboxErrors = _value.Value.Errors(_types.FlowcoreEventSchema, event2);
          for (const typeboxError of typeboxErrors) {
            errors2[typeboxError.path] = typeboxError.message;
          }
          throw new _exceptions.TransformerError("Invalid event", {
            errors: errors2
          });
        }
        return this.handleEvent(event2, secret, context);
      };
    }
    async handleEvent(event2, secret, context) {
      const response = await this.processEvent(event2, context ?? {}, secret);
      this.processResponse(event2, response).catch((error2) => {
        throw new _exceptions.TransformerError("Failed to run after response handler", {
          exception: error2
        });
      });
      return response;
    }
    async processEvent(event2, context, secret) {
      if (this.secret && this.secret !== secret) {
        return {
          status: "error",
          statusCode: 401,
          message: "Unauthorized"
        };
      }
      if (event2.aggregator !== this.flowType) {
        return {
          status: "error",
          message: "Invalid flow type",
          statusCode: 400
        };
      }
      const eventConsumer = this.eventTypes[event2.eventType];
      if (!eventConsumer || eventConsumer.handlers.length === 0) {
        return {
          status: "error",
          message: "Invalid event type",
          statusCode: 400
        };
      }
      const parsedPayload = (0, _safeparsetype.safeParseType)(eventConsumer.schema, event2.payload);
      if (!parsedPayload.success) {
        return {
          status: "error",
          message: "Invalid payload",
          statusCode: 400,
          errors: parsedPayload.errors
        };
      }
      try {
        for (const handler of eventConsumer.handlers) {
          await handler(parsedPayload.data, event2, context);
        }
      } catch (error2) {
        throw new _exceptions.TransformerError("Failed to handle event", {
          exception: error2
        });
      }
      return {
        status: "ok",
        statusCode: 200
      };
    }
    async processResponse(event2, response) {
      if (response.status === "ok") {
        await this.successHandler?.(event2, response);
      } else {
        await this.errorHandler?.(event2, response);
      }
    }
    constructor(flowType) {
      _define_property(this, "secret", undefined);
      _define_property(this, "flowType", undefined);
      _define_property(this, "successHandler", undefined);
      _define_property(this, "errorHandler", undefined);
      _define_property(this, "eventTypes", {});
      if (!flowType) {
        throw new _exceptions.TransformerError("Flow type is required to construct a transformer");
      }
      this.flowType = flowType;
    }
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/transformer-builder/index.js
var require_transformer_builder2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_exceptions(), exports2);
  _export_star(require_transformer_builder(), exports2);
  _export_star(require_types2(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/exceptions.js
var require_exceptions2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports2, {
    WebhookLocalTransformerError: function() {
      return WebhookLocalTransformerError;
    },
    WebhookPredicateError: function() {
      return WebhookPredicateError;
    },
    WebhookSendError: function() {
      return WebhookSendError;
    }
  });
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class WebhookSendError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookSendError");
      _define_property(this, "response", undefined);
      _define_property(this, "exception", undefined);
      this.response = options?.response;
      this.exception = options?.exception;
    }
  }

  class WebhookLocalTransformerError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookLocalTransformerError");
      _define_property(this, "exception", undefined);
      _define_property(this, "response", undefined);
      this.exception = options?.exception;
      this.response = options?.response;
    }
  }

  class WebhookPredicateError extends Error {
    constructor(message, options) {
      const errorMessage = options?.exception ? `${message} (${options.exception})` : message;
      super(errorMessage);
      _define_property(this, "name", "WebhookPredicateError");
      _define_property(this, "exception", undefined);
      _define_property(this, "eventIds", undefined);
      this.exception = options?.exception;
      this.eventIds = options?.eventIds;
    }
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/types.js
var require_types3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  function _export(target, all) {
    for (var name in all)
      Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
  }
  _export(exports2, {
    RETRYABLE_STATUS_CODES: function() {
      return RETRYABLE_STATUS_CODES;
    },
    WebhookBatchResponseSchema: function() {
      return WebhookBatchResponseSchema;
    },
    WebhookBatchSuccessResponseSchema: function() {
      return WebhookBatchSuccessResponseSchema;
    },
    WebhookError500ResponseSchema: function() {
      return WebhookError500ResponseSchema;
    },
    WebhookErrorResponseSchema: function() {
      return WebhookErrorResponseSchema;
    },
    WebhookFileResponseSchema: function() {
      return WebhookFileResponseSchema;
    },
    WebhookFileSuccessResponseSchema: function() {
      return WebhookFileSuccessResponseSchema;
    },
    WebhookResponseSchema: function() {
      return WebhookResponseSchema;
    },
    WebhookSuccessResponseSchema: function() {
      return WebhookSuccessResponseSchema;
    }
  });
  var _typebox = require_cjs2();
  var RETRYABLE_STATUS_CODES = [
    408,
    429,
    500,
    502,
    503,
    504
  ];
  var WebhookSuccessResponseSchema = _typebox.Type.Object({
    eventId: _typebox.Type.String()
  });
  var WebhookBatchSuccessResponseSchema = _typebox.Type.Object({
    eventIds: _typebox.Type.Array(_typebox.Type.String())
  });
  var WebhookFileSuccessResponseSchema = _typebox.Type.Object({
    checksum: _typebox.Type.String(),
    hashType: _typebox.Type.String(),
    eventIds: _typebox.Type.Array(_typebox.Type.String())
  });
  var WebhookErrorResponseSchema = _typebox.Type.Object({
    error: _typebox.Type.String(),
    message: _typebox.Type.String(),
    __localError: _typebox.Type.Optional(_typebox.Type.Any())
  });
  var WebhookError500ResponseSchema = _typebox.Type.Object({
    statusCode: _typebox.Type.Literal(500),
    message: _typebox.Type.String()
  });
  var WebhookResponseSchema = _typebox.Type.Union([
    WebhookSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
  var WebhookBatchResponseSchema = _typebox.Type.Union([
    WebhookBatchSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
  var WebhookFileResponseSchema = _typebox.Type.Union([
    WebhookFileSuccessResponseSchema,
    WebhookErrorResponseSchema
  ]);
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/webhook-builder.js
var require_webhook_builder = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "WebhookBuilder", {
    enumerable: true,
    get: function() {
      return WebhookBuilder;
    }
  });
  var _value = require_value5();
  var _exceptions = require_exceptions2();
  var _types = require_types3();
  function _define_property(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  class WebhookBuilder {
    withRetry(retryOptions) {
      this.retryOptions = {
        maxAttempts: retryOptions?.maxAttempts ?? this.retryOptions?.maxAttempts ?? 1,
        attemptDelayMs: retryOptions?.attemptDelayMs ?? this.retryOptions?.attemptDelayMs ?? 250
      };
      return this;
    }
    withPredicate({ predicate, options }) {
      this.predicate = predicate ?? this.predicate;
      this.predicateOptions = {
        maxAttempts: options?.maxAttempts ?? this.predicateOptions?.maxAttempts ?? 8,
        attemptDelayMs: options?.attemptDelayMs ?? this.predicateOptions?.attemptDelayMs ?? 250
      };
      return this;
    }
    withLocalTransform(options) {
      this.localTransformOptions = {
        baseUrl: options.baseUrl,
        secret: options.secret
      };
      return this;
    }
    factory() {
      return () => {
        const factory = new WebhookBuilder({
          baseUrl: this.baseUrl,
          tenant: this.tenant,
          dataCore: this.dataCore,
          apiKey: this.apiKey
        });
        if (this.retryOptions) {
          factory.withRetry(this.retryOptions);
        }
        if (this.predicate) {
          factory.withPredicate({
            predicate: this.predicate,
            options: this.predicateOptions
          });
        }
        if (this.localTransformOptions) {
          factory.withLocalTransform(this.localTransformOptions);
        }
        return factory;
      };
    }
    buildWebhook(flowType, eventType) {
      const send = async (payload, metadata, options) => {
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "event"), {
          method: "POST",
          headers: this.getHeaders(metadata, {
            contentType: "application/json",
            ...options
          }),
          body: JSON.stringify(payload)
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookSuccessResponseSchema);
        const eventId = response.eventId;
        await this.doLocalTransform(flowType, eventType, payload, eventId);
        await this.doPredicateCheck(eventId);
        return eventId;
      };
      const sendBatch = async (payload, metadata, options) => {
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "events"), {
          method: "POST",
          headers: this.getHeaders(metadata, {
            contentType: "application/json",
            ...options
          }),
          body: JSON.stringify(payload)
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookBatchSuccessResponseSchema);
        const eventIds = response.eventIds;
        if (eventIds.length !== payload.length) {
          throw new _exceptions.WebhookSendError("Webhook batch returned different number of event ids than payloads", {
            response
          });
        }
        await Promise.all(payload.map((payload2, index) => this.doLocalTransform(flowType, eventType, payload2, eventIds[index])));
        await this.doPredicateCheck(eventIds);
        return eventIds;
      };
      return {
        send,
        sendBatch
      };
    }
    buildFileWebhook(flowType, eventType) {
      const send = async (payload, metadata, options) => {
        const formData = new FormData;
        process.env.DEBUG?.includes("transformer-core") && console.log("additionalProperties", payload.additionalProperties);
        formData.append("additionalProperties", JSON.stringify(payload.additionalProperties ?? "{}"));
        formData.append("fileId", payload.fileId);
        formData.append("type", payload.fileType);
        formData.append("file", payload.fileContent, payload.fileName);
        const rawResponse = await this.fetchWithRetry(this.getUrl(flowType, eventType, "file"), {
          method: "POST",
          headers: this.getHeaders(metadata, options),
          body: formData
        });
        const response = this.validateWebhookResponse(rawResponse, _types.WebhookFileSuccessResponseSchema);
        const eventIds = response.eventIds;
        await this.doPredicateCheck(eventIds);
        return eventIds;
      };
      return {
        send
      };
    }
    async doLocalTransform(flowType, eventType, payload, eventId) {
      if (!this.localTransformOptions?.baseUrl) {
        return;
      }
      const url = `${this.localTransformOptions.baseUrl}/${flowType}`;
      const event2 = {
        aggregator: flowType,
        eventType,
        payload,
        eventId: eventId ?? "00000000-0000-0000-0000-000000000000",
        validTime: new Date().toISOString()
      };
      try {
        const response = await fetch(url, {
          method: "POST",
          headers: {
            "X-Secret": this.localTransformOptions.secret ?? "",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(event2)
        });
        if (!response.ok) {
          const responseBody = await response.json();
          throw new _exceptions.WebhookLocalTransformerError("Failed to send event to local transformer", {
            response: responseBody
          });
        }
      } catch (error2) {
        throw new _exceptions.WebhookLocalTransformerError("Failed to send event to local transformer", {
          exception: error2
        });
      }
    }
    validateWebhookResponse(response, responseSchema) {
      if (_value.Value.Check(_types.WebhookError500ResponseSchema, response)) {
        throw new _exceptions.WebhookSendError("Webhook failed", {
          response
        });
      }
      if (_value.Value.Check(_types.WebhookErrorResponseSchema, response)) {
        if (response.__localError) {
          throw new _exceptions.WebhookSendError("Webhook failed with exception", {
            exception: response.__localError
          });
        }
        throw new _exceptions.WebhookSendError("Webhook failed", {
          response
        });
      }
      if (!_value.Value.Check(responseSchema, response)) {
        throw new _exceptions.WebhookSendError("Webhook returned invalid response", {
          response
        });
      }
      return response;
    }
    async doPredicateCheck(eventIds) {
      if (!this.predicate || !this.predicateOptions) {
        return;
      }
      const predicate = this.predicate;
      const { maxAttempts, attemptDelayMs } = this.predicateOptions;
      let checks = Array.isArray(eventIds) ? eventIds : [
        eventIds
      ];
      for (let attempt = 1;attempt <= maxAttempts; attempt++) {
        try {
          checks = await Promise.all(checks.map(async (eventId) => {
            if (eventId === true) {
              return true;
            }
            const check = await predicate(eventId) ?? false;
            if (check) {
              return true;
            }
            return eventId;
          }));
          if (checks.every((check) => check === true)) {
            return;
          }
          if (attempt >= maxAttempts) {
            throw new _exceptions.WebhookPredicateError("Predicate check failed", {
              eventIds: Array.isArray(eventIds) ? eventIds : [
                eventIds
              ]
            });
          }
        } catch (error2) {
          if (attempt >= maxAttempts) {
            if (error2 instanceof _exceptions.WebhookPredicateError) {
              throw error2;
            }
            throw new _exceptions.WebhookPredicateError("Predicate check failed with exception", {
              eventIds: Array.isArray(eventIds) ? eventIds : [
                eventIds
              ],
              exception: error2
            });
          }
        }
        await sleep2(attemptDelayMs, attempt);
      }
      throw new _exceptions.WebhookPredicateError("Predicate check failed", {
        eventIds: Array.isArray(eventIds) ? eventIds : [
          eventIds
        ]
      });
    }
    async fetchWithRetry(url, options) {
      const { maxAttempts, attemptDelayMs } = this.retryOptions ?? {
        maxAttempts: 1,
        attemptDelayMs: 0
      };
      for (let attempt = 1;attempt <= maxAttempts; attempt++) {
        try {
          const response = await fetch(url, options);
          if (response.ok) {
            return response.json().catch((error2) => {
              return {
                success: false,
                message: "Failed to parse response",
                error: error2 instanceof Error ? error2.message : "Unknown error"
              };
            });
          }
          if (!_types.RETRYABLE_STATUS_CODES.includes(response.status) || attempt >= maxAttempts) {
            return response.json().catch((error2) => {
              return {
                success: false,
                message: "Failed to parse error response",
                error: error2 instanceof Error ? error2.message : "Unknown error"
              };
            });
          }
          await sleep2(attemptDelayMs, attempt);
        } catch (error2) {
          if (attempt >= maxAttempts) {
            return {
              success: false,
              message: "Failed with local exception",
              error: error2 instanceof Error ? error2.message : "Unknown error",
              __localError: error2
            };
          }
          await sleep2(attemptDelayMs, attempt);
        }
      }
    }
    getHeaders(metadata, options) {
      const headers = {
        Authorization: `${this.apiKey}`,
        ...options?.contentType ? {
          "Content-Type": options.contentType
        } : {},
        ...options?.eventTime ? {
          "x-flowcore-event-time": options.eventTime.toISOString()
        } : {},
        ...options?.validTime ? {
          "x-flowcore-valid-time": options.validTime.toISOString()
        } : {},
        ...options?.eventTimeKey ? {
          "x-flowcore-event-time-key": options.eventTimeKey
        } : {},
        ...options?.validTimeKey ? {
          "x-flowcore-valid-time-key": options.validTimeKey
        } : {},
        ...metadata ? {
          "x-flowcore-metadata-json": Buffer.from(JSON.stringify(metadata), "utf-8").toString("base64")
        } : {}
      };
      return headers;
    }
    getUrl(flowType, eventType, type) {
      return `${this.baseUrl}/${type}/${this.tenant}/${this.dataCore}/${flowType}/${eventType}`;
    }
    constructor(options) {
      _define_property(this, "baseUrl", undefined);
      _define_property(this, "tenant", undefined);
      _define_property(this, "dataCore", undefined);
      _define_property(this, "apiKey", undefined);
      _define_property(this, "retryOptions", undefined);
      _define_property(this, "predicate", undefined);
      _define_property(this, "predicateOptions", undefined);
      _define_property(this, "localTransformOptions", undefined);
      this.baseUrl = options.baseUrl ?? "https://webhook.api.flowcore.io";
      this.tenant = options.tenant;
      this.dataCore = options.dataCore;
      this.apiKey = options.apiKey;
    }
  }
  function sleep2(ms, attempt = 1) {
    return new Promise((resolve) => setTimeout(resolve, typeof ms === "function" ? ms(attempt) : ms));
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/metadata-webhook.js
var require_metadata_webhook = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "metadataWebhook", {
    enumerable: true,
    get: function() {
      return metadataWebhook;
    }
  });
  var metadataWebhook = (metadata) => async (webhook, payload, additionalMetadata) => {
    const augmentedMetadata = {
      ...additionalMetadata,
      ...metadata
    };
    return webhook(payload, augmentedMetadata);
  };
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/webhook-builder/index.js
var require_webhook_builder2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_webhook_builder(), exports2);
  _export_star(require_exceptions2(), exports2);
  _export_star(require_types3(), exports2);
  _export_star(require_metadata_webhook(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/flowcore/index.js
var require_flowcore = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_transformer_builder2(), exports2);
  _export_star(require_webhook_builder2(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/throw-safe-error.js
var require_throw_safe_error = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  Object.defineProperty(exports2, "throwSafeError", {
    enumerable: true,
    get: function() {
      return throwSafeError;
    }
  });
  var throwSafeError = (message, error2) => {
    if (error2 instanceof Error) {
      throw new Error(`${message}: ${error2.message}`);
    }
    throw new Error(`${message}: an unexpected error type`);
  };
});

// node_modules/@flowcore/sdk-transformer-core/dist/utils/index.js
var require_utils = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_throw_safe_error(), exports2);
  _export_star(require_safe_parse_type(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/@flowcore/sdk-transformer-core/dist/index.js
var require_dist3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  _export_star(require_contracts(), exports2);
  _export_star(require_flowcore(), exports2);
  _export_star(require_utils(), exports2);
  function _export_star(from, to) {
    Object.keys(from).forEach(function(k) {
      if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
        Object.defineProperty(to, k, {
          enumerable: true,
          get: function() {
            return from[k];
          }
        });
      }
    });
    return from;
  }
});

// node_modules/bun-sqlite-key-value/dist/index.js
class BunSqliteKeyValue {
  db;
  ttlMs;
  maxExpiringItemsInDb;
  data = this.getDataObject();
  d = this.data;
  deleteExpiredStatement;
  deleteStatement;
  clearStatement;
  countStatement;
  countValidStatement;
  setItemStatement;
  getItemStatement;
  getAllItemsStatement;
  getItemsStartsWithStatement;
  getKeyStatement;
  getAllKeysStatement;
  getKeysStartsWithStatement;
  countExpiringStatement;
  deleteExpiringStatement;
  getRandomKeyStatement;
  getRandomItemStatement;
  renameStatement;
  setExpiresStatement;
  getExpiresStatement;
  addTagStatement;
  deleteTagStatement;
  deleteAllTagsStatement;
  getTaggedKeysStatement;
  deleteTaggedItemsStatement;
  constructor(filename, options) {
    const {
      ttlMs,
      maxExpiringItemsInDb,
      ...otherOptions
    } = options ?? {};
    this.ttlMs = ttlMs;
    this.maxExpiringItemsInDb = maxExpiringItemsInDb;
    const dbOptions = {
      ...otherOptions,
      strict: true,
      readwrite: otherOptions?.readwrite ?? true,
      create: otherOptions?.create ?? true
    };
    if (filename?.length && filename.toLowerCase() !== ":memory:" && dbOptions.create) {
      const dbDir = import_node_path.dirname(import_node_path.resolve(filename));
      if (!import_node_fs.existsSync(dbDir)) {
        console.log(`The "${dbDir}" folder is created.`);
        import_node_fs.mkdirSync(dbDir, { recursive: true });
      }
    }
    this.db = new import_bun_sqlite.Database(filename, dbOptions);
    this.db.run("PRAGMA journal_mode = WAL");
    this.db.run("PRAGMA foreign_keys = ON");
    this.db.run(`
        CREATE TABLE IF NOT EXISTS items (
            key TEXT NOT NULL PRIMARY KEY, 
            value BLOB, 
            expires INT
        ) STRICT`);
    this.db.run("CREATE INDEX IF NOT EXISTS ix_items_expires ON items (expires)");
    this.db.run(`
        CREATE TABLE IF NOT EXISTS tags (
            tag TEXT NOT NULL,
            item_key TEXT NOT NULL REFERENCES items ON DELETE CASCADE ON UPDATE CASCADE,
            PRIMARY KEY (tag, item_key)
        ) STRICT`);
    this.db.run("CREATE INDEX IF NOT EXISTS ix_tags_item_key ON tags (item_key)");
    this.clearStatement = this.db.query("DELETE FROM items");
    this.deleteStatement = this.db.query("DELETE FROM items WHERE key = $key");
    this.deleteExpiredStatement = this.db.query("DELETE FROM items WHERE expires < $now");
    this.setItemStatement = this.db.query("INSERT OR REPLACE INTO items (key, value, expires) VALUES ($key, $value, $expires)");
    this.countStatement = this.db.query("SELECT COUNT(*) AS count FROM items");
    this.countValidStatement = this.db.query("SELECT COUNT(*) AS count FROM items WHERE expires IS NULL OR expires > $now");
    this.getAllItemsStatement = this.db.query("SELECT key, value, expires FROM items");
    this.getItemStatement = this.db.query("SELECT value, expires FROM items WHERE key = $key");
    this.getItemsStartsWithStatement = this.db.query("SELECT key, value, expires FROM items WHERE key = $key OR key >= $gte AND key < $lt");
    this.getAllKeysStatement = this.db.query("SELECT key, expires FROM items");
    this.getKeyStatement = this.db.query("SELECT expires FROM items WHERE key = $key");
    this.getKeysStartsWithStatement = this.db.query("SELECT key, expires FROM items WHERE key = $key OR key >= $gte AND key < $lt");
    this.countExpiringStatement = this.db.query("SELECT COUNT(*) as count FROM items WHERE expires IS NOT NULL");
    this.deleteExpiringStatement = this.db.query(`
        DELETE FROM items WHERE key IN (
            SELECT key FROM items
            WHERE expires IS NOT NULL
            ORDER BY expires ASC
            LIMIT $limit
        )`);
    this.getRandomKeyStatement = this.db.query(`
        SELECT key FROM items 
        WHERE expires IS NULL OR expires > $now
        ORDER BY RANDOM() 
        LIMIT 1
        `);
    this.getRandomItemStatement = this.db.query(`
        SELECT key, value from items
        WHERE key = (
            SELECT key FROM items 
            WHERE expires IS NULL OR expires > $now
            ORDER BY RANDOM() 
            LIMIT 1
        )`);
    this.renameStatement = this.db.query("UPDATE items SET key = $newKey WHERE key = $oldKey");
    this.setExpiresStatement = this.db.query("UPDATE items SET expires = $expires WHERE key = $key");
    this.getExpiresStatement = this.db.query("SELECT expires FROM items WHERE key = $key");
    this.addTagStatement = this.db.query("INSERT OR IGNORE INTO tags (tag, item_key) VALUES ($tag, $item_key)");
    this.deleteTagStatement = this.db.query("DELETE FROM tags WHERE tag = $tag AND item_key = $key");
    this.deleteAllTagsStatement = this.db.query("DELETE FROM tags WHERE item_key = $key");
    this.getTaggedKeysStatement = this.db.query("SELECT item_key AS key FROM tags WHERE tag = $tag");
    this.deleteTaggedItemsStatement = this.db.query("DELETE FROM items WHERE key IN (SELECT item_key FROM tags WHERE tag = $tag)");
    this.deleteExpired();
    this.deleteOldExpiringItems();
  }
  deleteExpired() {
    this.deleteExpiredStatement.run({ now: Date.now() });
  }
  delete(keyOrKeys) {
    if (typeof keyOrKeys === "string") {
      this.deleteStatement.run({ key: keyOrKeys });
    } else if (keyOrKeys?.length) {
      this.db.transaction(() => {
        keyOrKeys.forEach((key) => {
          this.deleteStatement.run({ key });
        });
      })();
    } else {
      this.clearStatement.run();
    }
  }
  del = this.delete;
  clear() {
    this.delete();
  }
  close() {
    this.db.close();
  }
  getCount() {
    return this.countStatement.get().count;
  }
  count = this.getCount;
  get length() {
    return this.getCount();
  }
  getCountValid(deleteExpired) {
    if (deleteExpired === true) {
      return this.db.transaction(() => {
        this.deleteExpiredStatement.run({ now: Date.now() });
        return this.countStatement.get().count;
      })();
    } else {
      return this.countValidStatement.get({ now: Date.now() }).count;
    }
  }
  set(key, value, ttlMs) {
    let expires;
    ttlMs = ttlMs ?? this.ttlMs;
    if (ttlMs !== undefined && ttlMs > 0) {
      expires = Date.now() + ttlMs;
    }
    if (key === undefined) {
      key = crypto.randomUUID();
    }
    this.setItemStatement.run({ key, value: import_node_v8.serialize(value), expires });
    return key;
  }
  setValue = this.set;
  put = this.set;
  setItems(items) {
    this.db.transaction(() => {
      items.forEach(({ key, value, ttlMs }) => {
        this.set(key, value, ttlMs);
      });
    })();
  }
  get(key) {
    const record = this.getItemStatement.get({ key });
    if (!record)
      return;
    const { value, expires } = record;
    if (expires) {
      if (expires < Date.now()) {
        this.delete(key);
        return;
      }
    }
    return value ? import_node_v8.deserialize(value) : undefined;
  }
  getValue = this.get;
  getItem(key) {
    return {
      key,
      value: this.get(key)
    };
  }
  getItems(startsWithOrKeys) {
    let records;
    if (startsWithOrKeys && typeof startsWithOrKeys === "string") {
      const key = startsWithOrKeys;
      const gte = key + MIN_UTF8_CHAR;
      const lt = key + MAX_UTF8_CHAR;
      records = this.getItemsStartsWithStatement.all({ key, gte, lt });
    } else if (startsWithOrKeys) {
      records = this.db.transaction(() => {
        return startsWithOrKeys.map((key) => {
          const record = this.getItemStatement.get({ key });
          return { ...record, key };
        });
      })();
    } else {
      records = this.getAllItemsStatement.all();
    }
    if (!records?.length)
      return;
    const now = Date.now();
    const result = [];
    const keysToDelete = [];
    for (const record of records) {
      const { key, value, expires } = record;
      if (expires && expires < now) {
        keysToDelete.push(key);
      } else {
        result.push({
          key,
          value: value ? import_node_v8.deserialize(value) : undefined
        });
      }
    }
    if (keysToDelete.length === 1) {
      this.delete(keysToDelete[0]);
    } else if (keysToDelete.length > 1) {
      this.delete(keysToDelete);
    }
    if (result.length) {
      return result;
    }
  }
  getItemsArray = this.getItems;
  get items() {
    return this.getItems();
  }
  getValues(startsWithOrKeys) {
    return this.getItems(startsWithOrKeys)?.map((result) => result.value);
  }
  getValuesArray = this.getValues;
  get values() {
    return this.getValues();
  }
  getItemsAsObject(startsWithOrKeys) {
    const items = this.getItems(startsWithOrKeys);
    if (!items)
      return;
    return Object.fromEntries(items.map((item) => [item.key, item.value]));
  }
  getItemsObject = this.getItemsAsObject;
  getItemsAsMap(startsWithOrKeys) {
    const items = this.getItems(startsWithOrKeys);
    if (!items)
      return;
    return new Map(items.map((item) => [item.key, item.value]));
  }
  getItemsMap = this.getItemsAsMap;
  getValuesAsSet(startsWithOrKeys) {
    const values = this.getValues(startsWithOrKeys);
    if (!values)
      return;
    return new Set(values);
  }
  getValuesSet = this.getValuesAsSet;
  has(key) {
    const record = this.getKeyStatement.get({ key });
    if (!record)
      return false;
    if (record.expires) {
      if (record.expires < Date.now()) {
        this.delete(key);
        return false;
      }
    }
    return true;
  }
  exists = this.has;
  getKeys(startsWithOrKeys) {
    let records;
    if (startsWithOrKeys && typeof startsWithOrKeys === "string") {
      const key = startsWithOrKeys;
      const gte = key + MIN_UTF8_CHAR;
      const lt = key + MAX_UTF8_CHAR;
      records = this.getKeysStartsWithStatement.all({ key, gte, lt });
    } else if (startsWithOrKeys) {
      records = this.db.transaction(() => {
        return startsWithOrKeys.map((key) => {
          const record = this.getKeyStatement.get({ key });
          return record ? { ...record, key } : undefined;
        });
      })();
    } else {
      records = this.getAllKeysStatement.all();
    }
    if (!records?.length)
      return;
    const now = Date.now();
    const result = [];
    const keysToDelete = [];
    for (const record of records) {
      if (!record)
        continue;
      const { key, expires } = record;
      if (expires && expires < now) {
        keysToDelete.push(key);
      } else {
        result.push(key);
      }
    }
    if (keysToDelete.length === 1) {
      this.delete(keysToDelete[0]);
    } else if (keysToDelete.length > 1) {
      this.delete(keysToDelete);
    }
    if (result.length) {
      return result;
    }
  }
  get keys() {
    return this.getKeys();
  }
  getExpiringItemsCount() {
    return this.countExpiringStatement.get().count;
  }
  deleteOldExpiringItems(maxExpiringItemsInDb) {
    let maxExpiringItems = maxExpiringItemsInDb ?? this.maxExpiringItemsInDb;
    if (maxExpiringItems === undefined)
      return;
    this.db.transaction(() => {
      const count = this.getExpiringItemsCount();
      if (count <= maxExpiringItems)
        return;
      const limit = count - maxExpiringItems;
      this.deleteExpiringStatement.run({ limit });
    })();
  }
  deleteOldestExpiringItems = this.deleteOldExpiringItems;
  getDataObject() {
    const self = this;
    return new Proxy({}, {
      get(_, property) {
        return self.get(property);
      },
      set(_, property, value) {
        self.set(property, value);
        return true;
      },
      has(_, property) {
        return self.has(property);
      },
      deleteProperty(_, property) {
        self.delete(property);
        return true;
      }
    });
  }
  incr(key, incrBy = 1, ttlMs) {
    return this.db.transaction(() => {
      const newValue = Number(this.get(key) ?? 0) + incrBy;
      if (isNaN(newValue))
        return NaN;
      this.set(key, newValue, ttlMs);
      return newValue;
    }).immediate();
  }
  decr(key, decrBy = 1, ttlMs) {
    return this.incr(key, decrBy * -1, ttlMs);
  }
  append(key, value, ttlMs) {
    return this.db.transaction(() => {
      const newValue = String(this.get(key) ?? "") + value;
      this.set(key, newValue, ttlMs);
      return newValue.length;
    }).immediate();
  }
  getSet(key, value, ttlMs) {
    return this.db.transaction(() => {
      const oldValue = this.get(key);
      this.set(key, value, ttlMs);
      return oldValue;
    }).immediate();
  }
  getRandomKey() {
    return this.getRandomKeyStatement.get({ now: Date.now() })?.key ?? undefined;
  }
  randomKey = this.getRandomKey;
  getRandomItem() {
    const record = this.getRandomItemStatement.get({ now: Date.now() });
    if (!record)
      return;
    return {
      key: record.key,
      value: record.value ? import_node_v8.deserialize(record.value) : undefined
    };
  }
  randomItem = this.getRandomItem;
  getRandomValue() {
    const item = this.randomItem();
    if (item)
      return item.value;
  }
  randomValue = this.getRandomValue;
  rename(oldKey, newKey) {
    return this.db.transaction(() => {
      if (this.has(oldKey)) {
        this.deleteStatement.run({ key: newKey });
        this.renameStatement.run({ oldKey, newKey });
        return true;
      } else {
        return false;
      }
    }).immediate();
  }
  setTtl(key, ttlMs) {
    let expires;
    ttlMs = ttlMs ?? this.ttlMs;
    if (ttlMs !== undefined && ttlMs > 0) {
      expires = Date.now() + ttlMs;
    }
    return this.setExpiresStatement.run({ key, expires }).changes === 1;
  }
  getTtl(key) {
    const record = this.getExpiresStatement.get({ key });
    if (!record)
      return;
    const expires = record?.expires;
    if (!expires)
      return;
    const now = Date.now();
    if (expires < now) {
      this.delete(key);
      return;
    }
    return expires - now;
  }
  hSet(key, field, value, ttlMs) {
    return this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      const isNewField = !map.has(field);
      map.set(field, value);
      this.set(key, map, ttlMs);
      return isNewField;
    }).immediate();
  }
  hGet(key, field) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.get(field);
  }
  hmSet(key, fields, ttlMs) {
    this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      Object.entries(fields).forEach(([field, value]) => {
        map.set(field, value);
      });
      this.set(key, map, ttlMs);
    }).immediate();
  }
  hmGet(key, fields) {
    const map = this.get(key);
    if (map === undefined)
      return;
    const result = {};
    if (fields) {
      fields.forEach((field) => {
        result[field] = map.get(field);
      });
    } else {
      Object.assign(result, Object.fromEntries(map.entries()));
    }
    return result;
  }
  hHasField(key, field) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.has(field);
  }
  hExists = this.hHasField;
  hGetCount(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return map.size;
  }
  hLen = this.hGetCount;
  hGetFields(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return Array.from(map.keys());
  }
  hKeys = this.hGetFields;
  hGetValues(key) {
    const map = this.get(key);
    if (map === undefined)
      return;
    return Array.from(map.values());
  }
  hVals = this.hGetValues;
  hDelete(key, field) {
    return this.db.transaction(() => {
      const map = this.get(key);
      if (map === undefined)
        return;
      const result = map.delete(field);
      this.set(key, map);
      return result;
    }).immediate();
  }
  hIncr(key, field, incrBy = 1, ttlMs) {
    return this.db.transaction(() => {
      const map = this.get(key) ?? new Map;
      let newValue;
      try {
        newValue = Number(map.get(field) ?? 0) + incrBy;
      } catch (error2) {
        if (error2.toString().includes("TypeError"))
          return NaN;
        throw error2;
      }
      if (isNaN(newValue))
        return NaN;
      map.set(field, newValue);
      this.set(key, map, ttlMs);
      return newValue;
    }).immediate();
  }
  hDecr(key, field, decrBy = 1, ttlMs) {
    return this.hIncr(key, field, decrBy * -1, ttlMs);
  }
  lPush(key, ...values) {
    return this.db.transaction(() => {
      const array = this.get(key) ?? new Array;
      let newLength;
      try {
        values.forEach((value) => {
          newLength = array.unshift(value);
        });
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return newLength;
    }).immediate();
  }
  rPush(key, ...values) {
    return this.db.transaction(() => {
      const array = this.get(key) ?? new Array;
      let newLength;
      try {
        newLength = array.push(...values);
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return newLength;
    }).immediate();
  }
  lPop(key, count) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined)
        return;
      let result;
      try {
        if (count === undefined) {
          result = array.shift();
        } else if (count > 0) {
          result = array.splice(0, count);
          if (!result?.length)
            return;
        } else {
          throw new Error(INVALID_COUNT_ERROR_LABEL + " `count` must be greater then 0.");
        }
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return result;
    }).immediate();
  }
  rPop(key, count) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined)
        return;
      let result;
      try {
        if (count === undefined) {
          result = array.pop();
        } else if (count > 0) {
          result = array.splice(count * -1, count);
          if (!result?.length)
            return;
          result.reverse();
        } else {
          throw new Error(INVALID_COUNT_ERROR_LABEL + " `count` must be greater then 0.");
        }
      } catch (error2) {
        if (error2.toString().includes("TypeError")) {
          throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
        }
        throw error2;
      }
      this.set(key, array);
      return result;
    }).immediate();
  }
  lIndex(key, index) {
    const array = this.get(key);
    if (array === undefined)
      return;
    try {
      return array.at(index);
    } catch (error2) {
      if (error2.toString().includes("TypeError")) {
        throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
      }
      throw error2;
    }
  }
  lLen(key) {
    const array = this.get(key);
    if (array === undefined)
      return 0;
    if (Array.isArray(array) === false) {
      throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
    }
    return array.length;
  }
  lSet(key, index, value) {
    return this.db.transaction(() => {
      const array = this.get(key);
      if (array === undefined) {
        throw new Error(ITEM_NOT_EXISTS_ERROR_LABEL + ` Key "${key.substring(-80)}" not found.`);
      }
      if (Array.isArray(array) === false) {
        throw new Error(NO_ARRAY_ERROR_LABEL + ` Value at "${key.substring(-80)}" is not an array.`);
      }
      const len = array.length;
      if (index >= len || index < len * -1) {
        throw new Error(INDEX_OUT_OF_RANGE_ERROR_LABEL + ` Array length: ${len}`);
      }
      if (index < 0) {
        array[len + index] = value;
      } else {
        array[index] = value;
      }
      this.set(key, array);
      return true;
    }).immediate();
  }
  addTag(key, tag) {
    try {
      return this.addTagStatement.run({ item_key: key, tag }).changes === 1;
    } catch (error2) {
      if (error2.toString().includes("FOREIGN KEY constraint failed")) {
        throw new Error(ITEM_NOT_EXISTS_ERROR_LABEL + ` Key "${key.substring(-80)}" not found.`);
      } else {
        throw error2;
      }
    }
  }
  deleteTag(key, tag) {
    return this.deleteTagStatement.run({ key, tag }).changes === 1;
  }
  deleteTags(key, tags) {
    if (tags) {
      this.db.transaction(() => {
        tags.forEach((tag) => this.deleteTag(key, tag));
      })();
    } else {
      this.deleteAllTagsStatement.run({ key });
    }
  }
  deleteTaggedItems(tag) {
    this.deleteTaggedItemsStatement.run({ tag });
  }
  getTaggedKeys(tag) {
    const records = this.getTaggedKeysStatement.all({ tag });
    if (!records?.length)
      return;
    return records.map((record) => record.key);
  }
  getTaggedValues(tag) {
    return this.db.transaction(() => {
      const taggedKeys = this.getTaggedKeys(tag);
      if (!taggedKeys)
        return;
      return this.getValues(taggedKeys);
    })();
  }
  getTaggedItems(tag) {
    return this.db.transaction(() => {
      const taggedKeys = this.getTaggedKeys(tag);
      if (!taggedKeys)
        return;
      return this.getItems(taggedKeys);
    })();
  }
}
var import_bun_sqlite, import_node_v8, import_node_path, import_node_fs, MIN_UTF8_CHAR, MAX_UTF8_CHAR, INVALID_COUNT_ERROR_LABEL = "[INVALID_COUNT_ERROR]", NO_ARRAY_ERROR_LABEL = "[NO_ARRAY_ERROR]", ITEM_NOT_EXISTS_ERROR_LABEL = "[ITEM_NOT_EXISTS]", INDEX_OUT_OF_RANGE_ERROR_LABEL = "[INDEX_OUT_OF_RANGE]";
var init_dist = __esm(() => {
  import_bun_sqlite = require("bun:sqlite");
  import_node_v8 = require("node:v8");
  import_node_path = require("node:path");
  import_node_fs = require("node:fs");
  MIN_UTF8_CHAR = String.fromCodePoint(1);
  MAX_UTF8_CHAR = String.fromCodePoint(1114111);
});

// node_modules/@flowcore/pathways/esm/pathways/kv/bun-kv-adapter.js
var exports_bun_kv_adapter = {};
__export(exports_bun_kv_adapter, {
  BunKvAdapter: () => BunKvAdapter
});

class BunKvAdapter {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.store = new BunSqliteKeyValue(":memory:");
  }
  get(key) {
    const value = this.store.get(key);
    return value;
  }
  set(key, value, ttlMs) {
    this.store.set(key, value, ttlMs);
  }
}
var init_bun_kv_adapter = __esm(() => {
  init_dist();
});

// node_modules/clone/clone.js
var require_clone4 = __commonJS((exports2, module2) => {
  var clone = function() {
    function _instanceof(obj, type) {
      return type != null && obj instanceof type;
    }
    var nativeMap;
    try {
      nativeMap = Map;
    } catch (_) {
      nativeMap = function() {};
    }
    var nativeSet;
    try {
      nativeSet = Set;
    } catch (_) {
      nativeSet = function() {};
    }
    var nativePromise;
    try {
      nativePromise = Promise;
    } catch (_) {
      nativePromise = function() {};
    }
    function clone2(parent, circular, depth, prototype, includeNonEnumerable) {
      if (typeof circular === "object") {
        depth = circular.depth;
        prototype = circular.prototype;
        includeNonEnumerable = circular.includeNonEnumerable;
        circular = circular.circular;
      }
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 === 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (_instanceof(parent2, nativeMap)) {
          child = new nativeMap;
        } else if (_instanceof(parent2, nativeSet)) {
          child = new nativeSet;
        } else if (_instanceof(parent2, nativePromise)) {
          child = new nativePromise(function(resolve2, reject) {
            parent2.then(function(value) {
              resolve2(_clone(value, depth2 - 1));
            }, function(err2) {
              reject(_clone(err2, depth2 - 1));
            });
          });
        } else if (clone2.__isArray(parent2)) {
          child = [];
        } else if (clone2.__isRegExp(parent2)) {
          child = new RegExp(parent2.source, __getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (clone2.__isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          if (Buffer.allocUnsafe) {
            child = Buffer.allocUnsafe(parent2.length);
          } else {
            child = new Buffer(parent2.length);
          }
          parent2.copy(child);
          return child;
        } else if (_instanceof(parent2, Error)) {
          child = Object.create(parent2);
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        if (_instanceof(parent2, nativeMap)) {
          parent2.forEach(function(value, key) {
            var keyChild = _clone(key, depth2 - 1);
            var valueChild = _clone(value, depth2 - 1);
            child.set(keyChild, valueChild);
          });
        }
        if (_instanceof(parent2, nativeSet)) {
          parent2.forEach(function(value) {
            var entryChild = _clone(value, depth2 - 1);
            child.add(entryChild);
          });
        }
        for (var i2 in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i2);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i2] = _clone(parent2[i2], depth2 - 1);
        }
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(parent2);
          for (var i2 = 0;i2 < symbols.length; i2++) {
            var symbol = symbols[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, symbol);
            if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
              continue;
            }
            child[symbol] = _clone(parent2[symbol], depth2 - 1);
            if (!descriptor.enumerable) {
              Object.defineProperty(child, symbol, {
                enumerable: false
              });
            }
          }
        }
        if (includeNonEnumerable) {
          var allPropertyNames = Object.getOwnPropertyNames(parent2);
          for (var i2 = 0;i2 < allPropertyNames.length; i2++) {
            var propertyName = allPropertyNames[i2];
            var descriptor = Object.getOwnPropertyDescriptor(parent2, propertyName);
            if (descriptor && descriptor.enumerable) {
              continue;
            }
            child[propertyName] = _clone(parent2[propertyName], depth2 - 1);
            Object.defineProperty(child, propertyName, {
              enumerable: false
            });
          }
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone2.clonePrototype = function clonePrototype(parent) {
      if (parent === null)
        return null;
      var c = function() {};
      c.prototype = parent;
      return new c;
    };
    function __objToStr(o) {
      return Object.prototype.toString.call(o);
    }
    clone2.__objToStr = __objToStr;
    function __isDate(o) {
      return typeof o === "object" && __objToStr(o) === "[object Date]";
    }
    clone2.__isDate = __isDate;
    function __isArray(o) {
      return typeof o === "object" && __objToStr(o) === "[object Array]";
    }
    clone2.__isArray = __isArray;
    function __isRegExp(o) {
      return typeof o === "object" && __objToStr(o) === "[object RegExp]";
    }
    clone2.__isRegExp = __isRegExp;
    function __getRegExpFlags(re) {
      var flags = "";
      if (re.global)
        flags += "g";
      if (re.ignoreCase)
        flags += "i";
      if (re.multiline)
        flags += "m";
      return flags;
    }
    clone2.__getRegExpFlags = __getRegExpFlags;
    return clone2;
  }();
  if (typeof module2 === "object" && module2.exports) {
    module2.exports = clone;
  }
});

// node_modules/node-cache/lib/node_cache.js
var require_node_cache = __commonJS((exports2, module2) => {
  (function() {
    var EventEmitter, NodeCache, clone, splice = [].splice, boundMethodCheck = function(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new Error("Bound instance method accessed before binding");
      }
    }, indexOf2 = [].indexOf;
    clone = require_clone4();
    EventEmitter = require("events").EventEmitter;
    module2.exports = NodeCache = function() {

      class NodeCache2 extends EventEmitter {
        constructor(options = {}) {
          super();
          this.get = this.get.bind(this);
          this.mget = this.mget.bind(this);
          this.set = this.set.bind(this);
          this.mset = this.mset.bind(this);
          this.del = this.del.bind(this);
          this.take = this.take.bind(this);
          this.ttl = this.ttl.bind(this);
          this.getTtl = this.getTtl.bind(this);
          this.keys = this.keys.bind(this);
          this.has = this.has.bind(this);
          this.getStats = this.getStats.bind(this);
          this.flushAll = this.flushAll.bind(this);
          this.flushStats = this.flushStats.bind(this);
          this.close = this.close.bind(this);
          this._checkData = this._checkData.bind(this);
          this._check = this._check.bind(this);
          this._isInvalidKey = this._isInvalidKey.bind(this);
          this._wrap = this._wrap.bind(this);
          this._getValLength = this._getValLength.bind(this);
          this._error = this._error.bind(this);
          this._initErrors = this._initErrors.bind(this);
          this.options = options;
          this._initErrors();
          this.data = {};
          this.options = Object.assign({
            forceString: false,
            objectValueSize: 80,
            promiseValueSize: 80,
            arrayValueSize: 40,
            stdTTL: 0,
            checkperiod: 600,
            useClones: true,
            deleteOnExpire: true,
            enableLegacyCallbacks: false,
            maxKeys: -1
          }, this.options);
          if (this.options.enableLegacyCallbacks) {
            console.warn("WARNING! node-cache legacy callback support will drop in v6.x");
            ["get", "mget", "set", "del", "ttl", "getTtl", "keys", "has"].forEach((methodKey) => {
              var oldMethod;
              oldMethod = this[methodKey];
              this[methodKey] = function(...args) {
                var cb, err2, ref, res;
                ref = args, [...args] = ref, [cb] = splice.call(args, -1);
                if (typeof cb === "function") {
                  try {
                    res = oldMethod(...args);
                    cb(null, res);
                  } catch (error1) {
                    err2 = error1;
                    cb(err2);
                  }
                } else {
                  return oldMethod(...args, cb);
                }
              };
            });
          }
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.validKeyTypes = ["string", "number"];
          this._checkData();
          return;
        }
        get(key) {
          var _ret, err2;
          boundMethodCheck(this, NodeCache2);
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            this.stats.hits++;
            _ret = this._unwrap(this.data[key]);
            return _ret;
          } else {
            this.stats.misses++;
            return;
          }
        }
        mget(keys) {
          var _err, err2, i2, key, len, oRet;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            _err = this._error("EKEYSTYPE");
            throw _err;
          }
          oRet = {};
          for (i2 = 0, len = keys.length;i2 < len; i2++) {
            key = keys[i2];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null && this._check(key, this.data[key])) {
              this.stats.hits++;
              oRet[key] = this._unwrap(this.data[key]);
            } else {
              this.stats.misses++;
            }
          }
          return oRet;
        }
        set(key, value, ttl) {
          var _err, err2, existent;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          if (this.options.forceString && false === "string") {
            value = JSON.stringify(value);
          }
          if (ttl == null) {
            ttl = this.options.stdTTL;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          existent = false;
          if (this.data[key]) {
            existent = true;
            this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
          }
          this.data[key] = this._wrap(value, ttl);
          this.stats.vsize += this._getValLength(value);
          if (!existent) {
            this.stats.ksize += this._getKeyLength(key);
            this.stats.keys++;
          }
          this.emit("set", key, value);
          return true;
        }
        mset(keyValueSet) {
          var _err, err2, i2, j, key, keyValuePair, len, len1, ttl, val;
          boundMethodCheck(this, NodeCache2);
          if (this.options.maxKeys > -1 && this.stats.keys + keyValueSet.length >= this.options.maxKeys) {
            _err = this._error("ECACHEFULL");
            throw _err;
          }
          for (i2 = 0, len = keyValueSet.length;i2 < len; i2++) {
            keyValuePair = keyValueSet[i2];
            ({ key, val, ttl } = keyValuePair);
            if (ttl && typeof ttl !== "number") {
              _err = this._error("ETTLTYPE");
              throw _err;
            }
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
          }
          for (j = 0, len1 = keyValueSet.length;j < len1; j++) {
            keyValuePair = keyValueSet[j];
            ({ key, val, ttl } = keyValuePair);
            this.set(key, val, ttl);
          }
          return true;
        }
        del(keys) {
          var delCount, err2, i2, key, len, oldVal;
          boundMethodCheck(this, NodeCache2);
          if (!Array.isArray(keys)) {
            keys = [keys];
          }
          delCount = 0;
          for (i2 = 0, len = keys.length;i2 < len; i2++) {
            key = keys[i2];
            if ((err2 = this._isInvalidKey(key)) != null) {
              throw err2;
            }
            if (this.data[key] != null) {
              this.stats.vsize -= this._getValLength(this._unwrap(this.data[key], false));
              this.stats.ksize -= this._getKeyLength(key);
              this.stats.keys--;
              delCount++;
              oldVal = this.data[key];
              delete this.data[key];
              this.emit("del", key, oldVal.v);
            }
          }
          return delCount;
        }
        take(key) {
          var _ret;
          boundMethodCheck(this, NodeCache2);
          _ret = this.get(key);
          if (_ret != null) {
            this.del(key);
          }
          return _ret;
        }
        ttl(key, ttl) {
          var err2;
          boundMethodCheck(this, NodeCache2);
          ttl || (ttl = this.options.stdTTL);
          if (!key) {
            return false;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            if (ttl >= 0) {
              this.data[key] = this._wrap(this.data[key].v, ttl, false);
            } else {
              this.del(key);
            }
            return true;
          } else {
            return false;
          }
        }
        getTtl(key) {
          var _ttl, err2;
          boundMethodCheck(this, NodeCache2);
          if (!key) {
            return;
          }
          if ((err2 = this._isInvalidKey(key)) != null) {
            throw err2;
          }
          if (this.data[key] != null && this._check(key, this.data[key])) {
            _ttl = this.data[key].t;
            return _ttl;
          } else {
            return;
          }
        }
        keys() {
          var _keys;
          boundMethodCheck(this, NodeCache2);
          _keys = Object.keys(this.data);
          return _keys;
        }
        has(key) {
          var _exists;
          boundMethodCheck(this, NodeCache2);
          _exists = this.data[key] != null && this._check(key, this.data[key]);
          return _exists;
        }
        getStats() {
          boundMethodCheck(this, NodeCache2);
          return this.stats;
        }
        flushAll(_startPeriod = true) {
          boundMethodCheck(this, NodeCache2);
          this.data = {};
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this._killCheckPeriod();
          this._checkData(_startPeriod);
          this.emit("flush");
        }
        flushStats() {
          boundMethodCheck(this, NodeCache2);
          this.stats = {
            hits: 0,
            misses: 0,
            keys: 0,
            ksize: 0,
            vsize: 0
          };
          this.emit("flush_stats");
        }
        close() {
          boundMethodCheck(this, NodeCache2);
          this._killCheckPeriod();
        }
        _checkData(startPeriod = true) {
          var key, ref, value;
          boundMethodCheck(this, NodeCache2);
          ref = this.data;
          for (key in ref) {
            value = ref[key];
            this._check(key, value);
          }
          if (startPeriod && this.options.checkperiod > 0) {
            this.checkTimeout = setTimeout(this._checkData, this.options.checkperiod * 1000, startPeriod);
            if (this.checkTimeout != null && this.checkTimeout.unref != null) {
              this.checkTimeout.unref();
            }
          }
        }
        _killCheckPeriod() {
          if (this.checkTimeout != null) {
            return clearTimeout(this.checkTimeout);
          }
        }
        _check(key, data) {
          var _retval;
          boundMethodCheck(this, NodeCache2);
          _retval = true;
          if (data.t !== 0 && data.t < Date.now()) {
            if (this.options.deleteOnExpire) {
              _retval = false;
              this.del(key);
            }
            this.emit("expired", key, this._unwrap(data));
          }
          return _retval;
        }
        _isInvalidKey(key) {
          var ref;
          boundMethodCheck(this, NodeCache2);
          if (ref = typeof key, indexOf2.call(this.validKeyTypes, ref) < 0) {
            return this._error("EKEYTYPE", {
              type: typeof key
            });
          }
        }
        _wrap(value, ttl, asClone = true) {
          var livetime, now, oReturn, ttlMultiplicator;
          boundMethodCheck(this, NodeCache2);
          if (!this.options.useClones) {
            asClone = false;
          }
          now = Date.now();
          livetime = 0;
          ttlMultiplicator = 1000;
          if (ttl === 0) {
            livetime = 0;
          } else if (ttl) {
            livetime = now + ttl * ttlMultiplicator;
          } else {
            if (this.options.stdTTL === 0) {
              livetime = this.options.stdTTL;
            } else {
              livetime = now + this.options.stdTTL * ttlMultiplicator;
            }
          }
          return oReturn = {
            t: livetime,
            v: asClone ? clone(value) : value
          };
        }
        _unwrap(value, asClone = true) {
          if (!this.options.useClones) {
            asClone = false;
          }
          if (value.v != null) {
            if (asClone) {
              return clone(value.v);
            } else {
              return value.v;
            }
          }
          return null;
        }
        _getKeyLength(key) {
          return key.toString().length;
        }
        _getValLength(value) {
          boundMethodCheck(this, NodeCache2);
          if (typeof value === "string") {
            return value.length;
          } else if (this.options.forceString) {
            return JSON.stringify(value).length;
          } else if (Array.isArray(value)) {
            return this.options.arrayValueSize * value.length;
          } else if (typeof value === "number") {
            return 8;
          } else if (typeof (value != null ? value.then : undefined) === "function") {
            return this.options.promiseValueSize;
          } else if (typeof Buffer !== "undefined" && Buffer !== null ? Buffer.isBuffer(value) : undefined) {
            return value.length;
          } else if (value != null && typeof value === "object") {
            return this.options.objectValueSize * Object.keys(value).length;
          } else if (typeof value === "boolean") {
            return 8;
          } else {
            return 0;
          }
        }
        _error(type, data = {}) {
          var error2;
          boundMethodCheck(this, NodeCache2);
          error2 = new Error;
          error2.name = type;
          error2.errorcode = type;
          error2.message = this.ERRORS[type] != null ? this.ERRORS[type](data) : "-";
          error2.data = data;
          return error2;
        }
        _initErrors() {
          var _errMsg, _errT, ref;
          boundMethodCheck(this, NodeCache2);
          this.ERRORS = {};
          ref = this._ERRORS;
          for (_errT in ref) {
            _errMsg = ref[_errT];
            this.ERRORS[_errT] = this.createErrorMessage(_errMsg);
          }
        }
        createErrorMessage(errMsg) {
          return function(args) {
            return errMsg.replace("__key", args.type);
          };
        }
      }
      NodeCache2.prototype._ERRORS = {
        ENOTFOUND: "Key `__key` not found",
        ECACHEFULL: "Cache max keys amount exceeded",
        EKEYTYPE: "The key argument has to be of type `string` or `number`. Found: `__key`",
        EKEYSTYPE: "The keys argument has to be an array.",
        ETTLTYPE: "The ttl argument has to be a number."
      };
      return NodeCache2;
    }.call(this);
  }).call(exports2);
});

// node_modules/node-cache/index.js
var require_node_cache2 = __commonJS((exports2, module2) => {
  (function() {
    var exports3;
    exports3 = module2.exports = require_node_cache();
    exports3.version = "5.1.2";
  }).call(exports2);
});

// node_modules/@flowcore/pathways/esm/pathways/kv/node-kv-adapter.js
var exports_node_kv_adapter = {};
__export(exports_node_kv_adapter, {
  NodeKvAdapter: () => NodeKvAdapter
});

class NodeKvAdapter {
  constructor() {
    Object.defineProperty(this, "kv", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new import_node_cache.default
    });
  }
  async get(key) {
    const result = await this.kv.get(key);
    return result ?? null;
  }
  async set(key, value, ttlMs) {
    await this.kv.set(key, value, ttlMs / 1000);
  }
}
var import_node_cache;
var init_node_kv_adapter = __esm(() => {
  import_node_cache = __toESM(require_node_cache2(), 1);
});

// node_modules/postgres/src/query.js
function cachedError(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x2 = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x2;
  return originCache.get(xs);
}
var originCache, originStackCache, originError, CLOSE, Query;
var init_query = __esm(() => {
  originCache = new Map;
  originStackCache = new Map;
  originError = Symbol("OriginError");
  CLOSE = {};
  Query = class Query extends Promise {
    constructor(strings, args, handler, canceller, options = {}) {
      let resolve2, reject;
      super((a, b) => {
        resolve2 = a;
        reject = b;
      });
      this.tagged = Array.isArray(strings.raw);
      this.strings = strings;
      this.args = args;
      this.handler = handler;
      this.canceller = canceller;
      this.options = options;
      this.state = null;
      this.statement = null;
      this.resolve = (x2) => (this.active = false, resolve2(x2));
      this.reject = (x2) => (this.active = false, reject(x2));
      this.active = false;
      this.cancelled = null;
      this.executed = false;
      this.signature = "";
      this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
    }
    get origin() {
      return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
    }
    static get [Symbol.species]() {
      return Promise;
    }
    cancel() {
      return this.canceller && (this.canceller(this), this.canceller = null);
    }
    simple() {
      this.options.simple = true;
      this.options.prepare = false;
      return this;
    }
    async readable() {
      this.simple();
      this.streaming = true;
      return this;
    }
    async writable() {
      this.simple();
      this.streaming = true;
      return this;
    }
    cursor(rows = 1, fn) {
      this.options.simple = false;
      if (typeof rows === "function") {
        fn = rows;
        rows = 1;
      }
      this.cursorRows = rows;
      if (typeof fn === "function")
        return this.cursorFn = fn, this;
      let prev;
      return {
        [Symbol.asyncIterator]: () => ({
          next: () => {
            if (this.executed && !this.active)
              return { done: true };
            prev && prev();
            const promise = new Promise((resolve2, reject) => {
              this.cursorFn = (value) => {
                resolve2({ value, done: false });
                return new Promise((r) => prev = r);
              };
              this.resolve = () => (this.active = false, resolve2({ done: true }));
              this.reject = (x2) => (this.active = false, reject(x2));
            });
            this.execute();
            return promise;
          },
          return() {
            prev && prev(CLOSE);
            return { done: true };
          }
        })
      };
    }
    describe() {
      this.options.simple = false;
      this.onlyDescribe = this.options.prepare = true;
      return this;
    }
    stream() {
      throw new Error(".stream has been renamed to .forEach");
    }
    forEach(fn) {
      this.forEachFn = fn;
      this.handle();
      return this;
    }
    raw() {
      this.isRaw = true;
      return this;
    }
    values() {
      this.isRaw = "values";
      return this;
    }
    async handle() {
      !this.executed && (this.executed = true) && await 1 && this.handler(this);
    }
    execute() {
      this.handle();
      return this;
    }
    then() {
      this.handle();
      return super.then.apply(this, arguments);
    }
    catch() {
      this.handle();
      return super.catch.apply(this, arguments);
    }
    finally() {
      this.handle();
      return super.finally.apply(this, arguments);
    }
  };
});

// node_modules/postgres/src/errors.js
function connection(x2, options, socket) {
  const { host, port } = socket || options;
  const error2 = Object.assign(new Error("write " + x2 + " " + (options.path || host + ":" + port)), {
    code: x2,
    errno: x2,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error2, connection);
  return error2;
}
function postgres(x2) {
  const error2 = new PostgresError(x2);
  Error.captureStackTrace(error2, postgres);
  return error2;
}
function generic(code, message) {
  const error2 = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error2, generic);
  return error2;
}
function notSupported(x2) {
  const error2 = Object.assign(new Error(x2 + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x2
  });
  Error.captureStackTrace(error2, notSupported);
  return error2;
}
var PostgresError, Errors;
var init_errors = __esm(() => {
  PostgresError = class PostgresError extends Error {
    constructor(x2) {
      super(x2.message);
      this.name = this.constructor.name;
      Object.assign(this, x2);
    }
  };
  Errors = {
    connection,
    postgres,
    generic,
    notSupported
  };
});

// node_modules/postgres/src/types.js
class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}
function handleValue(x2, parameters, types3, options) {
  let value = x2 instanceof Parameter ? x2.value : x2;
  if (value === undefined) {
    x2 instanceof Parameter ? x2.value = options.transform.undefined : value = x2 = options.transform.undefined;
    if (value === undefined)
      throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types3.push(x2 instanceof Parameter ? (parameters.push(x2.value), x2.array ? x2.array[x2.type || inferType(x2.value)] || x2.type || firstIsString(x2.value) : x2.type) : (parameters.push(x2), inferType(x2)));
}
function stringify2(q, string, value, parameters, types3, options) {
  for (let i2 = 1;i2 < q.strings.length; i2++) {
    string += stringifyValue(string, value, parameters, types3, options) + q.strings[i2];
    value = q.args[i2];
  }
  return string;
}
function stringifyValue(string, value, parameters, types3, o) {
  return value instanceof Builder ? value.build(string, parameters, types3, o) : value instanceof Query ? fragment(value, parameters, types3, o) : value instanceof Identifier ? value.value : value && value[0] instanceof Query ? value.reduce((acc, x2) => acc + " " + fragment(x2, parameters, types3, o), "") : handleValue(value, parameters, types3, o);
}
function fragment(q, parameters, types3, options) {
  q.fragment = true;
  return stringify2(q, q.strings[0], q.args[0], parameters, types3, options);
}
function valuesBuilder(first, parameters, types3, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue("values", row[column], parameters, types3, options)).join(",") + ")").join(",");
}
function values(first, rest, parameters, types3, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest.length ? rest.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters, types3, columns, options);
}
function select(first, rest, parameters, types3, options) {
  typeof first === "string" && (first = [first].concat(rest));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value;
  const columns = rest.length ? rest.flat() : Object.keys(first);
  return columns.map((x2) => {
    value = first[x2];
    return (value instanceof Query ? fragment(value, parameters, types3, options) : value instanceof Identifier ? value.value : handleValue(value, parameters, types3, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x2) : x2);
  }).join(",");
}
function notTagged() {
  throw Errors.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
}
function firstIsString(x2) {
  if (Array.isArray(x2))
    return firstIsString(x2[0]);
  return typeof x2 === "string" ? 1009 : 0;
}
function typeHandlers(types3) {
  return Object.keys(types3).reduce((acc, k) => {
    types3[k].from && [].concat(types3[k].from).forEach((x2) => acc.parsers[x2] = types3[k].parse);
    if (types3[k].serialize) {
      acc.serializers[types3[k].to] = types3[k].serialize;
      types3[k].from && [].concat(types3[k].from).forEach((x2) => acc.serializers[x2] = types3[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
}
function escapeIdentifiers(xs, { transform: { column } }) {
  return xs.map((x2) => escapeIdentifier(column.to ? column.to(x2) : x2)).join(",");
}
function arrayEscape(x2) {
  return x2.replace(escapeBackslash, "\\\\").replace(escapeQuote, "\\\"");
}
function arrayParserLoop(s, x2, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s.i < x2.length; s.i++) {
    s.char = x2[s.i];
    if (s.quoted) {
      if (s.char === "\\") {
        s.str += x2[++s.i];
      } else if (s.char === '"') {
        xs.push(parser ? parser(s.str) : s.str);
        s.str = "";
        s.quoted = x2[s.i + 1] === '"';
        s.last = s.i + 2;
      } else {
        s.str += s.char;
      }
    } else if (s.char === '"') {
      s.quoted = true;
    } else if (s.char === "{") {
      s.last = ++s.i;
      xs.push(arrayParserLoop(s, x2, parser, typarray));
    } else if (s.char === "}") {
      s.quoted = false;
      s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
      break;
    } else if (s.char === delimiter && s.p !== "}" && s.p !== '"') {
      xs.push(parser ? parser(x2.slice(s.last, s.i)) : x2.slice(s.last, s.i));
      s.last = s.i + 1;
    }
    s.p = s.char;
  }
  s.last < s.i && xs.push(parser ? parser(x2.slice(s.last, s.i + 1)) : x2.slice(s.last, s.i + 1));
  return xs;
}
function createJsonTransform(fn) {
  return function jsonTransform(x2, column) {
    return typeof x2 === "object" && x2 !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x2) ? x2.map((x3) => jsonTransform(x3, column)) : Object.entries(x2).reduce((acc, [k, v]) => Object.assign(acc, { [fn(k)]: jsonTransform(v, column) }), {}) : x2;
  };
}
var types2, Identifier, Parameter, Builder, defaultHandlers, builders, serializers, parsers, mergeUserTypes = function(types3) {
  const user = typeHandlers(types3 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
}, escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
}, inferType = function inferType2(x2) {
  return x2 instanceof Parameter ? x2.type : x2 instanceof Date ? 1184 : x2 instanceof Uint8Array ? 17 : x2 === true || x2 === false ? 16 : typeof x2 === "bigint" ? 20 : Array.isArray(x2) ? inferType2(x2[0]) : 0;
}, escapeBackslash, escapeQuote, arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x2) => arraySerializer2(x2, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x2) => {
    if (x2 === undefined) {
      x2 = options.transform.undefined;
      if (x2 === undefined)
        throw Errors.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x2 === null ? "null" : '"' + arrayEscape(serializer ? serializer(x2.type ? x2.value : x2) : "" + x2) + '"';
  }).join(delimiter) + "}";
}, arrayParserState, arrayParser = function arrayParser2(x2, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x2, parser, typarray);
}, toCamel = (x2) => {
  let str = x2[0];
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
}, toPascal = (x2) => {
  let str = x2[0].toUpperCase();
  for (let i2 = 1;i2 < x2.length; i2++)
    str += x2[i2] === "_" ? x2[++i2].toUpperCase() : x2[i2];
  return str;
}, toKebab = (x2) => x2.replace(/_/g, "-"), fromCamel = (x2) => x2.replace(/([A-Z])/g, "_$1").toLowerCase(), fromPascal = (x2) => (x2.slice(0, 1) + x2.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase(), fromKebab = (x2) => x2.replace(/-/g, "_"), camel, pascal, kebab;
var init_types = __esm(() => {
  init_query();
  init_errors();
  types2 = {
    string: {
      to: 25,
      from: null,
      serialize: (x2) => "" + x2
    },
    number: {
      to: 0,
      from: [21, 23, 26, 700, 701],
      serialize: (x2) => "" + x2,
      parse: (x2) => +x2
    },
    json: {
      to: 114,
      from: [114, 3802],
      serialize: (x2) => JSON.stringify(x2),
      parse: (x2) => JSON.parse(x2)
    },
    boolean: {
      to: 16,
      from: 16,
      serialize: (x2) => x2 === true ? "t" : "f",
      parse: (x2) => x2 === "t"
    },
    date: {
      to: 1184,
      from: [1082, 1114, 1184],
      serialize: (x2) => (x2 instanceof Date ? x2 : new Date(x2)).toISOString(),
      parse: (x2) => new Date(x2)
    },
    bytea: {
      to: 17,
      from: 17,
      serialize: (x2) => "\\x" + Buffer.from(x2).toString("hex"),
      parse: (x2) => Buffer.from(x2.slice(2), "hex")
    }
  };
  Identifier = class Identifier extends NotTagged {
    constructor(value) {
      super();
      this.value = escapeIdentifier(value);
    }
  };
  Parameter = class Parameter extends NotTagged {
    constructor(value, type, array) {
      super();
      this.value = value;
      this.type = type;
      this.array = array;
    }
  };
  Builder = class Builder extends NotTagged {
    constructor(first, rest) {
      super();
      this.first = first;
      this.rest = rest;
    }
    build(before, parameters, types3, options) {
      const keyword = builders.map(([x2, fn]) => ({ fn, i: before.search(x2) })).sort((a, b) => a.i - b.i).pop();
      return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters, types3, options);
    }
  };
  defaultHandlers = typeHandlers(types2);
  builders = Object.entries({
    values,
    in: (...xs) => {
      const x2 = values(...xs);
      return x2 === "()" ? "(null)" : x2;
    },
    select,
    as: select,
    returning: select,
    "\\(": select,
    update(first, rest, parameters, types3, options) {
      return (rest.length ? rest.flat() : Object.keys(first)).map((x2) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x2) : x2) + "=" + stringifyValue("values", first[x2], parameters, types3, options));
    },
    insert(first, rest, parameters, types3, options) {
      const columns = rest.length ? rest.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
      return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters, types3, columns, options);
    }
  }).map(([x2, fn]) => [new RegExp("((?:^|[\\s(])" + x2 + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
  serializers = defaultHandlers.serializers;
  parsers = defaultHandlers.parsers;
  escapeBackslash = /\\/g;
  escapeQuote = /"/g;
  arrayParserState = {
    i: 0,
    char: null,
    str: "",
    quoted: false,
    last: 0
  };
  toCamel.column = { from: toCamel };
  toCamel.value = { from: createJsonTransform(toCamel) };
  fromCamel.column = { to: fromCamel };
  camel = { ...toCamel };
  camel.column.to = fromCamel;
  toPascal.column = { from: toPascal };
  toPascal.value = { from: createJsonTransform(toPascal) };
  fromPascal.column = { to: fromPascal };
  pascal = { ...toPascal };
  pascal.column.to = fromPascal;
  toKebab.column = { from: toKebab };
  toKebab.value = { from: createJsonTransform(toKebab) };
  fromKebab.column = { to: fromKebab };
  kebab = { ...toKebab };
  kebab.column.to = fromKebab;
});

// node_modules/postgres/src/result.js
var Result;
var init_result = __esm(() => {
  Result = class Result extends Array {
    constructor() {
      super();
      Object.defineProperties(this, {
        count: { value: null, writable: true },
        state: { value: null, writable: true },
        command: { value: null, writable: true },
        columns: { value: null, writable: true },
        statement: { value: null, writable: true }
      });
    }
    static get [Symbol.species]() {
      return Array;
    }
  };
});

// node_modules/postgres/src/queue.js
function Queue(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x2) => {
      const index2 = xs.indexOf(x2);
      return index2 === -1 ? null : (xs.splice(index2, 1), x2);
    },
    push: (x2) => (xs.push(x2), x2),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
}
var queue_default;
var init_queue = __esm(() => {
  queue_default = Queue;
});

// node_modules/postgres/src/bytes.js
function fit(x2) {
  if (buffer.length - b.i < x2) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x2);
    prev.copy(buffer);
  }
}
function reset() {
  b.i = 0;
  return b;
}
var size = 256, buffer, messages, b, bytes_default;
var init_bytes = __esm(() => {
  buffer = Buffer.allocUnsafe(size);
  messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x2) => {
    const v = x2.charCodeAt(0);
    acc[x2] = () => {
      buffer[0] = v;
      b.i = 5;
      return b;
    };
    return acc;
  }, {});
  b = Object.assign(reset, messages, {
    N: String.fromCharCode(0),
    i: 0,
    inc(x2) {
      b.i += x2;
      return b;
    },
    str(x2) {
      const length = Buffer.byteLength(x2);
      fit(length);
      b.i += buffer.write(x2, b.i, length, "utf8");
      return b;
    },
    i16(x2) {
      fit(2);
      buffer.writeUInt16BE(x2, b.i);
      b.i += 2;
      return b;
    },
    i32(x2, i2) {
      if (i2 || i2 === 0) {
        buffer.writeUInt32BE(x2, i2);
        return b;
      }
      fit(4);
      buffer.writeUInt32BE(x2, b.i);
      b.i += 4;
      return b;
    },
    z(x2) {
      fit(x2);
      buffer.fill(0, b.i, b.i + x2);
      b.i += x2;
      return b;
    },
    raw(x2) {
      buffer = Buffer.concat([buffer.subarray(0, b.i), x2]);
      b.i = buffer.length;
      return b;
    },
    end(at = 1) {
      buffer.writeUInt32BE(b.i - at, at);
      const out = buffer.subarray(0, b.i);
      b.i = 0;
      buffer = Buffer.allocUnsafe(size);
      return out;
    }
  });
  bytes_default = b;
});

// node_modules/postgres/src/connection.js
function Connection(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max: max2,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query2) {
      initial = query2;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x2;
    try {
      x2 = options.socket ? await Promise.resolve(options.socket(options)) : new import_net.default.Socket;
    } catch (e) {
      error2(e);
      return;
    }
    x2.on("error", error2);
    x2.on("close", closed);
    x2.on("drain", drain);
    return x2;
  }
  async function cancel({ pid, secret }, resolve2, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve2);
    } catch (error3) {
      reject(error3);
    }
  }
  function execute(q) {
    if (terminated)
      return queryError(q, Errors.connection("CONNECTION_DESTROYED", options));
    if (q.cancelled)
      return;
    try {
      q.state = backend;
      query ? sent.push(q) : (query = q, query.active = true);
      build(q);
      return write2(toBuffer(q)) && !q.describeFirst && !q.cursorFn && sent.length < max_pipeline && (!q.options.onexecute || q.options.onexecute(connection2));
    } catch (error3) {
      sent.length === 0 && write2(Sync);
      errored(error3);
      return true;
    }
  }
  function toBuffer(q) {
    if (q.parameters.length >= 65534)
      throw Errors.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q.options.simple ? bytes_default().Q().str(q.statement.string + bytes_default.N).end() : q.describeFirst ? Buffer.concat([describe(q), Flush]) : q.prepare ? q.prepared ? prepared(q) : Buffer.concat([describe(q), prepared(q)]) : unnamed(q);
  }
  function describe(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types, q.statement.name),
      Describe("S", q.statement.name)
    ]);
  }
  function prepared(q) {
    return Buffer.concat([
      Bind(q.parameters, q.statement.types, q.statement.name, q.cursorName),
      q.cursorFn ? Execute("", q.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q) {
    return Buffer.concat([
      Parse(q.statement.string, q.parameters, q.statement.types),
      DescribeUnnamed,
      prepared(q)
    ]);
  }
  function build(q) {
    const parameters = [], types3 = [];
    const string = stringify2(q, q.strings[0], q.args[0], parameters, types3, options);
    !q.tagged && q.args.forEach((x2) => handleValue(x2, parameters, types3, options));
    q.prepare = options.prepare && ("prepare" in q.options ? q.options.prepare : true);
    q.string = string;
    q.signature = q.prepare && types3 + string;
    q.onlyDescribe && delete statements[q.signature];
    q.parameters = q.parameters || parameters;
    q.prepared = q.prepare && q.signature in statements;
    q.describeFirst = q.onlyDescribe || parameters.length && !q.prepared;
    q.statement = q.prepared ? statements[q.signature] : { string, types: types3, name: q.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string, parameters, types3);
  }
  function write2(x2, fn) {
    chunk = chunk ? Buffer.concat([chunk, x2]) : Buffer.from(x2);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x2 = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x2;
  }
  function connectTimedOut() {
    errored(Errors.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write2(SSLRequest);
    const canSSL = await new Promise((r) => socket.once("data", (x2) => r(x2[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = import_tls.default.connect({
      socket,
      servername: import_net.default.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error2);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query && onopen(connection2);
  }
  function data(x2) {
    if (incomings) {
      incomings.push(x2);
      remaining -= x2.length;
      if (remaining > 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x2 : Buffer.concat([incoming, x2], incoming.length + x2.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e) {
        query && (query.cursorFn || query.describeFirst) && write2(Sync);
        errored(e);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - import_perf_hooks.performance.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s = StartupMessage();
      write2(s);
    } catch (err2) {
      error2(err2);
    }
  }
  function error2(err2) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err2);
    while (sent.length)
      queryError(sent.shift(), err2);
  }
  function errored(err2) {
    stream && (stream.destroy(err2), stream = null);
    query && queryError(query, err2);
    initial && (queryError(initial, err2), initial = null);
  }
  function queryError(query2, err2) {
    if (query2.reserve)
      return query2.reject(err2);
    if (!err2 || typeof err2 !== "object")
      err2 = new Error(err2);
    "query" in err2 || "parameters" in err2 || Object.defineProperties(err2, {
      stack: { value: err2.stack + query2.origin.replace(/.*\n/, `
`), enumerable: options.debug },
      query: { value: query2.string, enumerable: options.debug },
      parameters: { value: query2.parameters, enumerable: options.debug },
      args: { value: query2.args, enumerable: options.debug },
      types: { value: query2.statement && query2.statement.types, enumerable: options.debug }
    });
    query2.reject(err2);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query && sent.length === 0 ? (terminate(), new Promise((r) => socket && socket.readyState !== "closed" ? socket.once("close", r) : r())) : ending = new Promise((r) => ended = r));
  }
  function terminate() {
    terminated = true;
    if (stream || query || initial || sent.length)
      error2(Errors.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    socket.removeAllListeners();
    socket = null;
    if (initial)
      return reconnect();
    !hadError && (query || sent.length) && error2(Errors.connection("CONNECTION_CLOSED", options, socket));
    closedDate = import_perf_hooks.performance.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x2 = xs[0]) {
    (x2 === 68 ? DataRow : x2 === 100 ? CopyData : x2 === 65 ? NotificationResponse : x2 === 83 ? ParameterStatus : x2 === 90 ? ReadyForQuery : x2 === 67 ? CommandComplete : x2 === 50 ? BindComplete : x2 === 49 ? ParseComplete : x2 === 116 ? ParameterDescription : x2 === 84 ? RowDescription : x2 === 82 ? Authentication : x2 === 110 ? NoData : x2 === 75 ? BackendKeyData : x2 === 69 ? ErrorResponse : x2 === 115 ? PortalSuspended : x2 === 51 ? CloseComplete : x2 === 71 ? CopyInResponse : x2 === 78 ? NoticeResponse : x2 === 72 ? CopyOutResponse : x2 === 99 ? CopyDone : x2 === 73 ? EmptyQueryResponse : x2 === 86 ? FunctionCallResponse : x2 === 118 ? NegotiateProtocolVersion : x2 === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x2) {
    let index = 7;
    let length2;
    let column;
    let value;
    const row = query.isRaw ? new Array(query.statement.columns.length) : {};
    for (let i2 = 0;i2 < query.statement.columns.length; i2++) {
      column = query.statement.columns[i2];
      length2 = x2.readInt32BE(index);
      index += 4;
      value = length2 === -1 ? null : query.isRaw === true ? x2.subarray(index, index += length2) : column.parser === undefined ? x2.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x2.toString("utf8", index + 1, index += length2)) : column.parser(x2.toString("utf8", index, index += length2));
      query.isRaw ? row[i2] = query.isRaw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
    }
    query.forEachFn ? query.forEachFn(transform.row.from ? transform.row.from(row) : row, result) : result[rows++] = transform.row.from ? transform.row.from(row) : row;
  }
  function ParameterStatus(x2) {
    const [k, v] = x2.toString("utf8", 5, x2.length - 1).split(bytes_default.N);
    backendParameters[k] = v;
    if (options.parameters[k] !== v) {
      options.parameters[k] = v;
      onparameter && onparameter(k, v);
    }
  }
  function ReadyForQuery(x2) {
    query && query.options.simple && query.resolve(results || result);
    query = results = null;
    result = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial.reserve && (initial = null);
        return fetchArrayTypes();
      }
      initial && !initial.reserve && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query = sent.shift()) && (query.active = true, query.cancelled))
      Connection(options).cancel(query.state, query.cancelled.resolve, query.cancelled.reject);
    if (query)
      return;
    connection2.reserved ? !connection2.reserved.release && x2[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x2) {
    rows = 0;
    for (let i2 = x2.length - 1;i2 > 0; i2--) {
      if (x2[i2] === 32 && x2[i2 + 1] < 58 && result.count === null)
        result.count = +x2.toString("utf8", i2 + 1, x2.length - 1);
      if (x2[i2 - 1] >= 65) {
        result.command = x2.toString("utf8", 5, i2);
        result.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result.command === "BEGIN" && max2 !== 1 && !connection2.reserved)
      return errored(Errors.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query.options.simple)
      return BindComplete();
    if (query.cursorFn) {
      result.count && query.cursorFn(result);
      write2(Sync);
    }
    query.resolve(result);
  }
  function ParseComplete() {
    query.parsing = false;
  }
  function BindComplete() {
    !result.statement && (result.statement = query.statement);
    result.columns = query.statement.columns;
  }
  function ParameterDescription(x2) {
    const length2 = x2.readUInt16BE(5);
    for (let i2 = 0;i2 < length2; ++i2)
      !query.statement.types[i2] && (query.statement.types[i2] = x2.readUInt32BE(7 + i2 * 4));
    query.prepare && (statements[query.signature] = query.statement);
    query.describeFirst && !query.onlyDescribe && (write2(prepared(query)), query.describeFirst = false);
  }
  function RowDescription(x2) {
    if (result.command) {
      results = results || [result];
      results.push(result = new Result);
      result.count = null;
      query.statement.columns = null;
    }
    const length2 = x2.readUInt16BE(5);
    let index = 7;
    let start;
    query.statement.columns = Array(length2);
    for (let i2 = 0;i2 < length2; ++i2) {
      start = index;
      while (x2[index++] !== 0)
        ;
      const table = x2.readUInt32BE(index);
      const number = x2.readUInt16BE(index + 4);
      const type = x2.readUInt32BE(index + 6);
      query.statement.columns[i2] = {
        name: transform.column.from ? transform.column.from(x2.toString("utf8", start, index - 1)) : x2.toString("utf8", start, index - 1),
        parser: parsers2[type],
        table,
        number,
        type
      };
      index += 18;
    }
    result.statement = query.statement;
    if (query.onlyDescribe)
      return query.resolve(query.statement), write2(Sync);
  }
  async function Authentication(x2, type = x2.readUInt32BE(5)) {
    (type === 3 ? AuthenticationCleartextPassword : type === 5 ? AuthenticationMD5Password : type === 10 ? SASL : type === 11 ? SASLContinue : type === 12 ? SASLFinal : type !== 0 ? UnknownAuth : noop)(x2, type);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write2(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x2) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x2.subarray(9)
    ]));
    write2(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await import_crypto2.default.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i2 = bytes_default.i;
    write2(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i2 - 4, i2).end());
  }
  async function SASLContinue(x2) {
    const res = x2.toString("utf8", 9).split(",").reduce((acc, x3) => (acc[x3[0]] = x3.slice(2), acc), {});
    const saltedPassword = await import_crypto2.default.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + "," + "r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha2562(clientKey), auth))).toString("base64");
    write2(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x2) {
    if (x2.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result.statement = query.statement;
    result.statement.columns = [];
    if (query.onlyDescribe)
      return query.resolve(query.statement), write2(Sync);
  }
  function BackendKeyData(x2) {
    backend.pid = x2.readUInt32BE(5);
    backend.secret = x2.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types3 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types3.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x2, xs) {
    return x2 === "read-write" && xs.default_transaction_read_only === "on" || x2 === "read-only" && xs.default_transaction_read_only === "off" || x2 === "primary" && xs.in_hot_standby === "on" || x2 === "standby" && xs.in_hot_standby === "off" || x2 === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query2 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query2.resolve = ([[a], [b2]]) => {
      backendParameters.default_transaction_read_only = a.transaction_read_only;
      backendParameters.in_hot_standby = b2.pg_is_in_recovery ? "on" : "off";
    };
    query2.execute();
  }
  function ErrorResponse(x2) {
    query && (query.cursorFn || query.describeFirst) && write2(Sync);
    const error3 = Errors.postgres(parseError2(x2));
    query && query.retried ? errored(query.retried) : query && query.prepared && retryRoutines.has(error3.routine) ? retry2(query, error3) : errored(error3);
  }
  function retry2(q, error3) {
    delete statements[q.signature];
    q.retried = error3;
    execute(q);
  }
  function NotificationResponse(x2) {
    if (!onnotify)
      return;
    let index = 9;
    while (x2[index++] !== 0)
      ;
    onnotify(x2.toString("utf8", 9, index - 1), x2.toString("utf8", index, x2.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x2 = await Promise.resolve(query.cursorFn(result));
      rows = 0;
      x2 === CLOSE ? write2(Close(query.portal)) : (result = new Result, write2(Execute("", query.cursorRows)));
    } catch (err2) {
      write2(Sync);
      query.reject(err2);
    }
  }
  function CloseComplete() {
    result.count && query.cursorFn(result);
    query.resolve(result);
  }
  function CopyInResponse() {
    stream = new import_stream8.default.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error3, callback) {
        callback(error3);
        socket.write(bytes_default().f().str(error3 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new import_stream8.default.Readable({
      read() {
        socket.resume();
      }
    });
    query.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new import_stream8.default.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error3, callback) {
        callback(error3);
        socket.write(bytes_default().f().str(error3 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query.resolve(stream);
  }
  function CopyData(x2) {
    stream && (stream.push(x2.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x2) {
    onnotice ? onnotice(parseError2(x2)) : console.log(parseError2(x2));
  }
  function EmptyQueryResponse() {}
  function FunctionCallResponse() {
    errored(Errors.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x2) {
    console.error("Postgres.js : Unknown Message:", x2[0]);
  }
  function UnknownAuth(x2, type) {
    console.error("Postgres.js : Unknown Auth:", type);
  }
  function Bind(parameters, types3, statement = "", portal = "") {
    let prev, type;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters.length);
    parameters.forEach((x2, i2) => {
      if (x2 === null)
        return bytes_default.i32(4294967295);
      type = types3[i2];
      parameters[i2] = x2 = type in options.serializers ? options.serializers[type](x2) : "" + x2;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x2).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters, types3, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters.length);
    parameters.forEach((x2, i2) => bytes_default.i32(types3[i2] || 0));
    return bytes_default.end();
  }
  function Describe(x2, name = "") {
    return bytes_default().D().str(x2).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v]) => v).map(([k, v]) => k + bytes_default.N + v).join(bytes_default.N)).z(2).end(0);
  }
}
function parseError2(x2) {
  const error2 = {};
  let start = 5;
  for (let i2 = 5;i2 < x2.length - 1; i2++) {
    if (x2[i2] === 0) {
      error2[errorFields[x2[start]]] = x2.toString("utf8", start + 1, i2);
      start = i2 + 1;
    }
  }
  return error2;
}
function md5(x2) {
  return import_crypto2.default.createHash("md5").update(x2).digest("hex");
}
function hmac(key, x2) {
  return import_crypto2.default.createHmac("sha256", key).update(x2).digest();
}
function sha2562(x2) {
  return import_crypto2.default.createHash("sha256").update(x2).digest();
}
function xor(a, b2) {
  const length = Math.max(a.length, b2.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i2 = 0;i2 < length; i2++)
    buffer2[i2] = a[i2] ^ b2[i2];
  return buffer2;
}
function timer(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
}
var import_net, import_tls, import_crypto2, import_stream8, import_perf_hooks, connection_default, uid = 1, Sync, Flush, SSLRequest, ExecuteUnnamed, DescribeUnnamed, noop = () => {}, retryRoutines, errorFields;
var init_connection = __esm(() => {
  init_types();
  init_errors();
  init_result();
  init_queue();
  init_query();
  init_bytes();
  import_net = __toESM(require("net"));
  import_tls = __toESM(require("tls"));
  import_crypto2 = __toESM(require("crypto"));
  import_stream8 = __toESM(require("stream"));
  import_perf_hooks = require("perf_hooks");
  connection_default = Connection;
  Sync = bytes_default().S().end();
  Flush = bytes_default().H().end();
  SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
  ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
  DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
  retryRoutines = new Set([
    "FetchPreparedStatement",
    "RevalidateCachedQuery",
    "transformAssignedExpr"
  ]);
  errorFields = {
    83: "severity_local",
    86: "severity",
    67: "code",
    77: "message",
    68: "detail",
    72: "hint",
    80: "position",
    112: "internal_position",
    113: "internal_query",
    87: "where",
    115: "schema_name",
    116: "table_name",
    99: "column_name",
    100: "data type_name",
    110: "constraint_name",
    70: "file",
    76: "line",
    82: "routine"
  };
});

// node_modules/postgres/src/subscribe.js
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init(sql, slot, options.publications));
      subscribers.forEach((event2) => event2.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql;
  sql.end = async () => {
    ended = true;
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return end();
  };
  sql.close = async () => {
    stream && await new Promise((r) => (stream.once("close", r), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event2, fn, onsubscribe = noop2, onerror = noop2) {
    event2 = parseEvent(event2);
    if (!connection2)
      connection2 = init(sql, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event2) ? subscribers.get(event2).add(subscriber) : subscribers.set(event2, new Set([subscriber])).get(event2);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event2);
    };
    return connection2.then((x2) => {
      connected(x2);
      onsubscribe();
      stream && stream.on("error", onerror);
      return { unsubscribe, state, sql };
    });
  }
  function connected(x2) {
    stream = x2.stream;
    state.pid = x2.state.pid;
    state.secret = x2.state.secret;
  }
  async function init(sql2, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql2.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x2] = xs;
    const stream2 = await sql2.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x2.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x2.consistent_point.split("/").map((x3) => Buffer.from(("00000000" + x3).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error2);
    stream2.on("close", sql2.close);
    return { stream: stream2, state: xs.state };
    function error2(e) {
      console.error("Unexpected error during logical streaming - reconnecting", e);
    }
    function data(x3) {
      if (x3[0] === 119) {
        parse4(x3.subarray(25), state2, sql2.options.parsers, handle, options.transform);
      } else if (x3[0] === 107 && x3[17]) {
        state2.lsn = x3.subarray(1, 9);
        pong();
      }
    }
    function handle(a, b2) {
      const path = b2.relation.schema + "." + b2.relation.table;
      call("*", a, b2);
      call("*:" + path, a, b2);
      b2.relation.keys.length && call("*:" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
      call(b2.command, a, b2);
      call(b2.command + ":" + path, a, b2);
      b2.relation.keys.length && call(b2.command + ":" + path + "=" + b2.relation.keys.map((x3) => a[x3.name]), a, b2);
    }
    function pong() {
      const x3 = Buffer.alloc(34);
      x3[0] = 114;
      x3.fill(state2.lsn, 1);
      x3.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x3);
    }
  }
  function call(x2, a, b2) {
    subscribers.has(x2) && subscribers.get(x2).forEach(({ fn }) => fn(a, b2, x2));
  }
}
function Time(x2) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x2 / BigInt(1000)));
}
function parse4(x2, state, parsers2, handle, transform) {
  const char = (acc, [k, v]) => (acc[k.charCodeAt(0)] = v, acc);
  Object.entries({
    R: (x3) => {
      let i2 = 1;
      const r = state[x3.readUInt32BE(i2)] = {
        schema: x3.toString("utf8", i2 += 4, i2 = x3.indexOf(0, i2)) || "pg_catalog",
        table: x3.toString("utf8", i2 + 1, i2 = x3.indexOf(0, i2 + 1)),
        columns: Array(x3.readUInt16BE(i2 += 2)),
        keys: []
      };
      i2 += 2;
      let columnIndex = 0, column;
      while (i2 < x3.length) {
        column = r.columns[columnIndex++] = {
          key: x3[i2++],
          name: transform.column.from ? transform.column.from(x3.toString("utf8", i2, i2 = x3.indexOf(0, i2))) : x3.toString("utf8", i2, i2 = x3.indexOf(0, i2)),
          type: x3.readUInt32BE(i2 += 1),
          parser: parsers2[x3.readUInt32BE(i2)],
          atttypmod: x3.readUInt32BE(i2 += 4)
        };
        column.key && r.keys.push(column);
        i2 += 4;
      }
    },
    Y: () => {},
    O: () => {},
    B: (x3) => {
      state.date = Time(x3.readBigInt64BE(9));
      state.lsn = x3.subarray(1, 9);
    },
    I: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      const { row } = tuples(x3, relation.columns, i2 += 7, transform);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      handle(key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x3) => {
      let i2 = 1;
      const relation = state[x3.readUInt32BE(i2)];
      i2 += 4;
      const key = x3[i2] === 75;
      const xs = key || x3[i2] === 79 ? tuples(x3, relation.columns, i2 += 3, transform) : null;
      xs && (i2 = xs.i);
      const { row } = tuples(x3, relation.columns, i2 + 3, transform);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {},
    C: () => {}
  }).reduce(char, {})[x2[0]](x2);
}
function tuples(x2, columns, xi, transform) {
  let type, column, value;
  const row = transform.raw ? new Array(columns.length) : {};
  for (let i2 = 0;i2 < columns.length; i2++) {
    type = x2[xi++];
    column = columns[i2];
    value = type === 110 ? null : type === 117 ? undefined : column.parser === undefined ? x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x2.toString("utf8", xi + 5, xi += 4 + x2.readUInt32BE(xi))) : column.parser(x2.toString("utf8", xi + 4, xi += 4 + x2.readUInt32BE(xi)));
    transform.raw ? row[i2] = transform.raw === true ? value : transform.value.from ? transform.value.from(value, column) : value : row[column.name] = transform.value.from ? transform.value.from(value, column) : value;
  }
  return { i: xi, row: transform.row.from ? transform.row.from(row) : row };
}
function parseEvent(x2) {
  const xs = x2.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x2);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
}
var noop2 = () => {};

// node_modules/postgres/src/large.js
function largeObject(sql, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve2, reject) => {
    await sql.begin(async (sql2) => {
      let finish;
      !oid && ([{ oid }] = await sql2`select lo_creat(-1) as oid`);
      const [{ fd: fd2 }] = await sql2`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql2`select lo_close(${fd2})`.then(finish),
        tell: () => sql2`select lo_tell64(${fd2})`,
        read: (x2) => sql2`select loread(${fd2}, ${x2}) as data`,
        write: (x2) => sql2`select lowrite(${fd2}, ${x2})`,
        truncate: (x2) => sql2`select lo_truncate64(${fd2}, ${x2})`,
        seek: (x2, whence = 0) => sql2`select lo_lseek64(${fd2}, ${x2}, ${whence})`,
        size: () => sql2`
          select
            lo_lseek64(${fd2}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve2(lo);
      return new Promise(async (r) => finish = r);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max2 = end - start;
        start && await lo.seek(start);
        return new import_stream9.default.Readable({
          highWaterMark,
          async read(size2) {
            const l = size2 > max2 ? size2 - max2 : size2;
            max2 -= size2;
            const [{ data }] = await lo.read(l);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new import_stream9.default.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}
var import_stream9;
var init_large = __esm(() => {
  import_stream9 = __toESM(require("stream"));
});

// node_modules/postgres/src/index.js
var exports_src = {};
__export(exports_src, {
  default: () => src_default
});
function Postgres(a, b2) {
  const options = parseOptions(a, b2), subscribe = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql = Sql(handler);
  Object.assign(sql, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql),
    subscribe,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type]) => {
      acc[name] = (x2) => new Parameter(x2, type.to);
      return acc;
    }, typed);
    Object.assign(sql2, {
      types: typed,
      typed,
      unsafe,
      notify,
      array,
      json,
      file
    });
    return sql2;
    function typed(value, type) {
      return new Parameter(value, type);
    }
    function sql2(strings, ...args) {
      const query = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query;
    }
    function unsafe(string, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([string], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query = new Query([], args, (query2) => {
        import_fs.default.readFile(path, "utf8", (err2, string) => {
          if (err2)
            return query2.reject(err2);
          query2.strings = [string];
          handler2(query2);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql2 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l) => listen(name2, l.fn, l.onlisten).catch(() => {})));
        });
      },
      onnotify(c, x2) {
        c in listen.channels && listen.channels[c].listeners.forEach((l) => l.fn(x2));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists = name in channels;
    if (exists) {
      channels[name].listeners.push(listener);
      const result2 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result2.state, unlisten };
    }
    channels[name] = { result: sql2`listen ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x2) => x2 !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql2`unlisten ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue = queue_default();
    const c = open.length ? open.shift() : await new Promise((resolve2, reject) => {
      const query = { reserve: resolve2, reject };
      queries.push(query);
      closed.length && connect(closed.shift(), query);
    });
    move(c, reserved);
    c.reserved = () => queue.length ? c.execute(queue.shift()) : move(c, reserved);
    c.reserved.release = true;
    const sql2 = Sql(handler2);
    sql2.release = () => {
      c.reserved = null;
      onopen(c);
    };
    return sql2;
    function handler2(q) {
      c.queue === full ? queue.push(q) : c.execute(q) || move(c, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection2, prepare = null;
    try {
      await sql.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection2, fn),
        new Promise((_, reject) => connection2.onclose = reject)
      ]);
    } catch (error2) {
      throw error2;
    }
    async function scope(c, fn2, name) {
      const sql2 = Sql(handler2);
      sql2.savepoint = savepoint;
      sql2.prepare = (x2) => prepare = x2.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result;
      name && await sql2`savepoint ${sql2(name)}`;
      try {
        result = await new Promise((resolve2, reject) => {
          const x2 = fn2(sql2);
          Promise.resolve(Array.isArray(x2) ? Promise.all(x2) : x2).then(resolve2, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e) {
        await (name ? sql2`rollback to ${sql2(name)}` : sql2`rollback`);
        throw e instanceof PostgresError && e.code === "25P02" && uncaughtError || e;
      }
      if (!name) {
        prepare ? await sql2`prepare transaction '${sql2.unsafe(prepare)}'` : await sql2`commit`;
      }
      return result;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql3) => sql3.apply(sql3, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q) {
        q.catch((e) => uncaughtError || (uncaughtError = e));
        c.queue === full ? queries2.push(q) : c.execute(q) || move(c, full);
      }
    }
    function onexecute(c) {
      connection2 = c;
      move(c, reserved);
      c.reserved = () => queries2.length ? c.execute(queries2.shift()) : move(c, reserved);
    }
  }
  function move(c, queue) {
    c.queue.remove(c);
    queue.push(c);
    c.queue = queue;
    queue === open ? c.idleTimer.start() : c.idleTimer.cancel();
    return c;
  }
  function json(x2) {
    return new Parameter(x2, 3802);
  }
  function array(x2, type) {
    if (!Array.isArray(x2))
      return array(Array.from(arguments));
    return new Parameter(x2, type || (x2.length ? inferType(x2) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query) {
    if (ending)
      return query.reject(Errors.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query);
    if (closed.length)
      return connect(closed.shift(), query);
    busy.length ? go(busy.shift(), query) : queries.push(query);
  }
  function go(c, query) {
    return c.execute(query) ? move(c, busy) : move(c, full);
  }
  function cancel(query) {
    return new Promise((resolve2, reject) => {
      query.state ? query.active ? connection_default(options).cancel(query.state, resolve2, reject) : query.cancelled = { resolve: resolve2, reject } : (queries.remove(query), query.cancelled = true, query.reject(Errors.generic("57014", "canceling statement due to user request")), resolve2());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r))),
      Promise.all(connections.map((c) => c.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe.sql ? subscribe.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c) => c.end()));
  }
  async function destroy(resolve2) {
    await Promise.all(connections.map((c) => c.terminate()));
    while (queries.length)
      queries.shift().reject(Errors.connection("CONNECTION_DESTROYED", options));
    resolve2();
  }
  function connect(c, query) {
    move(c, connecting);
    c.connect(query);
    return c;
  }
  function onend(c) {
    move(c, ended);
  }
  function onopen(c) {
    if (queries.length === 0)
      return move(c, open);
    let max2 = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max2-- > 0) {
      const query = queries.shift();
      if (query.reserve)
        return query.reserve(c);
      ready = c.execute(query);
    }
    ready ? move(c, busy) : move(c, full);
  }
  function onclose(c, e) {
    move(c, closed);
    c.reserved = null;
    c.onclose && (c.onclose(e), c.onclose = null);
    options.onclose && options.onclose(c.id);
    queries.length && connect(c, queries.shift());
  }
}
function parseOptions(a, b2) {
  if (a && a.shared)
    return a;
  const env = process.env, o = (!a || typeof a === "string" ? b2 : a) || {}, { url, multihost } = parseUrl(a), query = [...url.searchParams].reduce((a2, [b3, c]) => (a2[b3] = c, a2), {}), host = o.hostname || o.host || multihost || url.hostname || env.PGHOST || "localhost", port = o.port || url.port || env.PGPORT || 5432, user = o.user || o.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o.no_prepare && (o.prepare = false);
  query.sslmode && (query.ssl = query.sslmode, delete query.sslmode);
  "timeout" in o && (console.log("The timeout option is deprecated, use idle_timeout instead"), o.idle_timeout = o.timeout);
  query.sslrootcert === "system" && (query.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x2) => x2.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x2) => parseInt(x2.split(":")[1] || port)),
    path: o.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o.database || o.db || (url.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o.pass || o.password || url.password || env.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k, d]) => {
      const value = k in o ? o[k] : (k in query) ? query[k] === "disable" || query[k] === "false" ? false : query[k] : env["PG" + k.toUpperCase()] || d;
      acc[k] = typeof value === "string" && ints.includes(k) ? +value : value;
      return acc;
    }, {}),
    connection: {
      application_name: env.PGAPPNAME || "postgres.js",
      ...o.connection,
      ...Object.entries(query).reduce((acc, [k, v]) => ((k in defaults) || (acc[k] = v), acc), {})
    },
    types: o.types || {},
    target_session_attrs: tsa(o, url, env),
    onnotice: o.onnotice,
    onnotify: o.onnotify,
    onclose: o.onclose,
    onparameter: o.onparameter,
    socket: o.socket,
    transform: parseTransform(o.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o.types)
  };
}
function tsa(o, url, env) {
  const x2 = o.target_session_attrs || url.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x2 || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x2))
    return x2;
  throw new Error("target_session_attrs " + x2 + " is not supported");
}
function backoff(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
}
function max_lifetime() {
  return 60 * (30 + Math.random() * 30);
}
function parseTransform(x2) {
  return {
    undefined: x2.undefined,
    column: {
      from: typeof x2.column === "function" ? x2.column : x2.column && x2.column.from,
      to: x2.column && x2.column.to
    },
    value: {
      from: typeof x2.value === "function" ? x2.value : x2.value && x2.value.from,
      to: x2.value && x2.value.to
    },
    row: {
      from: typeof x2.row === "function" ? x2.row : x2.row && x2.row.from,
      to: x2.row && x2.row.to
    }
  };
}
function parseUrl(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
}
function osUsername() {
  try {
    return import_os.default.userInfo().username;
  } catch (_) {
    return process.env.USERNAME || process.env.USER || process.env.LOGNAME;
  }
}
var import_os, import_fs, src_default;
var init_src = __esm(() => {
  init_types();
  init_connection();
  init_query();
  init_queue();
  init_errors();
  init_large();
  import_os = __toESM(require("os"));
  import_fs = __toESM(require("fs"));
  Object.assign(Postgres, {
    PostgresError,
    toPascal,
    pascal,
    toCamel,
    camel,
    toKebab,
    kebab,
    fromPascal,
    fromCamel,
    fromKebab,
    BigInt: {
      to: 20,
      from: [20],
      parse: (x2) => BigInt(x2),
      serialize: (x2) => x2.toString()
    }
  });
  src_default = Postgres;
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports2) => {
  exports2.parse = function(source, transform) {
    return new ArrayParser(source, transform).parse();
  };

  class ArrayParser {
    constructor(source, transform) {
      this.source = source;
      this.transform = transform || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char2 = this.nextCharacter();
          if (char2.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value) {
    return value;
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports2, module2) => {
  var array = require_postgres_array();
  module2.exports = {
    create: function(source, transform) {
      return {
        parse: function() {
          return array.parse(source, transform);
        }
      };
    }
  };
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports2, module2) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module2.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date2;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date2 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date2.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date2.setTime(date2.getTime() - offset);
      }
    } else {
      date2 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date2.setFullYear(year);
      }
    }
    return date2;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date2 = new Date(year, month, day);
    if (is0To99(year)) {
      date2.setFullYear(year);
    }
    return date2;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type = zone[1];
    if (type === "Z") {
      return 0;
    }
    var sign = type === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports2, module2) => {
  module2.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i2 = 1;i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports2, module2) => {
  var extend = require_mutable();
  module2.exports = PostgresInterval;
  function PostgresInterval(raw2) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw2);
    }
    extend(this, parse5(raw2));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse5(interval2) {
    if (!interval2)
      return {};
    var matches = INTERVAL.exec(interval2);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value = matches[position];
      if (!value)
        return parsed;
      value = property === "milliseconds" ? parseMilliseconds(value) : parseInt(value, 10);
      if (!value)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1;
      }
      parsed[property] = value;
      return parsed;
    }, {});
  }
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports2, module2) => {
  module2.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i2 = 0;
    while (i2 < input.length) {
      if (input[i2] !== "\\") {
        output += input[i2];
        ++i2;
      } else {
        if (/[0-7]{3}/.test(input.substr(i2 + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i2 + 1, 3), 8));
          i2 += 4;
        } else {
          var backslashes = 1;
          while (i2 + backslashes < input.length && input[i2 + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i2 += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports2, module2) => {
  var array = require_postgres_array();
  var arrayParser3 = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value) {
      if (value === null)
        return value;
      return fn(value);
    };
  }
  function parseBool(value) {
    if (value === null)
      return value;
    return value === "TRUE" || value === "t" || value === "true" || value === "y" || value === "yes" || value === "on" || value === "1";
  }
  function parseBoolArray(value) {
    if (!value)
      return null;
    return array.parse(value, parseBool);
  }
  function parseBaseTenInt(string) {
    return parseInt(string, 10);
  }
  function parseIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value) {
    if (!value)
      return null;
    return array.parse(value, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser3.create(value, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser3.create(value, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser3.create(value);
    return p.parse();
  };
  var parseDateArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser3.create(value, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value) {
    if (!value) {
      return null;
    }
    var p = arrayParser3.create(value, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(parseByteA));
  };
  var parseInteger = function(value) {
    return parseInt(value, 10);
  };
  var parseBigInteger = function(value) {
    var valStr = String(value);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value;
  };
  var parseJsonArray = function(value) {
    if (!value) {
      return null;
    }
    return array.parse(value, allowNull(JSON.parse));
  };
  var parsePoint = function(value) {
    if (value[0] !== "(") {
      return null;
    }
    value = value.substring(1, value.length - 1).split(",");
    return {
      x: parseFloat(value[0]),
      y: parseFloat(value[1])
    };
  };
  var parseCircle = function(value) {
    if (value[0] !== "<" && value[1] !== "(") {
      return null;
    }
    var point2 = "(";
    var radius = "";
    var pointParsed = false;
    for (var i2 = 2;i2 < value.length - 1; i2++) {
      if (!pointParsed) {
        point2 += value[i2];
      }
      if (value[i2] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value[i2] === ",") {
        continue;
      }
      radius += value[i2];
    }
    var result = parsePoint(point2);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module2.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports2, module2) => {
  var BASE = 1e6;
  function readInt8(buffer2) {
    var high = buffer2.readInt32BE(0);
    var low = buffer2.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t;
    var digits;
    var pad;
    var l;
    var i2;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i2 = 0;i2 < l; i2++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i2 = 0;i2 < l; i2++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t = 4294967296 * carry + low;
      low = t / BASE >>> 0;
      digits = "" + (t - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i2 = 0;i2 < l; i2++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t = 4294967296 * carry + low;
      digits = "" + t % BASE;
      return sign + digits + result;
    }
  }
  module2.exports = readInt8;
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports2, module2) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits2, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits3) {
      return lastValue * Math.pow(2, bits3) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value) {
      if (invert) {
        return ~value & 255;
      }
      return value;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits2 < firstBits) {
      mask = 255 << 8 - bits2 & 255;
      firstBits = bits2;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits2 >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits2 + offset >> 3;
    for (var i2 = offsetBytes + 1;i2 < bytes; i2++) {
      result = callback(result, inv(data[i2]), 8);
    }
    var lastBits = (bits2 + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits2) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i2 = 1;i2 <= bits2; i2++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits2 - i2) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 15, 1, true) + 1);
    }
    return parseBits(value, 15, 1);
  };
  var parseInt32 = function(value) {
    if (parseBits(value, 1) == 1) {
      return -1 * (parseBits(value, 31, 1, true) + 1);
    }
    return parseBits(value, 31, 1);
  };
  var parseFloat32 = function(value) {
    return parseFloatFromBits(value, 23, 8);
  };
  var parseFloat64 = function(value) {
    return parseFloatFromBits(value, 52, 11);
  };
  var parseNumeric = function(value) {
    var sign = parseBits(value, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value, 16);
    for (var i2 = 0;i2 < ndigits; i2++) {
      result += parseBits(value, 16, 64 + 16 * i2) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value) {
    var sign = parseBits(value, 1);
    var rawValue = parseBits(value, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value2) {
      this.usec = value2;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value) {
    var dim = parseBits(value, 32);
    var flags = parseBits(value, 32, 32);
    var elementType = parseBits(value, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i2 = 0;i2 < dim; i2++) {
      dims[i2] = parseBits(value, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse5 = function(dimension, elementType2) {
      var array = [];
      var i3;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i3 = 0;i3 < count; i3++) {
          array[i3] = parse5(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i3 = 0;i3 < dimension[0]; i3++) {
          array[i3] = parseElement(elementType2);
        }
      }
      return array;
    };
    return parse5(dims, elementType);
  };
  var parseText = function(value) {
    return value.toString("utf8");
  };
  var parseBool = function(value) {
    if (value === null)
      return null;
    return parseBits(value, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module2.exports = {
    init
  };
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports2, module2) => {
  module2.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports2) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser3 = require_arrayParser();
  var builtinTypes = require_builtins();
  exports2.getTypeParser = getTypeParser;
  exports2.setTypeParser = setTypeParser;
  exports2.arrayParser = arrayParser3;
  exports2.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports2, module2) => {
  module2.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module2.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils2 = __commonJS((exports2, module2) => {
  var defaults = require_defaults();
  var util3 = require("util");
  var { isDate } = util3.types || util3;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i2 = 0;i2 < val.length; i2++) {
      if (i2 > 0) {
        result = result + ",";
      }
      if (val[i2] === null || typeof val[i2] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i2])) {
        result = result + arrayString(val[i2]);
      } else if (ArrayBuffer.isView(val[i2])) {
        let item = val[i2];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i2]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date2) {
    let offset = -date2.getTimezoneOffset();
    let year = date2.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date2.getMonth() + 1).padStart(2, "0") + "-" + String(date2.getDate()).padStart(2, "0") + "T" + String(date2.getHours()).padStart(2, "0") + ":" + String(date2.getMinutes()).padStart(2, "0") + ":" + String(date2.getSeconds()).padStart(2, "0") + "." + String(date2.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date2) {
    let year = date2.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date2.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date2.getUTCDate()).padStart(2, "0") + "T" + String(date2.getUTCHours()).padStart(2, "0") + ":" + String(date2.getUTCMinutes()).padStart(2, "0") + ":" + String(date2.getUTCSeconds()).padStart(2, "0") + "." + String(date2.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values2, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values2) {
      if (typeof values2 === "function") {
        config.callback = values2;
      } else {
        config.values = values2;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier2 = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i2 = 0;i2 < str.length; i2++) {
      const c = str[i2];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module2.exports = {
    prepareValue: function prepareValueWrapper(value) {
      return prepareValue(value);
    },
    normalizeQueryConfig,
    escapeIdentifier: escapeIdentifier2,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports2, module2) => {
  var nodeCrypto = require("crypto");
  function md52(string) {
    return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md52(password + user);
    const outer = md52(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha2563(text2) {
    return nodeCrypto.createHash("sha256").update(text2).digest();
  }
  function hashByName(hashName, text2) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text2).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module2.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256: sha2563,
    hashByName,
    hmacSha256,
    md5: md52
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports2, module2) => {
  var nodeCrypto = require("crypto");
  module2.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256: sha2563,
    hashByName,
    hmacSha256,
    md5: md52
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md52(string) {
    try {
      return nodeCrypto.createHash("md5").update(string, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string === "string" ? textEncoder.encode(string) : string;
      const hash = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash)).map((b2) => b2.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md52(password + user);
    const outer = await md52(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha2563(text2) {
    return await subtleCrypto.digest("SHA-256", text2);
  }
  async function hashByName(hashName, text2) {
    return await subtleCrypto.digest(hashName, text2);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils3 = __commonJS((exports2, module2) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module2.exports = require_utils_legacy();
  } else {
    module2.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports2, module2) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i2 = 0;i2 < lengthBytes; i2++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value = value << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module2.exports = { signatureAlgorithmHashFromCertificate };
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports2, module2) => {
  var crypto3 = require_utils3();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto3.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto3.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto3.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto3.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto3.sha256(clientKey);
    const clientSignature = await crypto3.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto3.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto3.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text2.split("").map((_, i2) => text2.charCodeAt(i2)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text2) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text2);
  }
  function parseAttributePairs(text2) {
    if (typeof text2 !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text2.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value = attrValue.substring(2);
      return [name, value];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b2) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b2)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b2.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i2) => a[i2] ^ b2[i2]));
  }
  module2.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports2, module2) => {
  var types4 = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types4;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module2.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports2, module2) => {
  function parse5(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err2) {
      err2.input && (err2.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs2 = config.sslcert || config.sslkey || config.sslrootcert ? require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs2.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs2.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs2.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config.sslrootcert) {
            config.ssl.checkServerIdentity = function() {};
          } else {
            config.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value]) => {
      if (value !== undefined && value !== null) {
        c[key] = value;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value]) => {
      if (key === "ssl") {
        const sslConfig = value;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value !== undefined && value !== null) {
        if (key === "port") {
          if (value !== "") {
            const v = parseInt(value, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse5(str));
  }
  module2.exports = parse5;
  parse5.parse = parse5;
  parse5.toClientConfig = toClientConfig;
  parse5.parseIntoClientConfig = parseIntoClientConfig;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports2, module2) => {
  var dns = require("dns");
  var defaults = require_defaults();
  var parse5 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value) {
    return "'" + ("" + value).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    const value = config[paramName];
    if (value !== undefined && value !== null) {
      params.push(paramName + "=" + quoteParamValue(value));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse5(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse5(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err2, address) {
        if (err2)
          return cb(err2, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module2.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports2, module2) => {
  var types4 = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result2 {
    constructor(rowMode, types5) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types5;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match2;
      if (msg.text) {
        match2 = matchRegexp.exec(msg.text);
      } else {
        match2 = matchRegexp.exec(msg.command);
      }
      if (match2) {
        this.command = match2[1];
        if (match2[3]) {
          this.oid = parseInt(match2[2], 10);
          this.rowCount = parseInt(match2[3], 10);
        } else if (match2[2]) {
          this.rowCount = parseInt(match2[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i2 = 0, len = rowData.length;i2 < len; i2++) {
        const rawValue = rowData[i2];
        if (rawValue !== null) {
          row[i2] = this._parsers[i2](rawValue);
        } else {
          row[i2] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i2 = 0, len = rowData.length;i2 < len; i2++) {
        const rawValue = rowData[i2];
        const field = this.fields[i2].name;
        if (rawValue !== null) {
          const v = this.fields[i2].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i2](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i2 = 0;i2 < fieldDescriptions.length; i2++) {
        const desc2 = fieldDescriptions[i2];
        row[desc2.name] = null;
        if (this._types) {
          this._parsers[i2] = this._types.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        } else {
          this._parsers[i2] = types4.getTypeParser(desc2.dataTypeID, desc2.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module2.exports = Result2;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports2, module2) => {
  var { EventEmitter } = require("events");
  var Result2 = require_result();
  var utils = require_utils2();

  class Query2 extends EventEmitter {
    constructor(config, values2, callback) {
      super();
      config = utils.normalizeQueryConfig(config, values2, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result2(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result2(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err2) {
        this._canceledDueToError = err2;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection2) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection2.sync();
      }
    }
    handleEmptyQuery(connection2) {
      if (this.rows) {
        connection2.sync();
      }
    }
    handleError(err2, connection2) {
      if (this._canceledDueToError) {
        err2 = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err2);
      }
      this.emit("error", err2);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err2) {
          process.nextTick(() => {
            throw err2;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection2) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection2.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection2.stream.cork && connection2.stream.cork();
        try {
          this.prepare(connection2);
        } finally {
          connection2.stream.uncork && connection2.stream.uncork();
        }
      } else {
        connection2.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection2) {
      return this.name && connection2.parsedStatements[this.name];
    }
    handlePortalSuspended(connection2) {
      this._getRows(connection2, this.rows);
    }
    _getRows(connection2, rows) {
      connection2.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection2.sync();
      } else {
        connection2.flush();
      }
    }
    prepare(connection2) {
      if (!this.hasBeenParsed(connection2)) {
        connection2.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection2.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err2) {
        this.handleError(err2, connection2);
        return;
      }
      connection2.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection2, this.rows);
    }
    handleCopyInResponse(connection2) {
      connection2.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection2) {}
  }
  module2.exports = Query2;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.NoticeMessage = exports2.DataRowMessage = exports2.CommandCompleteMessage = exports2.ReadyForQueryMessage = exports2.NotificationResponseMessage = exports2.BackendKeyDataMessage = exports2.AuthenticationMD5Password = exports2.ParameterStatusMessage = exports2.ParameterDescriptionMessage = exports2.RowDescriptionMessage = exports2.Field = exports2.CopyResponse = exports2.CopyDataMessage = exports2.DatabaseError = exports2.copyDone = exports2.emptyQuery = exports2.replicationStart = exports2.portalSuspended = exports2.noData = exports2.closeComplete = exports2.bindComplete = exports2.parseComplete = undefined;
  exports2.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports2.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports2.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports2.noData = {
    name: "noData",
    length: 5
  };
  exports2.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports2.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports2.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports2.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports2.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports2.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports2.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports2.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports2.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports2.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports2.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports2.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports2.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports2.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports2.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text2) {
      this.length = length;
      this.text = text2;
      this.name = "commandComplete";
    }
  }
  exports2.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports2.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports2.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Writer = undefined;

  class Writer {
    constructor(size2 = 256) {
      this.size = size2;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size2);
    }
    ensure(size2) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size2) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size2;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string) {
      if (!string) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string);
        this.ensure(len + 1);
        this.buffer.write(string, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string = "") {
      const len = Buffer.byteLength(string);
      this.ensure(len);
      this.buffer.write(string, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports2.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text2) => {
    return writer.addCString(text2).flush(81);
  };
  var emptyArray = [];
  var parse5 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types4 = query2.types || emptyArray;
    const len = types4.length;
    const buffer2 = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i2 = 0;i2 < len; i2++) {
      buffer2.addInt32(types4[i2]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values2, valueMapper) {
    for (let i2 = 0;i2 < values2.length; i2++) {
      const mappedVal = valueMapper ? valueMapper(values2[i2], i2) : values2[i2];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values2 = config.values || emptyArray;
    const len = values2.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values2, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer2 = Buffer.allocUnsafe(16);
    buffer2.writeInt32BE(16, 0);
    buffer2.writeInt16BE(1234, 4);
    buffer2.writeInt16BE(5678, 6);
    buffer2.writeInt32BE(processID, 8);
    buffer2.writeInt32BE(secretKey, 12);
    return buffer2;
  };
  var cstringMessage = (code, string) => {
    const stringLen = Buffer.byteLength(string);
    const len = 4 + stringLen + 1;
    const buffer2 = Buffer.allocUnsafe(1 + len);
    buffer2[0] = code;
    buffer2.writeInt32BE(len, 1);
    buffer2.write(string, 5, "utf-8");
    buffer2[len] = 0;
    return buffer2;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text2 = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text2);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize3 = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse5,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports2.serialize = serialize3;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer2) {
      this.offset = offset;
      this.buffer = buffer2;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports2.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer2, callback) {
      this.mergeBuffer(buffer2);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer2) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer2.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer2.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer2;
        this.bufferOffset = 0;
        this.bufferLength = buffer2.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text2 = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text2);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i2 = 0;i2 < columnCount; i2++) {
        message.columnTypes[i2] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i2 = 0;i2 < fieldCount; i2++) {
        message.fields[i2] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i2 = 0;i2 < parameterCount; i2++) {
        message.dataTypeIDs[i2] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i2 = 0;i2 < fieldCount; i2++) {
        const len = this.reader.int32();
        fields[i2] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports2.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.DatabaseError = exports2.serialize = exports2.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports2, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports2, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse5(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer2) => parser.parse(buffer2, callback));
    return new Promise((resolve2) => stream.on("end", () => resolve2()));
  }
  exports2.parse = parse5;
});

// node_modules/pg-cloudflare/dist/empty.js
var require_empty2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2.default = {};
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports2, module2) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module2.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net2 = require("net");
      return new net2.Socket;
    }
    function getSecureStream2(options) {
      const tls2 = require("tls");
      return tls2.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty2();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports2, module2) => {
  var EventEmitter = require("events").EventEmitter;
  var { parse: parse5, serialize: serialize3 } = require_dist4();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize3.flush();
  var syncBuffer = serialize3.sync();
  var endBuffer = serialize3.end();

  class Connection2 extends EventEmitter {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self._keepAlive) {
          self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);
        }
        self.emit("connect");
      });
      const reportStreamError = function(error2) {
        if (self._ending && (error2.code === "ECONNRESET" || error2.code === "EPIPE")) {
          return;
        }
        self.emit("error", error2);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer2) {
        const responseCode = buffer2.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self.stream.end();
            return self.emit("error", new Error("The server does not support SSL connections"));
          default:
            self.stream.end();
            return self.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self.stream
        };
        if (self.ssl !== true) {
          Object.assign(options, self.ssl);
          if ("key" in self.ssl) {
            options.key = self.ssl.key;
          }
        }
        const net2 = require("net");
        if (net2.isIP && net2.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self.stream = getSecureStream(options);
        } catch (err2) {
          return self.emit("error", err2);
        }
        self.attachListeners(self.stream);
        self.stream.on("error", reportStreamError);
        self.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse5(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize3.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize3.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize3.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize3.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize3.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize3.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer2) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer2);
    }
    query(text2) {
      this._send(serialize3.query(text2));
    }
    parse(query) {
      this._send(serialize3.parse(query));
    }
    bind(config) {
      this._send(serialize3.bind(config));
    }
    execute(config) {
      this._send(serialize3.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize3.close(msg));
    }
    describe(msg) {
      this._send(serialize3.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize3.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize3.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize3.copyFail(msg));
    }
  }
  module2.exports = Connection2;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports2, module2) => {
  var { Transform } = require("stream");
  var { StringDecoder } = require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i2 = 0;i2 < list.length; i2++) {
      try {
        push(this, this.mapper(list[i2]));
      } catch (error2) {
        return cb(error2);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error2) {
        return cb(error2);
      }
    }
    cb();
  }
  function push(self, val) {
    if (val !== undefined) {
      self.push(val);
    }
  }
  function noop3(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop3;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop3;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err2, cb) {
      this._writableState.errorEmitted = false;
      cb(err2);
    };
    return stream;
  }
  module2.exports = split;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports2, module2) => {
  var path = require("path");
  var Stream3 = require("stream").Stream;
  var split = require_split2();
  var util3 = require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream3 && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util3.format.apply(util3, args));
    }
  }
  Object.defineProperty(module2.exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  module2.exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  module2.exports.getFileName = function(rawEnv) {
    var env = rawEnv || process.env;
    var file = env.PGPASSFILE || (isWin ? path.join(env.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env.HOME || "./", ".pgpass"));
    return file;
  };
  module2.exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = module2.exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  module2.exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line2) {
      var entry = parseLine(line2);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err2) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err2);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = module2.exports.parseLine = function(line2) {
    if (line2.length < 11 || line2.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line2.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i2 = 0;i2 < line2.length - 1; i2 += 1) {
      curChar = line2.charAt(i2 + 1);
      prevChar = line2.charAt(i2);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i2 >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i2 + 1);
        startIdx = i2 + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = module2.exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x2) {
        return x2.length > 0;
      },
      1: function(x2) {
        if (x2 === "*") {
          return true;
        }
        x2 = Number(x2);
        return isFinite(x2) && x2 > 0 && x2 < 9007199254740992 && Math.floor(x2) === x2;
      },
      2: function(x2) {
        return x2.length > 0;
      },
      3: function(x2) {
        return x2.length > 0;
      },
      4: function(x2) {
        return x2.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value = entry[fieldNames[idx]] || "";
      var res = rule(value);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  var path = require("path");
  var fs2 = require("fs");
  var helper = require_helper();
  module2.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs2.stat(file, function(err2, stat) {
      if (err2 || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs2.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module2.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports2, module2) => {
  var EventEmitter = require("events").EventEmitter;
  var utils = require_utils2();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query2 = require_query();
  var defaults = require_defaults();
  var Connection2 = require_connection();
  var crypto3 = require_utils3();

  class Client extends EventEmitter {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection2({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err2) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err2, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err2 = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err2);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self.ssl) {
          con.requestSsl();
        } else {
          con.startup(self.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error2);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error2);
            } else {
              this._handleErrorEvent(error2);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error2);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve2, reject) => {
        this._connect((error2) => {
          if (error2) {
            reject(error2);
          } else {
            resolve2();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err2) => {
          con.emit("error", err2);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto3.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err2) {
          this.connection.emit("error", err2);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err2) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err2);
      }
      this.emit("error", err2);
    }
    _handleErrorEvent(err2) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err2);
      }
      this._queryable = false;
      this._errorAllQueries(err2);
      this.emit("error", err2);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values2, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values2 === "function") {
          query.callback = query.callback || values2;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new Query2(config, values2, callback);
        if (!query.callback) {
          result = new this._Promise((resolve2, reject) => {
            query.callback = (err2, res) => err2 ? reject(err2) : resolve2(res);
          }).catch((err2) => {
            Error.captureStackTrace(err2);
            throw err2;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error2 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error2, this.connection);
          });
          queryCallback(error2);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err2, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err2, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve2) => {
          this.connection.once("end", resolve2);
        });
      }
    }
  }
  Client.Query = Query2;
  module2.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports2, module2) => {
  var EventEmitter = require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i2 = list.findIndex(predicate);
    return i2 === -1 ? undefined : list.splice(i2, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise2, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err2, client) {
      err2 ? rej(err2) : res(client);
    };
    const result = new Promise2(function(resolve2, reject) {
      res = resolve2;
      rej = reject;
    }).catch((err2) => {
      Error.captureStackTrace(err2);
      throw err2;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err2) {
      err2.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err2);
      });
      pool._remove(client);
      pool.emit("error", err2, client);
    };
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err2 = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err2, res, done) => {
          clearTimeout(tid);
          response.callback(err2, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i2) => i2.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err2) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err2) {
          this.log("client failed to connect", err2);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err2 = new Error("Connection terminated due to connection timeout", { cause: err2 });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err2, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err3, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err2) => {
            if (err2) {
              client.release(err2);
              return pendingItem.callback(err2, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err2) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err2);
      };
    }
    _release(client, idleListener, err2) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err2, client);
      if (err2 || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text2, values2, cb) {
      if (typeof text2 === "function") {
        const response2 = promisify(this.Promise, text2);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values2 === "function") {
        cb = values2;
        values2 = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err2, client) => {
        if (err2) {
          return cb(err2);
        }
        let clientReleased = false;
        const onError = (err3) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err3);
          cb(err3);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text2, values2, (err3, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err3);
            if (err3) {
              return cb(err3);
            }
            return cb(undefined, res);
          });
        } catch (err3) {
          client.release(err3);
          return cb(err3);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err2 = new Error("Called end on pool more than once");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module2.exports = Pool;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports2, module2) => {
  var EventEmitter = require("events").EventEmitter;
  var util3 = require("util");
  var utils = require_utils2();
  var NativeQuery = module2.exports = function(config, values2, callback) {
    EventEmitter.call(this);
    config = utils.normalizeQueryConfig(config, values2, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event2) {
      if (event2 === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util3.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err2) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err2[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err2);
    } else {
      this.emit("error", err2);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve2, reject) {
      this._once("end", resolve2);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err2, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self.emit("_done");
      });
      if (err2) {
        return self.handleError(err2);
      }
      if (self._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i2) => {
            rowOfRows.forEach((row) => {
              self.emit("row", row, results[i2]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self.emit("row", row, results);
          });
        }
      }
      self.state = "end";
      self.emit("end", results);
      if (self.callback) {
        self.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values2 = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err2);
        }
        return client.native.execute(this.name, values2, after);
      }
      return client.native.prepare(this.name, this.text, values2.length, function(err2) {
        if (err2)
          return after(err2);
        client.namedQueries[self.name] = self.text;
        return self.native.execute(self.name, values2, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err2 = new Error("Query values must be an array");
        return after(err2);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports2, module2) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = require("events").EventEmitter;
  var util3 = require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module2.exports = function(config) {
    EventEmitter.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util3.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err2) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err2);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err2, conString) {
      if (self.connectionParameters.nativeConnectionString)
        conString = self.connectionParameters.nativeConnectionString;
      if (err2)
        return cb(err2);
      self.native.connect(conString, function(err3) {
        if (err3) {
          self.native.end();
          return cb(err3);
        }
        self._connected = true;
        self.native.on("error", function(err4) {
          self._queryable = false;
          self._errorAllQueries(err4);
          self.emit("error", err4);
        });
        self.native.on("notification", function(msg) {
          self.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self.emit("connect");
        self._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve2, reject) => {
      this._connect((error2) => {
        if (error2) {
          reject(error2);
        } else {
          resolve2();
        }
      });
    });
  };
  Client.prototype.query = function(config, values2, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query = config;
      if (typeof values2 === "function") {
        config.callback = values2;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config, values2, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve2, reject) => {
          resolveOut = resolve2;
          rejectOut = reject;
        }).catch((err2) => {
          Error.captureStackTrace(err2);
          throw err2;
        });
        query.callback = (err2, res) => err2 ? rejectOut(err2) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error2 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error2, this.connection);
        });
        queryCallback(error2);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err2, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err2, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve2, reject) {
        cb = (err2) => err2 ? reject(err2) : resolve2();
      });
    }
    this.native.end(function() {
      self._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self = this;
    query.once("_done", function() {
      self._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// node_modules/pg/lib/native/index.js
var require_native = __commonJS((exports2, module2) => {
  module2.exports = require_client2();
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection2 = require_connection();
  var Result2 = require_result();
  var utils = require_utils2();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist4();
  var { escapeIdentifier: escapeIdentifier2, escapeLiteral } = require_utils2();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection2;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier2;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result2;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module2.exports = new PG(require_native());
  } else {
    module2.exports = new PG(Client);
    Object.defineProperty(module2.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_native());
        } catch (err2) {
          if (err2.code !== "MODULE_NOT_FOUND") {
            throw err2;
          }
        }
        Object.defineProperty(module2.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS((exports2, module2) => {
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  module2.exports = _interopRequireDefault, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports2, module2) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return module2.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _typeof(o);
  }
  module2.exports = _typeof, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/date-fns/_lib/toInteger/index.js
var require_toInteger = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = toInteger;
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = requiredArgs;
  function requiredArgs(required, args) {
    if (args.length < required) {
      throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = toDate;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function toDate(argument) {
    (0, _index.default)(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || (0, _typeof2.default)(argument) === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addDays/index.js
var require_addDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addDays;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addDays(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var amount = (0, _index.default)(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date2;
    }
    date2.setDate(date2.getDate() + amount);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addMonths/index.js
var require_addMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addMonths;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addMonths(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var amount = (0, _index.default)(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date2;
    }
    var dayOfMonth = date2.getDate();
    var endOfDesiredMonth = new Date(date2.getTime());
    endOfDesiredMonth.setMonth(date2.getMonth() + amount + 1, 0);
    var daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      date2.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
      return date2;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/add/index.js
var require_add = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = add;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_toInteger());
  function add(dirtyDate, duration) {
    (0, _index4.default)(2, arguments);
    if (!duration || (0, _typeof2.default)(duration) !== "object")
      return new Date(NaN);
    var years = duration.years ? (0, _index5.default)(duration.years) : 0;
    var months = duration.months ? (0, _index5.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _index5.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _index5.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _index5.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _index5.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _index5.default)(duration.seconds) : 0;
    var date2 = (0, _index3.default)(dirtyDate);
    var dateWithMonths = months || years ? (0, _index2.default)(date2, months + years * 12) : date2;
    var dateWithDays = days || weeks ? (0, _index.default)(dateWithMonths, days + weeks * 7) : dateWithMonths;
    var minutesToAdd = minutes + hours * 60;
    var secondsToAdd = seconds + minutesToAdd * 60;
    var msToAdd = secondsToAdd * 1000;
    var finalDate = new Date(dateWithDays.getTime() + msToAdd);
    return finalDate;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isWeekend/index.js
var require_isWeekend = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isWeekend;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWeekend(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getDay();
    return day === 0 || day === 6;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSunday/index.js
var require_isSunday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSunday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSunday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 0;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSaturday/index.js
var require_isSaturday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSaturday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSaturday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 6;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addBusinessDays/index.js
var require_addBusinessDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addBusinessDays;
  var _index = _interopRequireDefault(require_isWeekend());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_isSunday());
  var _index6 = _interopRequireDefault(require_isSaturday());
  function addBusinessDays(dirtyDate, dirtyAmount) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var startedOnWeekend = (0, _index.default)(date2);
    var amount = (0, _index3.default)(dirtyAmount);
    if (isNaN(amount))
      return new Date(NaN);
    var hours = date2.getHours();
    var sign = amount < 0 ? -1 : 1;
    var fullWeeks = (0, _index3.default)(amount / 5);
    date2.setDate(date2.getDate() + fullWeeks * 7);
    var restDays = Math.abs(amount % 5);
    while (restDays > 0) {
      date2.setDate(date2.getDate() + sign);
      if (!(0, _index.default)(date2))
        restDays -= 1;
    }
    if (startedOnWeekend && (0, _index.default)(date2) && amount !== 0) {
      if ((0, _index6.default)(date2))
        date2.setDate(date2.getDate() + (sign < 0 ? 2 : -1));
      if ((0, _index5.default)(date2))
        date2.setDate(date2.getDate() + (sign < 0 ? 1 : -2));
    }
    date2.setHours(hours);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addMilliseconds/index.js
var require_addMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addMilliseconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addMilliseconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var timestamp2 = (0, _index2.default)(dirtyDate).getTime();
    var amount = (0, _index.default)(dirtyAmount);
    return new Date(timestamp2 + amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addHours/index.js
var require_addHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addHours;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_HOUR = 3600000;
  function addHours(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_HOUR);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/defaultOptions/index.js
var require_defaultOptions = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.getDefaultOptions = getDefaultOptions;
  exports2.setDefaultOptions = setDefaultOptions;
  var defaultOptions2 = {};
  function getDefaultOptions() {
    return defaultOptions2;
  }
  function setDefaultOptions(newOptions) {
    defaultOptions2 = newOptions;
  }
});

// node_modules/date-fns/startOfWeek/index.js
var require_startOfWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_defaultOptions();
  function startOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index3.default)(1, arguments);
    var defaultOptions2 = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date2.setDate(date2.getDate() - diff);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfISOWeek/index.js
var require_startOfISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfISOWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getISOWeekYear/index.js
var require_getISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getISOWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function getISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index2.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index2.default)(fourthOfJanuaryOfThisYear);
    if (date2.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date2.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfISOWeekYear/index.js
var require_startOfISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function startOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date2 = (0, _index2.default)(fourthOfJanuary);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js
var require_getTimezoneOffsetInMilliseconds = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getTimezoneOffsetInMilliseconds;
  function getTimezoneOffsetInMilliseconds(date2) {
    var utcDate = new Date(Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), date2.getMinutes(), date2.getSeconds(), date2.getMilliseconds()));
    utcDate.setUTCFullYear(date2.getFullYear());
    return date2.getTime() - utcDate.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfDay/index.js
var require_startOfDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarDays/index.js
var require_differenceInCalendarDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarDays;
  var _index = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index2 = _interopRequireDefault(require_startOfDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 86400000;
  function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var startOfDayLeft = (0, _index2.default)(dirtyDateLeft);
    var startOfDayRight = (0, _index2.default)(dirtyDateRight);
    var timestampLeft = startOfDayLeft.getTime() - (0, _index.default)(startOfDayLeft);
    var timestampRight = startOfDayRight.getTime() - (0, _index.default)(startOfDayRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setISOWeekYear/index.js
var require_setISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setISOWeekYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index4 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
    (0, _index5.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var isoWeekYear = (0, _index.default)(dirtyISOWeekYear);
    var diff = (0, _index4.default)(date2, (0, _index3.default)(date2));
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(isoWeekYear, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    date2 = (0, _index3.default)(fourthOfJanuary);
    date2.setDate(date2.getDate() + diff);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addISOWeekYears/index.js
var require_addISOWeekYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addISOWeekYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_getISOWeekYear());
  var _index3 = _interopRequireDefault(require_setISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function addISOWeekYears(dirtyDate, dirtyAmount) {
    (0, _index4.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index3.default)(dirtyDate, (0, _index2.default)(dirtyDate) + amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addMinutes/index.js
var require_addMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addMinutes;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_MINUTE = 60000;
  function addMinutes(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addQuarters/index.js
var require_addQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addQuarters;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addQuarters(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    var months = amount * 3;
    return (0, _index2.default)(dirtyDate, months);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addSeconds/index.js
var require_addSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addSeconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * 1000);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addWeeks/index.js
var require_addWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addWeeks;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addWeeks(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    var days = amount * 7;
    return (0, _index2.default)(dirtyDate, days);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/addYears/index.js
var require_addYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addYears(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * 12);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/areIntervalsOverlapping/index.js
var require_areIntervalsOverlapping = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = areIntervalsOverlapping;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
    (0, _index2.default)(2, arguments);
    var leftStartTime = (0, _index.default)(intervalLeft === null || intervalLeft === undefined ? undefined : intervalLeft.start).getTime();
    var leftEndTime = (0, _index.default)(intervalLeft === null || intervalLeft === undefined ? undefined : intervalLeft.end).getTime();
    var rightStartTime = (0, _index.default)(intervalRight === null || intervalRight === undefined ? undefined : intervalRight.start).getTime();
    var rightEndTime = (0, _index.default)(intervalRight === null || intervalRight === undefined ? undefined : intervalRight.end).getTime();
    if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
      throw new RangeError("Invalid interval");
    }
    if (options !== null && options !== undefined && options.inclusive) {
      return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
    }
    return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/max/index.js
var require_max2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = max3;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function max3(dirtyDatesArray) {
    (0, _index2.default)(1, arguments);
    var datesArray;
    if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else if ((0, _typeof2.default)(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    } else {
      return new Date(NaN);
    }
    var result;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (result === undefined || result < currentDate || isNaN(Number(currentDate))) {
        result = currentDate;
      }
    });
    return result || new Date(NaN);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/min/index.js
var require_min2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = min;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function min(dirtyDatesArray) {
    (0, _index2.default)(1, arguments);
    var datesArray;
    if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else if ((0, _typeof2.default)(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    } else {
      return new Date(NaN);
    }
    var result;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (result === undefined || result > currentDate || isNaN(currentDate.getDate())) {
        result = currentDate;
      }
    });
    return result || new Date(NaN);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/clamp/index.js
var require_clamp = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = clamp;
  var _index = _interopRequireDefault(require_max2());
  var _index2 = _interopRequireDefault(require_min2());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function clamp(date2, _ref) {
    var { start, end } = _ref;
    (0, _index3.default)(2, arguments);
    return (0, _index2.default)([(0, _index.default)([date2, start]), end]);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/closestIndexTo/index.js
var require_closestIndexTo = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = closestIndexTo;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
    (0, _index2.default)(2, arguments);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    if (isNaN(Number(dateToCompare)))
      return NaN;
    var timeToCompare = dateToCompare.getTime();
    var datesArray;
    if (dirtyDatesArray == null) {
      datesArray = [];
    } else if (typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    }
    var result;
    var minDistance;
    datesArray.forEach(function(dirtyDate, index) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (isNaN(Number(currentDate))) {
        result = NaN;
        minDistance = NaN;
        return;
      }
      var distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < Number(minDistance)) {
        result = index;
        minDistance = distance;
      }
    });
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/closestTo/index.js
var require_closestTo = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = closestTo;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function closestTo(dirtyDateToCompare, dirtyDatesArray) {
    (0, _index2.default)(2, arguments);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    if (isNaN(Number(dateToCompare)))
      return new Date(NaN);
    var timeToCompare = dateToCompare.getTime();
    var datesArray;
    if (dirtyDatesArray == null) {
      datesArray = [];
    } else if (typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    }
    var result;
    var minDistance;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (isNaN(Number(currentDate))) {
        result = new Date(NaN);
        minDistance = NaN;
        return;
      }
      var distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < Number(minDistance)) {
        result = currentDate;
        minDistance = distance;
      }
    });
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/compareAsc/index.js
var require_compareAsc = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = compareAsc;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/compareDesc/index.js
var require_compareDesc = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = compareDesc;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function compareDesc(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff > 0) {
      return -1;
    } else if (diff < 0) {
      return 1;
    } else {
      return diff;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/constants/index.js
var require_constants2 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.secondsInYear = exports2.secondsInWeek = exports2.secondsInQuarter = exports2.secondsInMonth = exports2.secondsInMinute = exports2.secondsInHour = exports2.secondsInDay = exports2.quartersInYear = exports2.monthsInYear = exports2.monthsInQuarter = exports2.minutesInHour = exports2.minTime = exports2.millisecondsInSecond = exports2.millisecondsInMinute = exports2.millisecondsInHour = exports2.maxTime = exports2.daysInYear = exports2.daysInWeek = undefined;
  var daysInWeek = 7;
  exports2.daysInWeek = daysInWeek;
  var daysInYear = 365.2425;
  exports2.daysInYear = daysInYear;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
  exports2.maxTime = maxTime;
  var millisecondsInMinute = 60000;
  exports2.millisecondsInMinute = millisecondsInMinute;
  var millisecondsInHour = 3600000;
  exports2.millisecondsInHour = millisecondsInHour;
  var millisecondsInSecond = 1000;
  exports2.millisecondsInSecond = millisecondsInSecond;
  var minTime = -maxTime;
  exports2.minTime = minTime;
  var minutesInHour = 60;
  exports2.minutesInHour = minutesInHour;
  var monthsInQuarter = 3;
  exports2.monthsInQuarter = monthsInQuarter;
  var monthsInYear = 12;
  exports2.monthsInYear = monthsInYear;
  var quartersInYear = 4;
  exports2.quartersInYear = quartersInYear;
  var secondsInHour = 3600;
  exports2.secondsInHour = secondsInHour;
  var secondsInMinute = 60;
  exports2.secondsInMinute = secondsInMinute;
  var secondsInDay = secondsInHour * 24;
  exports2.secondsInDay = secondsInDay;
  var secondsInWeek = secondsInDay * 7;
  exports2.secondsInWeek = secondsInWeek;
  var secondsInYear = secondsInDay * daysInYear;
  exports2.secondsInYear = secondsInYear;
  var secondsInMonth = secondsInYear / 12;
  exports2.secondsInMonth = secondsInMonth;
  var secondsInQuarter = secondsInMonth * 3;
  exports2.secondsInQuarter = secondsInQuarter;
});

// node_modules/date-fns/daysToWeeks/index.js
var require_daysToWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = daysToWeeks;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function daysToWeeks(days) {
    (0, _index.default)(1, arguments);
    var weeks = days / _index2.daysInWeek;
    return Math.floor(weeks);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameDay/index.js
var require_isSameDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameDay;
  var _index = _interopRequireDefault(require_startOfDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameDay(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfDay = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfDay = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isDate/index.js
var require_isDate2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isDate;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function isDate(value) {
    (0, _index.default)(1, arguments);
    return value instanceof Date || (0, _typeof2.default)(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isValid/index.js
var require_isValid = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isValid2;
  var _index = _interopRequireDefault(require_isDate2());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isValid2(dirtyDate) {
    (0, _index3.default)(1, arguments);
    if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== "number") {
      return false;
    }
    var date2 = (0, _index2.default)(dirtyDate);
    return !isNaN(Number(date2));
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInBusinessDays/index.js
var require_differenceInBusinessDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInBusinessDays;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_isSameDay());
  var _index4 = _interopRequireDefault(require_isValid());
  var _index5 = _interopRequireDefault(require_isWeekend());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_requiredArgs());
  var _index8 = _interopRequireDefault(require_toInteger());
  function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index7.default)(2, arguments);
    var dateLeft = (0, _index6.default)(dirtyDateLeft);
    var dateRight = (0, _index6.default)(dirtyDateRight);
    if (!(0, _index4.default)(dateLeft) || !(0, _index4.default)(dateRight))
      return NaN;
    var calendarDifference = (0, _index2.default)(dateLeft, dateRight);
    var sign = calendarDifference < 0 ? -1 : 1;
    var weeks = (0, _index8.default)(calendarDifference / 7);
    var result = weeks * 5;
    dateRight = (0, _index.default)(dateRight, weeks * 7);
    while (!(0, _index3.default)(dateLeft, dateRight)) {
      result += (0, _index5.default)(dateRight) ? 0 : sign;
      dateRight = (0, _index.default)(dateRight, sign);
    }
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarISOWeekYears/index.js
var require_differenceInCalendarISOWeekYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarISOWeekYears;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dirtyDateLeft) - (0, _index.default)(dirtyDateRight);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarISOWeeks/index.js
var require_differenceInCalendarISOWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarISOWeeks;
  var _index = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var startOfISOWeekLeft = (0, _index2.default)(dirtyDateLeft);
    var startOfISOWeekRight = (0, _index2.default)(dirtyDateRight);
    var timestampLeft = startOfISOWeekLeft.getTime() - (0, _index.default)(startOfISOWeekLeft);
    var timestampRight = startOfISOWeekRight.getTime() - (0, _index.default)(startOfISOWeekRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarMonths/index.js
var require_differenceInCalendarMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getQuarter/index.js
var require_getQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var quarter = Math.floor(date2.getMonth() / 3) + 1;
    return quarter;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarQuarters/index.js
var require_differenceInCalendarQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarQuarters;
  var _index = _interopRequireDefault(require_getQuarter());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var dateLeft = (0, _index2.default)(dirtyDateLeft);
    var dateRight = (0, _index2.default)(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var quarterDiff = (0, _index.default)(dateLeft) - (0, _index.default)(dateRight);
    return yearDiff * 4 + quarterDiff;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarWeeks/index.js
var require_differenceInCalendarWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarWeeks;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
    (0, _index3.default)(2, arguments);
    var startOfWeekLeft = (0, _index.default)(dirtyDateLeft, options);
    var startOfWeekRight = (0, _index.default)(dirtyDateRight, options);
    var timestampLeft = startOfWeekLeft.getTime() - (0, _index2.default)(startOfWeekLeft);
    var timestampRight = startOfWeekRight.getTime() - (0, _index2.default)(startOfWeekRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInCalendarYears/index.js
var require_differenceInCalendarYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInCalendarYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() - dateRight.getFullYear();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInDays/index.js
var require_differenceInDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInDays;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function compareLocalAsc(dateLeft, dateRight) {
    var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  function differenceInDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = compareLocalAsc(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft.setDate(dateLeft.getDate() - sign * difference);
    var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
    var result = sign * (difference - isLastDayNotFull);
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInMilliseconds/index.js
var require_differenceInMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInMilliseconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInMilliseconds(dateLeft, dateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dateLeft).getTime() - (0, _index.default)(dateRight).getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/roundingMethods/index.js
var require_roundingMethods = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.getRoundingMethod = getRoundingMethod;
  var roundingMap = {
    ceil: Math.ceil,
    round: Math.round,
    floor: Math.floor,
    trunc: function trunc(value) {
      return value < 0 ? Math.ceil(value) : Math.floor(value);
    }
  };
  var defaultRoundingMethod = "trunc";
  function getRoundingMethod(method) {
    return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
  }
});

// node_modules/date-fns/differenceInHours/index.js
var require_differenceInHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInHours;
  var _index = require_constants2();
  var _index2 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_roundingMethods();
  function differenceInHours(dateLeft, dateRight, options) {
    (0, _index3.default)(2, arguments);
    var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInHour;
    return (0, _index4.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subISOWeekYears/index.js
var require_subISOWeekYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subISOWeekYears;
  var _index = _interopRequireDefault(require_addISOWeekYears());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subISOWeekYears(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInISOWeekYears/index.js
var require_differenceInISOWeekYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInISOWeekYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarISOWeekYears());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_subISOWeekYears());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index5.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft = (0, _index4.default)(dateLeft, sign * difference);
    var isLastISOWeekYearNotFull = Number((0, _index3.default)(dateLeft, dateRight) === -sign);
    var result = sign * (difference - isLastISOWeekYearNotFull);
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInMinutes/index.js
var require_differenceInMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInMinutes;
  var _index = require_constants2();
  var _index2 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_roundingMethods();
  function differenceInMinutes(dateLeft, dateRight, options) {
    (0, _index3.default)(2, arguments);
    var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInMinute;
    return (0, _index4.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfDay/index.js
var require_endOfDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfMonth/index.js
var require_endOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var month = date2.getMonth();
    date2.setFullYear(date2.getFullYear(), month + 1, 0);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isLastDayOfMonth/index.js
var require_isLastDayOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isLastDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_endOfDay());
  var _index3 = _interopRequireDefault(require_endOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function isLastDayOfMonth(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    return (0, _index2.default)(date2).getTime() === (0, _index3.default)(date2).getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInMonths/index.js
var require_differenceInMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_isLastDayOfMonth());
  function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index4.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    var result;
    if (difference < 1) {
      result = 0;
    } else {
      if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
        dateLeft.setDate(30);
      }
      dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
      var isLastMonthNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
      if ((0, _index5.default)((0, _index.default)(dirtyDateLeft)) && difference === 1 && (0, _index3.default)(dirtyDateLeft, dateRight) === 1) {
        isLastMonthNotFull = false;
      }
      result = sign * (difference - Number(isLastMonthNotFull));
    }
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInQuarters/index.js
var require_differenceInQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInQuarters;
  var _index = _interopRequireDefault(require_differenceInMonths());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInQuarters(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 3;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInSeconds/index.js
var require_differenceInSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInSeconds;
  var _index = _interopRequireDefault(require_differenceInMilliseconds());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInSeconds(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 1000;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInWeeks/index.js
var require_differenceInWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInWeeks;
  var _index = _interopRequireDefault(require_differenceInDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInWeeks(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 7;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/differenceInYears/index.js
var require_differenceInYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = differenceInYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function differenceInYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index4.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft.setFullYear(1584);
    dateRight.setFullYear(1584);
    var isLastYearNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
    var result = sign * (difference - Number(isLastYearNotFull));
    return result === 0 ? 0 : result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachDayOfInterval/index.js
var require_eachDayOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachDayOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachDayOfInterval(dirtyInterval, options) {
    var _options$step;
    (0, _index2.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index.default)(interval2.start);
    var endDate = (0, _index.default)(interval2.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setDate(currentDate.getDate() + step);
      currentDate.setHours(0, 0, 0, 0);
    }
    return dates;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachHourOfInterval/index.js
var require_eachHourOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachHourOfInterval;
  var _index = _interopRequireDefault(require_addHours());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function eachHourOfInterval(dirtyInterval, options) {
    var _options$step;
    (0, _index3.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index2.default)(interval2.start);
    var endDate = (0, _index2.default)(interval2.end);
    var startTime = startDate.getTime();
    var endTime = endDate.getTime();
    if (!(startTime <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setMinutes(0, 0, 0);
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index2.default)(currentDate));
      currentDate = (0, _index.default)(currentDate, step);
    }
    return dates;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfMinute/index.js
var require_startOfMinute = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfMinute;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setSeconds(0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachMinuteOfInterval/index.js
var require_eachMinuteOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachMinuteOfInterval;
  var _index = _interopRequireDefault(require_addMinutes());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_startOfMinute());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachMinuteOfInterval(interval2, options) {
    var _options$step;
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index3.default)((0, _index2.default)(interval2.start));
    var endDate = (0, _index2.default)(interval2.end);
    var startTime = startDate.getTime();
    var endTime = endDate.getTime();
    if (startTime >= endTime) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number equal to or greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index2.default)(currentDate));
      currentDate = (0, _index.default)(currentDate, step);
    }
    return dates;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachMonthOfInterval/index.js
var require_eachMonthOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachMonthOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachMonthOfInterval(dirtyInterval) {
    (0, _index2.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index.default)(interval2.start);
    var endDate = (0, _index.default)(interval2.end);
    var endTime = endDate.getTime();
    var dates = [];
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setDate(1);
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
    return dates;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfQuarter/index.js
var require_startOfQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var currentMonth = date2.getMonth();
    var month = currentMonth - currentMonth % 3;
    date2.setMonth(month, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachQuarterOfInterval/index.js
var require_eachQuarterOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachQuarterOfInterval;
  var _index = _interopRequireDefault(require_addQuarters());
  var _index2 = _interopRequireDefault(require_startOfQuarter());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachQuarterOfInterval(dirtyInterval) {
    (0, _index4.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index3.default)(interval2.start);
    var endDate = (0, _index3.default)(interval2.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var startDateQuarter = (0, _index2.default)(startDate);
    var endDateQuarter = (0, _index2.default)(endDate);
    endTime = endDateQuarter.getTime();
    var quarters = [];
    var currentQuarter = startDateQuarter;
    while (currentQuarter.getTime() <= endTime) {
      quarters.push((0, _index3.default)(currentQuarter));
      currentQuarter = (0, _index.default)(currentQuarter, 1);
    }
    return quarters;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachWeekOfInterval/index.js
var require_eachWeekOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachWeekOfInterval;
  var _index = _interopRequireDefault(require_addWeeks());
  var _index2 = _interopRequireDefault(require_startOfWeek());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekOfInterval(dirtyInterval, options) {
    (0, _index4.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index3.default)(interval2.start);
    var endDate = (0, _index3.default)(interval2.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var startDateWeek = (0, _index2.default)(startDate, options);
    var endDateWeek = (0, _index2.default)(endDate, options);
    startDateWeek.setHours(15);
    endDateWeek.setHours(15);
    endTime = endDateWeek.getTime();
    var weeks = [];
    var currentWeek = startDateWeek;
    while (currentWeek.getTime() <= endTime) {
      currentWeek.setHours(0);
      weeks.push((0, _index3.default)(currentWeek));
      currentWeek = (0, _index.default)(currentWeek, 1);
      currentWeek.setHours(15);
    }
    return weeks;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachWeekendOfInterval/index.js
var require_eachWeekendOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachWeekendOfInterval;
  var _index = _interopRequireDefault(require_eachDayOfInterval());
  var _index2 = _interopRequireDefault(require_isSunday());
  var _index3 = _interopRequireDefault(require_isWeekend());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfInterval(interval2) {
    (0, _index4.default)(1, arguments);
    var dateInterval = (0, _index.default)(interval2);
    var weekends = [];
    var index = 0;
    while (index < dateInterval.length) {
      var date2 = dateInterval[index++];
      if ((0, _index3.default)(date2)) {
        weekends.push(date2);
        if ((0, _index2.default)(date2))
          index = index + 5;
      }
    }
    return weekends;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfMonth/index.js
var require_startOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachWeekendOfMonth/index.js
var require_eachWeekendOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachWeekendOfMonth;
  var _index = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index2 = _interopRequireDefault(require_startOfMonth());
  var _index3 = _interopRequireDefault(require_endOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfMonth(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index2.default)(dirtyDate);
    if (isNaN(startDate.getTime()))
      throw new RangeError("The passed date is invalid");
    var endDate = (0, _index3.default)(dirtyDate);
    return (0, _index.default)({
      start: startDate,
      end: endDate
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfYear/index.js
var require_endOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    date2.setFullYear(year + 1, 0, 0);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfYear/index.js
var require_startOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var cleanDate = (0, _index.default)(dirtyDate);
    var date2 = new Date(0);
    date2.setFullYear(cleanDate.getFullYear(), 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachWeekendOfYear/index.js
var require_eachWeekendOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachWeekendOfYear;
  var _index = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index2 = _interopRequireDefault(require_endOfYear());
  var _index3 = _interopRequireDefault(require_startOfYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfYear(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index3.default)(dirtyDate);
    var endDate = (0, _index2.default)(dirtyDate);
    return (0, _index.default)({
      start: startDate,
      end: endDate
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/eachYearOfInterval/index.js
var require_eachYearOfInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = eachYearOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachYearOfInterval(dirtyInterval) {
    (0, _index2.default)(1, arguments);
    var interval2 = dirtyInterval || {};
    var startDate = (0, _index.default)(interval2.start);
    var endDate = (0, _index.default)(interval2.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setMonth(0, 1);
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setFullYear(currentDate.getFullYear() + 1);
    }
    return dates;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfDecade/index.js
var require_endOfDecade = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var decade = 9 + Math.floor(year / 10) * 10;
    date2.setFullYear(decade, 11, 31);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfHour/index.js
var require_endOfHour = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfHour;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setMinutes(59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfWeek/index.js
var require_endOfWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfWeek;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function endOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date2 = (0, _index2.default)(dirtyDate);
    var day = date2.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date2.setDate(date2.getDate() + diff);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfISOWeek/index.js
var require_endOfISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfISOWeek;
  var _index = _interopRequireDefault(require_endOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfISOWeekYear/index.js
var require_endOfISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function endOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var date2 = (0, _index2.default)(fourthOfJanuaryOfNextYear);
    date2.setMilliseconds(date2.getMilliseconds() - 1);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfMinute/index.js
var require_endOfMinute = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfMinute;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setSeconds(59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfQuarter/index.js
var require_endOfQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var currentMonth = date2.getMonth();
    var month = currentMonth - currentMonth % 3 + 3;
    date2.setMonth(month, 0);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfSecond/index.js
var require_endOfSecond = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfSecond;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setMilliseconds(999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfToday/index.js
var require_endOfToday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfToday;
  var _index = _interopRequireDefault(require_endOfDay());
  function endOfToday() {
    return (0, _index.default)(Date.now());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfTomorrow/index.js
var require_endOfTomorrow = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfTomorrow;
  function endOfTomorrow() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date2 = new Date(0);
    date2.setFullYear(year, month, day + 1);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/endOfYesterday/index.js
var require_endOfYesterday = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = endOfYesterday;
  function endOfYesterday() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date2 = new Date(0);
    date2.setFullYear(year, month, day - 1);
    date2.setHours(23, 59, 59, 999);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subMilliseconds/index.js
var require_subMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subMilliseconds;
  var _index = _interopRequireDefault(require_addMilliseconds());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subMilliseconds(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getUTCDayOfYear/index.js
var require_getUTCDayOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUTCDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 86400000;
  function getUTCDayOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var timestamp2 = date2.getTime();
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date2.getTime();
    var difference = timestamp2 - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/startOfUTCISOWeek/index.js
var require_startOfUTCISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfUTCISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfUTCISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var weekStartsOn = 1;
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date2.setUTCDate(date2.getUTCDate() - diff);
    date2.setUTCHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getUTCISOWeekYear/index.js
var require_getUTCISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUTCISOWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCISOWeek());
  function getUTCISOWeekYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
    if (date2.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date2.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js
var require_startOfUTCISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfUTCISOWeekYear;
  var _index = _interopRequireDefault(require_getUTCISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function startOfUTCISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date2 = (0, _index2.default)(fourthOfJanuary);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getUTCISOWeek/index.js
var require_getUTCISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUTCISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var _index3 = _interopRequireDefault(require_startOfUTCISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getUTCISOWeek(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date2).getTime() - (0, _index3.default)(date2).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/startOfUTCWeek/index.js
var require_startOfUTCWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfUTCWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = require_defaultOptions();
  function startOfUTCWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var defaultOptions2 = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date2.setUTCDate(date2.getUTCDate() - diff);
    date2.setUTCHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getUTCWeekYear/index.js
var require_getUTCWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUTCWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCWeek());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = require_defaultOptions();
  function getUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getUTCFullYear();
    var defaultOptions2 = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
    if (date2.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date2.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/startOfUTCWeekYear/index.js
var require_startOfUTCWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfUTCWeekYear;
  var _index = _interopRequireDefault(require_getUTCWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCWeek());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = require_defaultOptions();
  function startOfUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var defaultOptions2 = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var year = (0, _index.default)(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date2 = (0, _index3.default)(firstWeek, options);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/getUTCWeek/index.js
var require_getUTCWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUTCWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var _index3 = _interopRequireDefault(require_startOfUTCWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getUTCWeek(dirtyDate, options) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date2, options).getTime() - (0, _index3.default)(date2, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/addLeadingZeros/index.js
var require_addLeadingZeros = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = addLeadingZeros;
  function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? "-" : "";
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = "0" + output;
    }
    return sign + output;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/format/lightFormatters/index.js
var require_lightFormatters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_addLeadingZeros());
  var formatters = {
    y: function y(date2, token) {
      var signedYear = date2.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return (0, _index.default)(token === "yy" ? year % 100 : year, token.length);
    },
    M: function M(date2, token) {
      var month = date2.getUTCMonth();
      return token === "M" ? String(month + 1) : (0, _index.default)(month + 1, 2);
    },
    d: function d(date2, token) {
      return (0, _index.default)(date2.getUTCDate(), token.length);
    },
    a: function a(date2, token) {
      var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    h: function h(date2, token) {
      return (0, _index.default)(date2.getUTCHours() % 12 || 12, token.length);
    },
    H: function H(date2, token) {
      return (0, _index.default)(date2.getUTCHours(), token.length);
    },
    m: function m(date2, token) {
      return (0, _index.default)(date2.getUTCMinutes(), token.length);
    },
    s: function s(date2, token) {
      return (0, _index.default)(date2.getUTCSeconds(), token.length);
    },
    S: function S(date2, token) {
      var numberOfDigits = token.length;
      var milliseconds = date2.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return (0, _index.default)(fractionalSeconds, token.length);
    }
  };
  var _default = formatters;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/format/formatters/index.js
var require_formatters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_getUTCDayOfYear());
  var _index2 = _interopRequireDefault(require_getUTCISOWeek());
  var _index3 = _interopRequireDefault(require_getUTCISOWeekYear());
  var _index4 = _interopRequireDefault(require_getUTCWeek());
  var _index5 = _interopRequireDefault(require_getUTCWeekYear());
  var _index6 = _interopRequireDefault(require_addLeadingZeros());
  var _index7 = _interopRequireDefault(require_lightFormatters());
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters = {
    G: function G(date2, token, localize) {
      var era = date2.getUTCFullYear() > 0 ? 1 : 0;
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return localize.era(era, {
            width: "abbreviated"
          });
        case "GGGGG":
          return localize.era(era, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return localize.era(era, {
            width: "wide"
          });
      }
    },
    y: function y(date2, token, localize) {
      if (token === "yo") {
        var signedYear = date2.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: "year"
        });
      }
      return _index7.default.y(date2, token);
    },
    Y: function Y(date2, token, localize, options) {
      var signedWeekYear = (0, _index5.default)(date2, options);
      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        var twoDigitYear = weekYear % 100;
        return (0, _index6.default)(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize.ordinalNumber(weekYear, {
          unit: "year"
        });
      }
      return (0, _index6.default)(weekYear, token.length);
    },
    R: function R(date2, token) {
      var isoWeekYear = (0, _index3.default)(date2);
      return (0, _index6.default)(isoWeekYear, token.length);
    },
    u: function u(date2, token) {
      var year = date2.getUTCFullYear();
      return (0, _index6.default)(year, token.length);
    },
    Q: function Q(date2, token, localize) {
      var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
      switch (token) {
        case "Q":
          return String(quarter);
        case "QQ":
          return (0, _index6.default)(quarter, 2);
        case "Qo":
          return localize.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "QQQ":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    q: function q(date2, token, localize) {
      var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
      switch (token) {
        case "q":
          return String(quarter);
        case "qq":
          return (0, _index6.default)(quarter, 2);
        case "qo":
          return localize.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "qqq":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    M: function M(date2, token, localize) {
      var month = date2.getUTCMonth();
      switch (token) {
        case "M":
        case "MM":
          return _index7.default.M(date2, token);
        case "Mo":
          return localize.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "MMM":
          return localize.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return localize.month(month, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return localize.month(month, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    L: function L(date2, token, localize) {
      var month = date2.getUTCMonth();
      switch (token) {
        case "L":
          return String(month + 1);
        case "LL":
          return (0, _index6.default)(month + 1, 2);
        case "Lo":
          return localize.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "LLL":
          return localize.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return localize.month(month, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return localize.month(month, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    w: function w(date2, token, localize, options) {
      var week = (0, _index4.default)(date2, options);
      if (token === "wo") {
        return localize.ordinalNumber(week, {
          unit: "week"
        });
      }
      return (0, _index6.default)(week, token.length);
    },
    I: function I(date2, token, localize) {
      var isoWeek = (0, _index2.default)(date2);
      if (token === "Io") {
        return localize.ordinalNumber(isoWeek, {
          unit: "week"
        });
      }
      return (0, _index6.default)(isoWeek, token.length);
    },
    d: function d(date2, token, localize) {
      if (token === "do") {
        return localize.ordinalNumber(date2.getUTCDate(), {
          unit: "date"
        });
      }
      return _index7.default.d(date2, token);
    },
    D: function D(date2, token, localize) {
      var dayOfYear = (0, _index.default)(date2);
      if (token === "Do") {
        return localize.ordinalNumber(dayOfYear, {
          unit: "dayOfYear"
        });
      }
      return (0, _index6.default)(dayOfYear, token.length);
    },
    E: function E(date2, token, localize) {
      var dayOfWeek = date2.getUTCDay();
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    e: function e(date2, token, localize, options) {
      var dayOfWeek = date2.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "e":
          return String(localDayOfWeek);
        case "ee":
          return (0, _index6.default)(localDayOfWeek, 2);
        case "eo":
          return localize.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "eee":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    c: function c(date2, token, localize, options) {
      var dayOfWeek = date2.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "c":
          return String(localDayOfWeek);
        case "cc":
          return (0, _index6.default)(localDayOfWeek, token.length);
        case "co":
          return localize.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "ccc":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    i: function i(date2, token, localize) {
      var dayOfWeek = date2.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        case "i":
          return String(isoDayOfWeek);
        case "ii":
          return (0, _index6.default)(isoDayOfWeek, token.length);
        case "io":
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: "day"
          });
        case "iii":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    a: function a(date2, token, localize) {
      var hours = date2.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    b: function b(date2, token, localize) {
      var hours = date2.getUTCHours();
      var dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    B: function B(date2, token, localize) {
      var hours = date2.getUTCHours();
      var dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    h: function h(date2, token, localize) {
      if (token === "ho") {
        var hours = date2.getUTCHours() % 12;
        if (hours === 0)
          hours = 12;
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return _index7.default.h(date2, token);
    },
    H: function H(date2, token, localize) {
      if (token === "Ho") {
        return localize.ordinalNumber(date2.getUTCHours(), {
          unit: "hour"
        });
      }
      return _index7.default.H(date2, token);
    },
    K: function K(date2, token, localize) {
      var hours = date2.getUTCHours() % 12;
      if (token === "Ko") {
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return (0, _index6.default)(hours, token.length);
    },
    k: function k(date2, token, localize) {
      var hours = date2.getUTCHours();
      if (hours === 0)
        hours = 24;
      if (token === "ko") {
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return (0, _index6.default)(hours, token.length);
    },
    m: function m(date2, token, localize) {
      if (token === "mo") {
        return localize.ordinalNumber(date2.getUTCMinutes(), {
          unit: "minute"
        });
      }
      return _index7.default.m(date2, token);
    },
    s: function s(date2, token, localize) {
      if (token === "so") {
        return localize.ordinalNumber(date2.getUTCSeconds(), {
          unit: "second"
        });
      }
      return _index7.default.s(date2, token);
    },
    S: function S(date2, token) {
      return _index7.default.S(date2, token);
    },
    X: function X(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timezoneOffset = originalDate.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    x: function x(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    O: function O(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    z: function z(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    t: function t(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timestamp2 = Math.floor(originalDate.getTime() / 1000);
      return (0, _index6.default)(timestamp2, token.length);
    },
    T: function T(date2, token, _localize, options) {
      var originalDate = options._originalDate || date2;
      var timestamp2 = originalDate.getTime();
      return (0, _index6.default)(timestamp2, token.length);
    }
  };
  function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    var delimiter = dirtyDelimiter || "";
    return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? "-" : "+";
      return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, dirtyDelimiter);
  }
  function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || "";
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
    var minutes = (0, _index6.default)(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  var _default = formatters;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/format/longFormatters/index.js
var require_longFormatters = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case "P":
        return formatLong.date({
          width: "short"
        });
      case "PP":
        return formatLong.date({
          width: "medium"
        });
      case "PPP":
        return formatLong.date({
          width: "long"
        });
      case "PPPP":
      default:
        return formatLong.date({
          width: "full"
        });
    }
  };
  var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case "p":
        return formatLong.time({
          width: "short"
        });
      case "pp":
        return formatLong.time({
          width: "medium"
        });
      case "ppp":
        return formatLong.time({
          width: "long"
        });
      case "pppp":
      default:
        return formatLong.time({
          width: "full"
        });
    }
  };
  var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong.dateTime({
          width: "short"
        });
        break;
      case "PP":
        dateTimeFormat = formatLong.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        dateTimeFormat = formatLong.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong.dateTime({
          width: "full"
        });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var _default = longFormatters;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/protectedTokens/index.js
var require_protectedTokens = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
  exports2.isProtectedWeekYearToken = isProtectedWeekYearToken;
  exports2.throwProtectedError = throwProtectedError;
  var protectedDayOfYearTokens = ["D", "DD"];
  var protectedWeekYearTokens = ["YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }
  function throwProtectedError(token, format, input) {
    if (token === "YYYY") {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "YY") {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "D") {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "DD") {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js
var require_formatDistance = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = function formatDistance(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options !== null && options !== undefined && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  var _default = formatDistance;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js
var require_buildFormatLongFn = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildFormatLongFn;
  function buildFormatLongFn(args) {
    return function() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatLong/index.js
var require_formatLong = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_buildFormatLongFn());
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: (0, _index.default)({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: (0, _index.default)({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: (0, _index.default)({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var _default = formatLong;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js
var require_formatRelative = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var _default = formatRelative;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js
var require_buildLocalizeFn = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildLocalizeFn;
  function buildLocalizeFn(args) {
    return function(dirtyIndex, options) {
      var context = options !== null && options !== undefined && options.context ? String(options.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options !== null && options !== undefined && options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options !== null && options !== undefined && options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/localize/index.js
var require_localize = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_buildLocalizeFn());
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  var localize = {
    ordinalNumber,
    era: (0, _index.default)({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: (0, _index.default)({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function argumentCallback(quarter) {
        return quarter - 1;
      }
    }),
    month: (0, _index.default)({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: (0, _index.default)({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: (0, _index.default)({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var _default = localize;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildMatchFn/index.js
var require_buildMatchFn = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchFn;
  function buildMatchFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      }) : findKey(parsePatterns, function(pattern) {
        return pattern.test(matchedString);
      });
      var value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
    return;
  }
  function findIndex(array, predicate) {
    for (var key = 0;key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js
var require_buildMatchPatternFn = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = buildMatchPatternFn;
  function buildMatchPatternFn(args) {
    return function(string) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult)
        return null;
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult)
        return null;
      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value,
        rest
      };
    };
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/_lib/match/index.js
var require_match = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_buildMatchFn());
  var _index2 = _interopRequireDefault(require_buildMatchPatternFn());
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match2 = {
    ordinalNumber: (0, _index2.default)({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: (0, _index.default)({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: (0, _index.default)({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: (0, _index.default)({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: (0, _index.default)({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: (0, _index.default)({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var _default = match2;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/locale/en-US/index.js
var require_en_US = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_formatDistance());
  var _index2 = _interopRequireDefault(require_formatLong());
  var _index3 = _interopRequireDefault(require_formatRelative());
  var _index4 = _interopRequireDefault(require_localize());
  var _index5 = _interopRequireDefault(require_match());
  var locale = {
    code: "en-US",
    formatDistance: _index.default,
    formatLong: _index2.default,
    formatRelative: _index3.default,
    localize: _index4.default,
    match: _index5.default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var _default = locale;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/defaultLocale/index.js
var require_defaultLocale = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = undefined;
  var _index = _interopRequireDefault(require_en_US());
  var _default = _index.default;
  exports2.default = _default;
  module2.exports = exports2.default;
});

// node_modules/date-fns/format/index.js
var require_format2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = format;
  var _index = _interopRequireDefault(require_isValid());
  var _index2 = _interopRequireDefault(require_subMilliseconds());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_formatters());
  var _index5 = _interopRequireDefault(require_longFormatters());
  var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index7 = require_protectedTokens();
  var _index8 = _interopRequireDefault(require_toInteger());
  var _index9 = _interopRequireDefault(require_requiredArgs());
  var _index10 = require_defaultOptions();
  var _index11 = _interopRequireDefault(require_defaultLocale());
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(dirtyDate, dirtyFormatStr, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _index9.default)(2, arguments);
    var formatStr = String(dirtyFormatStr);
    var defaultOptions2 = (0, _index10.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index11.default;
    var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== undefined ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale3 = options.locale) === null || _options$locale3 === undefined ? undefined : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === undefined ? undefined : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== undefined ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== undefined ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === undefined ? undefined : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === undefined ? undefined : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== undefined ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (!locale.localize) {
      throw new RangeError("locale must contain localize property");
    }
    if (!locale.formatLong) {
      throw new RangeError("locale must contain formatLong property");
    }
    var originalDate = (0, _index3.default)(dirtyDate);
    if (!(0, _index.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var timezoneOffset = (0, _index6.default)(originalDate);
    var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        var longFormatter = _index5.default[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map(function(substring) {
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }
      var formatter = _index4.default[firstCharacter];
      if (formatter) {
        if (!(options !== null && options !== undefined && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
          (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
        }
        if (!(options !== null && options !== undefined && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
          (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
        }
        return formatter(utcDate, substring, locale.localize, formatterOptions);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      return substring;
    }).join("");
    return result;
  }
  function cleanEscapedString(input) {
    var matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/assign/index.js
var require_assign = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = assign;
  function assign(target, object) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    for (var property in object) {
      if (Object.prototype.hasOwnProperty.call(object, property)) {
        target[property] = object[property];
      }
    }
    return target;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/_lib/cloneObject/index.js
var require_cloneObject = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = cloneObject;
  var _index = _interopRequireDefault(require_assign());
  function cloneObject(object) {
    return (0, _index.default)({}, object);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDistance/index.js
var require_formatDistance2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistance;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_compareAsc());
  var _index3 = _interopRequireDefault(require_differenceInMonths());
  var _index4 = _interopRequireDefault(require_differenceInSeconds());
  var _index5 = _interopRequireDefault(require_defaultLocale());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_cloneObject());
  var _index8 = _interopRequireDefault(require_assign());
  var _index9 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index10 = _interopRequireDefault(require_requiredArgs());
  var MINUTES_IN_DAY = 1440;
  var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
  var MINUTES_IN_MONTH = 43200;
  var MINUTES_IN_TWO_MONTHS = 86400;
  function formatDistance(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale;
    (0, _index10.default)(2, arguments);
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index5.default;
    if (!locale.formatDistance) {
      throw new RangeError("locale must contain formatDistance property");
    }
    var comparison = (0, _index2.default)(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = (0, _index8.default)((0, _index7.default)(options), {
      addSuffix: Boolean(options === null || options === undefined ? undefined : options.addSuffix),
      comparison
    });
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = (0, _index6.default)(dirtyBaseDate);
      dateRight = (0, _index6.default)(dirtyDate);
    } else {
      dateLeft = (0, _index6.default)(dirtyDate);
      dateRight = (0, _index6.default)(dirtyBaseDate);
    }
    var seconds = (0, _index4.default)(dateRight, dateLeft);
    var offsetInSeconds = ((0, _index9.default)(dateRight) - (0, _index9.default)(dateLeft)) / 1000;
    var minutes = Math.round((seconds - offsetInSeconds) / 60);
    var months;
    if (minutes < 2) {
      if (options !== null && options !== undefined && options.includeSeconds) {
        if (seconds < 5) {
          return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
        } else if (seconds < 10) {
          return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
        } else if (seconds < 20) {
          return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
        } else if (seconds < 40) {
          return locale.formatDistance("halfAMinute", 0, localizeOptions);
        } else if (seconds < 60) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", 1, localizeOptions);
        }
      } else {
        if (minutes === 0) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", minutes, localizeOptions);
        }
      }
    } else if (minutes < 45) {
      return locale.formatDistance("xMinutes", minutes, localizeOptions);
    } else if (minutes < 90) {
      return locale.formatDistance("aboutXHours", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_DAY) {
      var hours = Math.round(minutes / 60);
      return locale.formatDistance("aboutXHours", hours, localizeOptions);
    } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
      return locale.formatDistance("xDays", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_MONTH) {
      var days = Math.round(minutes / MINUTES_IN_DAY);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (minutes < MINUTES_IN_TWO_MONTHS) {
      months = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = (0, _index3.default)(dateRight, dateLeft);
    if (months < 12) {
      var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
    } else {
      var monthsSinceStartOfYear = months % 12;
      var years = Math.floor(months / 12);
      if (monthsSinceStartOfYear < 3) {
        return locale.formatDistance("aboutXYears", years, localizeOptions);
      } else if (monthsSinceStartOfYear < 9) {
        return locale.formatDistance("overXYears", years, localizeOptions);
      } else {
        return locale.formatDistance("almostXYears", years + 1, localizeOptions);
      }
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDistanceStrict/index.js
var require_formatDistanceStrict = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistanceStrict;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_toDate());
  var _index5 = _interopRequireDefault(require_cloneObject());
  var _index6 = _interopRequireDefault(require_assign());
  var _index7 = _interopRequireDefault(require_defaultLocale());
  var _index8 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_MINUTE = 1000 * 60;
  var MINUTES_IN_DAY = 60 * 24;
  var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
  var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
  function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale, _options$roundingMeth;
    (0, _index8.default)(2, arguments);
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index7.default;
    if (!locale.formatDistance) {
      throw new RangeError("locale must contain localize.formatDistance property");
    }
    var comparison = (0, _index3.default)(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = (0, _index6.default)((0, _index5.default)(options), {
      addSuffix: Boolean(options === null || options === undefined ? undefined : options.addSuffix),
      comparison
    });
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = (0, _index4.default)(dirtyBaseDate);
      dateRight = (0, _index4.default)(dirtyDate);
    } else {
      dateLeft = (0, _index4.default)(dirtyDate);
      dateRight = (0, _index4.default)(dirtyBaseDate);
    }
    var roundingMethod = String((_options$roundingMeth = options === null || options === undefined ? undefined : options.roundingMethod) !== null && _options$roundingMeth !== undefined ? _options$roundingMeth : "round");
    var roundingMethodFn;
    if (roundingMethod === "floor") {
      roundingMethodFn = Math.floor;
    } else if (roundingMethod === "ceil") {
      roundingMethodFn = Math.ceil;
    } else if (roundingMethod === "round") {
      roundingMethodFn = Math.round;
    } else {
      throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
    }
    var milliseconds = dateRight.getTime() - dateLeft.getTime();
    var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
    var timezoneOffset = (0, _index2.default)(dateRight) - (0, _index2.default)(dateLeft);
    var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
    var defaultUnit = options === null || options === undefined ? undefined : options.unit;
    var unit;
    if (!defaultUnit) {
      if (minutes < 1) {
        unit = "second";
      } else if (minutes < 60) {
        unit = "minute";
      } else if (minutes < MINUTES_IN_DAY) {
        unit = "hour";
      } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
        unit = "day";
      } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
        unit = "month";
      } else {
        unit = "year";
      }
    } else {
      unit = String(defaultUnit);
    }
    if (unit === "second") {
      var seconds = roundingMethodFn(milliseconds / 1000);
      return locale.formatDistance("xSeconds", seconds, localizeOptions);
    } else if (unit === "minute") {
      var roundedMinutes = roundingMethodFn(minutes);
      return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);
    } else if (unit === "hour") {
      var hours = roundingMethodFn(minutes / 60);
      return locale.formatDistance("xHours", hours, localizeOptions);
    } else if (unit === "day") {
      var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (unit === "month") {
      var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
      return months === 12 && defaultUnit !== "month" ? locale.formatDistance("xYears", 1, localizeOptions) : locale.formatDistance("xMonths", months, localizeOptions);
    } else if (unit === "year") {
      var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
      return locale.formatDistance("xYears", years, localizeOptions);
    }
    throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDistanceToNow/index.js
var require_formatDistanceToNow = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistanceToNow;
  var _index = _interopRequireDefault(require_formatDistance2());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function formatDistanceToNow(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDistanceToNowStrict/index.js
var require_formatDistanceToNowStrict = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDistanceToNowStrict;
  var _index = _interopRequireDefault(require_formatDistanceStrict());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function formatDistanceToNowStrict(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatDuration/index.js
var require_formatDuration = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatDuration;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_defaultLocale());
  var defaultFormat = ["years", "months", "weeks", "days", "hours", "minutes", "seconds"];
  function formatDuration(duration, options) {
    var _ref, _options$locale, _options$format, _options$zero, _options$delimiter;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
    }
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index2.default;
    var format = (_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : defaultFormat;
    var zero = (_options$zero = options === null || options === undefined ? undefined : options.zero) !== null && _options$zero !== undefined ? _options$zero : false;
    var delimiter = (_options$delimiter = options === null || options === undefined ? undefined : options.delimiter) !== null && _options$delimiter !== undefined ? _options$delimiter : " ";
    if (!locale.formatDistance) {
      return "";
    }
    var result = format.reduce(function(acc, unit) {
      var token = "x".concat(unit.replace(/(^.)/, function(m) {
        return m.toUpperCase();
      }));
      var value = duration[unit];
      if (typeof value === "number" && (zero || duration[unit])) {
        return acc.concat(locale.formatDistance(token, value));
      }
      return acc;
    }, []).join(delimiter);
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatISO/index.js
var require_formatISO = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatISO;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_addLeadingZeros());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function formatISO(date2, options) {
    var _options$format, _options$representati;
    (0, _index3.default)(1, arguments);
    var originalDate = (0, _index.default)(date2);
    if (isNaN(originalDate.getTime())) {
      throw new RangeError("Invalid time value");
    }
    var format = String((_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : "extended");
    var representation = String((_options$representati = options === null || options === undefined ? undefined : options.representation) !== null && _options$representati !== undefined ? _options$representati : "complete");
    if (format !== "extended" && format !== "basic") {
      throw new RangeError("format must be 'extended' or 'basic'");
    }
    if (representation !== "date" && representation !== "time" && representation !== "complete") {
      throw new RangeError("representation must be 'date', 'time', or 'complete'");
    }
    var result = "";
    var tzOffset = "";
    var dateDelimiter = format === "extended" ? "-" : "";
    var timeDelimiter = format === "extended" ? ":" : "";
    if (representation !== "time") {
      var day = (0, _index2.default)(originalDate.getDate(), 2);
      var month = (0, _index2.default)(originalDate.getMonth() + 1, 2);
      var year = (0, _index2.default)(originalDate.getFullYear(), 4);
      result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
    }
    if (representation !== "date") {
      var offset = originalDate.getTimezoneOffset();
      if (offset !== 0) {
        var absoluteOffset = Math.abs(offset);
        var hourOffset = (0, _index2.default)(Math.floor(absoluteOffset / 60), 2);
        var minuteOffset = (0, _index2.default)(absoluteOffset % 60, 2);
        var sign = offset < 0 ? "+" : "-";
        tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
      } else {
        tzOffset = "Z";
      }
      var hour = (0, _index2.default)(originalDate.getHours(), 2);
      var minute = (0, _index2.default)(originalDate.getMinutes(), 2);
      var second = (0, _index2.default)(originalDate.getSeconds(), 2);
      var separator = result === "" ? "" : "T";
      var time2 = [hour, minute, second].join(timeDelimiter);
      result = "".concat(result).concat(separator).concat(time2).concat(tzOffset);
    }
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatISO9075/index.js
var require_formatISO9075 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatISO9075;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  function formatISO9075(dirtyDate, options) {
    var _options$format, _options$representati;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var format = String((_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : "extended");
    var representation = String((_options$representati = options === null || options === undefined ? undefined : options.representation) !== null && _options$representati !== undefined ? _options$representati : "complete");
    if (format !== "extended" && format !== "basic") {
      throw new RangeError("format must be 'extended' or 'basic'");
    }
    if (representation !== "date" && representation !== "time" && representation !== "complete") {
      throw new RangeError("representation must be 'date', 'time', or 'complete'");
    }
    var result = "";
    var dateDelimiter = format === "extended" ? "-" : "";
    var timeDelimiter = format === "extended" ? ":" : "";
    if (representation !== "time") {
      var day = (0, _index3.default)(originalDate.getDate(), 2);
      var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
      var year = (0, _index3.default)(originalDate.getFullYear(), 4);
      result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
    }
    if (representation !== "date") {
      var hour = (0, _index3.default)(originalDate.getHours(), 2);
      var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
      var second = (0, _index3.default)(originalDate.getSeconds(), 2);
      var separator = result === "" ? "" : " ";
      result = "".concat(result).concat(separator).concat(hour).concat(timeDelimiter).concat(minute).concat(timeDelimiter).concat(second);
    }
    return result;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatISODuration/index.js
var require_formatISODuration = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatISODuration;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function formatISODuration(duration) {
    (0, _index.default)(1, arguments);
    if ((0, _typeof2.default)(duration) !== "object")
      throw new Error("Duration must be an object");
    var _duration$years = duration.years, years = _duration$years === undefined ? 0 : _duration$years, _duration$months = duration.months, months = _duration$months === undefined ? 0 : _duration$months, _duration$days = duration.days, days = _duration$days === undefined ? 0 : _duration$days, _duration$hours = duration.hours, hours = _duration$hours === undefined ? 0 : _duration$hours, _duration$minutes = duration.minutes, minutes = _duration$minutes === undefined ? 0 : _duration$minutes, _duration$seconds = duration.seconds, seconds = _duration$seconds === undefined ? 0 : _duration$seconds;
    return "P".concat(years, "Y").concat(months, "M").concat(days, "DT").concat(hours, "H").concat(minutes, "M").concat(seconds, "S");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatRFC3339/index.js
var require_formatRFC3339 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatRFC3339;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  var _index4 = _interopRequireDefault(require_toInteger());
  function formatRFC3339(dirtyDate, options) {
    var _options$fractionDigi;
    if (arguments.length < 1) {
      throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var fractionDigits = Number((_options$fractionDigi = options === null || options === undefined ? undefined : options.fractionDigits) !== null && _options$fractionDigi !== undefined ? _options$fractionDigi : 0);
    if (!(fractionDigits >= 0 && fractionDigits <= 3)) {
      throw new RangeError("fractionDigits must be between 0 and 3 inclusively");
    }
    var day = (0, _index3.default)(originalDate.getDate(), 2);
    var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
    var year = originalDate.getFullYear();
    var hour = (0, _index3.default)(originalDate.getHours(), 2);
    var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
    var second = (0, _index3.default)(originalDate.getSeconds(), 2);
    var fractionalSecond = "";
    if (fractionDigits > 0) {
      var milliseconds = originalDate.getMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, fractionDigits - 3));
      fractionalSecond = "." + (0, _index3.default)(fractionalSeconds, fractionDigits);
    }
    var offset = "";
    var tzOffset = originalDate.getTimezoneOffset();
    if (tzOffset !== 0) {
      var absoluteOffset = Math.abs(tzOffset);
      var hourOffset = (0, _index3.default)((0, _index4.default)(absoluteOffset / 60), 2);
      var minuteOffset = (0, _index3.default)(absoluteOffset % 60, 2);
      var sign = tzOffset < 0 ? "+" : "-";
      offset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      offset = "Z";
    }
    return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond).concat(offset);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatRFC7231/index.js
var require_formatRFC7231 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatRFC7231;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function formatRFC7231(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var dayName = days[originalDate.getUTCDay()];
    var dayOfMonth = (0, _index3.default)(originalDate.getUTCDate(), 2);
    var monthName = months[originalDate.getUTCMonth()];
    var year = originalDate.getUTCFullYear();
    var hour = (0, _index3.default)(originalDate.getUTCHours(), 2);
    var minute = (0, _index3.default)(originalDate.getUTCMinutes(), 2);
    var second = (0, _index3.default)(originalDate.getUTCSeconds(), 2);
    return "".concat(dayName, ", ").concat(dayOfMonth, " ").concat(monthName, " ").concat(year, " ").concat(hour, ":").concat(minute, ":").concat(second, " GMT");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/formatRelative/index.js
var require_formatRelative2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = formatRelative;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_format2());
  var _index4 = _interopRequireDefault(require_defaultLocale());
  var _index5 = _interopRequireDefault(require_subMilliseconds());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index8 = _interopRequireDefault(require_requiredArgs());
  var _index9 = _interopRequireDefault(require_toInteger());
  function formatRelative(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;
    (0, _index8.default)(2, arguments);
    var date2 = (0, _index6.default)(dirtyDate);
    var baseDate = (0, _index6.default)(dirtyBaseDate);
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index4.default;
    var weekStartsOn = (0, _index9.default)((_ref2 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== undefined ? _ref4 : defaultOptions2.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : 0);
    if (!locale.localize) {
      throw new RangeError("locale must contain localize property");
    }
    if (!locale.formatLong) {
      throw new RangeError("locale must contain formatLong property");
    }
    if (!locale.formatRelative) {
      throw new RangeError("locale must contain formatRelative property");
    }
    var diff = (0, _index2.default)(date2, baseDate);
    if (isNaN(diff)) {
      throw new RangeError("Invalid time value");
    }
    var token;
    if (diff < -6) {
      token = "other";
    } else if (diff < -1) {
      token = "lastWeek";
    } else if (diff < 0) {
      token = "yesterday";
    } else if (diff < 1) {
      token = "today";
    } else if (diff < 2) {
      token = "tomorrow";
    } else if (diff < 7) {
      token = "nextWeek";
    } else {
      token = "other";
    }
    var utcDate = (0, _index5.default)(date2, (0, _index7.default)(date2));
    var utcBaseDate = (0, _index5.default)(baseDate, (0, _index7.default)(baseDate));
    var formatStr = locale.formatRelative(token, utcDate, utcBaseDate, {
      locale,
      weekStartsOn
    });
    return (0, _index3.default)(date2, formatStr, {
      locale,
      weekStartsOn
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/fromUnixTime/index.js
var require_fromUnixTime = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = fromUnixTime;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function fromUnixTime(dirtyUnixTime) {
    (0, _index3.default)(1, arguments);
    var unixTime = (0, _index2.default)(dirtyUnixTime);
    return (0, _index.default)(unixTime * 1000);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDate/index.js
var require_getDate = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDate;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDate(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var dayOfMonth = date2.getDate();
    return dayOfMonth;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDay/index.js
var require_getDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getDay();
    return day;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDayOfYear/index.js
var require_getDayOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfYear());
  var _index3 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function getDayOfYear(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var diff = (0, _index3.default)(date2, (0, _index2.default)(date2));
    var dayOfYear = diff + 1;
    return dayOfYear;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDaysInMonth/index.js
var require_getDaysInMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDaysInMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDaysInMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var monthIndex = date2.getMonth();
    var lastDayOfMonth = new Date(0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isLeapYear/index.js
var require_isLeapYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isLeapYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isLeapYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDaysInYear/index.js
var require_getDaysInYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDaysInYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isLeapYear());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function getDaysInYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    if (String(new Date(date2)) === "Invalid Date") {
      return NaN;
    }
    return (0, _index2.default)(date2) ? 366 : 365;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDecade/index.js
var require_getDecade = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var decade = Math.floor(year / 10) * 10;
    return decade;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getDefaultOptions/index.js
var require_getDefaultOptions = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getDefaultOptions;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_assign());
  function getDefaultOptions() {
    return (0, _index2.default)({}, (0, _index.getDefaultOptions)());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getHours/index.js
var require_getHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getHours;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getHours(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var hours = date2.getHours();
    return hours;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getISODay/index.js
var require_getISODay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getISODay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getISODay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getDay();
    if (day === 0) {
      day = 7;
    }
    return day;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getISOWeek/index.js
var require_getISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getISOWeek(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date2).getTime() - (0, _index3.default)(date2).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getISOWeeksInYear/index.js
var require_getISOWeeksInYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getISOWeeksInYear;
  var _index = _interopRequireDefault(require_startOfISOWeekYear());
  var _index2 = _interopRequireDefault(require_addWeeks());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getISOWeeksInYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var thisYear = (0, _index.default)(dirtyDate);
    var nextYear = (0, _index.default)((0, _index2.default)(thisYear, 60));
    var diff = nextYear.valueOf() - thisYear.valueOf();
    return Math.round(diff / MILLISECONDS_IN_WEEK);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getMilliseconds/index.js
var require_getMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getMilliseconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMilliseconds(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var milliseconds = date2.getMilliseconds();
    return milliseconds;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getMinutes/index.js
var require_getMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getMinutes;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMinutes(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var minutes = date2.getMinutes();
    return minutes;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getMonth/index.js
var require_getMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var month = date2.getMonth();
    return month;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getOverlappingDaysInIntervals/index.js
var require_getOverlappingDaysInIntervals = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getOverlappingDaysInIntervals;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000;
  function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
    (0, _index2.default)(2, arguments);
    var intervalLeft = dirtyIntervalLeft || {};
    var intervalRight = dirtyIntervalRight || {};
    var leftStartTime = (0, _index.default)(intervalLeft.start).getTime();
    var leftEndTime = (0, _index.default)(intervalLeft.end).getTime();
    var rightStartTime = (0, _index.default)(intervalRight.start).getTime();
    var rightEndTime = (0, _index.default)(intervalRight.end).getTime();
    if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
      throw new RangeError("Invalid interval");
    }
    var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
    if (!isOverlapping) {
      return 0;
    }
    var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
    var overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
    var differenceInMs = overlapEndDate - overlapStartDate;
    return Math.ceil(differenceInMs / MILLISECONDS_IN_DAY);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getSeconds/index.js
var require_getSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getSeconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getSeconds(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var seconds = date2.getSeconds();
    return seconds;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getTime/index.js
var require_getTime = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getTime;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getTime(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var timestamp2 = date2.getTime();
    return timestamp2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getUnixTime/index.js
var require_getUnixTime = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getUnixTime;
  var _index = _interopRequireDefault(require_getTime());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getUnixTime(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return Math.floor((0, _index.default)(dirtyDate) / 1000);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getWeekYear/index.js
var require_getWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getWeekYear;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function getWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var year = date2.getFullYear();
    var defaultOptions2 = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index.default)(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index.default)(firstWeekOfThisYear, options);
    if (date2.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date2.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfWeekYear/index.js
var require_startOfWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfWeekYear;
  var _index = _interopRequireDefault(require_getWeekYear());
  var _index2 = _interopRequireDefault(require_startOfWeek());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function startOfWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var defaultOptions2 = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var year = (0, _index.default)(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    var date2 = (0, _index2.default)(firstWeek, options);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getWeek/index.js
var require_getWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_startOfWeekYear());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getWeek(dirtyDate, options) {
    (0, _index4.default)(1, arguments);
    var date2 = (0, _index3.default)(dirtyDate);
    var diff = (0, _index.default)(date2, options).getTime() - (0, _index2.default)(date2, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getWeekOfMonth/index.js
var require_getWeekOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getWeekOfMonth;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_getDate());
  var _index3 = _interopRequireDefault(require_getDay());
  var _index4 = _interopRequireDefault(require_startOfMonth());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  var _index6 = _interopRequireDefault(require_toInteger());
  function getWeekOfMonth(date2, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index5.default)(1, arguments);
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    var weekStartsOn = (0, _index6.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var currentDayOfMonth = (0, _index2.default)(date2);
    if (isNaN(currentDayOfMonth))
      return NaN;
    var startWeekDay = (0, _index3.default)((0, _index4.default)(date2));
    var lastDayOfFirstWeek = weekStartsOn - startWeekDay;
    if (lastDayOfFirstWeek <= 0)
      lastDayOfFirstWeek += 7;
    var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
    return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfMonth/index.js
var require_lastDayOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var month = date2.getMonth();
    date2.setFullYear(date2.getFullYear(), month + 1, 0);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getWeeksInMonth/index.js
var require_getWeeksInMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getWeeksInMonth;
  var _index = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index2 = _interopRequireDefault(require_lastDayOfMonth());
  var _index3 = _interopRequireDefault(require_startOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function getWeeksInMonth(date2, options) {
    (0, _index4.default)(1, arguments);
    return (0, _index.default)((0, _index2.default)(date2), (0, _index3.default)(date2), options) + 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/getYear/index.js
var require_getYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = getYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getFullYear();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/hoursToMilliseconds/index.js
var require_hoursToMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = hoursToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function hoursToMilliseconds(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.millisecondsInHour);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/hoursToMinutes/index.js
var require_hoursToMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = hoursToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function hoursToMinutes(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.minutesInHour);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/hoursToSeconds/index.js
var require_hoursToSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = hoursToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function hoursToSeconds(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.secondsInHour);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/intervalToDuration/index.js
var require_intervalToDuration = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = intervalToDuration;
  var _index = _interopRequireDefault(require_compareAsc());
  var _index2 = _interopRequireDefault(require_add());
  var _index3 = _interopRequireDefault(require_differenceInDays());
  var _index4 = _interopRequireDefault(require_differenceInHours());
  var _index5 = _interopRequireDefault(require_differenceInMinutes());
  var _index6 = _interopRequireDefault(require_differenceInMonths());
  var _index7 = _interopRequireDefault(require_differenceInSeconds());
  var _index8 = _interopRequireDefault(require_differenceInYears());
  var _index9 = _interopRequireDefault(require_toDate());
  var _index10 = _interopRequireDefault(require_requiredArgs());
  function intervalToDuration(interval2) {
    (0, _index10.default)(1, arguments);
    var start = (0, _index9.default)(interval2.start);
    var end = (0, _index9.default)(interval2.end);
    if (isNaN(start.getTime()))
      throw new RangeError("Start Date is invalid");
    if (isNaN(end.getTime()))
      throw new RangeError("End Date is invalid");
    var duration = {};
    duration.years = Math.abs((0, _index8.default)(end, start));
    var sign = (0, _index.default)(end, start);
    var remainingMonths = (0, _index2.default)(start, {
      years: sign * duration.years
    });
    duration.months = Math.abs((0, _index6.default)(end, remainingMonths));
    var remainingDays = (0, _index2.default)(remainingMonths, {
      months: sign * duration.months
    });
    duration.days = Math.abs((0, _index3.default)(end, remainingDays));
    var remainingHours = (0, _index2.default)(remainingDays, {
      days: sign * duration.days
    });
    duration.hours = Math.abs((0, _index4.default)(end, remainingHours));
    var remainingMinutes = (0, _index2.default)(remainingHours, {
      hours: sign * duration.hours
    });
    duration.minutes = Math.abs((0, _index5.default)(end, remainingMinutes));
    var remainingSeconds = (0, _index2.default)(remainingMinutes, {
      minutes: sign * duration.minutes
    });
    duration.seconds = Math.abs((0, _index7.default)(end, remainingSeconds));
    return duration;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/intlFormat/index.js
var require_intlFormat = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = intlFormat;
  var _index = _interopRequireDefault(require_requiredArgs());
  function intlFormat(date2, formatOrLocale, localeOptions) {
    var _localeOptions;
    (0, _index.default)(1, arguments);
    var formatOptions;
    if (isFormatOptions(formatOrLocale)) {
      formatOptions = formatOrLocale;
    } else {
      localeOptions = formatOrLocale;
    }
    return new Intl.DateTimeFormat((_localeOptions = localeOptions) === null || _localeOptions === undefined ? undefined : _localeOptions.locale, formatOptions).format(date2);
  }
  function isFormatOptions(opts) {
    return opts !== undefined && !("locale" in opts);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/intlFormatDistance/index.js
var require_intlFormatDistance = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = intlFormatDistance;
  var _index = require_constants2();
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index4 = _interopRequireDefault(require_differenceInCalendarQuarters());
  var _index5 = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index6 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index7 = _interopRequireDefault(require_differenceInHours());
  var _index8 = _interopRequireDefault(require_differenceInMinutes());
  var _index9 = _interopRequireDefault(require_differenceInSeconds());
  var _index10 = _interopRequireDefault(require_toDate());
  var _index11 = _interopRequireDefault(require_requiredArgs());
  function intlFormatDistance(date2, baseDate, options) {
    (0, _index11.default)(2, arguments);
    var value = 0;
    var unit;
    var dateLeft = (0, _index10.default)(date2);
    var dateRight = (0, _index10.default)(baseDate);
    if (!(options !== null && options !== undefined && options.unit)) {
      var diffInSeconds = (0, _index9.default)(dateLeft, dateRight);
      if (Math.abs(diffInSeconds) < _index.secondsInMinute) {
        value = (0, _index9.default)(dateLeft, dateRight);
        unit = "second";
      } else if (Math.abs(diffInSeconds) < _index.secondsInHour) {
        value = (0, _index8.default)(dateLeft, dateRight);
        unit = "minute";
      } else if (Math.abs(diffInSeconds) < _index.secondsInDay && Math.abs((0, _index2.default)(dateLeft, dateRight)) < 1) {
        value = (0, _index7.default)(dateLeft, dateRight);
        unit = "hour";
      } else if (Math.abs(diffInSeconds) < _index.secondsInWeek && (value = (0, _index2.default)(dateLeft, dateRight)) && Math.abs(value) < 7) {
        unit = "day";
      } else if (Math.abs(diffInSeconds) < _index.secondsInMonth) {
        value = (0, _index5.default)(dateLeft, dateRight);
        unit = "week";
      } else if (Math.abs(diffInSeconds) < _index.secondsInQuarter) {
        value = (0, _index3.default)(dateLeft, dateRight);
        unit = "month";
      } else if (Math.abs(diffInSeconds) < _index.secondsInYear) {
        if ((0, _index4.default)(dateLeft, dateRight) < 4) {
          value = (0, _index4.default)(dateLeft, dateRight);
          unit = "quarter";
        } else {
          value = (0, _index6.default)(dateLeft, dateRight);
          unit = "year";
        }
      } else {
        value = (0, _index6.default)(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      unit = options === null || options === undefined ? undefined : options.unit;
      if (unit === "second") {
        value = (0, _index9.default)(dateLeft, dateRight);
      } else if (unit === "minute") {
        value = (0, _index8.default)(dateLeft, dateRight);
      } else if (unit === "hour") {
        value = (0, _index7.default)(dateLeft, dateRight);
      } else if (unit === "day") {
        value = (0, _index2.default)(dateLeft, dateRight);
      } else if (unit === "week") {
        value = (0, _index5.default)(dateLeft, dateRight);
      } else if (unit === "month") {
        value = (0, _index3.default)(dateLeft, dateRight);
      } else if (unit === "quarter") {
        value = (0, _index4.default)(dateLeft, dateRight);
      } else if (unit === "year") {
        value = (0, _index6.default)(dateLeft, dateRight);
      }
    }
    var rtf = new Intl.RelativeTimeFormat(options === null || options === undefined ? undefined : options.locale, {
      localeMatcher: options === null || options === undefined ? undefined : options.localeMatcher,
      numeric: (options === null || options === undefined ? undefined : options.numeric) || "auto",
      style: options === null || options === undefined ? undefined : options.style
    });
    return rtf.format(value, unit);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isAfter/index.js
var require_isAfter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isAfter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isAfter(dirtyDate, dirtyDateToCompare) {
    (0, _index2.default)(2, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    return date2.getTime() > dateToCompare.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isBefore/index.js
var require_isBefore = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isBefore;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isBefore(dirtyDate, dirtyDateToCompare) {
    (0, _index2.default)(2, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    return date2.getTime() < dateToCompare.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isEqual/index.js
var require_isEqual = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isEqual;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isEqual(dirtyLeftDate, dirtyRightDate) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyLeftDate);
    var dateRight = (0, _index.default)(dirtyRightDate);
    return dateLeft.getTime() === dateRight.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isExists/index.js
var require_isExists = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isExists;
  function isExists(year, month, day) {
    if (arguments.length < 3) {
      throw new TypeError("3 argument required, but only " + arguments.length + " present");
    }
    var date2 = new Date(year, month, day);
    return date2.getFullYear() === year && date2.getMonth() === month && date2.getDate() === day;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isFirstDayOfMonth/index.js
var require_isFirstDayOfMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isFirstDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFirstDayOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDate() === 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isFriday/index.js
var require_isFriday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isFriday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFriday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 5;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isFuture/index.js
var require_isFuture = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isFuture;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFuture(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getTime() > Date.now();
  }
  module2.exports = exports2.default;
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS((exports2, module2) => {
  function _arrayLikeToArray(r, a) {
    (a == null || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a);e < a; e++)
      n[e] = r[e];
    return n;
  }
  module2.exports = _arrayLikeToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS((exports2, module2) => {
  var arrayLikeToArray = require_arrayLikeToArray();
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if (typeof r == "string")
        return arrayLikeToArray(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return t === "Object" && r.constructor && (t = r.constructor.name), t === "Map" || t === "Set" ? Array.from(r) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : undefined;
    }
  }
  module2.exports = _unsupportedIterableToArray, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
var require_createForOfIteratorHelper = __commonJS((exports2, module2) => {
  var unsupportedIterableToArray = require_unsupportedIterableToArray();
  function _createForOfIteratorHelper(r, e) {
    var t = typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = unsupportedIterableToArray(r)) || e && r && typeof r.length == "number") {
        t && (r = t);
        var _n = 0, F = function F() {};
        return {
          s: F,
          n: function n() {
            return _n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[_n++]
            };
          },
          e: function e(r2) {
            throw r2;
          },
          f: F
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t = t.call(r);
      },
      n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      },
      e: function e(r2) {
        u = true, o = r2;
      },
      f: function f() {
        try {
          a || t["return"] == null || t["return"]();
        } finally {
          if (u)
            throw o;
        }
      }
    };
  }
  module2.exports = _createForOfIteratorHelper, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS((exports2, module2) => {
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  module2.exports = _assertThisInitialized, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS((exports2, module2) => {
  function _setPrototypeOf(t, e) {
    return module2.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
      return t2.__proto__ = e2, t2;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _setPrototypeOf(t, e);
  }
  module2.exports = _setPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  var setPrototypeOf = require_setPrototypeOf();
  function _inherits(t, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e && setPrototypeOf(t, e);
  }
  module2.exports = _inherits, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS((exports2, module2) => {
  function _getPrototypeOf(t) {
    return module2.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports, _getPrototypeOf(t);
  }
  module2.exports = _getPrototypeOf, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS((exports2, module2) => {
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t2) {}
    return (module2.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    }, module2.exports.__esModule = true, module2.exports["default"] = module2.exports)();
  }
  module2.exports = _isNativeReflectConstruct, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS((exports2, module2) => {
  var _typeof = require_typeof()["default"];
  var assertThisInitialized = require_assertThisInitialized();
  function _possibleConstructorReturn(t, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return assertThisInitialized(t);
  }
  module2.exports = _possibleConstructorReturn, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/createSuper.js
var require_createSuper = __commonJS((exports2, module2) => {
  var getPrototypeOf = require_getPrototypeOf();
  var isNativeReflectConstruct = require_isNativeReflectConstruct();
  var possibleConstructorReturn = require_possibleConstructorReturn();
  function _createSuper(t) {
    var r = isNativeReflectConstruct();
    return function() {
      var e, o = getPrototypeOf(t);
      if (r) {
        var s = getPrototypeOf(this).constructor;
        e = Reflect.construct(o, arguments, s);
      } else
        e = o.apply(this, arguments);
      return possibleConstructorReturn(this, e);
    };
  }
  module2.exports = _createSuper, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS((exports2, module2) => {
  function _classCallCheck(a, n) {
    if (!(a instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  module2.exports = _classCallCheck, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS((exports2, module2) => {
  var _typeof = require_typeof()["default"];
  function toPrimitive(t, r) {
    if (_typeof(t) != "object" || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (e !== undefined) {
      var i2 = e.call(t, r || "default");
      if (_typeof(i2) != "object")
        return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t);
  }
  module2.exports = toPrimitive, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS((exports2, module2) => {
  var _typeof = require_typeof()["default"];
  var toPrimitive = require_toPrimitive();
  function toPropertyKey(t) {
    var i2 = toPrimitive(t, "string");
    return _typeof(i2) == "symbol" ? i2 : i2 + "";
  }
  module2.exports = toPropertyKey, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS((exports2, module2) => {
  var toPropertyKey = require_toPropertyKey();
  function _defineProperties(e, r) {
    for (var t = 0;t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  module2.exports = _createClass, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS((exports2, module2) => {
  var toPropertyKey = require_toPropertyKey();
  function _defineProperty(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t, e;
  }
  module2.exports = _defineProperty, module2.exports.__esModule = true, module2.exports["default"] = module2.exports;
});

// node_modules/date-fns/parse/_lib/Setter.js
var require_Setter = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ValueSetter = exports2.Setter = exports2.DateToSystemTimezoneSetter = undefined;
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var TIMEZONE_UNIT_PRIORITY = 10;
  var Setter = /* @__PURE__ */ function() {
    function Setter2() {
      (0, _classCallCheck2.default)(this, Setter2);
      (0, _defineProperty2.default)(this, "priority", undefined);
      (0, _defineProperty2.default)(this, "subPriority", 0);
    }
    (0, _createClass2.default)(Setter2, [{
      key: "validate",
      value: function validate(_utcDate, _options) {
        return true;
      }
    }]);
    return Setter2;
  }();
  exports2.Setter = Setter;
  var ValueSetter = /* @__PURE__ */ function(_Setter) {
    (0, _inherits2.default)(ValueSetter2, _Setter);
    var _super = (0, _createSuper2.default)(ValueSetter2);
    function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
      var _this;
      (0, _classCallCheck2.default)(this, ValueSetter2);
      _this = _super.call(this);
      _this.value = value;
      _this.validateValue = validateValue;
      _this.setValue = setValue;
      _this.priority = priority;
      if (subPriority) {
        _this.subPriority = subPriority;
      }
      return _this;
    }
    (0, _createClass2.default)(ValueSetter2, [{
      key: "validate",
      value: function validate(utcDate, options) {
        return this.validateValue(utcDate, this.value, options);
      }
    }, {
      key: "set",
      value: function set(utcDate, flags, options) {
        return this.setValue(utcDate, flags, this.value, options);
      }
    }]);
    return ValueSetter2;
  }(Setter);
  exports2.ValueSetter = ValueSetter;
  var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
    (0, _inherits2.default)(DateToSystemTimezoneSetter2, _Setter2);
    var _super2 = (0, _createSuper2.default)(DateToSystemTimezoneSetter2);
    function DateToSystemTimezoneSetter2() {
      var _this2;
      (0, _classCallCheck2.default)(this, DateToSystemTimezoneSetter2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _super2.call.apply(_super2, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "subPriority", -1);
      return _this2;
    }
    (0, _createClass2.default)(DateToSystemTimezoneSetter2, [{
      key: "set",
      value: function set(date2, flags) {
        if (flags.timestampIsSet) {
          return date2;
        }
        var convertedDate = new Date(0);
        convertedDate.setFullYear(date2.getUTCFullYear(), date2.getUTCMonth(), date2.getUTCDate());
        convertedDate.setHours(date2.getUTCHours(), date2.getUTCMinutes(), date2.getUTCSeconds(), date2.getUTCMilliseconds());
        return convertedDate;
      }
    }]);
    return DateToSystemTimezoneSetter2;
  }(Setter);
  exports2.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;
});

// node_modules/date-fns/parse/_lib/Parser.js
var require_Parser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Setter = require_Setter();
  var Parser = /* @__PURE__ */ function() {
    function Parser2() {
      (0, _classCallCheck2.default)(this, Parser2);
      (0, _defineProperty2.default)(this, "incompatibleTokens", undefined);
      (0, _defineProperty2.default)(this, "priority", undefined);
      (0, _defineProperty2.default)(this, "subPriority", undefined);
    }
    (0, _createClass2.default)(Parser2, [{
      key: "run",
      value: function run(dateString, token, match2, options) {
        var result = this.parse(dateString, token, match2, options);
        if (!result) {
          return null;
        }
        return {
          setter: new _Setter.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }
    }, {
      key: "validate",
      value: function validate(_utcDate, _value, _options) {
        return true;
      }
    }]);
    return Parser2;
  }();
  exports2.Parser = Parser;
});

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var require_EraParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.EraParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var EraParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(EraParser2, _Parser);
    var _super = (0, _createSuper2.default)(EraParser2);
    function EraParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, EraParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 140);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(EraParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return match2.era(dateString, {
              width: "abbreviated"
            }) || match2.era(dateString, {
              width: "narrow"
            });
          case "GGGGG":
            return match2.era(dateString, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return match2.era(dateString, {
              width: "wide"
            }) || match2.era(dateString, {
              width: "abbreviated"
            }) || match2.era(dateString, {
              width: "narrow"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date2, flags, value) {
        flags.era = value;
        date2.setUTCFullYear(value, 0, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return EraParser2;
  }(_Parser2.Parser);
  exports2.EraParser = EraParser;
});

// node_modules/date-fns/parse/_lib/constants.js
var require_constants3 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.timezonePatterns = exports2.numericPatterns = undefined;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  };
  exports2.numericPatterns = numericPatterns;
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };
  exports2.timezonePatterns = timezonePatterns;
});

// node_modules/date-fns/parse/_lib/utils.js
var require_utils4 = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.dayPeriodEnumToHours = dayPeriodEnumToHours;
  exports2.isLeapYearIndex = isLeapYearIndex;
  exports2.mapValue = mapValue;
  exports2.normalizeTwoDigitYear = normalizeTwoDigitYear;
  exports2.parseAnyDigitsSigned = parseAnyDigitsSigned;
  exports2.parseNDigits = parseNDigits;
  exports2.parseNDigitsSigned = parseNDigitsSigned;
  exports2.parseNumericPattern = parseNumericPattern;
  exports2.parseTimezonePattern = parseTimezonePattern;
  var _index = require_constants2();
  var _constants = require_constants3();
  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    var sign = matchResult[1] === "+" ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(_constants.numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(_constants.numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(_constants.numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(_constants.numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(_constants.numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
  }
  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(_constants.numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(_constants.numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(_constants.numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(_constants.numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
});

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var require_YearParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.YearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var YearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(YearParser2, _Parser);
    var _super = (0, _createSuper2.default)(YearParser2);
    function YearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, YearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(YearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        var valueCallback = function valueCallback(year) {
          return {
            year,
            isTwoDigitYear: token === "yy"
          };
        };
        switch (token) {
          case "y":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
          case "yo":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback);
          default:
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set(date2, flags, value) {
        var currentYear = date2.getUTCFullYear();
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
          date2.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date2.setUTCHours(0, 0, 0, 0);
          return date2;
        }
        var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date2.setUTCFullYear(year, 0, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return YearParser2;
  }(_Parser2.Parser);
  exports2.YearParser = YearParser;
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var require_LocalWeekYearParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.LocalWeekYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_getUTCWeekYear());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalWeekYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalWeekYearParser2);
    function LocalWeekYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalWeekYearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        var valueCallback = function valueCallback(year) {
          return {
            year,
            isTwoDigitYear: token === "YY"
          };
        };
        switch (token) {
          case "Y":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
          case "Yo":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback);
          default:
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set(date2, flags, value, options) {
        var currentYear = (0, _index.default)(date2, options);
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value.year, currentYear);
          date2.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date2.setUTCHours(0, 0, 0, 0);
          return (0, _index2.default)(date2, options);
        }
        var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date2.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date2.setUTCHours(0, 0, 0, 0);
        return (0, _index2.default)(date2, options);
      }
    }]);
    return LocalWeekYearParser2;
  }(_Parser2.Parser);
  exports2.LocalWeekYearParser = LocalWeekYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var require_ISOWeekYearParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ISOWeekYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_startOfUTCISOWeek());
  var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOWeekYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOWeekYearParser2);
    function ISOWeekYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISOWeekYearParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === "R") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return (0, _index.default)(firstWeekOfYear);
      }
    }]);
    return ISOWeekYearParser2;
  }(_Parser2.Parser);
  exports2.ISOWeekYearParser = ISOWeekYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var require_ExtendedYearParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ExtendedYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ExtendedYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(ExtendedYearParser2);
    function ExtendedYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ExtendedYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ExtendedYearParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === "u") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCFullYear(value, 0, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return ExtendedYearParser2;
  }(_Parser2.Parser);
  exports2.ExtendedYearParser = ExtendedYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var require_QuarterParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.QuarterParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var QuarterParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(QuarterParser2, _Parser);
    var _super = (0, _createSuper2.default)(QuarterParser2);
    function QuarterParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, QuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(QuarterParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "Q":
          case "QQ":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "Qo":
            return match2.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "QQQ":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMonth((value - 1) * 3, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return QuarterParser2;
  }(_Parser2.Parser);
  exports2.QuarterParser = QuarterParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var require_StandAloneQuarterParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.StandAloneQuarterParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneQuarterParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneQuarterParser2);
    function StandAloneQuarterParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneQuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneQuarterParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "q":
          case "qq":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "qo":
            return match2.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "qqq":
            return match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match2.quarter(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMonth((value - 1) * 3, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return StandAloneQuarterParser2;
  }(_Parser2.Parser);
  exports2.StandAloneQuarterParser = StandAloneQuarterParser;
});

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var require_MonthParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.MonthParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _utils = require_utils4();
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var MonthParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(MonthParser2, _Parser);
    var _super = (0, _createSuper2.default)(MonthParser2);
    function MonthParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, MonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
      return _this;
    }
    (0, _createClass2.default)(MonthParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };
        switch (token) {
          case "M":
            return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
          case "MM":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
          case "Mo":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback);
          case "MMM":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMMM":
            return match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match2.month(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMonth(value, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return MonthParser2;
  }(_Parser2.Parser);
  exports2.MonthParser = MonthParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var require_StandAloneMonthParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.StandAloneMonthParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneMonthParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneMonthParser2);
    function StandAloneMonthParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneMonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneMonthParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };
        switch (token) {
          case "L":
            return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
          case "LL":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
          case "Lo":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback);
          case "LLL":
            return match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLLL":
            return match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match2.month(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMonth(value, 1);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return StandAloneMonthParser2;
  }(_Parser2.Parser);
  exports2.StandAloneMonthParser = StandAloneMonthParser;
});

// node_modules/date-fns/_lib/setUTCWeek/index.js
var require_setUTCWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setUTCWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getUTCWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var week = (0, _index.default)(dirtyWeek);
    var diff = (0, _index3.default)(date2, options) - week;
    date2.setUTCDate(date2.getUTCDate() - diff * 7);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var require_LocalWeekParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.LocalWeekParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_setUTCWeek());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalWeekParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalWeekParser2);
    function LocalWeekParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalWeekParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "w":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
          case "wo":
            return match2.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value, options) {
        return (0, _index2.default)((0, _index.default)(date2, value, options), options);
      }
    }]);
    return LocalWeekParser2;
  }(_Parser2.Parser);
  exports2.LocalWeekParser = LocalWeekParser;
});

// node_modules/date-fns/_lib/setUTCISOWeek/index.js
var require_setUTCISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setUTCISOWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getUTCISOWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var isoWeek = (0, _index.default)(dirtyISOWeek);
    var diff = (0, _index3.default)(date2) - isoWeek;
    date2.setUTCDate(date2.getUTCDate() - diff * 7);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var require_ISOWeekParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ISOWeekParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_setUTCISOWeek());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOWeekParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOWeekParser2);
    function ISOWeekParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISOWeekParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "I":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
          case "Io":
            return match2.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        return (0, _index2.default)((0, _index.default)(date2, value));
      }
    }]);
    return ISOWeekParser2;
  }(_Parser2.Parser);
  exports2.ISOWeekParser = ISOWeekParser;
});

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var require_DateParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.DateParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _utils = require_utils4();
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DateParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DateParser2, _Parser);
    var _super = (0, _createSuper2.default)(DateParser2);
    function DateParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DateParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subPriority", 1);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DateParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "d":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.date, dateString);
          case "do":
            return match2.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date2, value) {
        var year = date2.getUTCFullYear();
        var isLeapYear = (0, _utils.isLeapYearIndex)(year);
        var month = date2.getUTCMonth();
        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH[month];
        }
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCDate(value);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return DateParser2;
  }(_Parser2.Parser);
  exports2.DateParser = DateParser;
});

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var require_DayOfYearParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.DayOfYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayOfYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayOfYearParser2);
    function DayOfYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayOfYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subpriority", 1);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayOfYearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "D":
          case "DD":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.dayOfYear, dateString);
          case "Do":
            return match2.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date2, value) {
        var year = date2.getUTCFullYear();
        var isLeapYear = (0, _utils.isLeapYearIndex)(year);
        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMonth(0, value);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return DayOfYearParser2;
  }(_Parser2.Parser);
  exports2.DayOfYearParser = DayOfYearParser;
});

// node_modules/date-fns/_lib/setUTCDay/index.js
var require_setUTCDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setUTCDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = require_defaultOptions();
  function setUTCDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(2, arguments);
    var defaultOptions2 = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date2 = (0, _index.default)(dirtyDate);
    var day = (0, _index3.default)(dirtyDay);
    var currentDay = date2.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date2.setUTCDate(date2.getUTCDate() + diff);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var require_DayParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.DayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _index = _interopRequireDefault(require_setUTCDay());
  var DayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayParser2);
    function DayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEE":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEE":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value, options) {
        date2 = (0, _index.default)(date2, value, options);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return DayParser2;
  }(_Parser2.Parser);
  exports2.DayParser = DayParser;
});

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var require_LocalDayParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.LocalDayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_setUTCDay());
  var LocalDayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalDayParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalDayParser2);
    function LocalDayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalDayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "e":
          case "ee":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
          case "eo":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback);
          case "eee":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeee":
            return match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeee":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value, options) {
        date2 = (0, _index.default)(date2, value, options);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return LocalDayParser2;
  }(_Parser2.Parser);
  exports2.LocalDayParser = LocalDayParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var require_StandAloneLocalDayParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.StandAloneLocalDayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_setUTCDay());
  var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneLocalDayParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneLocalDayParser2);
    function StandAloneLocalDayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneLocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneLocalDayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "c":
          case "cc":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
          case "co":
            return (0, _utils.mapValue)(match2.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback);
          case "ccc":
            return match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "ccccc":
            return match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccc":
          default:
            return match2.day(dateString, {
              width: "wide",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value, options) {
        date2 = (0, _index.default)(date2, value, options);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return StandAloneLocalDayParser2;
  }(_Parser2.Parser);
  exports2.StandAloneLocalDayParser = StandAloneLocalDayParser;
});

// node_modules/date-fns/_lib/setUTCISODay/index.js
var require_setUTCISODay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setUTCISODay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function setUTCISODay(dirtyDate, dirtyDay) {
    (0, _index2.default)(2, arguments);
    var day = (0, _index3.default)(dirtyDay);
    if (day % 7 === 0) {
      day = day - 7;
    }
    var weekStartsOn = 1;
    var date2 = (0, _index.default)(dirtyDate);
    var currentDay = date2.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date2.setUTCDate(date2.getUTCDate() + diff);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var require_ISODayParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ISODayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var _index = _interopRequireDefault(require_setUTCISODay());
  var ISODayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISODayParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISODayParser2);
    function ISODayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISODayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISODayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        var valueCallback = function valueCallback(value) {
          if (value === 0) {
            return 7;
          }
          return value;
        };
        switch (token) {
          case "i":
          case "ii":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "io":
            return match2.ordinalNumber(dateString, {
              unit: "day"
            });
          case "iii":
            return (0, _utils.mapValue)(match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiiii":
            return (0, _utils.mapValue)(match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiiiii":
            return (0, _utils.mapValue)(match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiii":
          default:
            return (0, _utils.mapValue)(match2.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match2.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 7;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2 = (0, _index.default)(date2, value);
        date2.setUTCHours(0, 0, 0, 0);
        return date2;
      }
    }]);
    return ISODayParser2;
  }(_Parser2.Parser);
  exports2.ISODayParser = ISODayParser;
});

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var require_AMPMParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.AMPMParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var AMPMParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(AMPMParser2, _Parser);
    var _super = (0, _createSuper2.default)(AMPMParser2);
    function AMPMParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, AMPMParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(AMPMParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date2;
      }
    }]);
    return AMPMParser2;
  }(_Parser2.Parser);
  exports2.AMPMParser = AMPMParser;
});

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var require_AMPMMidnightParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.AMPMMidnightParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(AMPMMidnightParser2, _Parser);
    var _super = (0, _createSuper2.default)(AMPMMidnightParser2);
    function AMPMMidnightParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, AMPMMidnightParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(AMPMMidnightParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date2;
      }
    }]);
    return AMPMMidnightParser2;
  }(_Parser2.Parser);
  exports2.AMPMMidnightParser = AMPMMidnightParser;
});

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var require_DayPeriodParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.DayPeriodParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayPeriodParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayPeriodParser2);
    function DayPeriodParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayPeriodParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayPeriodParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match2.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match2.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCHours((0, _utils.dayPeriodEnumToHours)(value), 0, 0, 0);
        return date2;
      }
    }]);
    return DayPeriodParser2;
  }(_Parser2.Parser);
  exports2.DayPeriodParser = DayPeriodParser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var require_Hour1to12Parser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Hour1to12Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour1to12Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour1to12Parser2);
    function Hour1to12Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour1to12Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour1to12Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "h":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour12h, dateString);
          case "ho":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 12;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        var isPM = date2.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date2.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date2.setUTCHours(0, 0, 0, 0);
        } else {
          date2.setUTCHours(value, 0, 0, 0);
        }
        return date2;
      }
    }]);
    return Hour1to12Parser2;
  }(_Parser2.Parser);
  exports2.Hour1to12Parser = Hour1to12Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var require_Hour0to23Parser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Hour0to23Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour0to23Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour0to23Parser2);
    function Hour0to23Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour0to23Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour0to23Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "H":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour23h, dateString);
          case "Ho":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 23;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCHours(value, 0, 0, 0);
        return date2;
      }
    }]);
    return Hour0to23Parser2;
  }(_Parser2.Parser);
  exports2.Hour0to23Parser = Hour0to23Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var require_Hour0To11Parser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Hour0To11Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour0To11Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour0To11Parser2);
    function Hour0To11Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour0To11Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour0To11Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "K":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour11h, dateString);
          case "Ko":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        var isPM = date2.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date2.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date2.setUTCHours(value, 0, 0, 0);
        }
        return date2;
      }
    }]);
    return Hour0To11Parser2;
  }(_Parser2.Parser);
  exports2.Hour0To11Parser = Hour0To11Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var require_Hour1To24Parser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.Hour1To24Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour1To24Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour1To24Parser2);
    function Hour1To24Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour1To24Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour1To24Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "k":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour24h, dateString);
          case "ko":
            return match2.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 24;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        var hours = value <= 24 ? value % 24 : value;
        date2.setUTCHours(hours, 0, 0, 0);
        return date2;
      }
    }]);
    return Hour1To24Parser2;
  }(_Parser2.Parser);
  exports2.Hour1To24Parser = Hour1To24Parser;
});

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var require_MinuteParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.MinuteParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var MinuteParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(MinuteParser2, _Parser);
    var _super = (0, _createSuper2.default)(MinuteParser2);
    function MinuteParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, MinuteParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 60);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(MinuteParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "m":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.minute, dateString);
          case "mo":
            return match2.ordinalNumber(dateString, {
              unit: "minute"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMinutes(value, 0, 0);
        return date2;
      }
    }]);
    return MinuteParser2;
  }(_Parser2.Parser);
  exports2.MinuteParser = MinuteParser;
});

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var require_SecondParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.SecondParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var SecondParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(SecondParser2, _Parser);
    var _super = (0, _createSuper2.default)(SecondParser2);
    function SecondParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, SecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 50);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(SecondParser2, [{
      key: "parse",
      value: function parse(dateString, token, match2) {
        switch (token) {
          case "s":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.second, dateString);
          case "so":
            return match2.ordinalNumber(dateString, {
              unit: "second"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCSeconds(value, 0);
        return date2;
      }
    }]);
    return SecondParser2;
  }(_Parser2.Parser);
  exports2.SecondParser = SecondParser;
});

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var require_FractionOfSecondParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.FractionOfSecondParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(FractionOfSecondParser2, _Parser);
    var _super = (0, _createSuper2.default)(FractionOfSecondParser2);
    function FractionOfSecondParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, FractionOfSecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 30);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(FractionOfSecondParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        var valueCallback = function valueCallback(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };
        return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
      }
    }, {
      key: "set",
      value: function set(date2, _flags, value) {
        date2.setUTCMilliseconds(value);
        return date2;
      }
    }]);
    return FractionOfSecondParser2;
  }(_Parser2.Parser);
  exports2.FractionOfSecondParser = FractionOfSecondParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var require_ISOTimezoneWithZParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ISOTimezoneWithZParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOTimezoneWithZParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOTimezoneWithZParser2);
    function ISOTimezoneWithZParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOTimezoneWithZParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T", "x"]);
      return _this;
    }
    (0, _createClass2.default)(ISOTimezoneWithZParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case "X":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
          case "XX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
          case "XXXX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
          case "XXXXX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
          case "XXX":
          default:
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date2, flags, value) {
        if (flags.timestampIsSet) {
          return date2;
        }
        return new Date(date2.getTime() - value);
      }
    }]);
    return ISOTimezoneWithZParser2;
  }(_Parser2.Parser);
  exports2.ISOTimezoneWithZParser = ISOTimezoneWithZParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var require_ISOTimezoneParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.ISOTimezoneParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants3();
  var _utils = require_utils4();
  var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOTimezoneParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOTimezoneParser2);
    function ISOTimezoneParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOTimezoneParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T", "X"]);
      return _this;
    }
    (0, _createClass2.default)(ISOTimezoneParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case "x":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
          case "xx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
          case "xxxx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
          case "xxxxx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
          case "xxx":
          default:
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date2, flags, value) {
        if (flags.timestampIsSet) {
          return date2;
        }
        return new Date(date2.getTime() - value);
      }
    }]);
    return ISOTimezoneParser2;
  }(_Parser2.Parser);
  exports2.ISOTimezoneParser = ISOTimezoneParser;
});

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var require_TimestampSecondsParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.TimestampSecondsParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(TimestampSecondsParser2, _Parser);
    var _super = (0, _createSuper2.default)(TimestampSecondsParser2);
    function TimestampSecondsParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, TimestampSecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 40);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", "*");
      return _this;
    }
    (0, _createClass2.default)(TimestampSecondsParser2, [{
      key: "parse",
      value: function parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampSecondsParser2;
  }(_Parser2.Parser);
  exports2.TimestampSecondsParser = TimestampSecondsParser;
});

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var require_TimestampMillisecondsParser = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.TimestampMillisecondsParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils4();
  var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(TimestampMillisecondsParser2, _Parser);
    var _super = (0, _createSuper2.default)(TimestampMillisecondsParser2);
    function TimestampMillisecondsParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, TimestampMillisecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 20);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", "*");
      return _this;
    }
    (0, _createClass2.default)(TimestampMillisecondsParser2, [{
      key: "parse",
      value: function parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampMillisecondsParser2;
  }(_Parser2.Parser);
  exports2.TimestampMillisecondsParser = TimestampMillisecondsParser;
});

// node_modules/date-fns/parse/_lib/parsers/index.js
var require_parsers = __commonJS((exports2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.parsers = undefined;
  var _EraParser = require_EraParser();
  var _YearParser = require_YearParser();
  var _LocalWeekYearParser = require_LocalWeekYearParser();
  var _ISOWeekYearParser = require_ISOWeekYearParser();
  var _ExtendedYearParser = require_ExtendedYearParser();
  var _QuarterParser = require_QuarterParser();
  var _StandAloneQuarterParser = require_StandAloneQuarterParser();
  var _MonthParser = require_MonthParser();
  var _StandAloneMonthParser = require_StandAloneMonthParser();
  var _LocalWeekParser = require_LocalWeekParser();
  var _ISOWeekParser = require_ISOWeekParser();
  var _DateParser = require_DateParser();
  var _DayOfYearParser = require_DayOfYearParser();
  var _DayParser = require_DayParser();
  var _LocalDayParser = require_LocalDayParser();
  var _StandAloneLocalDayParser = require_StandAloneLocalDayParser();
  var _ISODayParser = require_ISODayParser();
  var _AMPMParser = require_AMPMParser();
  var _AMPMMidnightParser = require_AMPMMidnightParser();
  var _DayPeriodParser = require_DayPeriodParser();
  var _Hour1to12Parser = require_Hour1to12Parser();
  var _Hour0to23Parser = require_Hour0to23Parser();
  var _Hour0To11Parser = require_Hour0To11Parser();
  var _Hour1To24Parser = require_Hour1To24Parser();
  var _MinuteParser = require_MinuteParser();
  var _SecondParser = require_SecondParser();
  var _FractionOfSecondParser = require_FractionOfSecondParser();
  var _ISOTimezoneWithZParser = require_ISOTimezoneWithZParser();
  var _ISOTimezoneParser = require_ISOTimezoneParser();
  var _TimestampSecondsParser = require_TimestampSecondsParser();
  var _TimestampMillisecondsParser = require_TimestampMillisecondsParser();
  var parsers2 = {
    G: new _EraParser.EraParser,
    y: new _YearParser.YearParser,
    Y: new _LocalWeekYearParser.LocalWeekYearParser,
    R: new _ISOWeekYearParser.ISOWeekYearParser,
    u: new _ExtendedYearParser.ExtendedYearParser,
    Q: new _QuarterParser.QuarterParser,
    q: new _StandAloneQuarterParser.StandAloneQuarterParser,
    M: new _MonthParser.MonthParser,
    L: new _StandAloneMonthParser.StandAloneMonthParser,
    w: new _LocalWeekParser.LocalWeekParser,
    I: new _ISOWeekParser.ISOWeekParser,
    d: new _DateParser.DateParser,
    D: new _DayOfYearParser.DayOfYearParser,
    E: new _DayParser.DayParser,
    e: new _LocalDayParser.LocalDayParser,
    c: new _StandAloneLocalDayParser.StandAloneLocalDayParser,
    i: new _ISODayParser.ISODayParser,
    a: new _AMPMParser.AMPMParser,
    b: new _AMPMMidnightParser.AMPMMidnightParser,
    B: new _DayPeriodParser.DayPeriodParser,
    h: new _Hour1to12Parser.Hour1to12Parser,
    H: new _Hour0to23Parser.Hour0to23Parser,
    K: new _Hour0To11Parser.Hour0To11Parser,
    k: new _Hour1To24Parser.Hour1To24Parser,
    m: new _MinuteParser.MinuteParser,
    s: new _SecondParser.SecondParser,
    S: new _FractionOfSecondParser.FractionOfSecondParser,
    X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser,
    x: new _ISOTimezoneParser.ISOTimezoneParser,
    t: new _TimestampSecondsParser.TimestampSecondsParser,
    T: new _TimestampMillisecondsParser.TimestampMillisecondsParser
  };
  exports2.parsers = parsers2;
});

// node_modules/date-fns/parse/index.js
var require_parse2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = parse5;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
  var _index = _interopRequireDefault(require_defaultLocale());
  var _index2 = _interopRequireDefault(require_subMilliseconds());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_assign());
  var _index5 = _interopRequireDefault(require_longFormatters());
  var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index7 = require_protectedTokens();
  var _index8 = _interopRequireDefault(require_toInteger());
  var _index9 = _interopRequireDefault(require_requiredArgs());
  var _Setter = require_Setter();
  var _index10 = require_parsers();
  var _index11 = require_defaultOptions();
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function parse5(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _index9.default)(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var defaultOptions2 = (0, _index11.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions2.locale) !== null && _ref !== undefined ? _ref : _index.default;
    if (!locale.match) {
      throw new RangeError("locale must contain match property");
    }
    var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== undefined ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale3 = options.locale) === null || _options$locale3 === undefined ? undefined : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === undefined ? undefined : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== undefined ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== undefined ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === undefined ? undefined : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === undefined ? undefined : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== undefined ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (formatString === "") {
      if (dateString === "") {
        return (0, _index3.default)(dirtyReferenceDate);
      } else {
        return new Date(NaN);
      }
    }
    var subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    var setters = [new _Setter.DateToSystemTimezoneSetter];
    var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter in _index5.default) {
        var longFormatter = _index5.default[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp);
    var usedTokens = [];
    var _iterator = (0, _createForOfIteratorHelper2.default)(tokens), _step;
    try {
      var _loop = function _loop() {
        var token = _step.value;
        if (!(options !== null && options !== undefined && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(token)) {
          (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
        }
        if (!(options !== null && options !== undefined && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(token)) {
          (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
        }
        var firstCharacter = token[0];
        var parser = _index10.parsers[firstCharacter];
        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;
          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function(usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });
            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
          }
          usedTokens.push({
            token: firstCharacter,
            fullToken: token
          });
          var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
          if (!parseResult) {
            return {
              v: new Date(NaN)
            };
          }
          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
          }
          if (token === "''") {
            token = "'";
          } else if (firstCharacter === "'") {
            token = cleanEscapedString(token);
          }
          if (dateString.indexOf(token) === 0) {
            dateString = dateString.slice(token.length);
          } else {
            return {
              v: new Date(NaN)
            };
          }
        }
      };
      for (_iterator.s();!(_step = _iterator.n()).done; ) {
        var _ret = _loop();
        if ((0, _typeof2.default)(_ret) === "object")
          return _ret.v;
      }
    } catch (err2) {
      _iterator.e(err2);
    } finally {
      _iterator.f();
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }
    var uniquePrioritySetters = setters.map(function(setter2) {
      return setter2.priority;
    }).sort(function(a, b2) {
      return b2 - a;
    }).filter(function(priority, index, array) {
      return array.indexOf(priority) === index;
    }).map(function(priority) {
      return setters.filter(function(setter2) {
        return setter2.priority === priority;
      }).sort(function(a, b2) {
        return b2.subPriority - a.subPriority;
      });
    }).map(function(setterArray) {
      return setterArray[0];
    });
    var date2 = (0, _index3.default)(dirtyReferenceDate);
    if (isNaN(date2.getTime())) {
      return new Date(NaN);
    }
    var utcDate = (0, _index2.default)(date2, (0, _index6.default)(date2));
    var flags = {};
    var _iterator2 = (0, _createForOfIteratorHelper2.default)(uniquePrioritySetters), _step2;
    try {
      for (_iterator2.s();!(_step2 = _iterator2.n()).done; ) {
        var setter = _step2.value;
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }
        var result = setter.set(utcDate, flags, subFnOptions);
        if (Array.isArray(result)) {
          utcDate = result[0];
          (0, _index4.default)(flags, result[1]);
        } else {
          utcDate = result;
        }
      }
    } catch (err2) {
      _iterator2.e(err2);
    } finally {
      _iterator2.f();
    }
    return utcDate;
  }
  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isMatch/index.js
var require_isMatch = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isMatch;
  var _index = _interopRequireDefault(require_parse2());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isMatch(dateString, formatString, options) {
    (0, _index3.default)(2, arguments);
    return (0, _index2.default)((0, _index.default)(dateString, formatString, new Date, options));
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isMonday/index.js
var require_isMonday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isMonday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isMonday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2).getDay() === 1;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isPast/index.js
var require_isPast = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isPast;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isPast(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getTime() < Date.now();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfHour/index.js
var require_startOfHour = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfHour;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setMinutes(0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameHour/index.js
var require_isSameHour = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameHour;
  var _index = _interopRequireDefault(require_startOfHour());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameHour(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfHour = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfHour = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameWeek/index.js
var require_isSameWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfWeek = (0, _index.default)(dirtyDateLeft, options);
    var dateRightStartOfWeek = (0, _index.default)(dirtyDateRight, options);
    return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameISOWeek/index.js
var require_isSameISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameISOWeek;
  var _index = _interopRequireDefault(require_isSameWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dirtyDateLeft, dirtyDateRight, {
      weekStartsOn: 1
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameISOWeekYear/index.js
var require_isSameISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameISOWeekYear;
  var _index = _interopRequireDefault(require_startOfISOWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfYear = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfYear = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameMinute/index.js
var require_isSameMinute = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameMinute;
  var _index = _interopRequireDefault(require_startOfMinute());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameMinute(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfMinute = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfMinute = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameMonth/index.js
var require_isSameMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameMonth(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameQuarter/index.js
var require_isSameQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameQuarter;
  var _index = _interopRequireDefault(require_startOfQuarter());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfQuarter = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfQuarter = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfSecond/index.js
var require_startOfSecond = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfSecond;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    date2.setMilliseconds(0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameSecond/index.js
var require_isSameSecond = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameSecond;
  var _index = _interopRequireDefault(require_startOfSecond());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameSecond(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfSecond = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfSecond = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isSameYear/index.js
var require_isSameYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isSameYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameYear(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear();
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisHour/index.js
var require_isThisHour = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisHour;
  var _index = _interopRequireDefault(require_isSameHour());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisISOWeek/index.js
var require_isThisISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisISOWeek;
  var _index = _interopRequireDefault(require_isSameISOWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisMinute/index.js
var require_isThisMinute = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisMinute;
  var _index = _interopRequireDefault(require_isSameMinute());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisMonth/index.js
var require_isThisMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisMonth;
  var _index = _interopRequireDefault(require_isSameMonth());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisQuarter/index.js
var require_isThisQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisQuarter;
  var _index = _interopRequireDefault(require_isSameQuarter());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisSecond/index.js
var require_isThisSecond = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisSecond;
  var _index = _interopRequireDefault(require_isSameSecond());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisWeek/index.js
var require_isThisWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisWeek;
  var _index = _interopRequireDefault(require_isSameWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisWeek(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThisYear/index.js
var require_isThisYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThisYear;
  var _index = _interopRequireDefault(require_isSameYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isThursday/index.js
var require_isThursday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isThursday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThursday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 4;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isToday/index.js
var require_isToday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isToday;
  var _index = _interopRequireDefault(require_isSameDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isToday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isTomorrow/index.js
var require_isTomorrow = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isTomorrow;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_isSameDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isTomorrow(dirtyDate) {
    (0, _index3.default)(1, arguments);
    return (0, _index2.default)(dirtyDate, (0, _index.default)(Date.now(), 1));
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isTuesday/index.js
var require_isTuesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isTuesday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isTuesday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isWednesday/index.js
var require_isWednesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isWednesday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWednesday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 3;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isWithinInterval/index.js
var require_isWithinInterval = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isWithinInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWithinInterval(dirtyDate, interval2) {
    (0, _index2.default)(2, arguments);
    var time2 = (0, _index.default)(dirtyDate).getTime();
    var startTime = (0, _index.default)(interval2.start).getTime();
    var endTime = (0, _index.default)(interval2.end).getTime();
    if (!(startTime <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    return time2 >= startTime && time2 <= endTime;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subDays/index.js
var require_subDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subDays;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subDays(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/isYesterday/index.js
var require_isYesterday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isYesterday;
  var _index = _interopRequireDefault(require_isSameDay());
  var _index2 = _interopRequireDefault(require_subDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isYesterday(dirtyDate) {
    (0, _index3.default)(1, arguments);
    return (0, _index.default)(dirtyDate, (0, _index2.default)(Date.now(), 1));
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfDecade/index.js
var require_lastDayOfDecade = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var decade = 9 + Math.floor(year / 10) * 10;
    date2.setFullYear(decade + 1, 0, 0);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfWeek/index.js
var require_lastDayOfWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_defaultOptions();
  function lastDayOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index3.default)(1, arguments);
    var defaultOptions2 = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6");
    }
    var date2 = (0, _index.default)(dirtyDate);
    var day = date2.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date2.setHours(0, 0, 0, 0);
    date2.setDate(date2.getDate() + diff);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfISOWeek/index.js
var require_lastDayOfISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfISOWeek;
  var _index = _interopRequireDefault(require_lastDayOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfISOWeekYear/index.js
var require_lastDayOfISOWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year + 1, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date2 = (0, _index2.default)(fourthOfJanuary);
    date2.setDate(date2.getDate() - 1);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfQuarter/index.js
var require_lastDayOfQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var currentMonth = date2.getMonth();
    var month = currentMonth - currentMonth % 3 + 3;
    date2.setMonth(month, 0);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lastDayOfYear/index.js
var require_lastDayOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lastDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    date2.setFullYear(year + 1, 0, 0);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/lightFormat/index.js
var require_lightFormat = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = lightFormat;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_lightFormatters());
  var _index3 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index4 = _interopRequireDefault(require_isValid());
  var _index5 = _interopRequireDefault(require_subMilliseconds());
  var _index6 = _interopRequireDefault(require_requiredArgs());
  var formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function lightFormat(dirtyDate, formatStr) {
    (0, _index6.default)(2, arguments);
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index4.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var timezoneOffset = (0, _index3.default)(originalDate);
    var utcDate = (0, _index5.default)(originalDate, timezoneOffset);
    var tokens = formatStr.match(formattingTokensRegExp);
    if (!tokens)
      return "";
    var result = tokens.map(function(substring) {
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }
      var formatter = _index2.default[firstCharacter];
      if (formatter) {
        return formatter(utcDate, substring);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      return substring;
    }).join("");
    return result;
  }
  function cleanEscapedString(input) {
    var matches = input.match(escapedStringRegExp);
    if (!matches) {
      return input;
    }
    return matches[1].replace(doubleQuoteRegExp, "'");
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/milliseconds/index.js
var require_milliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = milliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var daysInYear = 365.2425;
  function milliseconds(_ref) {
    var { years, months, weeks, days, hours, minutes, seconds } = _ref;
    (0, _index.default)(1, arguments);
    var totalDays = 0;
    if (years)
      totalDays += years * daysInYear;
    if (months)
      totalDays += months * (daysInYear / 12);
    if (weeks)
      totalDays += weeks * 7;
    if (days)
      totalDays += days;
    var totalSeconds = totalDays * 24 * 60 * 60;
    if (hours)
      totalSeconds += hours * 60 * 60;
    if (minutes)
      totalSeconds += minutes * 60;
    if (seconds)
      totalSeconds += seconds;
    return Math.round(totalSeconds * 1000);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/millisecondsToHours/index.js
var require_millisecondsToHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = millisecondsToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function millisecondsToHours(milliseconds) {
    (0, _index.default)(1, arguments);
    var hours = milliseconds / _index2.millisecondsInHour;
    return Math.floor(hours);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/millisecondsToMinutes/index.js
var require_millisecondsToMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = millisecondsToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function millisecondsToMinutes(milliseconds) {
    (0, _index.default)(1, arguments);
    var minutes = milliseconds / _index2.millisecondsInMinute;
    return Math.floor(minutes);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/millisecondsToSeconds/index.js
var require_millisecondsToSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = millisecondsToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function millisecondsToSeconds(milliseconds) {
    (0, _index.default)(1, arguments);
    var seconds = milliseconds / _index2.millisecondsInSecond;
    return Math.floor(seconds);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/minutesToHours/index.js
var require_minutesToHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = minutesToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function minutesToHours(minutes) {
    (0, _index.default)(1, arguments);
    var hours = minutes / _index2.minutesInHour;
    return Math.floor(hours);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/minutesToMilliseconds/index.js
var require_minutesToMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = minutesToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function minutesToMilliseconds(minutes) {
    (0, _index.default)(1, arguments);
    return Math.floor(minutes * _index2.millisecondsInMinute);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/minutesToSeconds/index.js
var require_minutesToSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = minutesToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function minutesToSeconds(minutes) {
    (0, _index.default)(1, arguments);
    return Math.floor(minutes * _index2.secondsInMinute);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/monthsToQuarters/index.js
var require_monthsToQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = monthsToQuarters;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function monthsToQuarters(months) {
    (0, _index.default)(1, arguments);
    var quarters = months / _index2.monthsInQuarter;
    return Math.floor(quarters);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/monthsToYears/index.js
var require_monthsToYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = monthsToYears;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function monthsToYears(months) {
    (0, _index.default)(1, arguments);
    var years = months / _index2.monthsInYear;
    return Math.floor(years);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextDay/index.js
var require_nextDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextDay;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_getDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function nextDay(date2, day) {
    (0, _index3.default)(2, arguments);
    var delta = day - (0, _index2.default)(date2);
    if (delta <= 0)
      delta += 7;
    return (0, _index.default)(date2, delta);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextFriday/index.js
var require_nextFriday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextFriday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextFriday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 5);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextMonday/index.js
var require_nextMonday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextMonday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextMonday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 1);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextSaturday/index.js
var require_nextSaturday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextSaturday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextSaturday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 6);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextSunday/index.js
var require_nextSunday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextSunday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextSunday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 0);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextThursday/index.js
var require_nextThursday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextThursday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextThursday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 4);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextTuesday/index.js
var require_nextTuesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextTuesday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextTuesday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 2);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/nextWednesday/index.js
var require_nextWednesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = nextWednesday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextWednesday(date2) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date2, 3);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parseISO/index.js
var require_parseISO = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = parseISO;
  var _index = require_constants2();
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function parseISO(argument, options) {
    var _options$additionalDi;
    (0, _index2.default)(1, arguments);
    var additionalDigits = (0, _index3.default)((_options$additionalDi = options === null || options === undefined ? undefined : options.additionalDigits) !== null && _options$additionalDi !== undefined ? _options$additionalDi : 2);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
      return new Date(NaN);
    }
    var dateStrings = splitDateString(argument);
    var date2;
    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date2 = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date2 || isNaN(date2.getTime())) {
      return new Date(NaN);
    }
    var timestamp2 = date2.getTime();
    var time2 = 0;
    var offset;
    if (dateStrings.time) {
      time2 = parseTime(dateStrings.time);
      if (isNaN(time2)) {
        return new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var dirtyDate = new Date(timestamp2 + time2);
      var result = new Date(0);
      result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
      result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
      return result;
    }
    return new Date(timestamp2 + time2 + offset);
  }
  var patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex2 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex2 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    var dateStrings = {};
    var array = dateString.split(patterns.dateTimeDelimiter);
    var timeString;
    if (array.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }
    if (timeString) {
      var token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex);
    if (!captures)
      return {
        year: NaN,
        restDateString: ""
      };
    var year = captures[1] ? parseInt(captures[1]) : null;
    var century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null)
      return new Date(NaN);
    var captures = dateString.match(dateRegex2);
    if (!captures)
      return new Date(NaN);
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date2 = new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }
      date2.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date2;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    var captures = timeString.match(timeRegex2);
    if (!captures)
      return NaN;
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1000;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
      return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures)
      return 0;
    var sign = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date2 = new Date(0);
    date2.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date2.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date2.setUTCDate(date2.getUTCDate() + diff);
    return date2;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date2) {
    return month >= 0 && month <= 11 && date2 >= 1 && date2 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/parseJSON/index.js
var require_parseJSON = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = parseJSON;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function parseJSON(argument) {
    (0, _index2.default)(1, arguments);
    if (typeof argument === "string") {
      var parts = argument.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
      if (parts) {
        return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1), +parts[6], +((parts[7] || "0") + "00").substring(0, 3)));
      }
      return new Date(NaN);
    }
    return (0, _index.default)(argument);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousDay/index.js
var require_previousDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousDay;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_getDay());
  var _index3 = _interopRequireDefault(require_subDays());
  function previousDay(date2, day) {
    (0, _index.default)(2, arguments);
    var delta = (0, _index2.default)(date2) - day;
    if (delta <= 0)
      delta += 7;
    return (0, _index3.default)(date2, delta);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousFriday/index.js
var require_previousFriday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousFriday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousFriday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 5);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousMonday/index.js
var require_previousMonday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousMonday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousMonday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 1);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousSaturday/index.js
var require_previousSaturday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousSaturday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousSaturday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 6);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousSunday/index.js
var require_previousSunday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousSunday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousSunday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 0);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousThursday/index.js
var require_previousThursday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousThursday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousThursday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 4);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousTuesday/index.js
var require_previousTuesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousTuesday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousTuesday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 2);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/previousWednesday/index.js
var require_previousWednesday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = previousWednesday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousWednesday(date2) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date2, 3);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/quartersToMonths/index.js
var require_quartersToMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = quartersToMonths;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function quartersToMonths(quarters) {
    (0, _index.default)(1, arguments);
    return Math.floor(quarters * _index2.monthsInQuarter);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/quartersToYears/index.js
var require_quartersToYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = quartersToYears;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function quartersToYears(quarters) {
    (0, _index.default)(1, arguments);
    var years = quarters / _index2.quartersInYear;
    return Math.floor(years);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/roundToNearestMinutes/index.js
var require_roundToNearestMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = roundToNearestMinutes;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = require_roundingMethods();
  var _index3 = _interopRequireDefault(require_toInteger());
  function roundToNearestMinutes(dirtyDate, options) {
    var _options$nearestTo;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only none provided present");
    }
    var nearestTo = (0, _index3.default)((_options$nearestTo = options === null || options === undefined ? undefined : options.nearestTo) !== null && _options$nearestTo !== undefined ? _options$nearestTo : 1);
    if (nearestTo < 1 || nearestTo > 30) {
      throw new RangeError("`options.nearestTo` must be between 1 and 30");
    }
    var date2 = (0, _index.default)(dirtyDate);
    var seconds = date2.getSeconds();
    var minutes = date2.getMinutes() + seconds / 60;
    var roundingMethod = (0, _index2.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod);
    var roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
    var remainderMinutes = minutes % nearestTo;
    var addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
    return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), date2.getHours(), roundedMinutes + addedMinutes);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/secondsToHours/index.js
var require_secondsToHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = secondsToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function secondsToHours(seconds) {
    (0, _index.default)(1, arguments);
    var hours = seconds / _index2.secondsInHour;
    return Math.floor(hours);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/secondsToMilliseconds/index.js
var require_secondsToMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = secondsToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function secondsToMilliseconds(seconds) {
    (0, _index.default)(1, arguments);
    return seconds * _index2.millisecondsInSecond;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/secondsToMinutes/index.js
var require_secondsToMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = secondsToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function secondsToMinutes(seconds) {
    (0, _index.default)(1, arguments);
    var minutes = seconds / _index2.secondsInMinute;
    return Math.floor(minutes);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setMonth/index.js
var require_setMonth = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setMonth;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getDaysInMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setMonth(dirtyDate, dirtyMonth) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var month = (0, _index.default)(dirtyMonth);
    var year = date2.getFullYear();
    var day = date2.getDate();
    var dateWithDesiredMonth = new Date(0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    var daysInMonth = (0, _index3.default)(dateWithDesiredMonth);
    date2.setMonth(month, Math.min(day, daysInMonth));
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/set/index.js
var require_set2 = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = set;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_setMonth());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function set(dirtyDate, values2) {
    (0, _index4.default)(2, arguments);
    if ((0, _typeof2.default)(values2) !== "object" || values2 === null) {
      throw new RangeError("values parameter must be an object");
    }
    var date2 = (0, _index.default)(dirtyDate);
    if (isNaN(date2.getTime())) {
      return new Date(NaN);
    }
    if (values2.year != null) {
      date2.setFullYear(values2.year);
    }
    if (values2.month != null) {
      date2 = (0, _index2.default)(date2, values2.month);
    }
    if (values2.date != null) {
      date2.setDate((0, _index3.default)(values2.date));
    }
    if (values2.hours != null) {
      date2.setHours((0, _index3.default)(values2.hours));
    }
    if (values2.minutes != null) {
      date2.setMinutes((0, _index3.default)(values2.minutes));
    }
    if (values2.seconds != null) {
      date2.setSeconds((0, _index3.default)(values2.seconds));
    }
    if (values2.milliseconds != null) {
      date2.setMilliseconds((0, _index3.default)(values2.milliseconds));
    }
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setDate/index.js
var require_setDate = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setDate;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setDate(dirtyDate, dirtyDayOfMonth) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var dayOfMonth = (0, _index.default)(dirtyDayOfMonth);
    date2.setDate(dayOfMonth);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setDay/index.js
var require_setDay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setDay;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function setDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(2, arguments);
    var defaultOptions2 = (0, _index5.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date2 = (0, _index2.default)(dirtyDate);
    var day = (0, _index3.default)(dirtyDay);
    var currentDay = date2.getDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var delta = 7 - weekStartsOn;
    var diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
    return (0, _index.default)(date2, diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setDayOfYear/index.js
var require_setDayOfYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setDayOfYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setDayOfYear(dirtyDate, dirtyDayOfYear) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var dayOfYear = (0, _index.default)(dirtyDayOfYear);
    date2.setMonth(0);
    date2.setDate(dayOfYear);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setDefaultOptions/index.js
var require_setDefaultOptions = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setDefaultOptions;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function setDefaultOptions(newOptions) {
    (0, _index2.default)(1, arguments);
    var result = {};
    var defaultOptions2 = (0, _index.getDefaultOptions)();
    for (var property in defaultOptions2) {
      if (Object.prototype.hasOwnProperty.call(defaultOptions2, property)) {
        result[property] = defaultOptions2[property];
      }
    }
    for (var _property in newOptions) {
      if (Object.prototype.hasOwnProperty.call(newOptions, _property)) {
        if (newOptions[_property] === undefined) {
          delete result[_property];
        } else {
          result[_property] = newOptions[_property];
        }
      }
    }
    (0, _index.setDefaultOptions)(result);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setHours/index.js
var require_setHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setHours;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setHours(dirtyDate, dirtyHours) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var hours = (0, _index.default)(dirtyHours);
    date2.setHours(hours);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setISODay/index.js
var require_setISODay = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setISODay;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_addDays());
  var _index4 = _interopRequireDefault(require_getISODay());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function setISODay(dirtyDate, dirtyDay) {
    (0, _index5.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var day = (0, _index.default)(dirtyDay);
    var currentDay = (0, _index4.default)(date2);
    var diff = day - currentDay;
    return (0, _index3.default)(date2, diff);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setISOWeek/index.js
var require_setISOWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setISOWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getISOWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setISOWeek(dirtyDate, dirtyISOWeek) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var isoWeek = (0, _index.default)(dirtyISOWeek);
    var diff = (0, _index3.default)(date2) - isoWeek;
    date2.setDate(date2.getDate() - diff * 7);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setMilliseconds/index.js
var require_setMilliseconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setMilliseconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setMilliseconds(dirtyDate, dirtyMilliseconds) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var milliseconds = (0, _index.default)(dirtyMilliseconds);
    date2.setMilliseconds(milliseconds);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setMinutes/index.js
var require_setMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setMinutes;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setMinutes(dirtyDate, dirtyMinutes) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var minutes = (0, _index.default)(dirtyMinutes);
    date2.setMinutes(minutes);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setQuarter/index.js
var require_setQuarter = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setQuarter;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_setMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setQuarter(dirtyDate, dirtyQuarter) {
    (0, _index4.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var quarter = (0, _index.default)(dirtyQuarter);
    var oldQuarter = Math.floor(date2.getMonth() / 3) + 1;
    var diff = quarter - oldQuarter;
    return (0, _index3.default)(date2, date2.getMonth() + diff * 3);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setSeconds/index.js
var require_setSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setSeconds(dirtyDate, dirtySeconds) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var seconds = (0, _index.default)(dirtySeconds);
    date2.setSeconds(seconds);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setWeek/index.js
var require_setWeek = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setWeek;
  var _index = _interopRequireDefault(require_getWeek());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = _interopRequireDefault(require_toInteger());
  function setWeek(dirtyDate, dirtyWeek, options) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var week = (0, _index4.default)(dirtyWeek);
    var diff = (0, _index.default)(date2, options) - week;
    date2.setDate(date2.getDate() - diff * 7);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setWeekYear/index.js
var require_setWeekYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setWeekYear;
  var _index = _interopRequireDefault(require_differenceInCalendarDays());
  var _index2 = _interopRequireDefault(require_startOfWeekYear());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  var _index6 = require_defaultOptions();
  function setWeekYear(dirtyDate, dirtyWeekYear, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index5.default)(2, arguments);
    var defaultOptions2 = (0, _index6.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var date2 = (0, _index3.default)(dirtyDate);
    var weekYear = (0, _index4.default)(dirtyWeekYear);
    var diff = (0, _index.default)(date2, (0, _index2.default)(date2, options));
    var firstWeek = new Date(0);
    firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    date2 = (0, _index2.default)(firstWeek, options);
    date2.setDate(date2.getDate() + diff);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/setYear/index.js
var require_setYear = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = setYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setYear(dirtyDate, dirtyYear) {
    (0, _index3.default)(2, arguments);
    var date2 = (0, _index2.default)(dirtyDate);
    var year = (0, _index.default)(dirtyYear);
    if (isNaN(date2.getTime())) {
      return new Date(NaN);
    }
    date2.setFullYear(year);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfDecade/index.js
var require_startOfDecade = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date2 = (0, _index.default)(dirtyDate);
    var year = date2.getFullYear();
    var decade = Math.floor(year / 10) * 10;
    date2.setFullYear(decade, 0, 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfToday/index.js
var require_startOfToday = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfToday;
  var _index = _interopRequireDefault(require_startOfDay());
  function startOfToday() {
    return (0, _index.default)(Date.now());
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfTomorrow/index.js
var require_startOfTomorrow = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfTomorrow;
  function startOfTomorrow() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date2 = new Date(0);
    date2.setFullYear(year, month, day + 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/startOfYesterday/index.js
var require_startOfYesterday = __commonJS((exports2, module2) => {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = startOfYesterday;
  function startOfYesterday() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date2 = new Date(0);
    date2.setFullYear(year, month, day - 1);
    date2.setHours(0, 0, 0, 0);
    return date2;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subMonths/index.js
var require_subMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subMonths;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subMonths(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/sub/index.js
var require_sub = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = sub;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_subDays());
  var _index2 = _interopRequireDefault(require_subMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = _interopRequireDefault(require_toInteger());
  function sub(date2, duration) {
    (0, _index3.default)(2, arguments);
    if (!duration || (0, _typeof2.default)(duration) !== "object")
      return new Date(NaN);
    var years = duration.years ? (0, _index4.default)(duration.years) : 0;
    var months = duration.months ? (0, _index4.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _index4.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _index4.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _index4.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _index4.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _index4.default)(duration.seconds) : 0;
    var dateWithoutMonths = (0, _index2.default)(date2, months + years * 12);
    var dateWithoutDays = (0, _index.default)(dateWithoutMonths, days + weeks * 7);
    var minutestoSub = minutes + hours * 60;
    var secondstoSub = seconds + minutestoSub * 60;
    var mstoSub = secondstoSub * 1000;
    var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
    return finalDate;
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subBusinessDays/index.js
var require_subBusinessDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subBusinessDays;
  var _index = _interopRequireDefault(require_addBusinessDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subBusinessDays(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subHours/index.js
var require_subHours = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subHours;
  var _index = _interopRequireDefault(require_addHours());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subHours(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subMinutes/index.js
var require_subMinutes = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subMinutes;
  var _index = _interopRequireDefault(require_addMinutes());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subMinutes(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subQuarters/index.js
var require_subQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subQuarters;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addQuarters());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subQuarters(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subSeconds/index.js
var require_subSeconds = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addSeconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subSeconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subWeeks/index.js
var require_subWeeks = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subWeeks;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addWeeks());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subWeeks(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/subYears/index.js
var require_subYears = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = subYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addYears());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subYears(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/weeksToDays/index.js
var require_weeksToDays = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = weeksToDays;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function weeksToDays(weeks) {
    (0, _index.default)(1, arguments);
    return Math.floor(weeks * _index2.daysInWeek);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/yearsToMonths/index.js
var require_yearsToMonths = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = yearsToMonths;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function yearsToMonths(years) {
    (0, _index.default)(1, arguments);
    return Math.floor(years * _index2.monthsInYear);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/yearsToQuarters/index.js
var require_yearsToQuarters = __commonJS((exports2, module2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = yearsToQuarters;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants2();
  function yearsToQuarters(years) {
    (0, _index.default)(1, arguments);
    return Math.floor(years * _index2.quartersInYear);
  }
  module2.exports = exports2.default;
});

// node_modules/date-fns/index.js
var require_date_fns = __commonJS((exports2) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var _exportNames = {
    add: true,
    addBusinessDays: true,
    addDays: true,
    addHours: true,
    addISOWeekYears: true,
    addMilliseconds: true,
    addMinutes: true,
    addMonths: true,
    addQuarters: true,
    addSeconds: true,
    addWeeks: true,
    addYears: true,
    areIntervalsOverlapping: true,
    clamp: true,
    closestIndexTo: true,
    closestTo: true,
    compareAsc: true,
    compareDesc: true,
    daysToWeeks: true,
    differenceInBusinessDays: true,
    differenceInCalendarDays: true,
    differenceInCalendarISOWeekYears: true,
    differenceInCalendarISOWeeks: true,
    differenceInCalendarMonths: true,
    differenceInCalendarQuarters: true,
    differenceInCalendarWeeks: true,
    differenceInCalendarYears: true,
    differenceInDays: true,
    differenceInHours: true,
    differenceInISOWeekYears: true,
    differenceInMilliseconds: true,
    differenceInMinutes: true,
    differenceInMonths: true,
    differenceInQuarters: true,
    differenceInSeconds: true,
    differenceInWeeks: true,
    differenceInYears: true,
    eachDayOfInterval: true,
    eachHourOfInterval: true,
    eachMinuteOfInterval: true,
    eachMonthOfInterval: true,
    eachQuarterOfInterval: true,
    eachWeekOfInterval: true,
    eachWeekendOfInterval: true,
    eachWeekendOfMonth: true,
    eachWeekendOfYear: true,
    eachYearOfInterval: true,
    endOfDay: true,
    endOfDecade: true,
    endOfHour: true,
    endOfISOWeek: true,
    endOfISOWeekYear: true,
    endOfMinute: true,
    endOfMonth: true,
    endOfQuarter: true,
    endOfSecond: true,
    endOfToday: true,
    endOfTomorrow: true,
    endOfWeek: true,
    endOfYear: true,
    endOfYesterday: true,
    format: true,
    formatDistance: true,
    formatDistanceStrict: true,
    formatDistanceToNow: true,
    formatDistanceToNowStrict: true,
    formatDuration: true,
    formatISO: true,
    formatISO9075: true,
    formatISODuration: true,
    formatRFC3339: true,
    formatRFC7231: true,
    formatRelative: true,
    fromUnixTime: true,
    getDate: true,
    getDay: true,
    getDayOfYear: true,
    getDaysInMonth: true,
    getDaysInYear: true,
    getDecade: true,
    getDefaultOptions: true,
    getHours: true,
    getISODay: true,
    getISOWeek: true,
    getISOWeekYear: true,
    getISOWeeksInYear: true,
    getMilliseconds: true,
    getMinutes: true,
    getMonth: true,
    getOverlappingDaysInIntervals: true,
    getQuarter: true,
    getSeconds: true,
    getTime: true,
    getUnixTime: true,
    getWeek: true,
    getWeekOfMonth: true,
    getWeekYear: true,
    getWeeksInMonth: true,
    getYear: true,
    hoursToMilliseconds: true,
    hoursToMinutes: true,
    hoursToSeconds: true,
    intervalToDuration: true,
    intlFormat: true,
    intlFormatDistance: true,
    isAfter: true,
    isBefore: true,
    isDate: true,
    isEqual: true,
    isExists: true,
    isFirstDayOfMonth: true,
    isFriday: true,
    isFuture: true,
    isLastDayOfMonth: true,
    isLeapYear: true,
    isMatch: true,
    isMonday: true,
    isPast: true,
    isSameDay: true,
    isSameHour: true,
    isSameISOWeek: true,
    isSameISOWeekYear: true,
    isSameMinute: true,
    isSameMonth: true,
    isSameQuarter: true,
    isSameSecond: true,
    isSameWeek: true,
    isSameYear: true,
    isSaturday: true,
    isSunday: true,
    isThisHour: true,
    isThisISOWeek: true,
    isThisMinute: true,
    isThisMonth: true,
    isThisQuarter: true,
    isThisSecond: true,
    isThisWeek: true,
    isThisYear: true,
    isThursday: true,
    isToday: true,
    isTomorrow: true,
    isTuesday: true,
    isValid: true,
    isWednesday: true,
    isWeekend: true,
    isWithinInterval: true,
    isYesterday: true,
    lastDayOfDecade: true,
    lastDayOfISOWeek: true,
    lastDayOfISOWeekYear: true,
    lastDayOfMonth: true,
    lastDayOfQuarter: true,
    lastDayOfWeek: true,
    lastDayOfYear: true,
    lightFormat: true,
    max: true,
    milliseconds: true,
    millisecondsToHours: true,
    millisecondsToMinutes: true,
    millisecondsToSeconds: true,
    min: true,
    minutesToHours: true,
    minutesToMilliseconds: true,
    minutesToSeconds: true,
    monthsToQuarters: true,
    monthsToYears: true,
    nextDay: true,
    nextFriday: true,
    nextMonday: true,
    nextSaturday: true,
    nextSunday: true,
    nextThursday: true,
    nextTuesday: true,
    nextWednesday: true,
    parse: true,
    parseISO: true,
    parseJSON: true,
    previousDay: true,
    previousFriday: true,
    previousMonday: true,
    previousSaturday: true,
    previousSunday: true,
    previousThursday: true,
    previousTuesday: true,
    previousWednesday: true,
    quartersToMonths: true,
    quartersToYears: true,
    roundToNearestMinutes: true,
    secondsToHours: true,
    secondsToMilliseconds: true,
    secondsToMinutes: true,
    set: true,
    setDate: true,
    setDay: true,
    setDayOfYear: true,
    setDefaultOptions: true,
    setHours: true,
    setISODay: true,
    setISOWeek: true,
    setISOWeekYear: true,
    setMilliseconds: true,
    setMinutes: true,
    setMonth: true,
    setQuarter: true,
    setSeconds: true,
    setWeek: true,
    setWeekYear: true,
    setYear: true,
    startOfDay: true,
    startOfDecade: true,
    startOfHour: true,
    startOfISOWeek: true,
    startOfISOWeekYear: true,
    startOfMinute: true,
    startOfMonth: true,
    startOfQuarter: true,
    startOfSecond: true,
    startOfToday: true,
    startOfTomorrow: true,
    startOfWeek: true,
    startOfWeekYear: true,
    startOfYear: true,
    startOfYesterday: true,
    sub: true,
    subBusinessDays: true,
    subDays: true,
    subHours: true,
    subISOWeekYears: true,
    subMilliseconds: true,
    subMinutes: true,
    subMonths: true,
    subQuarters: true,
    subSeconds: true,
    subWeeks: true,
    subYears: true,
    toDate: true,
    weeksToDays: true,
    yearsToMonths: true,
    yearsToQuarters: true
  };
  Object.defineProperty(exports2, "add", {
    enumerable: true,
    get: function get() {
      return _index.default;
    }
  });
  Object.defineProperty(exports2, "addBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index2.default;
    }
  });
  Object.defineProperty(exports2, "addDays", {
    enumerable: true,
    get: function get() {
      return _index3.default;
    }
  });
  Object.defineProperty(exports2, "addHours", {
    enumerable: true,
    get: function get() {
      return _index4.default;
    }
  });
  Object.defineProperty(exports2, "addISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index5.default;
    }
  });
  Object.defineProperty(exports2, "addMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index6.default;
    }
  });
  Object.defineProperty(exports2, "addMinutes", {
    enumerable: true,
    get: function get() {
      return _index7.default;
    }
  });
  Object.defineProperty(exports2, "addMonths", {
    enumerable: true,
    get: function get() {
      return _index8.default;
    }
  });
  Object.defineProperty(exports2, "addQuarters", {
    enumerable: true,
    get: function get() {
      return _index9.default;
    }
  });
  Object.defineProperty(exports2, "addSeconds", {
    enumerable: true,
    get: function get() {
      return _index10.default;
    }
  });
  Object.defineProperty(exports2, "addWeeks", {
    enumerable: true,
    get: function get() {
      return _index11.default;
    }
  });
  Object.defineProperty(exports2, "addYears", {
    enumerable: true,
    get: function get() {
      return _index12.default;
    }
  });
  Object.defineProperty(exports2, "areIntervalsOverlapping", {
    enumerable: true,
    get: function get() {
      return _index13.default;
    }
  });
  Object.defineProperty(exports2, "clamp", {
    enumerable: true,
    get: function get() {
      return _index14.default;
    }
  });
  Object.defineProperty(exports2, "closestIndexTo", {
    enumerable: true,
    get: function get() {
      return _index15.default;
    }
  });
  Object.defineProperty(exports2, "closestTo", {
    enumerable: true,
    get: function get() {
      return _index16.default;
    }
  });
  Object.defineProperty(exports2, "compareAsc", {
    enumerable: true,
    get: function get() {
      return _index17.default;
    }
  });
  Object.defineProperty(exports2, "compareDesc", {
    enumerable: true,
    get: function get() {
      return _index18.default;
    }
  });
  Object.defineProperty(exports2, "daysToWeeks", {
    enumerable: true,
    get: function get() {
      return _index19.default;
    }
  });
  Object.defineProperty(exports2, "differenceInBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index20.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarDays", {
    enumerable: true,
    get: function get() {
      return _index21.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index22.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarISOWeeks", {
    enumerable: true,
    get: function get() {
      return _index23.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarMonths", {
    enumerable: true,
    get: function get() {
      return _index24.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarQuarters", {
    enumerable: true,
    get: function get() {
      return _index25.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarWeeks", {
    enumerable: true,
    get: function get() {
      return _index26.default;
    }
  });
  Object.defineProperty(exports2, "differenceInCalendarYears", {
    enumerable: true,
    get: function get() {
      return _index27.default;
    }
  });
  Object.defineProperty(exports2, "differenceInDays", {
    enumerable: true,
    get: function get() {
      return _index28.default;
    }
  });
  Object.defineProperty(exports2, "differenceInHours", {
    enumerable: true,
    get: function get() {
      return _index29.default;
    }
  });
  Object.defineProperty(exports2, "differenceInISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index30.default;
    }
  });
  Object.defineProperty(exports2, "differenceInMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index31.default;
    }
  });
  Object.defineProperty(exports2, "differenceInMinutes", {
    enumerable: true,
    get: function get() {
      return _index32.default;
    }
  });
  Object.defineProperty(exports2, "differenceInMonths", {
    enumerable: true,
    get: function get() {
      return _index33.default;
    }
  });
  Object.defineProperty(exports2, "differenceInQuarters", {
    enumerable: true,
    get: function get() {
      return _index34.default;
    }
  });
  Object.defineProperty(exports2, "differenceInSeconds", {
    enumerable: true,
    get: function get() {
      return _index35.default;
    }
  });
  Object.defineProperty(exports2, "differenceInWeeks", {
    enumerable: true,
    get: function get() {
      return _index36.default;
    }
  });
  Object.defineProperty(exports2, "differenceInYears", {
    enumerable: true,
    get: function get() {
      return _index37.default;
    }
  });
  Object.defineProperty(exports2, "eachDayOfInterval", {
    enumerable: true,
    get: function get() {
      return _index38.default;
    }
  });
  Object.defineProperty(exports2, "eachHourOfInterval", {
    enumerable: true,
    get: function get() {
      return _index39.default;
    }
  });
  Object.defineProperty(exports2, "eachMinuteOfInterval", {
    enumerable: true,
    get: function get() {
      return _index40.default;
    }
  });
  Object.defineProperty(exports2, "eachMonthOfInterval", {
    enumerable: true,
    get: function get() {
      return _index41.default;
    }
  });
  Object.defineProperty(exports2, "eachQuarterOfInterval", {
    enumerable: true,
    get: function get() {
      return _index42.default;
    }
  });
  Object.defineProperty(exports2, "eachWeekOfInterval", {
    enumerable: true,
    get: function get() {
      return _index43.default;
    }
  });
  Object.defineProperty(exports2, "eachWeekendOfInterval", {
    enumerable: true,
    get: function get() {
      return _index44.default;
    }
  });
  Object.defineProperty(exports2, "eachWeekendOfMonth", {
    enumerable: true,
    get: function get() {
      return _index45.default;
    }
  });
  Object.defineProperty(exports2, "eachWeekendOfYear", {
    enumerable: true,
    get: function get() {
      return _index46.default;
    }
  });
  Object.defineProperty(exports2, "eachYearOfInterval", {
    enumerable: true,
    get: function get() {
      return _index47.default;
    }
  });
  Object.defineProperty(exports2, "endOfDay", {
    enumerable: true,
    get: function get() {
      return _index48.default;
    }
  });
  Object.defineProperty(exports2, "endOfDecade", {
    enumerable: true,
    get: function get() {
      return _index49.default;
    }
  });
  Object.defineProperty(exports2, "endOfHour", {
    enumerable: true,
    get: function get() {
      return _index50.default;
    }
  });
  Object.defineProperty(exports2, "endOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index51.default;
    }
  });
  Object.defineProperty(exports2, "endOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index52.default;
    }
  });
  Object.defineProperty(exports2, "endOfMinute", {
    enumerable: true,
    get: function get() {
      return _index53.default;
    }
  });
  Object.defineProperty(exports2, "endOfMonth", {
    enumerable: true,
    get: function get() {
      return _index54.default;
    }
  });
  Object.defineProperty(exports2, "endOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index55.default;
    }
  });
  Object.defineProperty(exports2, "endOfSecond", {
    enumerable: true,
    get: function get() {
      return _index56.default;
    }
  });
  Object.defineProperty(exports2, "endOfToday", {
    enumerable: true,
    get: function get() {
      return _index57.default;
    }
  });
  Object.defineProperty(exports2, "endOfTomorrow", {
    enumerable: true,
    get: function get() {
      return _index58.default;
    }
  });
  Object.defineProperty(exports2, "endOfWeek", {
    enumerable: true,
    get: function get() {
      return _index59.default;
    }
  });
  Object.defineProperty(exports2, "endOfYear", {
    enumerable: true,
    get: function get() {
      return _index60.default;
    }
  });
  Object.defineProperty(exports2, "endOfYesterday", {
    enumerable: true,
    get: function get() {
      return _index61.default;
    }
  });
  Object.defineProperty(exports2, "format", {
    enumerable: true,
    get: function get() {
      return _index62.default;
    }
  });
  Object.defineProperty(exports2, "formatDistance", {
    enumerable: true,
    get: function get() {
      return _index63.default;
    }
  });
  Object.defineProperty(exports2, "formatDistanceStrict", {
    enumerable: true,
    get: function get() {
      return _index64.default;
    }
  });
  Object.defineProperty(exports2, "formatDistanceToNow", {
    enumerable: true,
    get: function get() {
      return _index65.default;
    }
  });
  Object.defineProperty(exports2, "formatDistanceToNowStrict", {
    enumerable: true,
    get: function get() {
      return _index66.default;
    }
  });
  Object.defineProperty(exports2, "formatDuration", {
    enumerable: true,
    get: function get() {
      return _index67.default;
    }
  });
  Object.defineProperty(exports2, "formatISO", {
    enumerable: true,
    get: function get() {
      return _index68.default;
    }
  });
  Object.defineProperty(exports2, "formatISO9075", {
    enumerable: true,
    get: function get() {
      return _index69.default;
    }
  });
  Object.defineProperty(exports2, "formatISODuration", {
    enumerable: true,
    get: function get() {
      return _index70.default;
    }
  });
  Object.defineProperty(exports2, "formatRFC3339", {
    enumerable: true,
    get: function get() {
      return _index71.default;
    }
  });
  Object.defineProperty(exports2, "formatRFC7231", {
    enumerable: true,
    get: function get() {
      return _index72.default;
    }
  });
  Object.defineProperty(exports2, "formatRelative", {
    enumerable: true,
    get: function get() {
      return _index73.default;
    }
  });
  Object.defineProperty(exports2, "fromUnixTime", {
    enumerable: true,
    get: function get() {
      return _index74.default;
    }
  });
  Object.defineProperty(exports2, "getDate", {
    enumerable: true,
    get: function get() {
      return _index75.default;
    }
  });
  Object.defineProperty(exports2, "getDay", {
    enumerable: true,
    get: function get() {
      return _index76.default;
    }
  });
  Object.defineProperty(exports2, "getDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index77.default;
    }
  });
  Object.defineProperty(exports2, "getDaysInMonth", {
    enumerable: true,
    get: function get() {
      return _index78.default;
    }
  });
  Object.defineProperty(exports2, "getDaysInYear", {
    enumerable: true,
    get: function get() {
      return _index79.default;
    }
  });
  Object.defineProperty(exports2, "getDecade", {
    enumerable: true,
    get: function get() {
      return _index80.default;
    }
  });
  Object.defineProperty(exports2, "getDefaultOptions", {
    enumerable: true,
    get: function get() {
      return _index81.default;
    }
  });
  Object.defineProperty(exports2, "getHours", {
    enumerable: true,
    get: function get() {
      return _index82.default;
    }
  });
  Object.defineProperty(exports2, "getISODay", {
    enumerable: true,
    get: function get() {
      return _index83.default;
    }
  });
  Object.defineProperty(exports2, "getISOWeek", {
    enumerable: true,
    get: function get() {
      return _index84.default;
    }
  });
  Object.defineProperty(exports2, "getISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index85.default;
    }
  });
  Object.defineProperty(exports2, "getISOWeeksInYear", {
    enumerable: true,
    get: function get() {
      return _index86.default;
    }
  });
  Object.defineProperty(exports2, "getMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index87.default;
    }
  });
  Object.defineProperty(exports2, "getMinutes", {
    enumerable: true,
    get: function get() {
      return _index88.default;
    }
  });
  Object.defineProperty(exports2, "getMonth", {
    enumerable: true,
    get: function get() {
      return _index89.default;
    }
  });
  Object.defineProperty(exports2, "getOverlappingDaysInIntervals", {
    enumerable: true,
    get: function get() {
      return _index90.default;
    }
  });
  Object.defineProperty(exports2, "getQuarter", {
    enumerable: true,
    get: function get() {
      return _index91.default;
    }
  });
  Object.defineProperty(exports2, "getSeconds", {
    enumerable: true,
    get: function get() {
      return _index92.default;
    }
  });
  Object.defineProperty(exports2, "getTime", {
    enumerable: true,
    get: function get() {
      return _index93.default;
    }
  });
  Object.defineProperty(exports2, "getUnixTime", {
    enumerable: true,
    get: function get() {
      return _index94.default;
    }
  });
  Object.defineProperty(exports2, "getWeek", {
    enumerable: true,
    get: function get() {
      return _index95.default;
    }
  });
  Object.defineProperty(exports2, "getWeekOfMonth", {
    enumerable: true,
    get: function get() {
      return _index96.default;
    }
  });
  Object.defineProperty(exports2, "getWeekYear", {
    enumerable: true,
    get: function get() {
      return _index97.default;
    }
  });
  Object.defineProperty(exports2, "getWeeksInMonth", {
    enumerable: true,
    get: function get() {
      return _index98.default;
    }
  });
  Object.defineProperty(exports2, "getYear", {
    enumerable: true,
    get: function get() {
      return _index99.default;
    }
  });
  Object.defineProperty(exports2, "hoursToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index100.default;
    }
  });
  Object.defineProperty(exports2, "hoursToMinutes", {
    enumerable: true,
    get: function get() {
      return _index101.default;
    }
  });
  Object.defineProperty(exports2, "hoursToSeconds", {
    enumerable: true,
    get: function get() {
      return _index102.default;
    }
  });
  Object.defineProperty(exports2, "intervalToDuration", {
    enumerable: true,
    get: function get() {
      return _index103.default;
    }
  });
  Object.defineProperty(exports2, "intlFormat", {
    enumerable: true,
    get: function get() {
      return _index104.default;
    }
  });
  Object.defineProperty(exports2, "intlFormatDistance", {
    enumerable: true,
    get: function get() {
      return _index105.default;
    }
  });
  Object.defineProperty(exports2, "isAfter", {
    enumerable: true,
    get: function get() {
      return _index106.default;
    }
  });
  Object.defineProperty(exports2, "isBefore", {
    enumerable: true,
    get: function get() {
      return _index107.default;
    }
  });
  Object.defineProperty(exports2, "isDate", {
    enumerable: true,
    get: function get() {
      return _index108.default;
    }
  });
  Object.defineProperty(exports2, "isEqual", {
    enumerable: true,
    get: function get() {
      return _index109.default;
    }
  });
  Object.defineProperty(exports2, "isExists", {
    enumerable: true,
    get: function get() {
      return _index110.default;
    }
  });
  Object.defineProperty(exports2, "isFirstDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index111.default;
    }
  });
  Object.defineProperty(exports2, "isFriday", {
    enumerable: true,
    get: function get() {
      return _index112.default;
    }
  });
  Object.defineProperty(exports2, "isFuture", {
    enumerable: true,
    get: function get() {
      return _index113.default;
    }
  });
  Object.defineProperty(exports2, "isLastDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index114.default;
    }
  });
  Object.defineProperty(exports2, "isLeapYear", {
    enumerable: true,
    get: function get() {
      return _index115.default;
    }
  });
  Object.defineProperty(exports2, "isMatch", {
    enumerable: true,
    get: function get() {
      return _index116.default;
    }
  });
  Object.defineProperty(exports2, "isMonday", {
    enumerable: true,
    get: function get() {
      return _index117.default;
    }
  });
  Object.defineProperty(exports2, "isPast", {
    enumerable: true,
    get: function get() {
      return _index118.default;
    }
  });
  Object.defineProperty(exports2, "isSameDay", {
    enumerable: true,
    get: function get() {
      return _index119.default;
    }
  });
  Object.defineProperty(exports2, "isSameHour", {
    enumerable: true,
    get: function get() {
      return _index120.default;
    }
  });
  Object.defineProperty(exports2, "isSameISOWeek", {
    enumerable: true,
    get: function get() {
      return _index121.default;
    }
  });
  Object.defineProperty(exports2, "isSameISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index122.default;
    }
  });
  Object.defineProperty(exports2, "isSameMinute", {
    enumerable: true,
    get: function get() {
      return _index123.default;
    }
  });
  Object.defineProperty(exports2, "isSameMonth", {
    enumerable: true,
    get: function get() {
      return _index124.default;
    }
  });
  Object.defineProperty(exports2, "isSameQuarter", {
    enumerable: true,
    get: function get() {
      return _index125.default;
    }
  });
  Object.defineProperty(exports2, "isSameSecond", {
    enumerable: true,
    get: function get() {
      return _index126.default;
    }
  });
  Object.defineProperty(exports2, "isSameWeek", {
    enumerable: true,
    get: function get() {
      return _index127.default;
    }
  });
  Object.defineProperty(exports2, "isSameYear", {
    enumerable: true,
    get: function get() {
      return _index128.default;
    }
  });
  Object.defineProperty(exports2, "isSaturday", {
    enumerable: true,
    get: function get() {
      return _index129.default;
    }
  });
  Object.defineProperty(exports2, "isSunday", {
    enumerable: true,
    get: function get() {
      return _index130.default;
    }
  });
  Object.defineProperty(exports2, "isThisHour", {
    enumerable: true,
    get: function get() {
      return _index131.default;
    }
  });
  Object.defineProperty(exports2, "isThisISOWeek", {
    enumerable: true,
    get: function get() {
      return _index132.default;
    }
  });
  Object.defineProperty(exports2, "isThisMinute", {
    enumerable: true,
    get: function get() {
      return _index133.default;
    }
  });
  Object.defineProperty(exports2, "isThisMonth", {
    enumerable: true,
    get: function get() {
      return _index134.default;
    }
  });
  Object.defineProperty(exports2, "isThisQuarter", {
    enumerable: true,
    get: function get() {
      return _index135.default;
    }
  });
  Object.defineProperty(exports2, "isThisSecond", {
    enumerable: true,
    get: function get() {
      return _index136.default;
    }
  });
  Object.defineProperty(exports2, "isThisWeek", {
    enumerable: true,
    get: function get() {
      return _index137.default;
    }
  });
  Object.defineProperty(exports2, "isThisYear", {
    enumerable: true,
    get: function get() {
      return _index138.default;
    }
  });
  Object.defineProperty(exports2, "isThursday", {
    enumerable: true,
    get: function get() {
      return _index139.default;
    }
  });
  Object.defineProperty(exports2, "isToday", {
    enumerable: true,
    get: function get() {
      return _index140.default;
    }
  });
  Object.defineProperty(exports2, "isTomorrow", {
    enumerable: true,
    get: function get() {
      return _index141.default;
    }
  });
  Object.defineProperty(exports2, "isTuesday", {
    enumerable: true,
    get: function get() {
      return _index142.default;
    }
  });
  Object.defineProperty(exports2, "isValid", {
    enumerable: true,
    get: function get() {
      return _index143.default;
    }
  });
  Object.defineProperty(exports2, "isWednesday", {
    enumerable: true,
    get: function get() {
      return _index144.default;
    }
  });
  Object.defineProperty(exports2, "isWeekend", {
    enumerable: true,
    get: function get() {
      return _index145.default;
    }
  });
  Object.defineProperty(exports2, "isWithinInterval", {
    enumerable: true,
    get: function get() {
      return _index146.default;
    }
  });
  Object.defineProperty(exports2, "isYesterday", {
    enumerable: true,
    get: function get() {
      return _index147.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfDecade", {
    enumerable: true,
    get: function get() {
      return _index148.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index149.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index150.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index151.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index152.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfWeek", {
    enumerable: true,
    get: function get() {
      return _index153.default;
    }
  });
  Object.defineProperty(exports2, "lastDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index154.default;
    }
  });
  Object.defineProperty(exports2, "lightFormat", {
    enumerable: true,
    get: function get() {
      return _index155.default;
    }
  });
  Object.defineProperty(exports2, "max", {
    enumerable: true,
    get: function get() {
      return _index156.default;
    }
  });
  Object.defineProperty(exports2, "milliseconds", {
    enumerable: true,
    get: function get() {
      return _index157.default;
    }
  });
  Object.defineProperty(exports2, "millisecondsToHours", {
    enumerable: true,
    get: function get() {
      return _index158.default;
    }
  });
  Object.defineProperty(exports2, "millisecondsToMinutes", {
    enumerable: true,
    get: function get() {
      return _index159.default;
    }
  });
  Object.defineProperty(exports2, "millisecondsToSeconds", {
    enumerable: true,
    get: function get() {
      return _index160.default;
    }
  });
  Object.defineProperty(exports2, "min", {
    enumerable: true,
    get: function get() {
      return _index161.default;
    }
  });
  Object.defineProperty(exports2, "minutesToHours", {
    enumerable: true,
    get: function get() {
      return _index162.default;
    }
  });
  Object.defineProperty(exports2, "minutesToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index163.default;
    }
  });
  Object.defineProperty(exports2, "minutesToSeconds", {
    enumerable: true,
    get: function get() {
      return _index164.default;
    }
  });
  Object.defineProperty(exports2, "monthsToQuarters", {
    enumerable: true,
    get: function get() {
      return _index165.default;
    }
  });
  Object.defineProperty(exports2, "monthsToYears", {
    enumerable: true,
    get: function get() {
      return _index166.default;
    }
  });
  Object.defineProperty(exports2, "nextDay", {
    enumerable: true,
    get: function get() {
      return _index167.default;
    }
  });
  Object.defineProperty(exports2, "nextFriday", {
    enumerable: true,
    get: function get() {
      return _index168.default;
    }
  });
  Object.defineProperty(exports2, "nextMonday", {
    enumerable: true,
    get: function get() {
      return _index169.default;
    }
  });
  Object.defineProperty(exports2, "nextSaturday", {
    enumerable: true,
    get: function get() {
      return _index170.default;
    }
  });
  Object.defineProperty(exports2, "nextSunday", {
    enumerable: true,
    get: function get() {
      return _index171.default;
    }
  });
  Object.defineProperty(exports2, "nextThursday", {
    enumerable: true,
    get: function get() {
      return _index172.default;
    }
  });
  Object.defineProperty(exports2, "nextTuesday", {
    enumerable: true,
    get: function get() {
      return _index173.default;
    }
  });
  Object.defineProperty(exports2, "nextWednesday", {
    enumerable: true,
    get: function get() {
      return _index174.default;
    }
  });
  Object.defineProperty(exports2, "parse", {
    enumerable: true,
    get: function get() {
      return _index175.default;
    }
  });
  Object.defineProperty(exports2, "parseISO", {
    enumerable: true,
    get: function get() {
      return _index176.default;
    }
  });
  Object.defineProperty(exports2, "parseJSON", {
    enumerable: true,
    get: function get() {
      return _index177.default;
    }
  });
  Object.defineProperty(exports2, "previousDay", {
    enumerable: true,
    get: function get() {
      return _index178.default;
    }
  });
  Object.defineProperty(exports2, "previousFriday", {
    enumerable: true,
    get: function get() {
      return _index179.default;
    }
  });
  Object.defineProperty(exports2, "previousMonday", {
    enumerable: true,
    get: function get() {
      return _index180.default;
    }
  });
  Object.defineProperty(exports2, "previousSaturday", {
    enumerable: true,
    get: function get() {
      return _index181.default;
    }
  });
  Object.defineProperty(exports2, "previousSunday", {
    enumerable: true,
    get: function get() {
      return _index182.default;
    }
  });
  Object.defineProperty(exports2, "previousThursday", {
    enumerable: true,
    get: function get() {
      return _index183.default;
    }
  });
  Object.defineProperty(exports2, "previousTuesday", {
    enumerable: true,
    get: function get() {
      return _index184.default;
    }
  });
  Object.defineProperty(exports2, "previousWednesday", {
    enumerable: true,
    get: function get() {
      return _index185.default;
    }
  });
  Object.defineProperty(exports2, "quartersToMonths", {
    enumerable: true,
    get: function get() {
      return _index186.default;
    }
  });
  Object.defineProperty(exports2, "quartersToYears", {
    enumerable: true,
    get: function get() {
      return _index187.default;
    }
  });
  Object.defineProperty(exports2, "roundToNearestMinutes", {
    enumerable: true,
    get: function get() {
      return _index188.default;
    }
  });
  Object.defineProperty(exports2, "secondsToHours", {
    enumerable: true,
    get: function get() {
      return _index189.default;
    }
  });
  Object.defineProperty(exports2, "secondsToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index190.default;
    }
  });
  Object.defineProperty(exports2, "secondsToMinutes", {
    enumerable: true,
    get: function get() {
      return _index191.default;
    }
  });
  Object.defineProperty(exports2, "set", {
    enumerable: true,
    get: function get() {
      return _index192.default;
    }
  });
  Object.defineProperty(exports2, "setDate", {
    enumerable: true,
    get: function get() {
      return _index193.default;
    }
  });
  Object.defineProperty(exports2, "setDay", {
    enumerable: true,
    get: function get() {
      return _index194.default;
    }
  });
  Object.defineProperty(exports2, "setDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index195.default;
    }
  });
  Object.defineProperty(exports2, "setDefaultOptions", {
    enumerable: true,
    get: function get() {
      return _index196.default;
    }
  });
  Object.defineProperty(exports2, "setHours", {
    enumerable: true,
    get: function get() {
      return _index197.default;
    }
  });
  Object.defineProperty(exports2, "setISODay", {
    enumerable: true,
    get: function get() {
      return _index198.default;
    }
  });
  Object.defineProperty(exports2, "setISOWeek", {
    enumerable: true,
    get: function get() {
      return _index199.default;
    }
  });
  Object.defineProperty(exports2, "setISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index200.default;
    }
  });
  Object.defineProperty(exports2, "setMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index201.default;
    }
  });
  Object.defineProperty(exports2, "setMinutes", {
    enumerable: true,
    get: function get() {
      return _index202.default;
    }
  });
  Object.defineProperty(exports2, "setMonth", {
    enumerable: true,
    get: function get() {
      return _index203.default;
    }
  });
  Object.defineProperty(exports2, "setQuarter", {
    enumerable: true,
    get: function get() {
      return _index204.default;
    }
  });
  Object.defineProperty(exports2, "setSeconds", {
    enumerable: true,
    get: function get() {
      return _index205.default;
    }
  });
  Object.defineProperty(exports2, "setWeek", {
    enumerable: true,
    get: function get() {
      return _index206.default;
    }
  });
  Object.defineProperty(exports2, "setWeekYear", {
    enumerable: true,
    get: function get() {
      return _index207.default;
    }
  });
  Object.defineProperty(exports2, "setYear", {
    enumerable: true,
    get: function get() {
      return _index208.default;
    }
  });
  Object.defineProperty(exports2, "startOfDay", {
    enumerable: true,
    get: function get() {
      return _index209.default;
    }
  });
  Object.defineProperty(exports2, "startOfDecade", {
    enumerable: true,
    get: function get() {
      return _index210.default;
    }
  });
  Object.defineProperty(exports2, "startOfHour", {
    enumerable: true,
    get: function get() {
      return _index211.default;
    }
  });
  Object.defineProperty(exports2, "startOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index212.default;
    }
  });
  Object.defineProperty(exports2, "startOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index213.default;
    }
  });
  Object.defineProperty(exports2, "startOfMinute", {
    enumerable: true,
    get: function get() {
      return _index214.default;
    }
  });
  Object.defineProperty(exports2, "startOfMonth", {
    enumerable: true,
    get: function get() {
      return _index215.default;
    }
  });
  Object.defineProperty(exports2, "startOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index216.default;
    }
  });
  Object.defineProperty(exports2, "startOfSecond", {
    enumerable: true,
    get: function get() {
      return _index217.default;
    }
  });
  Object.defineProperty(exports2, "startOfToday", {
    enumerable: true,
    get: function get() {
      return _index218.default;
    }
  });
  Object.defineProperty(exports2, "startOfTomorrow", {
    enumerable: true,
    get: function get() {
      return _index219.default;
    }
  });
  Object.defineProperty(exports2, "startOfWeek", {
    enumerable: true,
    get: function get() {
      return _index220.default;
    }
  });
  Object.defineProperty(exports2, "startOfWeekYear", {
    enumerable: true,
    get: function get() {
      return _index221.default;
    }
  });
  Object.defineProperty(exports2, "startOfYear", {
    enumerable: true,
    get: function get() {
      return _index222.default;
    }
  });
  Object.defineProperty(exports2, "startOfYesterday", {
    enumerable: true,
    get: function get() {
      return _index223.default;
    }
  });
  Object.defineProperty(exports2, "sub", {
    enumerable: true,
    get: function get() {
      return _index224.default;
    }
  });
  Object.defineProperty(exports2, "subBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index225.default;
    }
  });
  Object.defineProperty(exports2, "subDays", {
    enumerable: true,
    get: function get() {
      return _index226.default;
    }
  });
  Object.defineProperty(exports2, "subHours", {
    enumerable: true,
    get: function get() {
      return _index227.default;
    }
  });
  Object.defineProperty(exports2, "subISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index228.default;
    }
  });
  Object.defineProperty(exports2, "subMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index229.default;
    }
  });
  Object.defineProperty(exports2, "subMinutes", {
    enumerable: true,
    get: function get() {
      return _index230.default;
    }
  });
  Object.defineProperty(exports2, "subMonths", {
    enumerable: true,
    get: function get() {
      return _index231.default;
    }
  });
  Object.defineProperty(exports2, "subQuarters", {
    enumerable: true,
    get: function get() {
      return _index232.default;
    }
  });
  Object.defineProperty(exports2, "subSeconds", {
    enumerable: true,
    get: function get() {
      return _index233.default;
    }
  });
  Object.defineProperty(exports2, "subWeeks", {
    enumerable: true,
    get: function get() {
      return _index234.default;
    }
  });
  Object.defineProperty(exports2, "subYears", {
    enumerable: true,
    get: function get() {
      return _index235.default;
    }
  });
  Object.defineProperty(exports2, "toDate", {
    enumerable: true,
    get: function get() {
      return _index236.default;
    }
  });
  Object.defineProperty(exports2, "weeksToDays", {
    enumerable: true,
    get: function get() {
      return _index237.default;
    }
  });
  Object.defineProperty(exports2, "yearsToMonths", {
    enumerable: true,
    get: function get() {
      return _index238.default;
    }
  });
  Object.defineProperty(exports2, "yearsToQuarters", {
    enumerable: true,
    get: function get() {
      return _index239.default;
    }
  });
  var _index = _interopRequireDefault(require_add());
  var _index2 = _interopRequireDefault(require_addBusinessDays());
  var _index3 = _interopRequireDefault(require_addDays());
  var _index4 = _interopRequireDefault(require_addHours());
  var _index5 = _interopRequireDefault(require_addISOWeekYears());
  var _index6 = _interopRequireDefault(require_addMilliseconds());
  var _index7 = _interopRequireDefault(require_addMinutes());
  var _index8 = _interopRequireDefault(require_addMonths());
  var _index9 = _interopRequireDefault(require_addQuarters());
  var _index10 = _interopRequireDefault(require_addSeconds());
  var _index11 = _interopRequireDefault(require_addWeeks());
  var _index12 = _interopRequireDefault(require_addYears());
  var _index13 = _interopRequireDefault(require_areIntervalsOverlapping());
  var _index14 = _interopRequireDefault(require_clamp());
  var _index15 = _interopRequireDefault(require_closestIndexTo());
  var _index16 = _interopRequireDefault(require_closestTo());
  var _index17 = _interopRequireDefault(require_compareAsc());
  var _index18 = _interopRequireDefault(require_compareDesc());
  var _index19 = _interopRequireDefault(require_daysToWeeks());
  var _index20 = _interopRequireDefault(require_differenceInBusinessDays());
  var _index21 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index22 = _interopRequireDefault(require_differenceInCalendarISOWeekYears());
  var _index23 = _interopRequireDefault(require_differenceInCalendarISOWeeks());
  var _index24 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index25 = _interopRequireDefault(require_differenceInCalendarQuarters());
  var _index26 = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index27 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index28 = _interopRequireDefault(require_differenceInDays());
  var _index29 = _interopRequireDefault(require_differenceInHours());
  var _index30 = _interopRequireDefault(require_differenceInISOWeekYears());
  var _index31 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index32 = _interopRequireDefault(require_differenceInMinutes());
  var _index33 = _interopRequireDefault(require_differenceInMonths());
  var _index34 = _interopRequireDefault(require_differenceInQuarters());
  var _index35 = _interopRequireDefault(require_differenceInSeconds());
  var _index36 = _interopRequireDefault(require_differenceInWeeks());
  var _index37 = _interopRequireDefault(require_differenceInYears());
  var _index38 = _interopRequireDefault(require_eachDayOfInterval());
  var _index39 = _interopRequireDefault(require_eachHourOfInterval());
  var _index40 = _interopRequireDefault(require_eachMinuteOfInterval());
  var _index41 = _interopRequireDefault(require_eachMonthOfInterval());
  var _index42 = _interopRequireDefault(require_eachQuarterOfInterval());
  var _index43 = _interopRequireDefault(require_eachWeekOfInterval());
  var _index44 = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index45 = _interopRequireDefault(require_eachWeekendOfMonth());
  var _index46 = _interopRequireDefault(require_eachWeekendOfYear());
  var _index47 = _interopRequireDefault(require_eachYearOfInterval());
  var _index48 = _interopRequireDefault(require_endOfDay());
  var _index49 = _interopRequireDefault(require_endOfDecade());
  var _index50 = _interopRequireDefault(require_endOfHour());
  var _index51 = _interopRequireDefault(require_endOfISOWeek());
  var _index52 = _interopRequireDefault(require_endOfISOWeekYear());
  var _index53 = _interopRequireDefault(require_endOfMinute());
  var _index54 = _interopRequireDefault(require_endOfMonth());
  var _index55 = _interopRequireDefault(require_endOfQuarter());
  var _index56 = _interopRequireDefault(require_endOfSecond());
  var _index57 = _interopRequireDefault(require_endOfToday());
  var _index58 = _interopRequireDefault(require_endOfTomorrow());
  var _index59 = _interopRequireDefault(require_endOfWeek());
  var _index60 = _interopRequireDefault(require_endOfYear());
  var _index61 = _interopRequireDefault(require_endOfYesterday());
  var _index62 = _interopRequireDefault(require_format2());
  var _index63 = _interopRequireDefault(require_formatDistance2());
  var _index64 = _interopRequireDefault(require_formatDistanceStrict());
  var _index65 = _interopRequireDefault(require_formatDistanceToNow());
  var _index66 = _interopRequireDefault(require_formatDistanceToNowStrict());
  var _index67 = _interopRequireDefault(require_formatDuration());
  var _index68 = _interopRequireDefault(require_formatISO());
  var _index69 = _interopRequireDefault(require_formatISO9075());
  var _index70 = _interopRequireDefault(require_formatISODuration());
  var _index71 = _interopRequireDefault(require_formatRFC3339());
  var _index72 = _interopRequireDefault(require_formatRFC7231());
  var _index73 = _interopRequireDefault(require_formatRelative2());
  var _index74 = _interopRequireDefault(require_fromUnixTime());
  var _index75 = _interopRequireDefault(require_getDate());
  var _index76 = _interopRequireDefault(require_getDay());
  var _index77 = _interopRequireDefault(require_getDayOfYear());
  var _index78 = _interopRequireDefault(require_getDaysInMonth());
  var _index79 = _interopRequireDefault(require_getDaysInYear());
  var _index80 = _interopRequireDefault(require_getDecade());
  var _index81 = _interopRequireDefault(require_getDefaultOptions());
  var _index82 = _interopRequireDefault(require_getHours());
  var _index83 = _interopRequireDefault(require_getISODay());
  var _index84 = _interopRequireDefault(require_getISOWeek());
  var _index85 = _interopRequireDefault(require_getISOWeekYear());
  var _index86 = _interopRequireDefault(require_getISOWeeksInYear());
  var _index87 = _interopRequireDefault(require_getMilliseconds());
  var _index88 = _interopRequireDefault(require_getMinutes());
  var _index89 = _interopRequireDefault(require_getMonth());
  var _index90 = _interopRequireDefault(require_getOverlappingDaysInIntervals());
  var _index91 = _interopRequireDefault(require_getQuarter());
  var _index92 = _interopRequireDefault(require_getSeconds());
  var _index93 = _interopRequireDefault(require_getTime());
  var _index94 = _interopRequireDefault(require_getUnixTime());
  var _index95 = _interopRequireDefault(require_getWeek());
  var _index96 = _interopRequireDefault(require_getWeekOfMonth());
  var _index97 = _interopRequireDefault(require_getWeekYear());
  var _index98 = _interopRequireDefault(require_getWeeksInMonth());
  var _index99 = _interopRequireDefault(require_getYear());
  var _index100 = _interopRequireDefault(require_hoursToMilliseconds());
  var _index101 = _interopRequireDefault(require_hoursToMinutes());
  var _index102 = _interopRequireDefault(require_hoursToSeconds());
  var _index103 = _interopRequireDefault(require_intervalToDuration());
  var _index104 = _interopRequireDefault(require_intlFormat());
  var _index105 = _interopRequireDefault(require_intlFormatDistance());
  var _index106 = _interopRequireDefault(require_isAfter());
  var _index107 = _interopRequireDefault(require_isBefore());
  var _index108 = _interopRequireDefault(require_isDate2());
  var _index109 = _interopRequireDefault(require_isEqual());
  var _index110 = _interopRequireDefault(require_isExists());
  var _index111 = _interopRequireDefault(require_isFirstDayOfMonth());
  var _index112 = _interopRequireDefault(require_isFriday());
  var _index113 = _interopRequireDefault(require_isFuture());
  var _index114 = _interopRequireDefault(require_isLastDayOfMonth());
  var _index115 = _interopRequireDefault(require_isLeapYear());
  var _index116 = _interopRequireDefault(require_isMatch());
  var _index117 = _interopRequireDefault(require_isMonday());
  var _index118 = _interopRequireDefault(require_isPast());
  var _index119 = _interopRequireDefault(require_isSameDay());
  var _index120 = _interopRequireDefault(require_isSameHour());
  var _index121 = _interopRequireDefault(require_isSameISOWeek());
  var _index122 = _interopRequireDefault(require_isSameISOWeekYear());
  var _index123 = _interopRequireDefault(require_isSameMinute());
  var _index124 = _interopRequireDefault(require_isSameMonth());
  var _index125 = _interopRequireDefault(require_isSameQuarter());
  var _index126 = _interopRequireDefault(require_isSameSecond());
  var _index127 = _interopRequireDefault(require_isSameWeek());
  var _index128 = _interopRequireDefault(require_isSameYear());
  var _index129 = _interopRequireDefault(require_isSaturday());
  var _index130 = _interopRequireDefault(require_isSunday());
  var _index131 = _interopRequireDefault(require_isThisHour());
  var _index132 = _interopRequireDefault(require_isThisISOWeek());
  var _index133 = _interopRequireDefault(require_isThisMinute());
  var _index134 = _interopRequireDefault(require_isThisMonth());
  var _index135 = _interopRequireDefault(require_isThisQuarter());
  var _index136 = _interopRequireDefault(require_isThisSecond());
  var _index137 = _interopRequireDefault(require_isThisWeek());
  var _index138 = _interopRequireDefault(require_isThisYear());
  var _index139 = _interopRequireDefault(require_isThursday());
  var _index140 = _interopRequireDefault(require_isToday());
  var _index141 = _interopRequireDefault(require_isTomorrow());
  var _index142 = _interopRequireDefault(require_isTuesday());
  var _index143 = _interopRequireDefault(require_isValid());
  var _index144 = _interopRequireDefault(require_isWednesday());
  var _index145 = _interopRequireDefault(require_isWeekend());
  var _index146 = _interopRequireDefault(require_isWithinInterval());
  var _index147 = _interopRequireDefault(require_isYesterday());
  var _index148 = _interopRequireDefault(require_lastDayOfDecade());
  var _index149 = _interopRequireDefault(require_lastDayOfISOWeek());
  var _index150 = _interopRequireDefault(require_lastDayOfISOWeekYear());
  var _index151 = _interopRequireDefault(require_lastDayOfMonth());
  var _index152 = _interopRequireDefault(require_lastDayOfQuarter());
  var _index153 = _interopRequireDefault(require_lastDayOfWeek());
  var _index154 = _interopRequireDefault(require_lastDayOfYear());
  var _index155 = _interopRequireDefault(require_lightFormat());
  var _index156 = _interopRequireDefault(require_max2());
  var _index157 = _interopRequireDefault(require_milliseconds());
  var _index158 = _interopRequireDefault(require_millisecondsToHours());
  var _index159 = _interopRequireDefault(require_millisecondsToMinutes());
  var _index160 = _interopRequireDefault(require_millisecondsToSeconds());
  var _index161 = _interopRequireDefault(require_min2());
  var _index162 = _interopRequireDefault(require_minutesToHours());
  var _index163 = _interopRequireDefault(require_minutesToMilliseconds());
  var _index164 = _interopRequireDefault(require_minutesToSeconds());
  var _index165 = _interopRequireDefault(require_monthsToQuarters());
  var _index166 = _interopRequireDefault(require_monthsToYears());
  var _index167 = _interopRequireDefault(require_nextDay());
  var _index168 = _interopRequireDefault(require_nextFriday());
  var _index169 = _interopRequireDefault(require_nextMonday());
  var _index170 = _interopRequireDefault(require_nextSaturday());
  var _index171 = _interopRequireDefault(require_nextSunday());
  var _index172 = _interopRequireDefault(require_nextThursday());
  var _index173 = _interopRequireDefault(require_nextTuesday());
  var _index174 = _interopRequireDefault(require_nextWednesday());
  var _index175 = _interopRequireDefault(require_parse2());
  var _index176 = _interopRequireDefault(require_parseISO());
  var _index177 = _interopRequireDefault(require_parseJSON());
  var _index178 = _interopRequireDefault(require_previousDay());
  var _index179 = _interopRequireDefault(require_previousFriday());
  var _index180 = _interopRequireDefault(require_previousMonday());
  var _index181 = _interopRequireDefault(require_previousSaturday());
  var _index182 = _interopRequireDefault(require_previousSunday());
  var _index183 = _interopRequireDefault(require_previousThursday());
  var _index184 = _interopRequireDefault(require_previousTuesday());
  var _index185 = _interopRequireDefault(require_previousWednesday());
  var _index186 = _interopRequireDefault(require_quartersToMonths());
  var _index187 = _interopRequireDefault(require_quartersToYears());
  var _index188 = _interopRequireDefault(require_roundToNearestMinutes());
  var _index189 = _interopRequireDefault(require_secondsToHours());
  var _index190 = _interopRequireDefault(require_secondsToMilliseconds());
  var _index191 = _interopRequireDefault(require_secondsToMinutes());
  var _index192 = _interopRequireDefault(require_set2());
  var _index193 = _interopRequireDefault(require_setDate());
  var _index194 = _interopRequireDefault(require_setDay());
  var _index195 = _interopRequireDefault(require_setDayOfYear());
  var _index196 = _interopRequireDefault(require_setDefaultOptions());
  var _index197 = _interopRequireDefault(require_setHours());
  var _index198 = _interopRequireDefault(require_setISODay());
  var _index199 = _interopRequireDefault(require_setISOWeek());
  var _index200 = _interopRequireDefault(require_setISOWeekYear());
  var _index201 = _interopRequireDefault(require_setMilliseconds());
  var _index202 = _interopRequireDefault(require_setMinutes());
  var _index203 = _interopRequireDefault(require_setMonth());
  var _index204 = _interopRequireDefault(require_setQuarter());
  var _index205 = _interopRequireDefault(require_setSeconds());
  var _index206 = _interopRequireDefault(require_setWeek());
  var _index207 = _interopRequireDefault(require_setWeekYear());
  var _index208 = _interopRequireDefault(require_setYear());
  var _index209 = _interopRequireDefault(require_startOfDay());
  var _index210 = _interopRequireDefault(require_startOfDecade());
  var _index211 = _interopRequireDefault(require_startOfHour());
  var _index212 = _interopRequireDefault(require_startOfISOWeek());
  var _index213 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index214 = _interopRequireDefault(require_startOfMinute());
  var _index215 = _interopRequireDefault(require_startOfMonth());
  var _index216 = _interopRequireDefault(require_startOfQuarter());
  var _index217 = _interopRequireDefault(require_startOfSecond());
  var _index218 = _interopRequireDefault(require_startOfToday());
  var _index219 = _interopRequireDefault(require_startOfTomorrow());
  var _index220 = _interopRequireDefault(require_startOfWeek());
  var _index221 = _interopRequireDefault(require_startOfWeekYear());
  var _index222 = _interopRequireDefault(require_startOfYear());
  var _index223 = _interopRequireDefault(require_startOfYesterday());
  var _index224 = _interopRequireDefault(require_sub());
  var _index225 = _interopRequireDefault(require_subBusinessDays());
  var _index226 = _interopRequireDefault(require_subDays());
  var _index227 = _interopRequireDefault(require_subHours());
  var _index228 = _interopRequireDefault(require_subISOWeekYears());
  var _index229 = _interopRequireDefault(require_subMilliseconds());
  var _index230 = _interopRequireDefault(require_subMinutes());
  var _index231 = _interopRequireDefault(require_subMonths());
  var _index232 = _interopRequireDefault(require_subQuarters());
  var _index233 = _interopRequireDefault(require_subSeconds());
  var _index234 = _interopRequireDefault(require_subWeeks());
  var _index235 = _interopRequireDefault(require_subYears());
  var _index236 = _interopRequireDefault(require_toDate());
  var _index237 = _interopRequireDefault(require_weeksToDays());
  var _index238 = _interopRequireDefault(require_yearsToMonths());
  var _index239 = _interopRequireDefault(require_yearsToQuarters());
  var _index240 = require_constants2();
  Object.keys(_index240).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports2 && exports2[key] === _index240[key])
      return;
    Object.defineProperty(exports2, key, {
      enumerable: true,
      get: function get() {
        return _index240[key];
      }
    });
  });
});

// node_modules/@scalar/core/dist/libs/html-rendering/html-rendering.js
function getScriptTags(configuration, cdn) {
  const restConfig = { ...configuration };
  const functionProps = [];
  for (const [key, value] of Object.entries(configuration)) {
    if (typeof value === "function") {
      functionProps.push(`"${key}": ${value.toString()}`);
      delete restConfig[key];
    } else if (Array.isArray(value) && value.some((item) => typeof item === "function")) {
      functionProps.push(`"${key}": ${serializeArrayWithFunctions(value)}`);
      delete restConfig[key];
    }
  }
  const configString = JSON.stringify(restConfig, null, 2).split(`
`).map((line2, index) => index === 0 ? line2 : "      " + line2).join(`
`).replace(/\s*}$/, "");
  const functionPropsString = functionProps.length ? `,
        ${functionProps.join(`,
        `)}
      }` : "}";
  return `
    <!-- Load the Script -->
    <script src="${cdn ?? "https://cdn.jsdelivr.net/npm/@scalar/api-reference"}"></script>

    <!-- Initialize the Scalar API Reference -->
    <script type="text/javascript">
      Scalar.createApiReference('#app', ${configString}${functionPropsString})
    </script>`;
}
var addIndent = (str, spaces = 2, initialIndent = false) => {
  const indent = " ".repeat(spaces);
  const lines = str.split(`
`);
  return lines.map((line2, index) => {
    if (index === 0 && !initialIndent) {
      return line2;
    }
    return `${indent}${line2}`;
  }).join(`
`);
}, getStyles = (configuration, customTheme) => {
  const styles = [];
  if (configuration.customCss) {
    styles.push("/* Custom CSS */");
    styles.push(configuration.customCss);
  }
  if (!configuration.theme && customTheme) {
    styles.push("/* Custom Theme */");
    styles.push(customTheme);
  }
  if (styles.length === 0) {
    return "";
  }
  return `
    <style type="text/css">
      ${addIndent(styles.join(`

`), 6)}
    </style>`;
}, getHtmlDocument = (givenConfiguration, customTheme = "") => {
  const { cdn, pageTitle, customCss, theme, ...rest } = givenConfiguration;
  const configuration = getConfiguration({
    ...rest,
    ...theme ? { theme } : {},
    customCss
  });
  const content = `<!doctype html>
<html>
  <head>
    <title>${pageTitle ?? "Scalar API Reference"}</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />${getStyles(configuration, customTheme)}
  </head>
  <body>
    <div id="app"></div>${getScriptTags(configuration, cdn)}
  </body>
</html>`;
  return content;
}, serializeArrayWithFunctions = (arr) => {
  return `[${arr.map((item) => typeof item === "function" ? item.toString() : JSON.stringify(item)).join(", ")}]`;
}, getConfiguration = (givenConfiguration) => {
  const configuration = {
    ...givenConfiguration
  };
  if (typeof configuration.content === "function") {
    configuration.content = configuration.content();
  }
  if (configuration.content && configuration.url) {
    delete configuration.content;
  }
  return configuration;
};
var init_html_rendering = () => {};

// node_modules/@scalar/core/dist/libs/html-rendering/index.js
var init_html_rendering2 = __esm(() => {
  init_html_rendering();
});

// node_modules/@scalar/hono-api-reference/dist/scalar.js
var DEFAULT_CONFIGURATION, customTheme = `
.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 245, .86);
  --scalar-color-2: rgba(255, 255, 245, .6);
  --scalar-color-3: rgba(255, 255, 245, .38);
  --scalar-color-disabled: rgba(255, 255, 245, .25);
  --scalar-color-ghost: rgba(255, 255, 245, .25);
  --scalar-color-accent: #e36002;
  --scalar-background-1: #1e1e20;
  --scalar-background-2: #2a2a2a;
  --scalar-background-3: #505053;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #e360021f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,
    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #3dd68c;
  --scalar-color-red: #f66f81;
  --scalar-color-yellow: #f9b44e;
  --scalar-color-blue: #5c73e7;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
/* Sidebar */
.dark-mode .sidebar {
  --scalar-sidebar-background-1: #161618;
  --scalar-sidebar-item-hover-color: var(--scalar-color-accent);
  --scalar-sidebar-item-hover-background: transparent;
  --scalar-sidebar-item-active-background: transparent;
  --scalar-sidebar-border-color: transparent;
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: #252529;
  --scalar-sidebar-search-border-color: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
`, Scalar = (configOrResolver) => {
  return async (c) => {
    let resolvedConfig = {};
    if (typeof configOrResolver === "function") {
      resolvedConfig = await configOrResolver(c);
    } else {
      resolvedConfig = configOrResolver;
    }
    const configuration = {
      ...DEFAULT_CONFIGURATION,
      ...resolvedConfig
    };
    return c.html(getHtmlDocument(configuration, customTheme));
  };
}, apiReference;
var init_scalar = __esm(() => {
  init_html_rendering2();
  DEFAULT_CONFIGURATION = {
    _integration: "hono"
  };
  apiReference = Scalar;
});

// node_modules/@scalar/hono-api-reference/dist/index.js
var exports_dist = {};
__export(exports_dist, {
  apiReference: () => apiReference,
  Scalar: () => Scalar
});
var init_dist2 = __esm(() => {
  init_scalar();
});

// src/index.ts
var exports_src2 = {};
__export(exports_src2, {
  default: () => src_default2,
  app: () => app
});
module.exports = __toCommonJS(exports_src2);

// node_modules/@hono/zod-openapi/dist/index.js
var import_zod_to_openapi = __toESM(require_dist(), 1);

// node_modules/hono/dist/utils/url.js
var splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var splitRoutingPath = (routePath) => {
  const { groups, path } = extractGroupsFromPath(routePath);
  const paths = splitPath(path);
  return replaceGroupMarks(paths, groups);
};
var extractGroupsFromPath = (path) => {
  const groups = [];
  path = path.replace(/\{[^}]+\}/g, (match, index) => {
    const mark = `@${index}`;
    groups.push([mark, match]);
    return mark;
  });
  return { groups, path };
};
var replaceGroupMarks = (paths, groups) => {
  for (let i = groups.length - 1;i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1;j >= 0; j--) {
      if (paths[j].includes(mark)) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
var patternCache = {};
var getPattern = (label, next) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    const cacheKey = `${label}#${next}`;
    if (!patternCache[cacheKey]) {
      if (match[2]) {
        patternCache[cacheKey] = next && next[0] !== ":" && next[0] !== "*" ? [cacheKey, match[1], new RegExp(`^${match[2]}(?=/${next})`)] : [label, match[1], new RegExp(`^${match[2]}$`)];
      } else {
        patternCache[cacheKey] = [label, match[1], true];
      }
    }
    return patternCache[cacheKey];
  }
  return null;
};
var tryDecode = (str, decoder) => {
  try {
    return decoder(str);
  } catch {
    return str.replace(/(?:%[0-9A-Fa-f]{2})+/g, (match) => {
      try {
        return decoder(match);
      } catch {
        return match;
      }
    });
  }
};
var tryDecodeURI = (str) => tryDecode(str, decodeURI);
var getPath = (request) => {
  const url = request.url;
  const start = url.indexOf("/", url.charCodeAt(9) === 58 ? 13 : 8);
  let i = start;
  for (;i < url.length; i++) {
    const charCode = url.charCodeAt(i);
    if (charCode === 37) {
      const queryIndex = url.indexOf("?", i);
      const path = url.slice(start, queryIndex === -1 ? undefined : queryIndex);
      return tryDecodeURI(path.includes("%25") ? path.replace(/%25/g, "%2525") : path);
    } else if (charCode === 63) {
      break;
    }
  }
  return url.slice(start, i);
};
var getPathNoStrict = (request) => {
  const result = getPath(request);
  return result.length > 1 && result.at(-1) === "/" ? result.slice(0, -1) : result;
};
var mergePath = (base, sub, ...rest) => {
  if (rest.length) {
    sub = mergePath(sub, ...rest);
  }
  return `${base?.[0] === "/" ? "" : "/"}${base}${sub === "/" ? "" : `${base?.at(-1) === "/" ? "" : "/"}${sub?.[0] === "/" ? sub.slice(1) : sub}`}`;
};
var checkOptionalParameter = (path) => {
  if (path.charCodeAt(path.length - 1) !== 63 || !path.includes(":")) {
    return null;
  }
  const segments = path.split("/");
  const results = [];
  let basePath = "";
  segments.forEach((segment) => {
    if (segment !== "" && !/\:/.test(segment)) {
      basePath += "/" + segment;
    } else if (/\:/.test(segment)) {
      if (/\?/.test(segment)) {
        if (results.length === 0 && basePath === "") {
          results.push("/");
        } else {
          results.push(basePath);
        }
        const optionalSegment = segment.replace("?", "");
        basePath += "/" + optionalSegment;
        results.push(basePath);
      } else {
        basePath += "/" + segment;
      }
    }
  });
  return results.filter((v, i, a) => a.indexOf(v) === i);
};
var _decodeURI = (value) => {
  if (!/[%+]/.test(value)) {
    return value;
  }
  if (value.indexOf("+") !== -1) {
    value = value.replace(/\+/g, " ");
  }
  return value.indexOf("%") !== -1 ? tryDecode(value, decodeURIComponent_) : value;
};
var _getQueryParam = (url, key, multiple) => {
  let encoded;
  if (!multiple && key && !/[%+]/.test(key)) {
    let keyIndex2 = url.indexOf(`?${key}`, 8);
    if (keyIndex2 === -1) {
      keyIndex2 = url.indexOf(`&${key}`, 8);
    }
    while (keyIndex2 !== -1) {
      const trailingKeyCode = url.charCodeAt(keyIndex2 + key.length + 1);
      if (trailingKeyCode === 61) {
        const valueIndex = keyIndex2 + key.length + 2;
        const endIndex = url.indexOf("&", valueIndex);
        return _decodeURI(url.slice(valueIndex, endIndex === -1 ? undefined : endIndex));
      } else if (trailingKeyCode == 38 || isNaN(trailingKeyCode)) {
        return "";
      }
      keyIndex2 = url.indexOf(`&${key}`, keyIndex2 + 1);
    }
    encoded = /[%+]/.test(url);
    if (!encoded) {
      return;
    }
  }
  const results = {};
  encoded ??= /[%+]/.test(url);
  let keyIndex = url.indexOf("?", 8);
  while (keyIndex !== -1) {
    const nextKeyIndex = url.indexOf("&", keyIndex + 1);
    let valueIndex = url.indexOf("=", keyIndex);
    if (valueIndex > nextKeyIndex && nextKeyIndex !== -1) {
      valueIndex = -1;
    }
    let name = url.slice(keyIndex + 1, valueIndex === -1 ? nextKeyIndex === -1 ? undefined : nextKeyIndex : valueIndex);
    if (encoded) {
      name = _decodeURI(name);
    }
    keyIndex = nextKeyIndex;
    if (name === "") {
      continue;
    }
    let value;
    if (valueIndex === -1) {
      value = "";
    } else {
      value = url.slice(valueIndex + 1, nextKeyIndex === -1 ? undefined : nextKeyIndex);
      if (encoded) {
        value = _decodeURI(value);
      }
    }
    if (multiple) {
      if (!(results[name] && Array.isArray(results[name]))) {
        results[name] = [];
      }
      results[name].push(value);
    } else {
      results[name] ??= value;
    }
  }
  return key ? results[key] : results;
};
var getQueryParam = _getQueryParam;
var getQueryParams = (url, key) => {
  return _getQueryParam(url, key, true);
};
var decodeURIComponent_ = decodeURIComponent;

// node_modules/hono/dist/utils/cookie.js
var validCookieNameRegEx = /^[\w!#$%&'*.^`|~+-]+$/;
var validCookieValueRegEx = /^[ !#-:<-[\]-~]*$/;
var parse = (cookie, name) => {
  if (name && cookie.indexOf(name) === -1) {
    return {};
  }
  const pairs = cookie.trim().split(";");
  const parsedCookie = {};
  for (let pairStr of pairs) {
    pairStr = pairStr.trim();
    const valueStartPos = pairStr.indexOf("=");
    if (valueStartPos === -1) {
      continue;
    }
    const cookieName = pairStr.substring(0, valueStartPos).trim();
    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {
      continue;
    }
    let cookieValue = pairStr.substring(valueStartPos + 1).trim();
    if (cookieValue.startsWith('"') && cookieValue.endsWith('"')) {
      cookieValue = cookieValue.slice(1, -1);
    }
    if (validCookieValueRegEx.test(cookieValue)) {
      parsedCookie[cookieName] = decodeURIComponent_(cookieValue);
      if (name) {
        break;
      }
    }
  }
  return parsedCookie;
};

// node_modules/hono/dist/helper/cookie/index.js
var getCookie = (c, key, prefix) => {
  const cookie = c.req.raw.headers.get("Cookie");
  if (typeof key === "string") {
    if (!cookie) {
      return;
    }
    let finalKey = key;
    if (prefix === "secure") {
      finalKey = "__Secure-" + key;
    } else if (prefix === "host") {
      finalKey = "__Host-" + key;
    }
    const obj2 = parse(cookie, finalKey);
    return obj2[finalKey];
  }
  if (!cookie) {
    return {};
  }
  const obj = parse(cookie);
  return obj;
};

// node_modules/hono/dist/http-exception.js
var HTTPException = class extends Error {
  res;
  status;
  constructor(status = 500, options) {
    super(options?.message, { cause: options?.cause });
    this.res = options?.res;
    this.status = status;
  }
  getResponse() {
    if (this.res) {
      const newResponse = new Response(this.res.body, {
        status: this.status,
        headers: this.res.headers
      });
      return newResponse;
    }
    return new Response(this.message, {
      status: this.status
    });
  }
};

// node_modules/hono/dist/utils/buffer.js
var bufferToFormData = (arrayBuffer, contentType) => {
  const response = new Response(arrayBuffer, {
    headers: {
      "Content-Type": contentType
    }
  });
  return response.formData();
};

// node_modules/hono/dist/validator/validator.js
var jsonRegex = /^application\/([a-z-\.]+\+)?json(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var multipartRegex = /^multipart\/form-data(;\s?boundary=[a-zA-Z0-9'"()+_,\-./:=?]+)?$/;
var urlencodedRegex = /^application\/x-www-form-urlencoded(;\s*[a-zA-Z0-9\-]+\=([^;]+))*$/;
var validator = (target, validationFunc) => {
  return async (c, next) => {
    let value = {};
    const contentType = c.req.header("Content-Type");
    switch (target) {
      case "json":
        if (!contentType || !jsonRegex.test(contentType)) {
          break;
        }
        try {
          value = await c.req.json();
        } catch {
          const message = "Malformed JSON in request body";
          throw new HTTPException(400, { message });
        }
        break;
      case "form": {
        if (!contentType || !(multipartRegex.test(contentType) || urlencodedRegex.test(contentType))) {
          break;
        }
        let formData;
        if (c.req.bodyCache.formData) {
          formData = await c.req.bodyCache.formData;
        } else {
          try {
            const arrayBuffer = await c.req.arrayBuffer();
            formData = await bufferToFormData(arrayBuffer, contentType);
            c.req.bodyCache.formData = formData;
          } catch (e) {
            let message = "Malformed FormData request.";
            message += e instanceof Error ? ` ${e.message}` : ` ${String(e)}`;
            throw new HTTPException(400, { message });
          }
        }
        const form = {};
        formData.forEach((value2, key) => {
          if (key.endsWith("[]")) {
            (form[key] ??= []).push(value2);
          } else if (Array.isArray(form[key])) {
            form[key].push(value2);
          } else if (key in form) {
            form[key] = [form[key], value2];
          } else {
            form[key] = value2;
          }
        });
        value = form;
        break;
      }
      case "query":
        value = Object.fromEntries(Object.entries(c.req.queries()).map(([k, v]) => {
          return v.length === 1 ? [k, v[0]] : [k, v];
        }));
        break;
      case "param":
        value = c.req.param();
        break;
      case "header":
        value = c.req.header();
        break;
      case "cookie":
        value = getCookie(c);
        break;
    }
    const res = await validationFunc(value, c);
    if (res instanceof Response) {
      return res;
    }
    c.req.addValidatedData(target, res);
    await next();
  };
};

// node_modules/@hono/zod-validator/dist/index.js
var zValidator = (target, schema, hook, options) => validator(target, async (value, c) => {
  let validatorValue = value;
  if (target === "header" && "_def" in schema || target === "header" && "_zod" in schema) {
    const schemaKeys = Object.keys("in" in schema ? schema.in.shape : schema.shape);
    const caseInsensitiveKeymap = Object.fromEntries(schemaKeys.map((key) => [key.toLowerCase(), key]));
    validatorValue = Object.fromEntries(Object.entries(value).map(([key, value2]) => [caseInsensitiveKeymap[key] || key, value2]));
  }
  const result = options && options.validationFunction ? await options.validationFunction(schema, validatorValue) : await schema.safeParseAsync(validatorValue);
  if (hook) {
    const hookResult = await hook({ data: validatorValue, ...result, target }, c);
    if (hookResult) {
      if (hookResult instanceof Response) {
        return hookResult;
      }
      if ("response" in hookResult) {
        return hookResult.response;
      }
    }
  }
  if (!result.success) {
    return c.json(result, 400);
  }
  return result.data;
});

// node_modules/hono/dist/compose.js
var compose = (middleware, onError, onNotFound) => {
  return (context, next) => {
    let index = -1;
    return dispatch(0);
    async function dispatch(i) {
      if (i <= index) {
        throw new Error("next() called multiple times");
      }
      index = i;
      let res;
      let isError = false;
      let handler;
      if (middleware[i]) {
        handler = middleware[i][0][0];
        context.req.routeIndex = i;
      } else {
        handler = i === middleware.length && next || undefined;
      }
      if (handler) {
        try {
          res = await handler(context, () => dispatch(i + 1));
        } catch (err) {
          if (err instanceof Error && onError) {
            context.error = err;
            res = await onError(err, context);
            isError = true;
          } else {
            throw err;
          }
        }
      } else {
        if (context.finalized === false && onNotFound) {
          res = await onNotFound(context);
        }
      }
      if (res && (context.finalized === false || isError)) {
        context.res = res;
      }
      return context;
    }
  };
};

// node_modules/hono/dist/request/constants.js
var GET_MATCH_RESULT = Symbol();

// node_modules/hono/dist/utils/body.js
var parseBody = async (request, options = /* @__PURE__ */ Object.create(null)) => {
  const { all = false, dot = false } = options;
  const headers = request instanceof HonoRequest ? request.raw.headers : request.headers;
  const contentType = headers.get("Content-Type");
  if (contentType?.startsWith("multipart/form-data") || contentType?.startsWith("application/x-www-form-urlencoded")) {
    return parseFormData(request, { all, dot });
  }
  return {};
};
async function parseFormData(request, options) {
  const formData = await request.formData();
  if (formData) {
    return convertFormDataToBodyData(formData, options);
  }
  return {};
}
function convertFormDataToBodyData(formData, options) {
  const form = /* @__PURE__ */ Object.create(null);
  formData.forEach((value, key) => {
    const shouldParseAllValues = options.all || key.endsWith("[]");
    if (!shouldParseAllValues) {
      form[key] = value;
    } else {
      handleParsingAllValues(form, key, value);
    }
  });
  if (options.dot) {
    Object.entries(form).forEach(([key, value]) => {
      const shouldParseDotValues = key.includes(".");
      if (shouldParseDotValues) {
        handleParsingNestedValues(form, key, value);
        delete form[key];
      }
    });
  }
  return form;
}
var handleParsingAllValues = (form, key, value) => {
  if (form[key] !== undefined) {
    if (Array.isArray(form[key])) {
      form[key].push(value);
    } else {
      form[key] = [form[key], value];
    }
  } else {
    if (!key.endsWith("[]")) {
      form[key] = value;
    } else {
      form[key] = [value];
    }
  }
};
var handleParsingNestedValues = (form, key, value) => {
  let nestedForm = form;
  const keys = key.split(".");
  keys.forEach((key2, index) => {
    if (index === keys.length - 1) {
      nestedForm[key2] = value;
    } else {
      if (!nestedForm[key2] || typeof nestedForm[key2] !== "object" || Array.isArray(nestedForm[key2]) || nestedForm[key2] instanceof File) {
        nestedForm[key2] = /* @__PURE__ */ Object.create(null);
      }
      nestedForm = nestedForm[key2];
    }
  });
};

// node_modules/hono/dist/request.js
var tryDecodeURIComponent = (str) => tryDecode(str, decodeURIComponent_);
var HonoRequest = class {
  raw;
  #validatedData;
  #matchResult;
  routeIndex = 0;
  path;
  bodyCache = {};
  constructor(request, path = "/", matchResult = [[]]) {
    this.raw = request;
    this.path = path;
    this.#matchResult = matchResult;
    this.#validatedData = {};
  }
  param(key) {
    return key ? this.#getDecodedParam(key) : this.#getAllDecodedParams();
  }
  #getDecodedParam(key) {
    const paramKey = this.#matchResult[0][this.routeIndex][1][key];
    const param = this.#getParamValue(paramKey);
    return param ? /\%/.test(param) ? tryDecodeURIComponent(param) : param : undefined;
  }
  #getAllDecodedParams() {
    const decoded = {};
    const keys = Object.keys(this.#matchResult[0][this.routeIndex][1]);
    for (const key of keys) {
      const value = this.#getParamValue(this.#matchResult[0][this.routeIndex][1][key]);
      if (value && typeof value === "string") {
        decoded[key] = /\%/.test(value) ? tryDecodeURIComponent(value) : value;
      }
    }
    return decoded;
  }
  #getParamValue(paramKey) {
    return this.#matchResult[1] ? this.#matchResult[1][paramKey] : paramKey;
  }
  query(key) {
    return getQueryParam(this.url, key);
  }
  queries(key) {
    return getQueryParams(this.url, key);
  }
  header(name) {
    if (name) {
      return this.raw.headers.get(name) ?? undefined;
    }
    const headerData = {};
    this.raw.headers.forEach((value, key) => {
      headerData[key] = value;
    });
    return headerData;
  }
  async parseBody(options) {
    return this.bodyCache.parsedBody ??= await parseBody(this, options);
  }
  #cachedBody = (key) => {
    const { bodyCache, raw } = this;
    const cachedBody = bodyCache[key];
    if (cachedBody) {
      return cachedBody;
    }
    const anyCachedKey = Object.keys(bodyCache)[0];
    if (anyCachedKey) {
      return bodyCache[anyCachedKey].then((body) => {
        if (anyCachedKey === "json") {
          body = JSON.stringify(body);
        }
        return new Response(body)[key]();
      });
    }
    return bodyCache[key] = raw[key]();
  };
  json() {
    return this.#cachedBody("json");
  }
  text() {
    return this.#cachedBody("text");
  }
  arrayBuffer() {
    return this.#cachedBody("arrayBuffer");
  }
  blob() {
    return this.#cachedBody("blob");
  }
  formData() {
    return this.#cachedBody("formData");
  }
  addValidatedData(target, data) {
    this.#validatedData[target] = data;
  }
  valid(target) {
    return this.#validatedData[target];
  }
  get url() {
    return this.raw.url;
  }
  get method() {
    return this.raw.method;
  }
  get [GET_MATCH_RESULT]() {
    return this.#matchResult;
  }
  get matchedRoutes() {
    return this.#matchResult[0].map(([[, route]]) => route);
  }
  get routePath() {
    return this.#matchResult[0].map(([[, route]]) => route)[this.routeIndex].path;
  }
};

// node_modules/hono/dist/utils/html.js
var HtmlEscapedCallbackPhase = {
  Stringify: 1,
  BeforeStream: 2,
  Stream: 3
};
var raw = (value, callbacks) => {
  const escapedString = new String(value);
  escapedString.isEscaped = true;
  escapedString.callbacks = callbacks;
  return escapedString;
};
var resolveCallback = async (str, phase, preserveCallbacks, context, buffer) => {
  if (typeof str === "object" && !(str instanceof String)) {
    if (!(str instanceof Promise)) {
      str = str.toString();
    }
    if (str instanceof Promise) {
      str = await str;
    }
  }
  const callbacks = str.callbacks;
  if (!callbacks?.length) {
    return Promise.resolve(str);
  }
  if (buffer) {
    buffer[0] += str;
  } else {
    buffer = [str];
  }
  const resStr = Promise.all(callbacks.map((c) => c({ phase, buffer, context }))).then((res) => Promise.all(res.filter(Boolean).map((str2) => resolveCallback(str2, phase, false, context, buffer))).then(() => buffer[0]));
  if (preserveCallbacks) {
    return raw(await resStr, callbacks);
  } else {
    return resStr;
  }
};

// node_modules/hono/dist/context.js
var TEXT_PLAIN = "text/plain; charset=UTF-8";
var setDefaultContentType = (contentType, headers) => {
  return {
    "Content-Type": contentType,
    ...headers
  };
};
var Context = class {
  #rawRequest;
  #req;
  env = {};
  #var;
  finalized = false;
  error;
  #status;
  #executionCtx;
  #res;
  #layout;
  #renderer;
  #notFoundHandler;
  #preparedHeaders;
  #matchResult;
  #path;
  constructor(req, options) {
    this.#rawRequest = req;
    if (options) {
      this.#executionCtx = options.executionCtx;
      this.env = options.env;
      this.#notFoundHandler = options.notFoundHandler;
      this.#path = options.path;
      this.#matchResult = options.matchResult;
    }
  }
  get req() {
    this.#req ??= new HonoRequest(this.#rawRequest, this.#path, this.#matchResult);
    return this.#req;
  }
  get event() {
    if (this.#executionCtx && "respondWith" in this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this.#executionCtx) {
      return this.#executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this.#res ||= new Response(null, {
      headers: this.#preparedHeaders ??= new Headers
    });
  }
  set res(_res) {
    if (this.#res && _res) {
      _res = new Response(_res.body, _res);
      for (const [k, v] of this.#res.headers.entries()) {
        if (k === "content-type") {
          continue;
        }
        if (k === "set-cookie") {
          const cookies = this.#res.headers.getSetCookie();
          _res.headers.delete("set-cookie");
          for (const cookie of cookies) {
            _res.headers.append("set-cookie", cookie);
          }
        } else {
          _res.headers.set(k, v);
        }
      }
    }
    this.#res = _res;
    this.finalized = true;
  }
  render = (...args) => {
    this.#renderer ??= (content) => this.html(content);
    return this.#renderer(...args);
  };
  setLayout = (layout) => this.#layout = layout;
  getLayout = () => this.#layout;
  setRenderer = (renderer) => {
    this.#renderer = renderer;
  };
  header = (name, value, options) => {
    if (this.finalized) {
      this.#res = new Response(this.#res.body, this.#res);
    }
    const headers = this.#res ? this.#res.headers : this.#preparedHeaders ??= new Headers;
    if (value === undefined) {
      headers.delete(name);
    } else if (options?.append) {
      headers.append(name, value);
    } else {
      headers.set(name, value);
    }
  };
  status = (status) => {
    this.#status = status;
  };
  set = (key, value) => {
    this.#var ??= /* @__PURE__ */ new Map;
    this.#var.set(key, value);
  };
  get = (key) => {
    return this.#var ? this.#var.get(key) : undefined;
  };
  get var() {
    if (!this.#var) {
      return {};
    }
    return Object.fromEntries(this.#var);
  }
  #newResponse(data, arg, headers) {
    const responseHeaders = this.#res ? new Headers(this.#res.headers) : this.#preparedHeaders ?? new Headers;
    if (typeof arg === "object" && "headers" in arg) {
      const argHeaders = arg.headers instanceof Headers ? arg.headers : new Headers(arg.headers);
      for (const [key, value] of argHeaders) {
        if (key.toLowerCase() === "set-cookie") {
          responseHeaders.append(key, value);
        } else {
          responseHeaders.set(key, value);
        }
      }
    }
    if (headers) {
      for (const [k, v] of Object.entries(headers)) {
        if (typeof v === "string") {
          responseHeaders.set(k, v);
        } else {
          responseHeaders.delete(k);
          for (const v2 of v) {
            responseHeaders.append(k, v2);
          }
        }
      }
    }
    const status = typeof arg === "number" ? arg : arg?.status ?? this.#status;
    return new Response(data, { status, headers: responseHeaders });
  }
  newResponse = (...args) => this.#newResponse(...args);
  body = (data, arg, headers) => this.#newResponse(data, arg, headers);
  text = (text, arg, headers) => {
    return !this.#preparedHeaders && !this.#status && !arg && !headers && !this.finalized ? new Response(text) : this.#newResponse(text, arg, setDefaultContentType(TEXT_PLAIN, headers));
  };
  json = (object, arg, headers) => {
    return this.#newResponse(JSON.stringify(object), arg, setDefaultContentType("application/json", headers));
  };
  html = (html, arg, headers) => {
    const res = (html2) => this.#newResponse(html2, arg, setDefaultContentType("text/html; charset=UTF-8", headers));
    return typeof html === "object" ? resolveCallback(html, HtmlEscapedCallbackPhase.Stringify, false, {}).then(res) : res(html);
  };
  redirect = (location, status) => {
    this.header("Location", String(location));
    return this.newResponse(null, status ?? 302);
  };
  notFound = () => {
    this.#notFoundHandler ??= () => new Response;
    return this.#notFoundHandler(this);
  };
};

// node_modules/hono/dist/router.js
var METHOD_NAME_ALL = "ALL";
var METHOD_NAME_ALL_LOWERCASE = "all";
var METHODS = ["get", "post", "put", "delete", "options", "patch"];
var MESSAGE_MATCHER_IS_ALREADY_BUILT = "Can not add a route since the matcher is already built.";
var UnsupportedPathError = class extends Error {
};

// node_modules/hono/dist/utils/constants.js
var COMPOSED_HANDLER = "__COMPOSED_HANDLER";

// node_modules/hono/dist/hono-base.js
var notFoundHandler = (c) => {
  return c.text("404 Not Found", 404);
};
var errorHandler = (err, c) => {
  if ("getResponse" in err) {
    const res = err.getResponse();
    return c.newResponse(res.body, res);
  }
  console.error(err);
  return c.text("Internal Server Error", 500);
};
var Hono = class {
  get;
  post;
  put;
  delete;
  options;
  patch;
  all;
  on;
  use;
  router;
  getPath;
  _basePath = "/";
  #path = "/";
  routes = [];
  constructor(options = {}) {
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.forEach((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.#path = args1;
        } else {
          this.#addRoute(method, this.#path, args1);
        }
        args.forEach((handler) => {
          this.#addRoute(method, this.#path, handler);
        });
        return this;
      };
    });
    this.on = (method, path, ...handlers) => {
      for (const p of [path].flat()) {
        this.#path = p;
        for (const m of [method].flat()) {
          handlers.map((handler) => {
            this.#addRoute(m.toUpperCase(), this.#path, handler);
          });
        }
      }
      return this;
    };
    this.use = (arg1, ...handlers) => {
      if (typeof arg1 === "string") {
        this.#path = arg1;
      } else {
        this.#path = "*";
        handlers.unshift(arg1);
      }
      handlers.forEach((handler) => {
        this.#addRoute(METHOD_NAME_ALL, this.#path, handler);
      });
      return this;
    };
    const { strict, ...optionsWithoutStrict } = options;
    Object.assign(this, optionsWithoutStrict);
    this.getPath = strict ?? true ? options.getPath ?? getPath : getPathNoStrict;
  }
  #clone() {
    const clone = new Hono({
      router: this.router,
      getPath: this.getPath
    });
    clone.errorHandler = this.errorHandler;
    clone.#notFoundHandler = this.#notFoundHandler;
    clone.routes = this.routes;
    return clone;
  }
  #notFoundHandler = notFoundHandler;
  errorHandler = errorHandler;
  route(path, app) {
    const subApp = this.basePath(path);
    app.routes.map((r) => {
      let handler;
      if (app.errorHandler === errorHandler) {
        handler = r.handler;
      } else {
        handler = async (c, next) => (await compose([], app.errorHandler)(c, () => r.handler(c, next))).res;
        handler[COMPOSED_HANDLER] = r.handler;
      }
      subApp.#addRoute(r.method, r.path, handler);
    });
    return this;
  }
  basePath(path) {
    const subApp = this.#clone();
    subApp._basePath = mergePath(this._basePath, path);
    return subApp;
  }
  onError = (handler) => {
    this.errorHandler = handler;
    return this;
  };
  notFound = (handler) => {
    this.#notFoundHandler = handler;
    return this;
  };
  mount(path, applicationHandler, options) {
    let replaceRequest;
    let optionHandler;
    if (options) {
      if (typeof options === "function") {
        optionHandler = options;
      } else {
        optionHandler = options.optionHandler;
        if (options.replaceRequest === false) {
          replaceRequest = (request) => request;
        } else {
          replaceRequest = options.replaceRequest;
        }
      }
    }
    const getOptions = optionHandler ? (c) => {
      const options2 = optionHandler(c);
      return Array.isArray(options2) ? options2 : [options2];
    } : (c) => {
      let executionContext = undefined;
      try {
        executionContext = c.executionCtx;
      } catch {}
      return [c.env, executionContext];
    };
    replaceRequest ||= (() => {
      const mergedPath = mergePath(this._basePath, path);
      const pathPrefixLength = mergedPath === "/" ? 0 : mergedPath.length;
      return (request) => {
        const url = new URL(request.url);
        url.pathname = url.pathname.slice(pathPrefixLength) || "/";
        return new Request(url, request);
      };
    })();
    const handler = async (c, next) => {
      const res = await applicationHandler(replaceRequest(c.req.raw), ...getOptions(c));
      if (res) {
        return res;
      }
      await next();
    };
    this.#addRoute(METHOD_NAME_ALL, mergePath(path, "*"), handler);
    return this;
  }
  #addRoute(method, path, handler) {
    method = method.toUpperCase();
    path = mergePath(this._basePath, path);
    const r = { basePath: this._basePath, path, method, handler };
    this.router.add(method, path, [handler, r]);
    this.routes.push(r);
  }
  #handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  #dispatch(request, executionCtx, env, method) {
    if (method === "HEAD") {
      return (async () => new Response(null, await this.#dispatch(request, executionCtx, env, "GET")))();
    }
    const path = this.getPath(request, { env });
    const matchResult = this.router.match(method, path);
    const c = new Context(request, {
      path,
      matchResult,
      env,
      executionCtx,
      notFoundHandler: this.#notFoundHandler
    });
    if (matchResult[0].length === 1) {
      let res;
      try {
        res = matchResult[0][0][0][0](c, async () => {
          c.res = await this.#notFoundHandler(c);
        });
      } catch (err) {
        return this.#handleError(err, c);
      }
      return res instanceof Promise ? res.then((resolved) => resolved || (c.finalized ? c.res : this.#notFoundHandler(c))).catch((err) => this.#handleError(err, c)) : res ?? this.#notFoundHandler(c);
    }
    const composed = compose(matchResult[0], this.errorHandler, this.#notFoundHandler);
    return (async () => {
      try {
        const context = await composed(c);
        if (!context.finalized) {
          throw new Error("Context is not finalized. Did you forget to return a Response object or `await next()`?");
        }
        return context.res;
      } catch (err) {
        return this.#handleError(err, c);
      }
    })();
  }
  fetch = (request, ...rest) => {
    return this.#dispatch(request, rest[1], rest[0], request.method);
  };
  request = (input, requestInit, Env, executionCtx) => {
    if (input instanceof Request) {
      return this.fetch(requestInit ? new Request(input, requestInit) : input, Env, executionCtx);
    }
    input = input.toString();
    return this.fetch(new Request(/^https?:\/\//.test(input) ? input : `http://localhost${mergePath("/", input)}`, requestInit), Env, executionCtx);
  };
  fire = () => {
    addEventListener("fetch", (event) => {
      event.respondWith(this.#dispatch(event.request, event, undefined, event.request.method));
    });
  };
};

// node_modules/hono/dist/router/reg-exp-router/node.js
var LABEL_REG_EXP_STR = "[^/]+";
var ONLY_WILDCARD_REG_EXP_STR = ".*";
var TAIL_WILDCARD_REG_EXP_STR = "(?:|/.*)";
var PATH_ERROR = Symbol();
var regExpMetaChars = new Set(".\\+*[^]$()");
function compareKey(a, b) {
  if (a.length === 1) {
    return b.length === 1 ? a < b ? -1 : 1 : -1;
  }
  if (b.length === 1) {
    return 1;
  }
  if (a === ONLY_WILDCARD_REG_EXP_STR || a === TAIL_WILDCARD_REG_EXP_STR) {
    return 1;
  } else if (b === ONLY_WILDCARD_REG_EXP_STR || b === TAIL_WILDCARD_REG_EXP_STR) {
    return -1;
  }
  if (a === LABEL_REG_EXP_STR) {
    return 1;
  } else if (b === LABEL_REG_EXP_STR) {
    return -1;
  }
  return a.length === b.length ? a < b ? -1 : 1 : b.length - a.length;
}
var Node = class {
  #index;
  #varIndex;
  #children = /* @__PURE__ */ Object.create(null);
  insert(tokens, index, paramMap, context, pathErrorCheckOnly) {
    if (tokens.length === 0) {
      if (this.#index !== undefined) {
        throw PATH_ERROR;
      }
      if (pathErrorCheckOnly) {
        return;
      }
      this.#index = index;
      return;
    }
    const [token, ...restTokens] = tokens;
    const pattern = token === "*" ? restTokens.length === 0 ? ["", "", ONLY_WILDCARD_REG_EXP_STR] : ["", "", LABEL_REG_EXP_STR] : token === "/*" ? ["", "", TAIL_WILDCARD_REG_EXP_STR] : token.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
    let node;
    if (pattern) {
      const name = pattern[1];
      let regexpStr = pattern[2] || LABEL_REG_EXP_STR;
      if (name && pattern[2]) {
        regexpStr = regexpStr.replace(/^\((?!\?:)(?=[^)]+\)$)/, "(?:");
        if (/\((?!\?:)/.test(regexpStr)) {
          throw PATH_ERROR;
        }
      }
      node = this.#children[regexpStr];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[regexpStr] = new Node;
        if (name !== "") {
          node.#varIndex = context.varIndex++;
        }
      }
      if (!pathErrorCheckOnly && name !== "") {
        paramMap.push([name, node.#varIndex]);
      }
    } else {
      node = this.#children[token];
      if (!node) {
        if (Object.keys(this.#children).some((k) => k.length > 1 && k !== ONLY_WILDCARD_REG_EXP_STR && k !== TAIL_WILDCARD_REG_EXP_STR)) {
          throw PATH_ERROR;
        }
        if (pathErrorCheckOnly) {
          return;
        }
        node = this.#children[token] = new Node;
      }
    }
    node.insert(restTokens, index, paramMap, context, pathErrorCheckOnly);
  }
  buildRegExpStr() {
    const childKeys = Object.keys(this.#children).sort(compareKey);
    const strList = childKeys.map((k) => {
      const c = this.#children[k];
      return (typeof c.#varIndex === "number" ? `(${k})@${c.#varIndex}` : regExpMetaChars.has(k) ? `\\${k}` : k) + c.buildRegExpStr();
    });
    if (typeof this.#index === "number") {
      strList.unshift(`#${this.#index}`);
    }
    if (strList.length === 0) {
      return "";
    }
    if (strList.length === 1) {
      return strList[0];
    }
    return "(?:" + strList.join("|") + ")";
  }
};

// node_modules/hono/dist/router/reg-exp-router/trie.js
var Trie = class {
  #context = { varIndex: 0 };
  #root = new Node;
  insert(path, index, pathErrorCheckOnly) {
    const paramAssoc = [];
    const groups = [];
    for (let i = 0;; ) {
      let replaced = false;
      path = path.replace(/\{[^}]+\}/g, (m) => {
        const mark = `@\\${i}`;
        groups[i] = [mark, m];
        i++;
        replaced = true;
        return mark;
      });
      if (!replaced) {
        break;
      }
    }
    const tokens = path.match(/(?::[^\/]+)|(?:\/\*$)|./g) || [];
    for (let i = groups.length - 1;i >= 0; i--) {
      const [mark] = groups[i];
      for (let j = tokens.length - 1;j >= 0; j--) {
        if (tokens[j].indexOf(mark) !== -1) {
          tokens[j] = tokens[j].replace(mark, groups[i][1]);
          break;
        }
      }
    }
    this.#root.insert(tokens, index, paramAssoc, this.#context, pathErrorCheckOnly);
    return paramAssoc;
  }
  buildRegExp() {
    let regexp = this.#root.buildRegExpStr();
    if (regexp === "") {
      return [/^$/, [], []];
    }
    let captureIndex = 0;
    const indexReplacementMap = [];
    const paramReplacementMap = [];
    regexp = regexp.replace(/#(\d+)|@(\d+)|\.\*\$/g, (_, handlerIndex, paramIndex) => {
      if (handlerIndex !== undefined) {
        indexReplacementMap[++captureIndex] = Number(handlerIndex);
        return "$()";
      }
      if (paramIndex !== undefined) {
        paramReplacementMap[Number(paramIndex)] = ++captureIndex;
        return "";
      }
      return "";
    });
    return [new RegExp(`^${regexp}`), indexReplacementMap, paramReplacementMap];
  }
};

// node_modules/hono/dist/router/reg-exp-router/router.js
var emptyParam = [];
var nullMatcher = [/^$/, [], /* @__PURE__ */ Object.create(null)];
var wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
function buildWildcardRegExp(path) {
  return wildcardRegExpCache[path] ??= new RegExp(path === "*" ? "" : `^${path.replace(/\/\*$|([.\\+*[^\]$()])/g, (_, metaChar) => metaChar ? `\\${metaChar}` : "(?:|/.*)")}$`);
}
function clearWildcardRegExpCache() {
  wildcardRegExpCache = /* @__PURE__ */ Object.create(null);
}
function buildMatcherFromPreprocessedRoutes(routes) {
  const trie = new Trie;
  const handlerData = [];
  if (routes.length === 0) {
    return nullMatcher;
  }
  const routesWithStaticPathFlag = routes.map((route) => [!/\*|\/:/.test(route[0]), ...route]).sort(([isStaticA, pathA], [isStaticB, pathB]) => isStaticA ? 1 : isStaticB ? -1 : pathA.length - pathB.length);
  const staticMap = /* @__PURE__ */ Object.create(null);
  for (let i = 0, j = -1, len = routesWithStaticPathFlag.length;i < len; i++) {
    const [pathErrorCheckOnly, path, handlers] = routesWithStaticPathFlag[i];
    if (pathErrorCheckOnly) {
      staticMap[path] = [handlers.map(([h]) => [h, /* @__PURE__ */ Object.create(null)]), emptyParam];
    } else {
      j++;
    }
    let paramAssoc;
    try {
      paramAssoc = trie.insert(path, j, pathErrorCheckOnly);
    } catch (e) {
      throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
    }
    if (pathErrorCheckOnly) {
      continue;
    }
    handlerData[j] = handlers.map(([h, paramCount]) => {
      const paramIndexMap = /* @__PURE__ */ Object.create(null);
      paramCount -= 1;
      for (;paramCount >= 0; paramCount--) {
        const [key, value] = paramAssoc[paramCount];
        paramIndexMap[key] = value;
      }
      return [h, paramIndexMap];
    });
  }
  const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
  for (let i = 0, len = handlerData.length;i < len; i++) {
    for (let j = 0, len2 = handlerData[i].length;j < len2; j++) {
      const map = handlerData[i][j]?.[1];
      if (!map) {
        continue;
      }
      const keys = Object.keys(map);
      for (let k = 0, len3 = keys.length;k < len3; k++) {
        map[keys[k]] = paramReplacementMap[map[keys[k]]];
      }
    }
  }
  const handlerMap = [];
  for (const i in indexReplacementMap) {
    handlerMap[i] = handlerData[indexReplacementMap[i]];
  }
  return [regexp, handlerMap, staticMap];
}
function findMiddleware(middleware, path) {
  if (!middleware) {
    return;
  }
  for (const k of Object.keys(middleware).sort((a, b) => b.length - a.length)) {
    if (buildWildcardRegExp(k).test(path)) {
      return [...middleware[k]];
    }
  }
  return;
}
var RegExpRouter = class {
  name = "RegExpRouter";
  #middleware;
  #routes;
  constructor() {
    this.#middleware = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
    this.#routes = { [METHOD_NAME_ALL]: /* @__PURE__ */ Object.create(null) };
  }
  add(method, path, handler) {
    const middleware = this.#middleware;
    const routes = this.#routes;
    if (!middleware || !routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    if (!middleware[method]) {
      [middleware, routes].forEach((handlerMap) => {
        handlerMap[method] = /* @__PURE__ */ Object.create(null);
        Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p) => {
          handlerMap[method][p] = [...handlerMap[METHOD_NAME_ALL][p]];
        });
      });
    }
    if (path === "/*") {
      path = "*";
    }
    const paramCount = (path.match(/\/:/g) || []).length;
    if (/\*$/.test(path)) {
      const re = buildWildcardRegExp(path);
      if (method === METHOD_NAME_ALL) {
        Object.keys(middleware).forEach((m) => {
          middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
        });
      } else {
        middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
      }
      Object.keys(middleware).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(middleware[m]).forEach((p) => {
            re.test(p) && middleware[m][p].push([handler, paramCount]);
          });
        }
      });
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          Object.keys(routes[m]).forEach((p) => re.test(p) && routes[m][p].push([handler, paramCount]));
        }
      });
      return;
    }
    const paths = checkOptionalParameter(path) || [path];
    for (let i = 0, len = paths.length;i < len; i++) {
      const path2 = paths[i];
      Object.keys(routes).forEach((m) => {
        if (method === METHOD_NAME_ALL || method === m) {
          routes[m][path2] ||= [
            ...findMiddleware(middleware[m], path2) || findMiddleware(middleware[METHOD_NAME_ALL], path2) || []
          ];
          routes[m][path2].push([handler, paramCount - len + i + 1]);
        }
      });
    }
  }
  match(method, path) {
    clearWildcardRegExpCache();
    const matchers = this.#buildAllMatchers();
    this.match = (method2, path2) => {
      const matcher = matchers[method2] || matchers[METHOD_NAME_ALL];
      const staticMatch = matcher[2][path2];
      if (staticMatch) {
        return staticMatch;
      }
      const match = path2.match(matcher[0]);
      if (!match) {
        return [[], emptyParam];
      }
      const index = match.indexOf("", 1);
      return [matcher[1][index], match];
    };
    return this.match(method, path);
  }
  #buildAllMatchers() {
    const matchers = /* @__PURE__ */ Object.create(null);
    Object.keys(this.#routes).concat(Object.keys(this.#middleware)).forEach((method) => {
      matchers[method] ||= this.#buildMatcher(method);
    });
    this.#middleware = this.#routes = undefined;
    return matchers;
  }
  #buildMatcher(method) {
    const routes = [];
    let hasOwnRoute = method === METHOD_NAME_ALL;
    [this.#middleware, this.#routes].forEach((r) => {
      const ownRoute = r[method] ? Object.keys(r[method]).map((path) => [path, r[method][path]]) : [];
      if (ownRoute.length !== 0) {
        hasOwnRoute ||= true;
        routes.push(...ownRoute);
      } else if (method !== METHOD_NAME_ALL) {
        routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path) => [path, r[METHOD_NAME_ALL][path]]));
      }
    });
    if (!hasOwnRoute) {
      return null;
    } else {
      return buildMatcherFromPreprocessedRoutes(routes);
    }
  }
};

// node_modules/hono/dist/router/smart-router/router.js
var SmartRouter = class {
  name = "SmartRouter";
  #routers = [];
  #routes = [];
  constructor(init) {
    this.#routers = init.routers;
  }
  add(method, path, handler) {
    if (!this.#routes) {
      throw new Error(MESSAGE_MATCHER_IS_ALREADY_BUILT);
    }
    this.#routes.push([method, path, handler]);
  }
  match(method, path) {
    if (!this.#routes) {
      throw new Error("Fatal error");
    }
    const routers = this.#routers;
    const routes = this.#routes;
    const len = routers.length;
    let i = 0;
    let res;
    for (;i < len; i++) {
      const router = routers[i];
      try {
        for (let i2 = 0, len2 = routes.length;i2 < len2; i2++) {
          router.add(...routes[i2]);
        }
        res = router.match(method, path);
      } catch (e) {
        if (e instanceof UnsupportedPathError) {
          continue;
        }
        throw e;
      }
      this.match = router.match.bind(router);
      this.#routers = [router];
      this.#routes = undefined;
      break;
    }
    if (i === len) {
      throw new Error("Fatal error");
    }
    this.name = `SmartRouter + ${this.activeRouter.name}`;
    return res;
  }
  get activeRouter() {
    if (this.#routes || this.#routers.length !== 1) {
      throw new Error("No active router has been determined yet.");
    }
    return this.#routers[0];
  }
};

// node_modules/hono/dist/router/trie-router/node.js
var emptyParams = /* @__PURE__ */ Object.create(null);
var Node2 = class {
  #methods;
  #children;
  #patterns;
  #order = 0;
  #params = emptyParams;
  constructor(method, handler, children) {
    this.#children = children || /* @__PURE__ */ Object.create(null);
    this.#methods = [];
    if (method && handler) {
      const m = /* @__PURE__ */ Object.create(null);
      m[method] = { handler, possibleKeys: [], score: 0 };
      this.#methods = [m];
    }
    this.#patterns = [];
  }
  insert(method, path, handler) {
    this.#order = ++this.#order;
    let curNode = this;
    const parts = splitRoutingPath(path);
    const possibleKeys = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const p = parts[i];
      const nextP = parts[i + 1];
      const pattern = getPattern(p, nextP);
      const key = Array.isArray(pattern) ? pattern[0] : p;
      if (key in curNode.#children) {
        curNode = curNode.#children[key];
        if (pattern) {
          possibleKeys.push(pattern[1]);
        }
        continue;
      }
      curNode.#children[key] = new Node2;
      if (pattern) {
        curNode.#patterns.push(pattern);
        possibleKeys.push(pattern[1]);
      }
      curNode = curNode.#children[key];
    }
    curNode.#methods.push({
      [method]: {
        handler,
        possibleKeys: possibleKeys.filter((v, i, a) => a.indexOf(v) === i),
        score: this.#order
      }
    });
    return curNode;
  }
  #getHandlerSets(node, method, nodeParams, params) {
    const handlerSets = [];
    for (let i = 0, len = node.#methods.length;i < len; i++) {
      const m = node.#methods[i];
      const handlerSet = m[method] || m[METHOD_NAME_ALL];
      const processedSet = {};
      if (handlerSet !== undefined) {
        handlerSet.params = /* @__PURE__ */ Object.create(null);
        handlerSets.push(handlerSet);
        if (nodeParams !== emptyParams || params && params !== emptyParams) {
          for (let i2 = 0, len2 = handlerSet.possibleKeys.length;i2 < len2; i2++) {
            const key = handlerSet.possibleKeys[i2];
            const processed = processedSet[handlerSet.score];
            handlerSet.params[key] = params?.[key] && !processed ? params[key] : nodeParams[key] ?? params?.[key];
            processedSet[handlerSet.score] = true;
          }
        }
      }
    }
    return handlerSets;
  }
  search(method, path) {
    const handlerSets = [];
    this.#params = emptyParams;
    const curNode = this;
    let curNodes = [curNode];
    const parts = splitPath(path);
    const curNodesQueue = [];
    for (let i = 0, len = parts.length;i < len; i++) {
      const part = parts[i];
      const isLast = i === len - 1;
      const tempNodes = [];
      for (let j = 0, len2 = curNodes.length;j < len2; j++) {
        const node = curNodes[j];
        const nextNode = node.#children[part];
        if (nextNode) {
          nextNode.#params = node.#params;
          if (isLast) {
            if (nextNode.#children["*"]) {
              handlerSets.push(...this.#getHandlerSets(nextNode.#children["*"], method, node.#params));
            }
            handlerSets.push(...this.#getHandlerSets(nextNode, method, node.#params));
          } else {
            tempNodes.push(nextNode);
          }
        }
        for (let k = 0, len3 = node.#patterns.length;k < len3; k++) {
          const pattern = node.#patterns[k];
          const params = node.#params === emptyParams ? {} : { ...node.#params };
          if (pattern === "*") {
            const astNode = node.#children["*"];
            if (astNode) {
              handlerSets.push(...this.#getHandlerSets(astNode, method, node.#params));
              astNode.#params = params;
              tempNodes.push(astNode);
            }
            continue;
          }
          if (!part) {
            continue;
          }
          const [key, name, matcher] = pattern;
          const child = node.#children[key];
          const restPathString = parts.slice(i).join("/");
          if (matcher instanceof RegExp) {
            const m = matcher.exec(restPathString);
            if (m) {
              params[name] = m[0];
              handlerSets.push(...this.#getHandlerSets(child, method, node.#params, params));
              if (Object.keys(child.#children).length) {
                child.#params = params;
                const componentCount = m[0].match(/\//)?.length ?? 0;
                const targetCurNodes = curNodesQueue[componentCount] ||= [];
                targetCurNodes.push(child);
              }
              continue;
            }
          }
          if (matcher === true || matcher.test(part)) {
            params[name] = part;
            if (isLast) {
              handlerSets.push(...this.#getHandlerSets(child, method, params, node.#params));
              if (child.#children["*"]) {
                handlerSets.push(...this.#getHandlerSets(child.#children["*"], method, params, node.#params));
              }
            } else {
              child.#params = params;
              tempNodes.push(child);
            }
          }
        }
      }
      curNodes = tempNodes.concat(curNodesQueue.shift() ?? []);
    }
    if (handlerSets.length > 1) {
      handlerSets.sort((a, b) => {
        return a.score - b.score;
      });
    }
    return [handlerSets.map(({ handler, params }) => [handler, params])];
  }
};

// node_modules/hono/dist/router/trie-router/router.js
var TrieRouter = class {
  name = "TrieRouter";
  #node;
  constructor() {
    this.#node = new Node2;
  }
  add(method, path, handler) {
    const results = checkOptionalParameter(path);
    if (results) {
      for (let i = 0, len = results.length;i < len; i++) {
        this.#node.insert(method, results[i], handler);
      }
      return;
    }
    this.#node.insert(method, path, handler);
  }
  match(method, path) {
    return this.#node.search(method, path);
  }
};

// node_modules/hono/dist/hono.js
var Hono2 = class extends Hono {
  constructor(options = {}) {
    super(options);
    this.router = options.router ?? new SmartRouter({
      routers: [new RegExpRouter, new TrieRouter]
    });
  }
};

// node_modules/zod/dist/esm/v3/external.js
var exports_external = {};
__export(exports_external, {
  void: () => voidType,
  util: () => util,
  unknown: () => unknownType,
  union: () => unionType,
  undefined: () => undefinedType,
  tuple: () => tupleType,
  transformer: () => effectsType,
  symbol: () => symbolType,
  string: () => stringType,
  strictObject: () => strictObjectType,
  setErrorMap: () => setErrorMap,
  set: () => setType,
  record: () => recordType,
  quotelessJson: () => quotelessJson,
  promise: () => promiseType,
  preprocess: () => preprocessType,
  pipeline: () => pipelineType,
  ostring: () => ostring,
  optional: () => optionalType,
  onumber: () => onumber,
  oboolean: () => oboolean,
  objectUtil: () => objectUtil,
  object: () => objectType,
  number: () => numberType,
  nullable: () => nullableType,
  null: () => nullType,
  never: () => neverType,
  nativeEnum: () => nativeEnumType,
  nan: () => nanType,
  map: () => mapType,
  makeIssue: () => makeIssue,
  literal: () => literalType,
  lazy: () => lazyType,
  late: () => late,
  isValid: () => isValid,
  isDirty: () => isDirty,
  isAsync: () => isAsync,
  isAborted: () => isAborted,
  intersection: () => intersectionType,
  instanceof: () => instanceOfType,
  getParsedType: () => getParsedType,
  getErrorMap: () => getErrorMap,
  function: () => functionType,
  enum: () => enumType,
  effect: () => effectsType,
  discriminatedUnion: () => discriminatedUnionType,
  defaultErrorMap: () => en_default,
  datetimeRegex: () => datetimeRegex,
  date: () => dateType,
  custom: () => custom,
  coerce: () => coerce,
  boolean: () => booleanType,
  bigint: () => bigIntType,
  array: () => arrayType,
  any: () => anyType,
  addIssueToContext: () => addIssueToContext,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransformer: () => ZodEffects,
  ZodSymbol: () => ZodSymbol,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodSchema: () => ZodType,
  ZodRecord: () => ZodRecord,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPipeline: () => ZodPipeline,
  ZodParsedType: () => ZodParsedType,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNever: () => ZodNever,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEffects: () => ZodEffects,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCatch: () => ZodCatch,
  ZodBranded: () => ZodBranded,
  ZodBoolean: () => ZodBoolean,
  ZodBigInt: () => ZodBigInt,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  Schema: () => ZodType,
  ParseStatus: () => ParseStatus,
  OK: () => OK,
  NEVER: () => NEVER,
  INVALID: () => INVALID,
  EMPTY_PATH: () => EMPTY_PATH,
  DIRTY: () => DIRTY,
  BRAND: () => BRAND
});

// node_modules/zod/dist/esm/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {};
  function assertIs(_arg) {}
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/dist/esm/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/dist/esm/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/dist/esm/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
// node_modules/zod/dist/esm/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== undefined) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === en_default ? undefined : en_default
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/zod/dist/esm/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/dist/esm/v3/types.js
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}

class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {} else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [undefined, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
// node_modules/@hono/zod-openapi/dist/index.js
var OpenAPIHono = class _OpenAPIHono extends Hono2 {
  openAPIRegistry;
  defaultHook;
  constructor(init) {
    super(init);
    this.openAPIRegistry = new import_zod_to_openapi.OpenAPIRegistry;
    this.defaultHook = init?.defaultHook;
  }
  openapi = ({ middleware: routeMiddleware, hide, ...route }, handler, hook = this.defaultHook) => {
    if (!hide) {
      this.openAPIRegistry.registerPath(route);
    }
    const validators = [];
    if (route.request?.query) {
      const validator2 = zValidator("query", route.request.query, hook);
      validators.push(validator2);
    }
    if (route.request?.params) {
      const validator2 = zValidator("param", route.request.params, hook);
      validators.push(validator2);
    }
    if (route.request?.headers) {
      const validator2 = zValidator("header", route.request.headers, hook);
      validators.push(validator2);
    }
    if (route.request?.cookies) {
      const validator2 = zValidator("cookie", route.request.cookies, hook);
      validators.push(validator2);
    }
    const bodyContent = route.request?.body?.content;
    if (bodyContent) {
      for (const mediaType of Object.keys(bodyContent)) {
        if (!bodyContent[mediaType]) {
          continue;
        }
        const schema = bodyContent[mediaType]["schema"];
        if (!(schema instanceof ZodType)) {
          continue;
        }
        if (isJSONContentType(mediaType)) {
          const validator2 = zValidator("json", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = async (c, next) => {
              if (c.req.header("content-type")) {
                if (isJSONContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("json", {});
              await next();
            };
            validators.push(mw);
          }
        }
        if (isFormContentType(mediaType)) {
          const validator2 = zValidator("form", schema, hook);
          if (route.request?.body?.required) {
            validators.push(validator2);
          } else {
            const mw = async (c, next) => {
              if (c.req.header("content-type")) {
                if (isFormContentType(c.req.header("content-type"))) {
                  return await validator2(c, next);
                }
              }
              c.req.addValidatedData("form", {});
              await next();
            };
            validators.push(mw);
          }
        }
      }
    }
    const middleware = routeMiddleware ? Array.isArray(routeMiddleware) ? routeMiddleware : [routeMiddleware] : [];
    this.on([route.method], route.path.replaceAll(/\/{(.+?)}/g, "/:$1"), ...middleware, ...validators, handler);
    return this;
  };
  getOpenAPIDocument = (config) => {
    const generator = new import_zod_to_openapi.OpenApiGeneratorV3(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  };
  getOpenAPI31Document = (config) => {
    const generator = new import_zod_to_openapi.OpenApiGeneratorV31(this.openAPIRegistry.definitions);
    const document2 = generator.generateDocument(config);
    return this._basePath ? addBasePathToDocument(document2, this._basePath) : document2;
  };
  doc = (path, configure) => {
    return this.get(path, (c) => {
      const config = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPIDocument(config);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  };
  doc31 = (path, configure) => {
    return this.get(path, (c) => {
      const config = typeof configure === "function" ? configure(c) : configure;
      try {
        const document2 = this.getOpenAPI31Document(config);
        return c.json(document2);
      } catch (e) {
        return c.json(e, 500);
      }
    });
  };
  route(path, app) {
    const pathForOpenAPI = path.replaceAll(/:([^\/]+)/g, "{$1}");
    super.route(path, app);
    if (!(app instanceof _OpenAPIHono)) {
      return this;
    }
    app.openAPIRegistry.definitions.forEach((def) => {
      switch (def.type) {
        case "component":
          return this.openAPIRegistry.registerComponent(def.componentType, def.name, def.component);
        case "route": {
          this.openAPIRegistry.registerPath({
            ...def.route,
            path: mergePath(pathForOpenAPI, app._basePath.replaceAll(/:([^\/]+)/g, "{$1}"), def.route.path)
          });
          return;
        }
        case "webhook": {
          this.openAPIRegistry.registerWebhook({
            ...def.webhook,
            path: mergePath(pathForOpenAPI, app._basePath.replaceAll(/:([^\/]+)/g, "{$1}"), def.webhook.path)
          });
          return;
        }
        case "schema":
          return this.openAPIRegistry.register(def.schema._def.openapi._internal.refId, def.schema);
        case "parameter":
          return this.openAPIRegistry.registerParameter(def.schema._def.openapi._internal.refId, def.schema);
        default: {
          const errorIfNotExhaustive = def;
          throw new Error(`Unknown registry type: ${errorIfNotExhaustive}`);
        }
      }
    });
    return this;
  }
  basePath(path) {
    return new _OpenAPIHono({ ...super.basePath(path), defaultHook: this.defaultHook });
  }
};
var createRoute = (routeConfig) => {
  const route = {
    ...routeConfig,
    getRoutingPath() {
      return routeConfig.path.replaceAll(/\/{(.+?)}/g, "/:$1");
    }
  };
  return Object.defineProperty(route, "getRoutingPath", { enumerable: false });
};
import_zod_to_openapi.extendZodWithOpenApi(exports_external);
function addBasePathToDocument(document2, basePath) {
  const updatedPaths = {};
  Object.keys(document2.paths).forEach((path) => {
    updatedPaths[mergePath(basePath.replaceAll(/:([^\/]+)/g, "{$1}"), path)] = document2.paths[path];
  });
  return {
    ...document2,
    paths: updatedPaths
  };
}
function isJSONContentType(contentType) {
  return /^application\/([a-z-\.]+\+)?json/.test(contentType);
}
function isFormContentType(contentType) {
  return contentType.startsWith("multipart/form-data") || contentType.startsWith("application/x-www-form-urlencoded");
}

// node_modules/hono/dist/middleware/cors/index.js
var cors = (options) => {
  const defaults = {
    origin: "*",
    allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH"],
    allowHeaders: [],
    exposeHeaders: []
  };
  const opts = {
    ...defaults,
    ...options
  };
  const findAllowOrigin = ((optsOrigin) => {
    if (typeof optsOrigin === "string") {
      if (optsOrigin === "*") {
        return () => optsOrigin;
      } else {
        return (origin) => optsOrigin === origin ? origin : null;
      }
    } else if (typeof optsOrigin === "function") {
      return optsOrigin;
    } else {
      return (origin) => optsOrigin.includes(origin) ? origin : null;
    }
  })(opts.origin);
  const findAllowMethods = ((optsAllowMethods) => {
    if (typeof optsAllowMethods === "function") {
      return optsAllowMethods;
    } else if (Array.isArray(optsAllowMethods)) {
      return () => optsAllowMethods;
    } else {
      return () => [];
    }
  })(opts.allowMethods);
  return async function cors2(c, next) {
    function set(key, value) {
      c.res.headers.set(key, value);
    }
    const allowOrigin = findAllowOrigin(c.req.header("origin") || "", c);
    if (allowOrigin) {
      set("Access-Control-Allow-Origin", allowOrigin);
    }
    if (opts.origin !== "*") {
      const existingVary = c.req.header("Vary");
      if (existingVary) {
        set("Vary", existingVary);
      } else {
        set("Vary", "Origin");
      }
    }
    if (opts.credentials) {
      set("Access-Control-Allow-Credentials", "true");
    }
    if (opts.exposeHeaders?.length) {
      set("Access-Control-Expose-Headers", opts.exposeHeaders.join(","));
    }
    if (c.req.method === "OPTIONS") {
      if (opts.maxAge != null) {
        set("Access-Control-Max-Age", opts.maxAge.toString());
      }
      const allowMethods = findAllowMethods(c.req.header("origin") || "", c);
      if (allowMethods.length) {
        set("Access-Control-Allow-Methods", allowMethods.join(","));
      }
      let headers = opts.allowHeaders;
      if (!headers?.length) {
        const requestHeaders = c.req.header("Access-Control-Request-Headers");
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/);
        }
      }
      if (headers?.length) {
        set("Access-Control-Allow-Headers", headers.join(","));
        c.res.headers.append("Vary", "Access-Control-Request-Headers");
      }
      c.res.headers.delete("Content-Length");
      c.res.headers.delete("Content-Type");
      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: "No Content"
      });
    }
    await next();
  };
};

// node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs
var DEV_OR_STAGING_SUFFIXES = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
];

// node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs
var defaultOptions = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (_, iteration) => iteration < 5,
  retryImmediately: false,
  jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms) => new Promise((s) => setTimeout(s, ms));
var applyJitter = (delay, jitter) => {
  return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts) => {
  let timesCalled = 0;
  const calculateDelayInMs = () => {
    const constant = opts.initialDelay;
    const base = opts.factor;
    let delay = constant * Math.pow(base, timesCalled);
    delay = applyJitter(delay, opts.jitter);
    return Math.min(opts.maxDelayBetweenRetries || delay, delay);
  };
  return async () => {
    await sleep(calculateDelayInMs());
    timesCalled++;
  };
};
var retry = async (callback, options = {}) => {
  let iterations = 0;
  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter } = {
    ...defaultOptions,
    ...options
  };
  const delay = createExponentialDelayAsyncFn({
    initialDelay,
    maxDelayBetweenRetries,
    factor,
    jitter
  });
  while (true) {
    try {
      return await callback();
    } catch (e) {
      iterations++;
      if (!shouldRetry(e, iterations)) {
        throw e;
      }
      if (retryImmediately && iterations === 1) {
        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
      } else {
        await delay();
      }
    }
  }
};

// node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") {
    return atob(data);
  } else if (typeof global !== "undefined" && global.Buffer) {
    return new global.Buffer(data, "base64").toString();
  }
  return data;
};

// node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs
function createDevOrStagingUrlCache() {
  const devOrStagingUrlCache = /* @__PURE__ */ new Map;
  return {
    isDevOrStagingUrl: (url) => {
      if (!url) {
        return false;
      }
      const hostname = typeof url === "string" ? url : url.hostname;
      let res = devOrStagingUrlCache.get(hostname);
      if (res === undefined) {
        res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
        devOrStagingUrlCache.set(hostname, res);
      }
      return res;
    }
  };
}

// node_modules/@clerk/shared/dist/chunk-35WGBVWP.mjs
var DefaultMessages = Object.freeze({
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  function buildMessage(rawMessage, replacements) {
    if (!replacements) {
      return `${pkg}: ${rawMessage}`;
    }
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  return {
    setPackageName({ packageName: packageName2 }) {
      if (typeof packageName2 === "string") {
        pkg = packageName2;
      }
      return this;
    },
    setMessages({ customMessages: customMessages2 }) {
      Object.assign(messages, customMessages2 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(params) {
      throw new Error(buildMessage(messages.MissingClerkProvider, params));
    },
    throw(message) {
      throw new Error(buildMessage(message));
    }
  };
}

// node_modules/@clerk/backend/dist/chunk-LWOXHF4E.mjs
var errorThrower = buildErrorThrower({ packageName: "@clerk/backend" });
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();

// node_modules/@clerk/backend/dist/chunk-YW6OOOXM.mjs
var TokenVerificationErrorCode = {
  InvalidSecretKey: "clerk_key_invalid"
};
var TokenVerificationErrorReason = {
  TokenExpired: "token-expired",
  TokenInvalid: "token-invalid",
  TokenInvalidAlgorithm: "token-invalid-algorithm",
  TokenInvalidAuthorizedParties: "token-invalid-authorized-parties",
  TokenInvalidSignature: "token-invalid-signature",
  TokenNotActiveYet: "token-not-active-yet",
  TokenIatInTheFuture: "token-iat-in-the-future",
  TokenVerificationFailed: "token-verification-failed",
  InvalidSecretKey: "secret-key-invalid",
  LocalJWKMissing: "jwk-local-missing",
  RemoteJWKFailedToLoad: "jwk-remote-failed-to-load",
  RemoteJWKInvalid: "jwk-remote-invalid",
  RemoteJWKMissing: "jwk-remote-missing",
  JWKFailedToResolve: "jwk-failed-to-resolve",
  JWKKidMismatch: "jwk-kid-mismatch"
};
var TokenVerificationErrorAction = {
  ContactSupport: "Contact support@clerk.com",
  EnsureClerkJWT: "Make sure that this is a valid Clerk generate JWT.",
  SetClerkJWTKey: "Set the CLERK_JWT_KEY environment variable.",
  SetClerkSecretKey: "Set the CLERK_SECRET_KEY environment variable.",
  EnsureClockSync: "Make sure your system clock is in sync (e.g. turn off and on automatic time synchronization)."
};
var TokenVerificationError = class _TokenVerificationError extends Error {
  constructor({
    action,
    message,
    reason
  }) {
    super(message);
    Object.setPrototypeOf(this, _TokenVerificationError.prototype);
    this.reason = reason;
    this.message = message;
    this.action = action;
  }
  getFullMessage() {
    return `${[this.message, this.action].filter((m) => m).join(" ")} (reason=${this.reason}, token-carrier=${this.tokenCarrier})`;
  }
};

// node_modules/@clerk/backend/dist/runtime/node/crypto.mjs
var import_node_crypto = require("node:crypto");

// node_modules/@clerk/backend/dist/chunk-XJ4RTXJG.mjs
var globalFetch = fetch.bind(globalThis);
var runtime = {
  crypto: import_node_crypto.webcrypto,
  get fetch() {
    return globalFetch;
  },
  AbortController: globalThis.AbortController,
  Blob: globalThis.Blob,
  FormData: globalThis.FormData,
  Headers: globalThis.Headers,
  Request: globalThis.Request,
  Response: globalThis.Response
};
var base64url = {
  parse(string, opts) {
    return parse2(string, base64UrlEncoding, opts);
  },
  stringify(data, opts) {
    return stringify(data, base64UrlEncoding, opts);
  }
};
var base64UrlEncoding = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bits: 6
};
function parse2(string, encoding, opts = {}) {
  if (!encoding.codes) {
    encoding.codes = {};
    for (let i = 0;i < encoding.chars.length; ++i) {
      encoding.codes[encoding.chars[i]] = i;
    }
  }
  if (!opts.loose && string.length * encoding.bits & 7) {
    throw new SyntaxError("Invalid padding");
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {
      throw new SyntaxError("Invalid padding");
    }
  }
  const out = new (opts.out ?? Uint8Array)(end * encoding.bits / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0;i < end; ++i) {
    const value = encoding.codes[string[i]];
    if (value === undefined) {
      throw new SyntaxError("Invalid character " + string[i]);
    }
    buffer = buffer << encoding.bits | value;
    bits += encoding.bits;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= encoding.bits || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
}
function stringify(data, encoding, opts = {}) {
  const { pad = true } = opts;
  const mask = (1 << encoding.bits) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0;i < data.length; ++i) {
    buffer = buffer << 8 | 255 & data[i];
    bits += 8;
    while (bits > encoding.bits) {
      bits -= encoding.bits;
      out += encoding.chars[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += encoding.chars[mask & buffer << encoding.bits - bits];
  }
  if (pad) {
    while (out.length * encoding.bits & 7) {
      out += "=";
    }
  }
  return out;
}
var algToHash = {
  RS256: "SHA-256",
  RS384: "SHA-384",
  RS512: "SHA-512"
};
var RSA_ALGORITHM_NAME = "RSASSA-PKCS1-v1_5";
var jwksAlgToCryptoAlg = {
  RS256: RSA_ALGORITHM_NAME,
  RS384: RSA_ALGORITHM_NAME,
  RS512: RSA_ALGORITHM_NAME
};
var algs = Object.keys(algToHash);
function getCryptoAlgorithm(algorithmName) {
  const hash = algToHash[algorithmName];
  const name = jwksAlgToCryptoAlg[algorithmName];
  if (!hash || !name) {
    throw new Error(`Unsupported algorithm ${algorithmName}, expected one of ${algs.join(",")}.`);
  }
  return {
    hash: { name: algToHash[algorithmName] },
    name: jwksAlgToCryptoAlg[algorithmName]
  };
}
var isArrayString = (s) => {
  return Array.isArray(s) && s.length > 0 && s.every((a) => typeof a === "string");
};
var assertAudienceClaim = (aud, audience) => {
  const audienceList = [audience].flat().filter((a) => !!a);
  const audList = [aud].flat().filter((a) => !!a);
  const shouldVerifyAudience = audienceList.length > 0 && audList.length > 0;
  if (!shouldVerifyAudience) {
    return;
  }
  if (typeof aud === "string") {
    if (!audienceList.includes(aud)) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.EnsureClerkJWT,
        reason: TokenVerificationErrorReason.TokenVerificationFailed,
        message: `Invalid JWT audience claim (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(audienceList)}".`
      });
    }
  } else if (isArrayString(aud)) {
    if (!aud.some((a) => audienceList.includes(a))) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.EnsureClerkJWT,
        reason: TokenVerificationErrorReason.TokenVerificationFailed,
        message: `Invalid JWT audience claim array (aud) ${JSON.stringify(aud)}. Is not included in "${JSON.stringify(audienceList)}".`
      });
    }
  }
};
var assertHeaderType = (typ) => {
  if (typeof typ === "undefined") {
    return;
  }
  if (typ !== "JWT") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenInvalid,
      message: `Invalid JWT type ${JSON.stringify(typ)}. Expected "JWT".`
    });
  }
};
var assertHeaderAlgorithm = (alg) => {
  if (!algs.includes(alg)) {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenInvalidAlgorithm,
      message: `Invalid JWT algorithm ${JSON.stringify(alg)}. Supported: ${algs}.`
    });
  }
};
var assertSubClaim = (sub) => {
  if (typeof sub !== "string") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Subject claim (sub) is required and must be a string. Received ${JSON.stringify(sub)}.`
    });
  }
};
var assertAuthorizedPartiesClaim = (azp, authorizedParties) => {
  if (!azp || !authorizedParties || authorizedParties.length === 0) {
    return;
  }
  if (!authorizedParties.includes(azp)) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenInvalidAuthorizedParties,
      message: `Invalid JWT Authorized party claim (azp) ${JSON.stringify(azp)}. Expected "${authorizedParties}".`
    });
  }
};
var assertExpirationClaim = (exp, clockSkewInMs) => {
  if (typeof exp !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT expiry date claim (exp) ${JSON.stringify(exp)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const expiryDate = /* @__PURE__ */ new Date(0);
  expiryDate.setUTCSeconds(exp);
  const expired = expiryDate.getTime() <= currentDate.getTime() - clockSkewInMs;
  if (expired) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenExpired,
      message: `JWT is expired. Expiry date: ${expiryDate.toUTCString()}, Current date: ${currentDate.toUTCString()}.`
    });
  }
};
var assertActivationClaim = (nbf, clockSkewInMs) => {
  if (typeof nbf === "undefined") {
    return;
  }
  if (typeof nbf !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT not before date claim (nbf) ${JSON.stringify(nbf)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const notBeforeDate = /* @__PURE__ */ new Date(0);
  notBeforeDate.setUTCSeconds(nbf);
  const early = notBeforeDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (early) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenNotActiveYet,
      message: `JWT cannot be used prior to not before date claim (nbf). Not before date: ${notBeforeDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
var assertIssuedAtClaim = (iat, clockSkewInMs) => {
  if (typeof iat === "undefined") {
    return;
  }
  if (typeof iat !== "number") {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.EnsureClerkJWT,
      reason: TokenVerificationErrorReason.TokenVerificationFailed,
      message: `Invalid JWT issued at date claim (iat) ${JSON.stringify(iat)}. Expected number.`
    });
  }
  const currentDate = new Date(Date.now());
  const issuedAtDate = /* @__PURE__ */ new Date(0);
  issuedAtDate.setUTCSeconds(iat);
  const postIssued = issuedAtDate.getTime() > currentDate.getTime() + clockSkewInMs;
  if (postIssued) {
    throw new TokenVerificationError({
      reason: TokenVerificationErrorReason.TokenIatInTheFuture,
      message: `JWT issued at date claim (iat) is in the future. Issued at date: ${issuedAtDate.toUTCString()}; Current date: ${currentDate.toUTCString()};`
    });
  }
};
function pemToBuffer(secret) {
  const trimmed = secret.replace(/-----BEGIN.*?-----/g, "").replace(/-----END.*?-----/g, "").replace(/\s/g, "");
  const decoded = isomorphicAtob(trimmed);
  const buffer = new ArrayBuffer(decoded.length);
  const bufView = new Uint8Array(buffer);
  for (let i = 0, strLen = decoded.length;i < strLen; i++) {
    bufView[i] = decoded.charCodeAt(i);
  }
  return bufView;
}
function importKey(key, algorithm, keyUsage) {
  if (typeof key === "object") {
    return runtime.crypto.subtle.importKey("jwk", key, algorithm, false, [keyUsage]);
  }
  const keyData = pemToBuffer(key);
  const format = keyUsage === "sign" ? "pkcs8" : "spki";
  return runtime.crypto.subtle.importKey(format, keyData, algorithm, false, [keyUsage]);
}
var DEFAULT_CLOCK_SKEW_IN_MS = 5 * 1000;
async function hasValidSignature(jwt, key) {
  const { header, signature, raw: raw2 } = jwt;
  const encoder = new TextEncoder;
  const data = encoder.encode([raw2.header, raw2.payload].join("."));
  const algorithm = getCryptoAlgorithm(header.alg);
  try {
    const cryptoKey = await importKey(key, algorithm, "verify");
    const verified = await runtime.crypto.subtle.verify(algorithm.name, cryptoKey, signature, data);
    return { data: verified };
  } catch (error) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalidSignature,
          message: error?.message
        })
      ]
    };
  }
}
function decodeJwt(token) {
  const tokenParts = (token || "").toString().split(".");
  if (tokenParts.length !== 3) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalid,
          message: `Invalid JWT form. A JWT consists of three parts separated by dots.`
        })
      ]
    };
  }
  const [rawHeader, rawPayload, rawSignature] = tokenParts;
  const decoder = new TextDecoder;
  const header = JSON.parse(decoder.decode(base64url.parse(rawHeader, { loose: true })));
  const payload = JSON.parse(decoder.decode(base64url.parse(rawPayload, { loose: true })));
  const signature = base64url.parse(rawSignature, { loose: true });
  const data = {
    header,
    payload,
    signature,
    raw: {
      header: rawHeader,
      payload: rawPayload,
      signature: rawSignature,
      text: token
    }
  };
  return { data };
}
async function verifyJwt(token, options) {
  const { audience, authorizedParties, clockSkewInMs, key } = options;
  const clockSkew = clockSkewInMs || DEFAULT_CLOCK_SKEW_IN_MS;
  const { data: decoded, errors: errors2 } = decodeJwt(token);
  if (errors2) {
    return { errors: errors2 };
  }
  const { header, payload } = decoded;
  try {
    const { typ, alg } = header;
    assertHeaderType(typ);
    assertHeaderAlgorithm(alg);
    const { azp, sub, aud, iat, exp, nbf } = payload;
    assertSubClaim(sub);
    assertAudienceClaim([aud], [audience]);
    assertAuthorizedPartiesClaim(azp, authorizedParties);
    assertExpirationClaim(exp, clockSkew);
    assertActivationClaim(nbf, clockSkew);
    assertIssuedAtClaim(iat, clockSkew);
  } catch (err) {
    return { errors: [err] };
  }
  const { data: signatureValid, errors: signatureErrors } = await hasValidSignature(decoded, key);
  if (signatureErrors) {
    return {
      errors: [
        new TokenVerificationError({
          action: TokenVerificationErrorAction.EnsureClerkJWT,
          reason: TokenVerificationErrorReason.TokenVerificationFailed,
          message: `Error verifying JWT signature. ${signatureErrors[0]}`
        })
      ]
    };
  }
  if (!signatureValid) {
    return {
      errors: [
        new TokenVerificationError({
          reason: TokenVerificationErrorReason.TokenInvalidSignature,
          message: "JWT signature is invalid."
        })
      ]
    };
  }
  return { data: payload };
}

// node_modules/@clerk/backend/dist/chunk-HJEYNBQX.mjs
var import_cookie3 = __toESM(require_dist2(), 1);
var API_URL = "https://api.clerk.com";
var API_VERSION = "v1";
var USER_AGENT = `${"@clerk/backend"}@${"2.5.0"}`;
var MAX_CACHE_LAST_UPDATED_AT_SECONDS = 5 * 60;
var SUPPORTED_BAPI_VERSION = "2025-04-10";
var Cookies = {
  Session: "__session",
  Refresh: "__refresh",
  ClientUat: "__client_uat",
  Handshake: "__clerk_handshake",
  DevBrowser: "__clerk_db_jwt",
  RedirectCount: "__clerk_redirect_count",
  HandshakeNonce: "__clerk_handshake_nonce"
};
var QueryParameters = {
  ClerkSynced: "__clerk_synced",
  SuffixedCookies: "suffixed_cookies",
  ClerkRedirectUrl: "__clerk_redirect_url",
  DevBrowser: Cookies.DevBrowser,
  Handshake: Cookies.Handshake,
  HandshakeHelp: "__clerk_help",
  LegacyDevBrowser: "__dev_session",
  HandshakeReason: "__clerk_hs_reason",
  HandshakeNonce: Cookies.HandshakeNonce,
  HandshakeFormat: "format"
};
var SEPARATOR = "/";
var MULTIPLE_SEPARATOR_REGEX = new RegExp("(?<!:)" + SEPARATOR + "{1,}", "g");
function joinPaths(...args) {
  return args.filter((p) => p).join(SEPARATOR).replace(MULTIPLE_SEPARATOR_REGEX, SEPARATOR);
}
var mapObjectSkip = Symbol("mapObjectSkip");
var PlainObjectConstructor = {}.constructor;
var cache = {};
var lastUpdatedAt = 0;
function getFromCache(kid) {
  return cache[kid];
}
function getCacheValues() {
  return Object.values(cache);
}
function setInCache(jwk, shouldExpire = true) {
  cache[jwk.kid] = jwk;
  lastUpdatedAt = shouldExpire ? Date.now() : -1;
}
var LocalJwkKid = "local";
var PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
var PEM_TRAILER = "-----END PUBLIC KEY-----";
var RSA_PREFIX = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA";
var RSA_SUFFIX = "IDAQAB";
function loadClerkJWKFromLocal(localKey) {
  if (!getFromCache(LocalJwkKid)) {
    if (!localKey) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.SetClerkJWTKey,
        message: "Missing local JWK.",
        reason: TokenVerificationErrorReason.LocalJWKMissing
      });
    }
    const modulus = localKey.replace(/\r\n|\n|\r/g, "").replace(PEM_HEADER, "").replace(PEM_TRAILER, "").replace(RSA_PREFIX, "").replace(RSA_SUFFIX, "").replace(/\+/g, "-").replace(/\//g, "_");
    setInCache({
      kid: "local",
      kty: "RSA",
      alg: "RS256",
      n: modulus,
      e: "AQAB"
    }, false);
  }
  return getFromCache(LocalJwkKid);
}
async function loadClerkJWKFromRemote({
  secretKey,
  apiUrl = API_URL,
  apiVersion = API_VERSION,
  kid,
  skipJwksCache
}) {
  if (skipJwksCache || cacheHasExpired() || !getFromCache(kid)) {
    if (!secretKey) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: "Failed to load JWKS from Clerk Backend or Frontend API.",
        reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
      });
    }
    const fetcher = () => fetchJWKSFromBAPI(apiUrl, secretKey, apiVersion);
    const { keys } = await retry(fetcher);
    if (!keys || !keys.length) {
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: "The JWKS endpoint did not contain any signing keys. Contact support@clerk.com.",
        reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
      });
    }
    keys.forEach((key) => setInCache(key));
  }
  const jwk = getFromCache(kid);
  if (!jwk) {
    const cacheValues = getCacheValues();
    const jwkKeys = cacheValues.map((jwk2) => jwk2.kid).sort().join(", ");
    throw new TokenVerificationError({
      action: `Go to your Dashboard and validate your secret and public keys are correct. ${TokenVerificationErrorAction.ContactSupport} if the issue persists.`,
      message: `Unable to find a signing key in JWKS that matches the kid='${kid}' of the provided session token. Please make sure that the __session cookie or the HTTP authorization header contain a Clerk-generated session JWT. The following kid is available: ${jwkKeys}`,
      reason: TokenVerificationErrorReason.JWKKidMismatch
    });
  }
  return jwk;
}
async function fetchJWKSFromBAPI(apiUrl, key, apiVersion) {
  if (!key) {
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.SetClerkSecretKey,
      message: "Missing Clerk Secret Key or API Key. Go to https://dashboard.clerk.com and get your key for your instance.",
      reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
    });
  }
  const url = new URL(apiUrl);
  url.pathname = joinPaths(url.pathname, apiVersion, "/jwks");
  const response = await runtime.fetch(url.href, {
    headers: {
      Authorization: `Bearer ${key}`,
      "Clerk-API-Version": SUPPORTED_BAPI_VERSION,
      "Content-Type": "application/json",
      "User-Agent": USER_AGENT
    }
  });
  if (!response.ok) {
    const json = await response.json();
    const invalidSecretKeyError = getErrorObjectByCode(json?.errors, TokenVerificationErrorCode.InvalidSecretKey);
    if (invalidSecretKeyError) {
      const reason = TokenVerificationErrorReason.InvalidSecretKey;
      throw new TokenVerificationError({
        action: TokenVerificationErrorAction.ContactSupport,
        message: invalidSecretKeyError.message,
        reason
      });
    }
    throw new TokenVerificationError({
      action: TokenVerificationErrorAction.ContactSupport,
      message: `Error loading Clerk JWKS from ${url.href} with code=${response.status}`,
      reason: TokenVerificationErrorReason.RemoteJWKFailedToLoad
    });
  }
  return response.json();
}
function cacheHasExpired() {
  if (lastUpdatedAt === -1) {
    return false;
  }
  const isExpired = Date.now() - lastUpdatedAt >= MAX_CACHE_LAST_UPDATED_AT_SECONDS * 1000;
  if (isExpired) {
    cache = {};
  }
  return isExpired;
}
var getErrorObjectByCode = (errors2, code) => {
  if (!errors2) {
    return null;
  }
  return errors2.find((err) => err.code === code);
};
async function verifyToken(token, options) {
  const { data: decodedResult, errors: errors2 } = decodeJwt(token);
  if (errors2) {
    return { errors: errors2 };
  }
  const { header } = decodedResult;
  const { kid } = header;
  try {
    let key;
    if (options.jwtKey) {
      key = loadClerkJWKFromLocal(options.jwtKey);
    } else if (options.secretKey) {
      key = await loadClerkJWKFromRemote({ ...options, kid });
    } else {
      return {
        errors: [
          new TokenVerificationError({
            action: TokenVerificationErrorAction.SetClerkJWTKey,
            message: "Failed to resolve JWK during verification.",
            reason: TokenVerificationErrorReason.JWKFailedToResolve
          })
        ]
      };
    }
    return await verifyJwt(token, { ...options, key });
  } catch (error) {
    return { errors: [error] };
  }
}

// node_modules/@clerk/backend/dist/chunk-P263NW7Z.mjs
function withLegacyReturn(cb) {
  return async (...args) => {
    const { data, errors: errors2 } = await cb(...args);
    if (errors2) {
      throw errors2[0];
    }
    return data;
  };
}

// node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs
function snakeToCamel(str) {
  return str ? str.replace(/([-_][a-z])/g, (match2) => match2.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform) => {
  const deepTransform = (obj) => {
    if (!obj) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((el) => {
        if (typeof el === "object" || Array.isArray(el)) {
          return deepTransform(el);
        }
        return el;
      });
    }
    const copy = { ...obj };
    const keys = Object.keys(copy);
    for (const oldName of keys) {
      const newName = transform(oldName.toString());
      if (newName !== oldName) {
        copy[newName] = copy[oldName];
        delete copy[oldName];
      }
      if (typeof copy[newName] === "object") {
        copy[newName] = deepTransform(copy[newName]);
      }
    }
    return copy;
  };
  return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);

// node_modules/@clerk/shared/dist/chunk-YXR7ZZRP.mjs
var _storageKey;
var _cacheTtl;
var _TelemetryEventThrottler_instances;
var generateKey_fn;
var cache_get;
var isValidBrowser_get;
_storageKey = new WeakMap;
_cacheTtl = new WeakMap;
_TelemetryEventThrottler_instances = new WeakSet;
generateKey_fn = function(event) {
  const { sk: _sk, pk: _pk, payload, ...rest } = event;
  const sanitizedEvent = {
    ...payload,
    ...rest
  };
  return JSON.stringify(Object.keys({
    ...payload,
    ...rest
  }).sort().map((key) => sanitizedEvent[key]));
};
cache_get = function() {
  const cacheString = localStorage.getItem(__privateGet(this, _storageKey));
  if (!cacheString) {
    return {};
  }
  return JSON.parse(cacheString);
};
isValidBrowser_get = function() {
  if (typeof window === "undefined") {
    return false;
  }
  const storage = window.localStorage;
  if (!storage) {
    return false;
  }
  try {
    const testKey = "test";
    storage.setItem(testKey, testKey);
    storage.removeItem(testKey);
    return true;
  } catch (err) {
    const isQuotaExceededError = err instanceof DOMException && (err.name === "QuotaExceededError" || err.name === "NS_ERROR_DOM_QUOTA_REACHED");
    if (isQuotaExceededError && storage.length > 0) {
      storage.removeItem(__privateGet(this, _storageKey));
    }
    return false;
  }
};
var _config;
var _eventThrottler;
var _metadata;
var _buffer;
var _pendingFlush;
var _TelemetryCollector_instances;
var shouldRecord_fn;
var shouldBeSampled_fn;
var scheduleFlush_fn;
var flush_fn;
var logEvent_fn;
var getSDKMetadata_fn;
var preparePayload_fn;
_config = new WeakMap;
_eventThrottler = new WeakMap;
_metadata = new WeakMap;
_buffer = new WeakMap;
_pendingFlush = new WeakMap;
_TelemetryCollector_instances = new WeakSet;
shouldRecord_fn = function(preparedPayload, eventSamplingRate) {
  return this.isEnabled && !this.isDebug && __privateMethod(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);
};
shouldBeSampled_fn = function(preparedPayload, eventSamplingRate) {
  const randomSeed = Math.random();
  const toBeSampled = randomSeed <= __privateGet(this, _config).samplingRate && (typeof eventSamplingRate === "undefined" || randomSeed <= eventSamplingRate);
  if (!toBeSampled) {
    return false;
  }
  return !__privateGet(this, _eventThrottler).isEventThrottled(preparedPayload);
};
scheduleFlush_fn = function() {
  if (typeof window === "undefined") {
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  const isBufferFull = __privateGet(this, _buffer).length >= __privateGet(this, _config).maxBufferSize;
  if (isBufferFull) {
    if (__privateGet(this, _pendingFlush)) {
      const cancel = typeof cancelIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
      cancel(__privateGet(this, _pendingFlush));
    }
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  if (__privateGet(this, _pendingFlush)) {
    return;
  }
  if ("requestIdleCallback" in window) {
    __privateSet(this, _pendingFlush, requestIdleCallback(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }));
  } else {
    __privateSet(this, _pendingFlush, setTimeout(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }, 0));
  }
};
flush_fn = function() {
  fetch(new URL("/v1/event", __privateGet(this, _config).endpoint), {
    method: "POST",
    body: JSON.stringify({
      events: __privateGet(this, _buffer)
    }),
    headers: {
      "Content-Type": "application/json"
    }
  }).catch(() => {
    return;
  }).then(() => {
    __privateSet(this, _buffer, []);
  }).catch(() => {
    return;
  });
};
logEvent_fn = function(event, payload) {
  if (!this.isDebug) {
    return;
  }
  if (typeof console.groupCollapsed !== "undefined") {
    console.groupCollapsed("[clerk/telemetry]", event);
    console.log(payload);
    console.groupEnd();
  } else {
    console.log("[clerk/telemetry]", event, payload);
  }
};
getSDKMetadata_fn = function() {
  let sdkMetadata = {
    name: __privateGet(this, _metadata).sdk,
    version: __privateGet(this, _metadata).sdkVersion
  };
  if (typeof window !== "undefined" && window.Clerk) {
    sdkMetadata = { ...sdkMetadata, ...window.Clerk.constructor.sdkMetadata };
  }
  return sdkMetadata;
};
preparePayload_fn = function(event, payload) {
  const sdkMetadata = __privateMethod(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);
  return {
    event,
    cv: __privateGet(this, _metadata).clerkVersion ?? "",
    it: __privateGet(this, _metadata).instanceType ?? "",
    sdk: sdkMetadata.name,
    sdkv: sdkMetadata.version,
    ...__privateGet(this, _metadata).publishableKey ? { pk: __privateGet(this, _metadata).publishableKey } : {},
    ...__privateGet(this, _metadata).secretKey ? { sk: __privateGet(this, _metadata).secretKey } : {},
    payload
  };
};

// node_modules/@clerk/backend/dist/index.mjs
var verifyToken2 = withLegacyReturn(verifyToken);

// env.ts
var envSchema = exports_external.object({
  POSTGRES_CONNECTION_STRING: exports_external.string(),
  FLOWCORE_TENANT: exports_external.string(),
  FLOWCORE_DATA_CORE_NAME: exports_external.string(),
  FLOWCORE_WEBHOOK_API_KEY: exports_external.string(),
  FLOWCORE_WEBHOOK_BASE_URL: exports_external.string(),
  CLERK_SECRET_KEY: exports_external.string()
});
var cachedEnv;
function getEnv() {
  if (cachedEnv)
    return cachedEnv;
  const parsed = envSchema.safeParse(process.env);
  if (!parsed.success) {
    const fields = parsed.error.issues.map((i) => i.path.join(".") || "(root)").join(", ");
    const message = `Missing/invalid required environment variables: ${fields}`;
    console.error(message, parsed.error.flatten());
    throw new Error(message);
  }
  cachedEnv = parsed.data;
  return cachedEnv;
}
var zodEnv = new Proxy({}, {
  get(_target, prop) {
    return getEnv()[prop];
  }
});

// src/utils/api-responses.ts
var StatusCodes = {
  CREATED: 201,
  OK: 200,
  ACCEPTED: 202,
  NO_CONTENT: 204,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  UNPROCESSABLE: 422,
  SERVER_ERROR: 500,
  SERVICE_UNAVAILABLE: 503
};
function success(message, data) {
  if (data !== undefined) {
    return {
      success: true,
      message,
      data
    };
  }
  return {
    success: true,
    message
  };
}
function error(message, errors2) {
  return {
    success: false,
    message,
    errors: errors2
  };
}
var ApiResponse = {
  success,
  error
};

// src/middleware/auth.ts
var clerkAuth = () => {
  return async (c, next) => {
    try {
      const authHeader = c.req.header("Authorization");
      if (!authHeader?.startsWith("Bearer ")) {
        return c.json(ApiResponse.error("Authorization header with Bearer token is required"), StatusCodes.UNAUTHORIZED);
      }
      const token = authHeader.substring(7);
      const payload = await verifyToken2(token, {
        secretKey: zodEnv.CLERK_SECRET_KEY
      });
      if (!payload || !payload.sub) {
        return c.json(ApiResponse.error("Invalid or expired token"), StatusCodes.UNAUTHORIZED);
      }
      c.userId = payload.sub;
      await next();
    } catch (error2) {
      console.error("Authentication error:", error2);
      return c.json(ApiResponse.error("Authentication failed", error2), StatusCodes.UNAUTHORIZED);
    }
  };
};
var requireAuth = clerkAuth;

// src/routes/api/food-item/index.ts
var foodItem = new Hono2;
foodItem.use("/*", requireAuth());
var food_item_default = foodItem;

// src/routes/api/habit/index.ts
var habit = new Hono2;
habit.use("/*", requireAuth());
var habit_default = habit;

// src/routes/api/meal/index.ts
var meal = new Hono2;
meal.use("/*", requireAuth());
var meal_default = meal;

// src/routes/api/recipe/index.ts
var recipe = new Hono2;
recipe.use("/*", requireAuth());
var recipe_default = recipe;

// src/routes/api/todo/index.ts
var todo = new Hono2;
todo.use("/*", requireAuth());
var todo_default = todo;
// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream";

class EndOfStreamError extends Error {
  constructor() {
    super(defaultMessages);
    this.name = "EndOfStreamError";
  }
}

class AbortError extends Error {
  constructor(message = "The operation was aborted") {
    super(message);
    this.name = "AbortError";
  }
}
// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer, mayBeLess = false) {
    if (buffer.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer) {
    let remaining = buffer.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
// node_modules/strtok3/lib/stream/WebStreamReader.js
class WebStreamReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
}

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
class WebStreamByobReader extends WebStreamReader {
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    const result = await this.reader.read(new Uint8Array(buffer.length), { min: mayBeLess ? undefined : buffer.length });
    if (result.done) {
      this.endOfStream = result.done;
    }
    if (result.value) {
      buffer.set(result.value);
      return result.value.length;
    }
    return 0;
  }
}
// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
class WebStreamDefaultReader extends AbstractStreamReader {
  constructor(reader) {
    super();
    this.reader = reader;
    this.buffer = null;
  }
  writeChunk(target, chunk) {
    const written = Math.min(chunk.length, target.length);
    target.set(chunk.subarray(0, written));
    if (written < chunk.length) {
      this.buffer = chunk.subarray(written);
    } else {
      this.buffer = null;
    }
    return written;
  }
  async readFromStream(buffer, mayBeLess) {
    if (buffer.length === 0)
      return 0;
    let totalBytesRead = 0;
    if (this.buffer) {
      totalBytesRead += this.writeChunk(buffer, this.buffer);
    }
    while (totalBytesRead < buffer.length && !this.endOfStream) {
      const result = await this.reader.read();
      if (result.done) {
        this.endOfStream = true;
        break;
      }
      if (result.value) {
        totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
      }
    }
    if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
      throw new EndOfStreamError;
    }
    return totalBytesRead;
  }
  abort() {
    this.interrupted = true;
    return this.reader.cancel();
  }
  async close() {
    await this.abort();
    this.reader.releaseLock();
  }
}
// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
  try {
    const reader = stream.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error2) {
    if (error2 instanceof TypeError) {
      return new WebStreamDefaultReader(stream.getReader());
    }
    throw error2;
  }
}
// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length;
    return length;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000;

class ReadStreamTokenizer extends AbstractTokenizer {
  constructor(streamReader, options) {
    super(options);
    this.streamReader = streamReader;
    this.fileInfo = options?.fileInfo ?? {};
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const skipBytes = normOptions.position - this.position;
    if (skipBytes > 0) {
      await this.ignore(skipBytes);
      return this.readBuffer(uint8Array, options);
    }
    if (skipBytes < 0) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    if (normOptions.length === 0) {
      return 0;
    }
    const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
    this.position += bytesRead;
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    let bytesRead = 0;
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
        uint8Array.set(skipBuffer.subarray(skipBytes));
        return bytesRead - skipBytes;
      }
      if (skipBytes < 0) {
        throw new Error("Cannot peek from a negative offset in a stream");
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      } catch (err) {
        if (options?.mayBeLess && err instanceof EndOfStreamError) {
          return 0;
        }
        throw err;
      }
      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
    }
    return bytesRead;
  }
  async ignore(length) {
    const bufSize = Math.min(maxBufferSize, length);
    const buf = new Uint8Array(bufSize);
    let totBytesRead = 0;
    while (totBytesRead < length) {
      const remaining = length - totBytesRead;
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
      if (bytesRead < 0) {
        return bytesRead;
      }
      totBytesRead += bytesRead;
    }
    return totBytesRead;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
}

// node_modules/strtok3/lib/BufferTokenizer.js
class BufferTokenizer extends AbstractTokenizer {
  constructor(uint8Array, options) {
    super(options);
    this.uint8Array = uint8Array;
    this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
  }
  async readBuffer(uint8Array, options) {
    if (options?.position) {
      this.position = options.position;
    }
    const bytesRead = await this.peekBuffer(uint8Array, options);
    this.position += bytesRead;
    return bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
    if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
      throw new EndOfStreamError;
    }
    uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
    return bytes2read;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(position) {
    this.position = position;
  }
}
// node_modules/strtok3/lib/core.js
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}

// node_modules/strtok3/lib/FileTokenizer.js
var import_promises = require("node:fs/promises");

class FileTokenizer extends AbstractTokenizer {
  static async fromFile(sourceFilePath) {
    const fileHandle = await import_promises.open(sourceFilePath, "r");
    const stat = await fileHandle.stat();
    return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
  }
  constructor(fileHandle, options) {
    super(options);
    this.fileHandle = fileHandle;
    this.fileInfo = options.fileInfo;
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    this.position = normOptions.position;
    if (normOptions.length === 0)
      return 0;
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    this.position += res.bytesRead;
    if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options);
    const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
    if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
      throw new EndOfStreamError;
    }
    return res.bytesRead;
  }
  async close() {
    await this.fileHandle.close();
    return super.close();
  }
  setPosition(position) {
    this.position = position;
  }
  supportsRandomAccess() {
    return true;
  }
}
// node_modules/strtok3/lib/index.js
var fromFile = FileTokenizer.fromFile;

// node_modules/token-types/lib/index.js
var ieee754 = __toESM(require_ieee754(), 1);
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
var UINT8 = {
  len: 1,
  get(array, offset) {
    return dv(array).getUint8(offset);
  },
  put(array, offset, value) {
    dv(array).setUint8(offset, value);
    return offset + 1;
  }
};
var UINT16_LE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value, true);
    return offset + 2;
  }
};
var UINT16_BE = {
  len: 2,
  get(array, offset) {
    return dv(array).getUint16(offset);
  },
  put(array, offset, value) {
    dv(array).setUint16(offset, value);
    return offset + 2;
  }
};
var UINT32_LE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset, true);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value, true);
    return offset + 4;
  }
};
var UINT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getUint32(offset);
  },
  put(array, offset, value) {
    dv(array).setUint32(offset, value);
    return offset + 4;
  }
};
var INT32_BE = {
  len: 4,
  get(array, offset) {
    return dv(array).getInt32(offset);
  },
  put(array, offset, value) {
    dv(array).setInt32(offset, value);
    return offset + 4;
  }
};
var UINT64_LE = {
  len: 8,
  get(array, offset) {
    return dv(array).getBigUint64(offset, true);
  },
  put(array, offset, value) {
    dv(array).setBigUint64(offset, value, true);
    return offset + 8;
  }
};
class StringType {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
    this.textDecoder = new TextDecoder(encoding);
  }
  get(uint8Array, offset) {
    return this.textDecoder.decode(uint8Array.subarray(offset, offset + this.len));
  }
}

// node_modules/fflate/esm/index.mjs
var import_module = require("module");
var require2 = import_module.createRequire("/");
var Worker;
try {
  Worker = require2("worker_threads").Worker;
} catch (e) {}
var u8 = Uint8Array;
var u16 = Uint16Array;
var i32 = Int32Array;
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function(eb, start) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
};
var _a = freb(fleb, 2);
var fl = _a.b;
var revfl = _a.r;
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0);
var fd = _b.b;
var revfd = _b.r;
var rev = new u16(32768);
for (i = 0;i < 32768; ++i) {
  x = (i & 43690) >> 1 | (i & 21845) << 1;
  x = (x & 52428) >> 2 | (x & 13107) << 2;
  x = (x & 61680) >> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
}
var x;
var i;
var hMap = function(cd, mb, r) {
  var s = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (;i2 < s; ++i2) {
    if (cd[i2])
      ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 1;i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i2 = 0;i2 < s; ++i2) {
      if (cd[i2]) {
        co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];
      }
    }
  }
  return co;
};
var flt = new u8(288);
for (i = 0;i < 144; ++i)
  flt[i] = 8;
var i;
for (i = 144;i < 256; ++i)
  flt[i] = 9;
var i;
for (i = 256;i < 280; ++i)
  flt[i] = 7;
var i;
for (i = 280;i < 288; ++i)
  flt[i] = 8;
var i;
var fdt = new u8(32);
for (i = 0;i < 32; ++i)
  fdt[i] = 5;
var i;
var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
var max = function(a) {
  var m = a[0];
  for (var i2 = 1;i2 < a.length; ++i2) {
    if (a[i2] > m)
      m = a[i2];
  }
  return m;
};
var bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
};
var bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
};
var shft = function(p) {
  return (p + 7) / 8 | 0;
};
var slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
};
var ec = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
];
var err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
};
var inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i2 = 0;i2 < hcLen; ++i2) {
          clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i2 = 0;i2 < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i2++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i2++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max(lt);
        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254;
        if (sym > 264) {
          var i2 = sym - 257, b = fleb[i2];
          add = bits(dat, pos, (1 << b) - 1) + fl[i2];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end = bt + add;
        if (bt < dt) {
          var shift = dl - dt, dend = Math.min(dt, end);
          if (shift + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift + bt];
        }
        for (;bt < end; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
};
var et = /* @__PURE__ */ new u8(0);
var gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
};
var gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
};
var zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
};
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
var tds = 0;
try {
  td.decode(et, { stream: true });
  tds = 1;
} catch (e) {}

// node_modules/@tokenizer/inflate/lib/index.js
var import_debug = __toESM(require_src(), 1);

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature = {
  LocalFileHeader: 67324752,
  DataDescriptor: 134695760,
  CentralFileHeader: 33639248,
  EndOfCentralDirectory: 101010256
};
var DataDescriptor = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      compressedSize: UINT32_LE.get(array, 8),
      uncompressedSize: UINT32_LE.get(array, 12)
    };
  },
  len: 16
};
var LocalFileHeaderToken = {
  get(array) {
    const flags = UINT16_LE.get(array, 6);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 4),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 8),
      compressedSize: UINT32_LE.get(array, 18),
      uncompressedSize: UINT32_LE.get(array, 22),
      filenameLength: UINT16_LE.get(array, 26),
      extraFieldLength: UINT16_LE.get(array, 28),
      filename: null
    };
  },
  len: 30
};
var EndOfCentralDirectoryRecordToken = {
  get(array) {
    return {
      signature: UINT32_LE.get(array, 0),
      nrOfThisDisk: UINT16_LE.get(array, 4),
      nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
      nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
      nrOfEntriesOfSize: UINT16_LE.get(array, 10),
      sizeOfCd: UINT32_LE.get(array, 12),
      offsetOfStartOfCd: UINT32_LE.get(array, 16),
      zipFileCommentLength: UINT16_LE.get(array, 20)
    };
  },
  len: 22
};
var FileHeader = {
  get(array) {
    const flags = UINT16_LE.get(array, 8);
    return {
      signature: UINT32_LE.get(array, 0),
      minVersion: UINT16_LE.get(array, 6),
      dataDescriptor: !!(flags & 8),
      compressedMethod: UINT16_LE.get(array, 10),
      compressedSize: UINT32_LE.get(array, 20),
      uncompressedSize: UINT32_LE.get(array, 24),
      filenameLength: UINT16_LE.get(array, 28),
      extraFieldLength: UINT16_LE.get(array, 30),
      fileCommentLength: UINT16_LE.get(array, 32),
      relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
      filename: null
    };
  },
  len: 46
};

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
var debug = import_debug.default("tokenizer:inflate");
var syncBufferSize = 256 * 1024;
var ddSignatureArray = signatureToArray(Signature.DataDescriptor);
var eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i2 = buffer.length - 4;i2 >= 0; i2--) {
      if (buffer[i2] === eocdSignatureBytes[0] && buffer[i2 + 1] === eocdSignatureBytes[1] && buffer[i2 + 2] === eocdSignatureBytes[2] && buffer[i2 + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i2;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug("Cannot reading central-directory without random-read support");
      return;
    }
    debug("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries = await this.readCentralDirectory();
    if (entries) {
      return this.iterateOverCentralDirectory(entries, fileCb);
    }
    let stop = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next = fileCb(zipHeader);
      stop = !!next.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks = [];
        let len = syncBufferSize;
        debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next.handler) {
            const data = new Uint8Array(size);
            await this.tokenizer.readBuffer(data);
            chunks.push(data);
          } else {
            await this.tokenizer.ignore(size);
          }
        }
        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
        }
      } else {
        if (next.handler) {
          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        } else {
          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop);
  }
  async iterateOverCentralDirectory(entries, fileCb) {
    for (const fileHeader of entries) {
      const next = fileCb(fileHeader);
      if (next.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next.handler);
        }
      }
      if (next.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
function indexOf(buffer, portion) {
  const bufferLength = buffer.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i2 = 0;i2 <= bufferLength - portionLength; i2++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer[i2 + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i2;
    }
  }
  return -1;
}
function mergeArrays(chunks) {
  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of chunks) {
    mergedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return mergedArray;
}

// node_modules/uint8array-extras/index.js
var cachedDecoders = {
  utf8: new globalThis.TextDecoder("utf8")
};
var cachedEncoder = new globalThis.TextEncoder;
var byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}

// node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum += arrayBuffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken = {
  get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
  len: 4
};

// node_modules/file-type/supported.js
var extensions = [
  "jpg",
  "png",
  "apng",
  "gif",
  "webp",
  "flif",
  "xcf",
  "cr2",
  "cr3",
  "orf",
  "arw",
  "dng",
  "nef",
  "rw2",
  "raf",
  "tif",
  "bmp",
  "icns",
  "jxr",
  "psd",
  "indd",
  "zip",
  "tar",
  "rar",
  "gz",
  "bz2",
  "7z",
  "dmg",
  "mp4",
  "mid",
  "mkv",
  "webm",
  "mov",
  "avi",
  "mpg",
  "mp2",
  "mp3",
  "m4a",
  "oga",
  "ogg",
  "ogv",
  "opus",
  "flac",
  "wav",
  "spx",
  "amr",
  "pdf",
  "epub",
  "elf",
  "macho",
  "exe",
  "swf",
  "rtf",
  "wasm",
  "woff",
  "woff2",
  "eot",
  "ttf",
  "otf",
  "ttc",
  "ico",
  "flv",
  "ps",
  "xz",
  "sqlite",
  "nes",
  "crx",
  "xpi",
  "cab",
  "deb",
  "ar",
  "rpm",
  "Z",
  "lz",
  "cfb",
  "mxf",
  "mts",
  "blend",
  "bpg",
  "docx",
  "pptx",
  "xlsx",
  "3gp",
  "3g2",
  "j2c",
  "jp2",
  "jpm",
  "jpx",
  "mj2",
  "aif",
  "qcp",
  "odt",
  "ods",
  "odp",
  "xml",
  "mobi",
  "heic",
  "cur",
  "ktx",
  "ape",
  "wv",
  "dcm",
  "ics",
  "glb",
  "pcap",
  "dsf",
  "lnk",
  "alias",
  "voc",
  "ac3",
  "m4v",
  "m4p",
  "m4b",
  "f4v",
  "f4p",
  "f4b",
  "f4a",
  "mie",
  "asf",
  "ogm",
  "ogx",
  "mpc",
  "arrow",
  "shp",
  "aac",
  "mp1",
  "it",
  "s3m",
  "xm",
  "skp",
  "avif",
  "eps",
  "lzh",
  "pgp",
  "asar",
  "stl",
  "chm",
  "3mf",
  "zst",
  "jxl",
  "vcf",
  "jls",
  "pst",
  "dwg",
  "parquet",
  "class",
  "arj",
  "cpio",
  "ace",
  "avro",
  "icc",
  "fbx",
  "vsdx",
  "vtt",
  "apk",
  "drc",
  "lz4",
  "potx",
  "xltx",
  "dotx",
  "xltm",
  "ott",
  "ots",
  "otp",
  "odg",
  "otg",
  "xlsm",
  "docm",
  "dotm",
  "potm",
  "pptm",
  "jar",
  "rm",
  "ppsm",
  "ppsx"
];
var mimeTypes = [
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",
  "image/flif",
  "image/x-xcf",
  "image/x-canon-cr2",
  "image/x-canon-cr3",
  "image/tiff",
  "image/bmp",
  "image/vnd.ms-photo",
  "image/vnd.adobe.photoshop",
  "application/x-indesign",
  "application/epub+zip",
  "application/x-xpinstall",
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
  "application/vnd.oasis.opendocument.text",
  "application/vnd.oasis.opendocument.spreadsheet",
  "application/vnd.oasis.opendocument.presentation",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
  "application/zip",
  "application/x-tar",
  "application/x-rar-compressed",
  "application/gzip",
  "application/x-bzip2",
  "application/x-7z-compressed",
  "application/x-apple-diskimage",
  "application/vnd.apache.arrow.file",
  "video/mp4",
  "audio/midi",
  "video/matroska",
  "video/webm",
  "video/quicktime",
  "video/vnd.avi",
  "audio/wav",
  "audio/qcelp",
  "audio/x-ms-asf",
  "video/x-ms-asf",
  "application/vnd.ms-asf",
  "video/mpeg",
  "video/3gpp",
  "audio/mpeg",
  "audio/mp4",
  "video/ogg",
  "audio/ogg",
  "audio/ogg; codecs=opus",
  "application/ogg",
  "audio/flac",
  "audio/ape",
  "audio/wavpack",
  "audio/amr",
  "application/pdf",
  "application/x-elf",
  "application/x-mach-binary",
  "application/x-msdownload",
  "application/x-shockwave-flash",
  "application/rtf",
  "application/wasm",
  "font/woff",
  "font/woff2",
  "application/vnd.ms-fontobject",
  "font/ttf",
  "font/otf",
  "font/collection",
  "image/x-icon",
  "video/x-flv",
  "application/postscript",
  "application/eps",
  "application/x-xz",
  "application/x-sqlite3",
  "application/x-nintendo-nes-rom",
  "application/x-google-chrome-extension",
  "application/vnd.ms-cab-compressed",
  "application/x-deb",
  "application/x-unix-archive",
  "application/x-rpm",
  "application/x-compress",
  "application/x-lzip",
  "application/x-cfb",
  "application/x-mie",
  "application/mxf",
  "video/mp2t",
  "application/x-blender",
  "image/bpg",
  "image/j2c",
  "image/jp2",
  "image/jpx",
  "image/jpm",
  "image/mj2",
  "audio/aiff",
  "application/xml",
  "application/x-mobipocket-ebook",
  "image/heif",
  "image/heif-sequence",
  "image/heic",
  "image/heic-sequence",
  "image/icns",
  "image/ktx",
  "application/dicom",
  "audio/x-musepack",
  "text/calendar",
  "text/vcard",
  "text/vtt",
  "model/gltf-binary",
  "application/vnd.tcpdump.pcap",
  "audio/x-dsf",
  "application/x.ms.shortcut",
  "application/x.apple.alias",
  "audio/x-voc",
  "audio/vnd.dolby.dd-raw",
  "audio/x-m4a",
  "image/apng",
  "image/x-olympus-orf",
  "image/x-sony-arw",
  "image/x-adobe-dng",
  "image/x-nikon-nef",
  "image/x-panasonic-rw2",
  "image/x-fujifilm-raf",
  "video/x-m4v",
  "video/3gpp2",
  "application/x-esri-shape",
  "audio/aac",
  "audio/x-it",
  "audio/x-s3m",
  "audio/x-xm",
  "video/MP1S",
  "video/MP2P",
  "application/vnd.sketchup.skp",
  "image/avif",
  "application/x-lzh-compressed",
  "application/pgp-encrypted",
  "application/x-asar",
  "model/stl",
  "application/vnd.ms-htmlhelp",
  "model/3mf",
  "image/jxl",
  "application/zstd",
  "image/jls",
  "application/vnd.ms-outlook",
  "image/vnd.dwg",
  "application/vnd.apache.parquet",
  "application/java-vm",
  "application/x-arj",
  "application/x-cpio",
  "application/x-ace-compressed",
  "application/avro",
  "application/vnd.iccprofile",
  "application/x.autodesk.fbx",
  "application/vnd.visio",
  "application/vnd.android.package-archive",
  "application/vnd.google.draco",
  "application/x-lz4",
  "application/vnd.openxmlformats-officedocument.presentationml.template",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
  "application/vnd.ms-excel.template.macroenabled.12",
  "application/vnd.oasis.opendocument.text-template",
  "application/vnd.oasis.opendocument.spreadsheet-template",
  "application/vnd.oasis.opendocument.presentation-template",
  "application/vnd.oasis.opendocument.graphics",
  "application/vnd.oasis.opendocument.graphics-template",
  "application/vnd.ms-excel.sheet.macroenabled.12",
  "application/vnd.ms-word.document.macroenabled.12",
  "application/vnd.ms-word.template.macroenabled.12",
  "application/vnd.ms-powerpoint.template.macroenabled.12",
  "application/vnd.ms-powerpoint.presentation.macroenabled.12",
  "application/java-archive",
  "application/vnd.rn-realmedia"
];

// node_modules/file-type/core.js
var reasonableDetectionSizeInBytes = 4100;
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream) {
    const tokenizer = await fromWebStream(stream, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream.getReader({ mode: "byob" });
    try {
      const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk;
      if (!done && chunk) {
        try {
          detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
        } catch (error2) {
          if (!(error2 instanceof EndOfStreamError)) {
            throw error2;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk, controller) {
        controller.enqueue(chunk);
      }
    });
    const newStream = stream.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type = new Uint8Array(8);
      await tokenizer.readBuffer(type);
      if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id);
        return id;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children) {
        while (children > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string = await tokenizer.readToken(new StringType(13, "ascii"));
      if (string === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && [`
`, "\r", "\t", " ", "\x00"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType(4, "latin1"))
        };
      }
      do {
        const chunk = await readChunkHeader();
        if (chunk.length < 0) {
          return;
        }
        switch (chunk.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType(4, "latin1").get(this.buffer, 8).replace("\x00", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type = await tokenizer.readToken(new StringType(4, "ascii"));
      switch (type) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {}
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \x00")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type = this.scanMpeg(depth);
        if (type) {
          return type;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var supportedExtensions = new Set(extensions);
var supportedMimeTypes = new Set(mimeTypes);
// node_modules/@flowcore/pathways/esm/pathways/builder.js
var import_rxjs = __toESM(require_cjs(), 1);

// node_modules/@flowcore/pathways/esm/compatibility/flowcore-transformer-core.sdk.js
var import_sdk_transformer_core = __toESM(require_dist3(), 1);
var { WebhookBuilder } = import_sdk_transformer_core.default;

// node_modules/@flowcore/pathways/esm/pathways/kv/kv-adapter.js
async function createKvAdapter() {
  try {
    const { BunKvAdapter: BunKvAdapter2 } = await Promise.resolve().then(() => (init_bun_kv_adapter(), exports_bun_kv_adapter));
    return new BunKvAdapter2;
  } catch {
    const { NodeKvAdapter: NodeKvAdapter2 } = await Promise.resolve().then(() => (init_node_kv_adapter(), exports_node_kv_adapter));
    return new NodeKvAdapter2;
  }
}

// node_modules/@flowcore/pathways/esm/pathways/internal-pathway.state.js
class InternalPathwayState {
  constructor() {
    Object.defineProperty(this, "kv", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
  }
  async getKv() {
    if (!this.kv) {
      this.kv = await createKvAdapter();
    }
    return this.kv;
  }
  async isProcessed(eventId) {
    const kv = await this.getKv();
    const result = await kv.get(eventId);
    return result === true;
  }
  async setProcessed(eventId) {
    const kv = await this.getKv();
    await kv.set(eventId, true, InternalPathwayState.DEFAULT_TTL_MS);
  }
}
Object.defineProperty(InternalPathwayState, "DEFAULT_TTL_MS", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5 * 60 * 1000
});

// node_modules/@flowcore/pathways/esm/pathways/logger.js
class NoopLogger {
  debug(_message, _context) {}
  info(_message, _context) {}
  warn(_message, _context) {}
  error(_messageOrError, _errorOrContext, _context) {}
}

// node_modules/@flowcore/pathways/esm/pathways/constants.js
var AUDIT_SESSION_ID = "audit/session-id";
var AUDIT_ENTITY_ID = "audit/entity-id";
var AUDIT_ON_BEHALF_OF_TYPE = "audit/on-behalf-of-type";
var AUDIT_ON_BEHALF_OF_ID = "audit/on-behalf-of-id";
var AUDIT_MODE = "audit/mode";
var AUDIT_ENTITY_TYPE = "audit/entity-type";
var AUDIT_SYSTEM_MODE = "system";
var AUDIT_USER_MODE = "user";

// node_modules/@flowcore/pathways/esm/pathways/types.js
var import_node_buffer = require("node:buffer");
var FileInputSchema = exports_external.object({
  fileId: exports_external.string(),
  fileName: exports_external.string(),
  fileContent: exports_external.instanceof(import_node_buffer.Buffer)
});
var FileEventSchema = exports_external.object({
  fileName: exports_external.string(),
  fileType: exports_external.string(),
  fileSize: exports_external.number(),
  data: exports_external.string(),
  part: exports_external.number(),
  totalParts: exports_external.number(),
  checksum: exports_external.string(),
  hashType: exports_external.string(),
  fileId: exports_external.string()
});

// node_modules/@flowcore/pathways/esm/pathways/builder.js
var import_node_process = __toESM(require("node:process"));
var DEFAULT_PATHWAY_TIMEOUT_MS = 1e4;
var DEFAULT_MAX_RETRIES = 3;
var DEFAULT_RETRY_DELAY_MS = 500;
var DEFAULT_SESSION_USER_RESOLVER_TTL_MS = 10 * 1000;

class SessionUser {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.store = new Map;
  }
  get(key) {
    const entry = this.store.get(key);
    if (!entry) {
      return;
    }
    return entry.value;
  }
  set(key, value, ttlMs = 1000 * 60 * 5) {
    const existingEntry = this.store.get(key);
    if (existingEntry) {
      clearTimeout(existingEntry.timeout);
    }
    const timeout = setTimeout(() => {
      this.store.delete(key);
    }, ttlMs);
    this.store.set(key, { value, timeout });
  }
}

class PathwaysBuilder {
  constructor({ baseUrl, tenant, dataCore, apiKey, pathwayTimeoutMs, logger, enableSessionUserResolvers, overrideSessionUserResolvers, logLevel }) {
    Object.defineProperty(this, "pathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "handlers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "beforeObservable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "afterObservers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "errorObservers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "globalErrorSubject", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new import_rxjs.Subject
    });
    Object.defineProperty(this, "writers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "batchWriters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "fileWriters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "schemas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "inputSchemas", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "writable", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "timeouts", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "maxRetries", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "retryDelays", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "filePathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new Set
    });
    Object.defineProperty(this, "webhookBuilderFactory", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "pathwayState", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new InternalPathwayState
    });
    Object.defineProperty(this, "pathwayTimeoutMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: DEFAULT_PATHWAY_TIMEOUT_MS
    });
    Object.defineProperty(this, "auditHandler", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "userIdResolver", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "sessionUserResolvers", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "logger", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "baseUrl", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tenant", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "dataCore", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "apiKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "logLevel", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.logger = logger ?? new NoopLogger;
    this.logLevel = {
      writeSuccess: logLevel?.writeSuccess ?? "info"
    };
    this.baseUrl = baseUrl;
    this.tenant = tenant;
    this.dataCore = dataCore;
    this.apiKey = apiKey;
    if (enableSessionUserResolvers) {
      this.sessionUserResolvers = overrideSessionUserResolvers ?? new SessionUser;
    }
    this.logger.debug("Initializing PathwaysBuilder", {
      baseUrl,
      tenant,
      dataCore,
      pathwayTimeoutMs
    });
    this.webhookBuilderFactory = new WebhookBuilder({
      baseUrl,
      tenant,
      dataCore,
      apiKey
    }).withRetry({
      maxAttempts: 5,
      attemptDelayMs: 250
    }).factory();
    if (pathwayTimeoutMs) {
      this.pathwayTimeoutMs = pathwayTimeoutMs;
    }
  }
  withPathwayState(state) {
    this.logger.debug("Setting custom pathway state");
    this.pathwayState = state;
    return this;
  }
  withAudit(handler) {
    this.logger.debug("Configuring audit functionality");
    this.auditHandler = handler;
    return this;
  }
  withUserResolver(resolver) {
    this.logger.debug("Configuring user resolver");
    this.userIdResolver = resolver;
    return this;
  }
  withSessionUserResolver(sessionId, resolver) {
    if (!this.sessionUserResolvers) {
      throw new Error("Session user resolvers not configured");
    }
    this.logger.debug("Configuring session-specific user resolver", { sessionId });
    this.sessionUserResolvers.set(sessionId, resolver, DEFAULT_SESSION_USER_RESOLVER_TTL_MS);
    return this;
  }
  getSessionUserResolver(sessionId) {
    if (!this.sessionUserResolvers) {
      return;
    }
    const resolver = this.sessionUserResolvers.get(sessionId);
    return resolver;
  }
  async process(pathway, data) {
    const pathwayStr = String(pathway);
    this.logger.debug(`Processing pathway event`, {
      pathway: pathwayStr,
      eventId: data.eventId
    });
    if (!this.pathways[pathway]) {
      const error2 = `Pathway ${pathwayStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (this.schemas[pathway]) {
      const parsedPayload = this.schemas[pathway].safeParse(data.payload);
      try {
        if (!parsedPayload.success) {
          const validationMessage = this.validationErrorToString(parsedPayload.error);
          const error2 = `Event payload does not match schema for pathway ${pathwayStr}. ${validationMessage}`;
          this.logger.error(error2, {
            pathway: pathwayStr,
            schema: this.schemas[pathway].toString(),
            validationErrors: parsedPayload.error.errors
          });
          throw new Error(error2);
        }
      } catch (err2) {
        const error2 = `Error validating event payload against schema for pathway ${pathwayStr}: ${err2 instanceof Error ? err2.message : String(err2)}`;
        this.logger.error(error2);
        throw new Error(error2);
      }
      data.payload = parsedPayload.data;
    }
    if (this.auditHandler) {
      this.logger.debug(`Calling audit handler for pathway`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.auditHandler(pathwayStr, data);
    }
    if (this.handlers[pathway]) {
      let retryCount = 0;
      const maxRetries = this.maxRetries[pathway] ?? DEFAULT_MAX_RETRIES;
      const retryDelayMs = this.retryDelays[pathway] ?? DEFAULT_RETRY_DELAY_MS;
      this.logger.debug(`Emitting 'before' event`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.beforeObservable[pathway].next(data);
      while (true) {
        try {
          this.logger.debug(`Executing handler for pathway`, {
            pathway: pathwayStr,
            eventId: data.eventId,
            attempt: retryCount + 1
          });
          const handle = this.handlers[pathway](data);
          await handle;
          this.logger.debug(`Handler executed successfully, emitting 'after' event`, {
            pathway: pathwayStr,
            eventId: data.eventId
          });
          this.afterObservers[pathway].next(data);
          await this.pathwayState.setProcessed(data.eventId);
          this.logger.info(`Successfully processed pathway event`, {
            pathway: pathwayStr,
            eventId: data.eventId
          });
          return;
        } catch (error2) {
          const errorObj = error2 instanceof Error ? error2 : new Error(String(error2));
          this.logger.error(`Error processing pathway event`, errorObj, {
            pathway: pathwayStr,
            eventId: data.eventId,
            retryCount,
            maxRetries
          });
          this.errorObservers[pathway].next({ event: data, error: errorObj });
          this.globalErrorSubject.next({
            pathway: pathwayStr,
            event: data,
            error: errorObj
          });
          if (retryCount < maxRetries) {
            retryCount++;
            const nextDelay = retryDelayMs * retryCount;
            this.logger.debug(`Retrying pathway event processing`, {
              pathway: pathwayStr,
              eventId: data.eventId,
              attempt: retryCount,
              maxRetries,
              nextDelay
            });
            await new Promise((resolve2) => setTimeout(resolve2, nextDelay));
            continue;
          }
          this.logger.warn(`Max retries exceeded for pathway event, marking as processed`, {
            pathway: pathwayStr,
            eventId: data.eventId,
            retryCount,
            maxRetries
          });
          await this.pathwayState.setProcessed(data.eventId);
          throw error2;
        }
      }
    } else {
      this.logger.debug(`No handler for pathway, emitting events and marking as processed`, {
        pathway: pathwayStr,
        eventId: data.eventId
      });
      this.beforeObservable[pathway].next(data);
      this.afterObservers[pathway].next(data);
      await this.pathwayState.setProcessed(data.eventId);
    }
  }
  register(contract) {
    const path = `${contract.flowType}/${contract.eventType}`;
    const writable = contract.writable ?? true;
    this.logger.debug(`Registering pathway`, {
      pathway: path,
      flowType: contract.flowType,
      eventType: contract.eventType,
      writable,
      isFilePathway: contract.isFilePathway,
      timeoutMs: contract.timeoutMs,
      maxRetries: contract.maxRetries,
      retryDelayMs: contract.retryDelayMs
    });
    this.pathways[path] = true;
    this.beforeObservable[path] = new import_rxjs.Subject;
    this.afterObservers[path] = new import_rxjs.Subject;
    this.errorObservers[path] = new import_rxjs.Subject;
    if (writable) {
      if (contract.isFilePathway) {
        this.filePathways.add(path);
        this.fileWriters[path] = this.webhookBuilderFactory().buildFileWebhook(contract.flowType, contract.eventType).send;
      } else {
        this.writers[path] = this.webhookBuilderFactory().buildWebhook(contract.flowType, contract.eventType).send;
        this.batchWriters[path] = this.webhookBuilderFactory().buildWebhook(contract.flowType, contract.eventType).sendBatch;
      }
    }
    if (contract.timeoutMs) {
      this.timeouts[path] = contract.timeoutMs;
    }
    if (contract.maxRetries !== undefined) {
      this.maxRetries[path] = contract.maxRetries;
    }
    if (contract.retryDelayMs !== undefined) {
      this.retryDelays[path] = contract.retryDelayMs;
    }
    if (contract.isFilePathway) {
      this.schemas[path] = (contract.schema ?? exports_external.object({})).merge(FileEventSchema);
      this.inputSchemas[path] = (contract.schema ?? exports_external.object({})).merge(FileInputSchema);
    } else {
      this.schemas[path] = contract.schema ?? exports_external.object({});
      this.inputSchemas[path] = contract.schema ?? exports_external.object({});
    }
    this.writable[path] = writable;
    this.logger.info(`Pathway registered successfully`, {
      pathway: path,
      flowType: contract.flowType,
      eventType: contract.eventType,
      writable,
      isFilePathway: contract.isFilePathway
    });
    return this;
  }
  get(path) {
    this.logger.debug(`Getting pathway`, { pathway: String(path) });
    return this.pathways[path];
  }
  handle(path, handler) {
    const pathStr = String(path);
    this.logger.debug(`Setting handler for pathway`, { pathway: pathStr });
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (this.handlers[path]) {
      const error2 = `Someone is already handling pathway ${pathStr} in this instance`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    this.handlers[path] = handler;
    this.logger.info(`Handler set for pathway`, { pathway: pathStr });
    return this;
  }
  subscribe(path, handler, type = "before") {
    const pathStr = String(path);
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const typedHandler = handler;
    if (type === "before" || type === "all") {
      this.beforeObservable[path].subscribe(typedHandler);
      this.logger.debug(`Subscribed to 'before' events for pathway`, { pathway: pathStr });
    }
    if (type === "after" || type === "all") {
      this.afterObservers[path].subscribe(typedHandler);
      this.logger.debug(`Subscribed to 'after' events for pathway`, { pathway: pathStr });
    }
    this.logger.info(`Subscription to pathway events set up`, {
      pathway: pathStr,
      type
    });
    return this;
  }
  onError(path, handler) {
    const pathStr = String(path);
    this.logger.debug(`Setting error handler for pathway`, { pathway: pathStr });
    const pathway = this.pathways[path];
    if (!pathway) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const typedHandler = (payload) => handler(payload.error, payload.event);
    this.errorObservers[path].subscribe(typedHandler);
    this.logger.info(`Error handler set for pathway`, { pathway: pathStr });
    return this;
  }
  onAnyError(handler) {
    this.logger.debug(`Subscribing to all pathway errors`);
    this.globalErrorSubject.subscribe(({ pathway, event: event2, error: error2 }) => handler(error2, event2, pathway));
    this.logger.debug(`Subscribed to all pathway errors`);
    return this;
  }
  async write(path, input) {
    const pathStr = String(path);
    const { data: inputData, metadata, options, batch } = input;
    if (batch && this.filePathways.has(path)) {
      const error2 = `Batch is not possible for file pathways. Pathway ${pathStr} is a file pathway`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    this.logger.debug(`Writing to pathway`, {
      pathway: pathStr,
      metadata,
      options: {
        fireAndForget: options?.fireAndForget,
        sessionId: options?.sessionId
      }
    });
    if (!this.pathways[path]) {
      const error2 = `Pathway ${pathStr} not found`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    if (!this.writable[path]) {
      const error2 = `Pathway ${pathStr} is not writable`;
      this.logger.error(error2);
      throw new Error(error2);
    }
    const schema = batch ? exports_external.array(this.inputSchemas[path]) : this.inputSchemas[path];
    const parsedData = schema.safeParse(inputData);
    if (!parsedData.success) {
      const validationMessage = this.validationErrorToString(parsedData.error);
      const errorMessage = `Invalid data for pathway ${pathStr}. ${validationMessage}`;
      this.logger.error(errorMessage, {
        pathway: pathStr,
        schema: schema.toString(),
        validationErrors: parsedData.error.errors
      });
      throw new Error(errorMessage);
    }
    const data = parsedData.data;
    const finalMetadata = metadata ? { ...metadata } : {};
    let userId;
    if (options?.sessionId) {
      const sessionUserResolver = this.getSessionUserResolver(options.sessionId);
      if (sessionUserResolver) {
        try {
          userId = await sessionUserResolver();
          this.logger.debug(`Using session-specific user resolver`, {
            pathway: pathStr,
            sessionId: options.sessionId,
            userId
          });
        } catch (error2) {
          this.logger.error(`Error resolving session user ID`, error2 instanceof Error ? error2 : new Error(String(error2)), {
            pathway: pathStr,
            sessionId: options.sessionId
          });
        }
      }
    }
    if (this.userIdResolver) {
      if (!userId) {
        this.logger.debug(`Resolving user ID for audit metadata`, { pathway: pathStr });
        userId = await this.userIdResolver();
      }
    }
    const auditMode = options?.auditMode ?? "user";
    this.logger.debug(`Adding audit metadata`, {
      pathway: pathStr,
      auditMode,
      userId
    });
    if (userId) {
      if (auditMode === AUDIT_SYSTEM_MODE) {
        finalMetadata[AUDIT_MODE] = AUDIT_SYSTEM_MODE;
        finalMetadata[AUDIT_ENTITY_TYPE] = "system";
        finalMetadata[AUDIT_ENTITY_ID] = "system";
        finalMetadata[AUDIT_ON_BEHALF_OF_TYPE] = userId.entityType;
        finalMetadata[AUDIT_ON_BEHALF_OF_ID] = userId.entityId;
      } else {
        finalMetadata[AUDIT_MODE] = AUDIT_USER_MODE;
        finalMetadata[AUDIT_ENTITY_TYPE] = userId.entityType;
        finalMetadata[AUDIT_ENTITY_ID] = userId.entityId;
      }
    }
    if (options?.sessionId) {
      finalMetadata[AUDIT_SESSION_ID] = options.sessionId;
    }
    let eventIds = [];
    this.logger.debug(`Writing webhook data to pathway`, { pathway: pathStr, batch });
    if (batch) {
      eventIds = await this.batchWriters[path](data, finalMetadata, options);
    } else if (this.filePathways.has(path)) {
      const { fileId, fileName, fileContent, ...additionalProperties } = data;
      const fileType = await fileTypeFromBuffer(fileContent);
      import_node_process.default.env.DEBUG?.includes("pathways") && console.log("additionalProperties", additionalProperties);
      eventIds = await this.fileWriters[path]({
        fileId,
        fileName,
        fileType: fileType?.mime ?? "application/octet-stream",
        fileContent: new Blob([fileContent]),
        additionalProperties
      }, finalMetadata, options);
    } else {
      eventIds = await this.writers[path](data, finalMetadata, options);
    }
    this.logger[this.logLevel.writeSuccess](`Successfully wrote to pathway`, {
      pathway: pathStr,
      eventIds: Array.isArray(eventIds) ? eventIds : [eventIds],
      fireAndForget: options?.fireAndForget
    });
    if (!options?.fireAndForget) {
      this.logger.debug(`Waiting for pathway to be processed`, {
        pathway: pathStr,
        eventIds: Array.isArray(eventIds) ? eventIds : [eventIds]
      });
      await Promise.all(Array.isArray(eventIds) ? eventIds.map((id) => this.waitForPathwayToBeProcessed(id)) : [this.waitForPathwayToBeProcessed(eventIds)]);
    }
    return eventIds;
  }
  async waitForPathwayToBeProcessed(eventId) {
    const startTime = Date.now();
    const timeoutMs = this.timeouts[eventId] ?? this.pathwayTimeoutMs;
    this.logger.debug(`Waiting for event to be processed`, {
      eventId,
      timeoutMs
    });
    let attempts = 0;
    while (!await this.pathwayState.isProcessed(eventId)) {
      attempts++;
      const elapsedTime = Date.now() - startTime;
      if (elapsedTime > timeoutMs) {
        const errorMessage = `Pathway processing timed out after ${timeoutMs}ms for event ${eventId}`;
        this.logger.error(errorMessage, new Error(errorMessage), {
          eventId,
          timeoutMs,
          elapsedTime,
          attempts
        });
        throw new Error(errorMessage);
      }
      if (attempts % 10 === 0) {
        this.logger.debug(`Still waiting for event to be processed`, {
          eventId,
          elapsedTime,
          attempts,
          timeoutMs
        });
      }
      await new Promise((resolve2) => setTimeout(resolve2, 100));
    }
    this.logger.debug(`Event has been processed`, {
      eventId,
      elapsedTime: Date.now() - startTime,
      attempts
    });
  }
  validationErrorToString(error2) {
    const primaryError = error2?.errors[0];
    if (!primaryError) {
      return "Unknown validation error";
    }
    const path = primaryError.path.join(".");
    const pathOutput = path ? `${path}: ` : "";
    return `${pathOutput}${primaryError.message}`;
  }
}
// node_modules/@flowcore/pathways/esm/pathways/postgres/postgres-adapter.js
class PostgresJsAdapter {
  constructor(config) {
    Object.defineProperty(this, "postgres", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "sql", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: null
    });
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "connectionString", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.config = config;
    if ("connectionString" in config && config.connectionString) {
      this.connectionString = config.connectionString;
    } else {
      this.connectionString = `postgres://${config.user}:${config.password}@${config.host}:${config.port}/${config.database}`;
      if (config.ssl) {
        this.connectionString += "?sslmode=require";
      }
    }
  }
  async connect() {
    try {
      const module2 = await Promise.resolve().then(() => (init_src(), exports_src));
      this.postgres = module2.default;
      const postgresOptions = {};
      if (this.config.pool) {
        if (this.config.pool.max !== undefined) {
          postgresOptions.max = this.config.pool.max;
        }
        if (this.config.pool.max_lifetime !== undefined) {
          postgresOptions.max_lifetime = this.config.pool.max_lifetime;
        }
        if (this.config.pool.idle_timeout !== undefined) {
          postgresOptions.idle_timeout = this.config.pool.idle_timeout;
        }
        if (this.config.pool.connect_timeout !== undefined) {
          postgresOptions.connect_timeout = this.config.pool.connect_timeout;
        }
      }
      this.sql = this.postgres(this.connectionString, postgresOptions);
    } catch (error2) {
      console.error("Failed to connect to PostgreSQL:", error2);
      throw error2;
    }
  }
  async disconnect() {
    if (this.sql) {
      await this.sql.end();
      this.sql = null;
    }
  }
  async query(sql, params = []) {
    if (!this.sql) {
      await this.connect();
    }
    return await this.sql.unsafe(sql, params);
  }
  async execute(sql, params = []) {
    if (!this.sql) {
      await this.connect();
    }
    await this.sql.unsafe(sql, params);
  }
}
async function createPostgresAdapter(config) {
  const adapter = new PostgresJsAdapter(config);
  await adapter.connect();
  return adapter;
}
// node_modules/@flowcore/pathways/esm/pathways/postgres/postgres-pathway-state.js
class PostgresPathwayState {
  constructor(config) {
    Object.defineProperty(this, "config", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: config
    });
    Object.defineProperty(this, "postgres", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "tableName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "ttlMs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    Object.defineProperty(this, "initialized", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    this.tableName = config.tableName || PostgresPathwayState.DEFAULT_TABLE_NAME;
    this.ttlMs = config.ttlMs || PostgresPathwayState.DEFAULT_TTL_MS;
    this.postgres = null;
  }
  async initialize() {
    if (this.initialized) {
      return;
    }
    if ("connectionString" in this.config && this.config.connectionString) {
      this.postgres = await createPostgresAdapter({
        connectionString: this.config.connectionString,
        pool: this.config.pool
      });
    } else {
      this.postgres = await createPostgresAdapter({
        host: this.config.host,
        port: this.config.port,
        user: this.config.user,
        password: this.config.password,
        database: this.config.database,
        ssl: this.config.ssl,
        pool: this.config.pool
      });
    }
    const tableExists = await this.postgres.query(`
      SELECT EXISTS (
        SELECT 1
        FROM information_schema.tables
        WHERE table_name = $1
      )
    `, [this.tableName]);
    if (!tableExists[0]?.exists) {
      await this.postgres.execute(`
        CREATE TABLE IF NOT EXISTS ${this.tableName} (
          event_id TEXT PRIMARY KEY,
          processed BOOLEAN NOT NULL,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
          expires_at TIMESTAMP WITH TIME ZONE NOT NULL
        )
      `);
      await this.postgres.execute(`
        CREATE INDEX IF NOT EXISTS ${this.tableName}_expires_at_idx ON ${this.tableName} (expires_at)
      `);
    }
    this.initialized = true;
  }
  async isProcessed(eventId) {
    await this.initialize();
    await this.cleanupExpired();
    const result = await this.postgres.query(`
      SELECT processed FROM ${this.tableName}
      WHERE event_id = $1 AND expires_at > NOW()
    `, [eventId]);
    return result.length > 0 && result[0].processed;
  }
  async setProcessed(eventId) {
    await this.initialize();
    await this.postgres.execute(`
      INSERT INTO ${this.tableName} (event_id, processed, expires_at)
      VALUES ($1, TRUE, NOW() + interval '${Math.floor(this.ttlMs / 1000)} seconds')
      ON CONFLICT (event_id)
      DO UPDATE SET
        processed = TRUE,
        expires_at = NOW() + interval '${Math.floor(this.ttlMs / 1000)} seconds'
    `, [eventId]);
  }
  async cleanupExpired() {
    await this.postgres.execute(`
      DELETE FROM ${this.tableName}
      WHERE expires_at < NOW()
    `);
  }
  async close() {
    if (this.postgres) {
      await this.postgres.disconnect();
    }
  }
}
Object.defineProperty(PostgresPathwayState, "DEFAULT_TTL_MS", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5 * 60 * 1000
});
Object.defineProperty(PostgresPathwayState, "DEFAULT_TABLE_NAME", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: "pathway_state"
});
function createPostgresPathwayState(config) {
  const state = new PostgresPathwayState(config);
  return state;
}
// node_modules/@flowcore/pathways/esm/router/index.js
class PathwayRouter {
  constructor(pathways, secretKey, logger2) {
    Object.defineProperty(this, "pathways", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: pathways
    });
    Object.defineProperty(this, "secretKey", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: secretKey
    });
    Object.defineProperty(this, "logger", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: undefined
    });
    this.logger = logger2 ?? new NoopLogger;
    if (!secretKey || secretKey.trim() === "") {
      const errorMsg = "Secret key is required for PathwayRouter";
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    this.logger.debug("PathwayRouter initialized");
  }
  async processEvent(event2, providedSecret) {
    if (!providedSecret || providedSecret !== this.secretKey) {
      const errorMsg = "Invalid secret key";
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    const compatibleEvent = {
      ...event2,
      ...event2.aggregator ? { flowType: event2.aggregator } : {}
    };
    const pathwayKey = `${compatibleEvent.flowType}/${compatibleEvent.eventType}`;
    this.logger.debug(`Processing event for pathway: ${pathwayKey}`, {
      eventId: compatibleEvent.eventId
    });
    const pathway = this.pathways.get(pathwayKey);
    if (!pathway) {
      const errorMsg = `Pathway ${pathwayKey} not found`;
      this.logger.error(errorMsg, new Error(errorMsg));
      throw new Error(errorMsg);
    }
    try {
      this.logger.debug(`Delegating event processing to pathway handler`, {
        pathwayKey,
        eventId: compatibleEvent.eventId
      });
      await this.pathways.process(pathwayKey, compatibleEvent);
      this.logger.debug(`Event successfully processed through pathway`, {
        pathwayKey,
        eventId: compatibleEvent.eventId
      });
      return { success: true, message: `Event processed through pathway ${pathwayKey}` };
    } catch (error2) {
      const errorObj = error2 instanceof Error ? error2 : new Error(String(error2));
      this.logger.error(`Error processing pathway ${pathwayKey}`, errorObj, {
        eventId: compatibleEvent.eventId
      });
      throw new Error(`Failed to process event in pathway ${pathwayKey}: ${errorObj.message}`);
    }
  }
}
// src/contracts/food/food-item/food-item.contract.ts
var foodItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  name: exports_external.string().min(1, "The name of the food item is required").max(100, "The name of the food item must be less than 100 characters"),
  categoryHierarchy: exports_external.array(exports_external.string().min(1, "Category level cannot be empty").max(30, "Category level must be less than 30 characters").regex(/^[a-zA-Z0-9\s\-_]+$/, "Category can only contain letters, numbers, spaces, hyphens, and underscores")).min(1, "if foodItemCategoryHierarchy is NOT undefined, then you must have atleast 1 string in the array").max(5, "Maximum 5 category levels allowed").optional()
});
var foodItemDeletedSchema = exports_external.object({
  foodItemId: exports_external.string().uuid()
});
// src/contracts/food/food-item/food-item.shared_utils.ts
var UnitOfMeasurementEnum;
((UnitOfMeasurementEnum2) => {
  UnitOfMeasurementEnum2["GRAM"] = "Gram";
  UnitOfMeasurementEnum2["KILOGRAM"] = "Kilogram";
  UnitOfMeasurementEnum2["MILLILITER"] = "Milliliter";
  UnitOfMeasurementEnum2["LITER"] = "Liter";
  UnitOfMeasurementEnum2["TABLESPOON"] = "Tablespoon";
  UnitOfMeasurementEnum2["TEASPOON"] = "Teaspoon";
  UnitOfMeasurementEnum2["PIECE"] = "Piece";
  UnitOfMeasurementEnum2["WHOLE"] = "Whole";
  UnitOfMeasurementEnum2["PINCH"] = "Pinch";
  UnitOfMeasurementEnum2["HANDFUL"] = "Handful";
  UnitOfMeasurementEnum2["CLOVE"] = "Clove";
  UnitOfMeasurementEnum2["SLICE"] = "Slice";
  UnitOfMeasurementEnum2["STRIP"] = "Strip";
  UnitOfMeasurementEnum2["HEAD"] = "Head";
  UnitOfMeasurementEnum2["BUNCH"] = "Bunch";
  UnitOfMeasurementEnum2["TO_TASTE"] = "To taste";
  UnitOfMeasurementEnum2["AS_NEEDED"] = "As needed";
  UnitOfMeasurementEnum2["SHOT"] = "Shot";
  UnitOfMeasurementEnum2["DASH"] = "Dash";
  UnitOfMeasurementEnum2["DROP"] = "Drop";
  UnitOfMeasurementEnum2["SPLASH"] = "Splash";
  UnitOfMeasurementEnum2["SCOOP"] = "Scoop";
  UnitOfMeasurementEnum2["DRIZZLE"] = "Drizzle";
})(UnitOfMeasurementEnum ||= {});

// src/contracts/food/food-item/food-item-units.contract.ts
var foodItemUnitBaseSchema = exports_external.object({
  id: exports_external.string().uuid(),
  unitOfMeasurement: exports_external.nativeEnum(UnitOfMeasurementEnum),
  unitDescription: exports_external.string().max(100, "Unit description must be less than 100 characters").optional(),
  nutritionPerOfThisUnit: exports_external.object({
    calories: exports_external.number().min(0, "Calories must be 0 or greater"),
    proteinInGrams: exports_external.number().min(0, "Protein must be 0 or greater").optional(),
    carbohydratesInGrams: exports_external.number().min(0, "Carbohydrates must be 0 or greater").optional(),
    fatInGrams: exports_external.number().min(0, "Fat must be 0 or greater").optional(),
    fiberInGrams: exports_external.number().min(0, "Fiber must be 0 or greater").optional(),
    sugarInGrams: exports_external.number().min(0, "Sugar must be 0 or greater").optional(),
    sodiumInMilligrams: exports_external.number().min(0, "Sodium must be 0 or greater").optional()
  }),
  source: exports_external.enum(["user_measured", "package_label", "database", "estimated"]).default("user_measured")
});
var foodItemUnitSchema = exports_external.object({
  foodItemId: exports_external.string().uuid(),
  units: exports_external.array(foodItemUnitBaseSchema).min(1, "Food must have at least one unit").max(20, "Food can have at most 20 units")
});
var foodItemUnitUpdatedSchema = foodItemUnitSchema.extend({
  oldValues: foodItemUnitSchema
});
var foodItemUnitDeletedSchema = foodItemUnitSchema;
// src/contracts/food/meal/meal.contract.ts
var mealSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  mealName: exports_external.string().min(1, "Meal name is required").max(100, "Meal name must be less than 100 characters")
});
var mealUpdateSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  mealName: exports_external.string().min(1, "Meal name is required").max(100, "Meal name must be less than 100 characters").optional()
});
var mealRecipeAttachSchema = exports_external.object({
  mealId: exports_external.string().uuid(),
  recipes: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    orderInMeal: exports_external.number().int().min(0)
  })).min(1, "At least one recipe is required")
});
var mealRecipeDetachSchema = exports_external.object({
  mealRecipeId: exports_external.string().uuid()
});
// src/contracts/food/recipe/recipe.shared_utils.ts
var MealTimingEnum;
((MealTimingEnum2) => {
  MealTimingEnum2["BREAKFAST"] = "Breakfast";
  MealTimingEnum2["BRUNCH"] = "Brunch";
  MealTimingEnum2["LUNCH"] = "Lunch";
  MealTimingEnum2["DINNER"] = "Dinner";
  MealTimingEnum2["ON_THE_GO"] = "On The Go";
  MealTimingEnum2["SNACK"] = "Snack";
  MealTimingEnum2["LATE_NIGHT"] = "Late Night";
  MealTimingEnum2["AFTERNOON_TEA"] = "Afternoon Tea";
  MealTimingEnum2["SUPPER"] = "Supper";
})(MealTimingEnum ||= {});

// src/contracts/food/recipe/recipe.contract.ts
var recipeSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  whenIsItConsumed: exports_external.array(exports_external.nativeEnum(MealTimingEnum)).optional(),
  nameOfTheRecipe: exports_external.string().min(1, "The name of the recipe is required").max(75, "The name of the recipe must be less than 75 characters"),
  generalDescriptionOfTheRecipe: exports_external.string().min(1, "If generalDescriptionOfTheRecipe is NOT undefined, you must have at least one character").max(250, "The general description of the recipe must be less than 250 characters").optional()
});
var recipeUpdateSchema = recipeSchema.extend({
  oldValues: recipeSchema
});
var recipeDeletedSchema = exports_external.object({
  recipeId: exports_external.string().uuid()
});
// src/contracts/food/recipe/recipe-ingredients.contract.ts
var recipeIngredientsSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  ingredients: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    ingredientText: exports_external.string().min(1, "Ingredient text is required").max(150, "Ingredient text must be less than 150 characters")
  })).min(1, "You must have at least one ingredient").max(50, "Maximum 50 ingredients allowed")
});
var recipeIngredientsUpdateSchema = recipeIngredientsSchema.extend({
  oldValues: recipeIngredientsSchema
});
// src/contracts/food/recipe/recipe-instructions.contract.ts
var recipeInstructionsSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  stepByStepInstructions: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    instructionNumber: exports_external.number().positive("Step number must be greater than 0").int("Step number must be an integer"),
    stepInstruction: exports_external.string().min(1, "The instruction is required").max(250, "The instruction must be less than 250 characters"),
    foodItemUnitsUsedInStep: exports_external.array(exports_external.object({
      foodItemUnitId: exports_external.string().uuid(),
      quantityOfFoodItemUnit: exports_external.number().positive("Quantity used in this step must be greater than 0").max(1e6, "Quantity is unreasonably large").refine((n) => Math.floor(n * 1000) === n * 1000, {
        message: "Max 3 decimal places allowed"
      }).default(1)
    })).min(1, "If ingredientsUsedInThisStep is NOT undefined, you must have at least one ingredient").max(50, "The number of ingredients used in this step must be less than 50").optional()
  })).min(1, "You must have at least one step").max(30, "The number of steps in the recipe must be less than 30")
});
var recipeInstructionsUpdateSchema = recipeInstructionsSchema.extend({
  oldValues: recipeInstructionsSchema
});
// src/contracts/habit/habit.contract.ts
var YMD = exports_external.string().regex(/^\d{4}-\d{2}-\d{2}$/);
var HHMM = exports_external.string().regex(/^\d{2}:\d{2}$/);
var Weekday = exports_external.enum([
  "monday",
  "tuesday",
  "wednesday",
  "thursday",
  "friday",
  "saturday",
  "sunday"
]);
var weeklyHabitCreationSchema = exports_external.object({
  userId: exports_external.string(),
  domain: exports_external.string(),
  entityId: exports_external.string().uuid(),
  recurrenceType: exports_external.literal("weekly"),
  targetWeekday: Weekday,
  targetTime: HHMM.optional(),
  startDate: YMD,
  subEntities: exports_external.array(exports_external.object({
    subEntityId: exports_external.string().uuid().optional(),
    scheduledWeekday: Weekday,
    scheduledTime: HHMM.optional()
  })).min(1)
});
var habitsCreatedSchema = weeklyHabitCreationSchema;

// src/contracts/todo/todo.completed.ts
var todoCompletedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string()
});
// src/contracts/todo/todo.contract.ts
var mealRelationSchema = exports_external.object({
  mealId: exports_external.string().uuid(),
  mealName: exports_external.string().min(1).max(100),
  stepId: exports_external.string().uuid().optional(),
  instructionNumber: exports_external.number().int().positive().optional(),
  recipeName: exports_external.string().optional()
});
var mealInstructionRelationSchema = exports_external.object({
  mealStepId: exports_external.string().uuid(),
  mealId: exports_external.string().uuid(),
  recipeId: exports_external.string().uuid(),
  instructionNumber: exports_external.number().int().positive()
});
var todoSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  completed: exports_external.boolean().default(false),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
var todoUpdateSchema = todoSchema.extend({
  oldValues: todoSchema
});
var todoCancelledSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  cancelledAt: exports_external.string().datetime(),
  reasonForCancelling: exports_external.string().min(1).optional()
});
var todoRelationsUpdatedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema.optional()
  })).max(5, "you can only have up to 5 relations")
});
var todoWithMealRelationSchema = todoSchema.extend({
  relations: exports_external.object({
    meal: mealRelationSchema
  })
});
// src/contracts/todo/todo-generated.contract.ts
var todoGeneratedSchema = exports_external.object({
  id: exports_external.string().uuid(),
  userId: exports_external.string(),
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  completed: exports_external.boolean().default(false),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: mealInstructionRelationSchema
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
// node_modules/drizzle-orm/entity.js
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");
function is(value, type) {
  if (!value || typeof value !== "object") {
    return false;
  }
  if (value instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = Object.getPrototypeOf(value).constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
}

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.keyAsName = config.keyAsName;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.onUpdateFn = config.onUpdateFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
    this.generated = config.generated;
    this.generatedIdentity = config.generatedIdentity;
  }
  static [entityKind] = "Column";
  name;
  keyAsName;
  primary;
  notNull;
  default;
  defaultFn;
  onUpdateFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  generated = undefined;
  generatedIdentity = undefined;
  config;
  mapFromDriverValue(value) {
    return value;
  }
  mapToDriverValue(value) {
    return value;
  }
  shouldDisableInsert() {
    return this.config.generated !== undefined && this.config.generated.type !== "byDefault";
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      keyAsName: name === "",
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType,
      generated: undefined
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value) {
    this.config.default = value;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  $onUpdateFn(fn) {
    this.config.onUpdateFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $onUpdate = this.$onUpdateFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
  setName(name) {
    if (this.config.name !== "")
      return;
    this.config.name = name;
  }
}

// node_modules/drizzle-orm/table.utils.js
var TableName = Symbol.for("drizzle:Name");

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  constructor(table, builder2) {
    this.table = table;
    this.reference = builder2.reference;
    this.onUpdate = builder2._onUpdate;
    this.onDelete = builder2._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[TableName],
      ...columnNames,
      foreignColumns[0].table[TableName],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/tracing-utils.js
function iife(fn, ...args) {
  return fn(...args);
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
function uniqueKeyName(table, columns) {
  return `${table[TableName]}_${columns.join("_")}_unique`;
}

// node_modules/drizzle-orm/pg-core/utils/array.js
function parsePgArrayValue(arrayString, startFrom, inQuotes) {
  for (let i2 = startFrom;i2 < arrayString.length; i2++) {
    const char = arrayString[i2];
    if (char === "\\") {
      i2++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2 + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i2).replace(/\\/g, ""), i2];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
}
function parsePgNestedArray(arrayString, startFrom = 0) {
  const result = [];
  let i2 = startFrom;
  let lastCharIsComma = false;
  while (i2 < arrayString.length) {
    const char = arrayString[i2];
    if (char === ",") {
      if (lastCharIsComma || i2 === startFrom) {
        result.push("");
      }
      lastCharIsComma = true;
      i2++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i2 += 2;
      continue;
    }
    if (char === '"') {
      const [value2, startFrom2] = parsePgArrayValue(arrayString, i2 + 1, true);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result, i2 + 1];
    }
    if (char === "{") {
      const [value2, startFrom2] = parsePgNestedArray(arrayString, i2 + 1);
      result.push(value2);
      i2 = startFrom2;
      continue;
    }
    const [value, newStartFrom] = parsePgArrayValue(arrayString, i2, false);
    result.push(value);
    i2 = newStartFrom;
  }
  return [result, i2];
}
function parsePgArray(arrayString) {
  const [result] = parsePgNestedArray(arrayString, 1);
  return result;
}
function makePgArray(array) {
  return `{${array.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"")}"`;
    }
    return `${item}`;
  }).join(",")}}`;
}

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size2) {
    return new PgArrayBuilder(this.config.name, this, size2);
  }
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  generatedAlwaysAs(as) {
    this.config.generated = {
      as,
      type: "always",
      mode: "stored"
    };
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return iife((ref2, actions2) => {
        const builder2 = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder2.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder2.onDelete(actions2.onDelete);
        }
        return builder2.build(table);
      }, ref, actions);
    });
  }
  buildExtraConfigColumn(table) {
    return new ExtraConfigColumn(table, this.config);
  }
}

class PgColumn extends Column {
  constructor(table, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table, [config.name]);
    }
    super(table, config);
    this.table = table;
  }
  static [entityKind] = "PgColumn";
}

class ExtraConfigColumn extends PgColumn {
  static [entityKind] = "ExtraConfigColumn";
  getSQLType() {
    return this.getSQLType();
  }
  indexConfig = {
    order: this.config.order ?? "asc",
    nulls: this.config.nulls ?? "last",
    opClass: this.config.opClass
  };
  defaultConfig = {
    order: "asc",
    nulls: "last",
    opClass: undefined
  };
  asc() {
    this.indexConfig.order = "asc";
    return this;
  }
  desc() {
    this.indexConfig.order = "desc";
    return this;
  }
  nullsFirst() {
    this.indexConfig.nulls = "first";
    return this;
  }
  nullsLast() {
    this.indexConfig.nulls = "last";
    return this;
  }
  op(opClass) {
    this.indexConfig.opClass = opClass;
    return this;
  }
}
class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size2) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size2;
  }
  build(table) {
    const baseColumn = this.config.baseBuilder.build(table);
    return new PgArray(table, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table, config, baseColumn, range) {
    super(table, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      value = parsePgArray(value);
    }
    return value.map((v) => this.baseColumn.mapFromDriverValue(v));
  }
  mapToDriverValue(value, isNestedArray = false) {
    const a = value.map((v) => v === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v, true) : this.baseColumn.mapToDriverValue(v));
    if (isNestedArray)
      return a;
    return makePgArray(a);
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
class PgEnumObjectColumn extends PgColumn {
  static [entityKind] = "PgEnumObjectColumn";
  enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
function isPgEnum(obj) {
  return !!obj && typeof obj === "function" && isPgEnumSym in obj && obj[isPgEnumSym] === true;
}
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config) {
    super(table, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/subquery.js
class Subquery {
  static [entityKind] = "Subquery";
  constructor(sql, fields, alias, isWith = false, usedTables = []) {
    this._ = {
      brand: "Subquery",
      sql,
      selectedFields: fields,
      alias,
      isWith,
      usedTables
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/version.js
var version = "0.44.2";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e instanceof Error ? e.message : "Unknown error"
        });
        throw e;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var ExtraConfigColumns = Symbol.for("drizzle:ExtraConfigColumns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    ExtraConfigColumns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [ExtraConfigColumns];
  [BaseName];
  [IsAlias] = false;
  [IsDrizzleTable] = true;
  [ExtraConfigBuilder] = undefined;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
}
function getTableName(table) {
  return table[TableName];
}
function getTableUniqueName(table) {
  return `${table[Schema] ?? "public"}.${table[TableName]}`;
}

// node_modules/drizzle-orm/sql/sql.js
function isSQLWrapper(value) {
  return value !== null && value !== undefined && typeof value.getSQL === "function";
}
function mergeQueries(queries) {
  const result = { sql: "", params: [] };
  for (const query of queries) {
    result.sql += query.sql;
    result.params.push(...query.params);
    if (query.typings?.length) {
      if (!result.typings) {
        result.typings = [];
      }
      result.typings.push(...query.typings);
    }
  }
  return result;
}

class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value) {
    this.value = Array.isArray(value) ? value : [value];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
    for (const chunk of queryChunks) {
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        this.usedTables.push(schemaName === undefined ? chunk[Table.Symbol.Name] : schemaName + "." + chunk[Table.Symbol.Name]);
      }
    }
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  usedTables = [];
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config2) {
    const config = Object.assign({}, _config2, {
      inlineParams: _config2.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config2.paramStartIndex || { value: 0 }
    });
    const {
      casing,
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result = [new StringChunk("(")];
        for (const [i2, p] of chunk.entries()) {
          result.push(p);
          if (i2 < chunk.length - 1) {
            result.push(new StringChunk(", "));
          }
        }
        result.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined || chunk[IsAlias] ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        const columnName = casing.getColumnCasing(chunk);
        if (_config2.invokeSource === "indexes") {
          return { sql: escapeName(columnName), params: [] };
        }
        const schemaName = chunk.table[Table.Symbol.Schema];
        return {
          sql: chunk.table[IsAlias] || schemaName === undefined ? escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName) : escapeName(schemaName) + "." + escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(columnName),
          params: []
        };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined || chunk[ViewBaseConfig].isAlias ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        if (is(chunk.value, Placeholder)) {
          return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
        }
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings = ["none"];
        if (prepareTyping) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk._.isWith) {
          return { sql: escapeName(chunk._.alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk._.sql,
          new StringChunk(") "),
          new Name(chunk._.alias)
        ], config);
      }
      if (isPgEnum(chunk)) {
        if (chunk.schema) {
          return { sql: escapeName(chunk.schema) + "." + escapeName(chunk.enumName), params: [] };
        }
        return { sql: escapeName(chunk.enumName), params: [] };
      }
      if (isSQLWrapper(chunk)) {
        if (chunk.shouldOmitSQLParens?.()) {
          return this.buildQueryFromSourceParams([chunk.getSQL()], config);
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ["none"] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
  if(condition) {
    return condition ? this : undefined;
  }
}

class Name {
  constructor(value) {
    this.value = value;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function isDriverValueEncoder(value) {
  return typeof value === "object" && value !== null && "mapToDriverValue" in value && typeof value.mapToDriverValue === "function";
}
var noopDecoder = {
  mapFromDriverValue: (value) => value
};
var noopEncoder = {
  mapToDriverValue: (value) => value
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value, encoder = noopEncoder) {
    this.value = value;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
function sql(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw2(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw2;
  function join(chunks, separator) {
    const result = [];
    for (const [i2, chunk] of chunks.entries()) {
      if (i2 > 0 && separator !== undefined) {
        result.push(separator);
      }
      result.push(chunk);
    }
    return new SQL(result);
  }
  sql2.join = join;
  function identifier(value) {
    return new Name(value);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value, encoder) {
    return new Param(value, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}
function fillPlaceholders(params, values2) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values2)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values2[p.name];
    }
    if (is(p, Param) && is(p.value, Placeholder)) {
      if (!(p.value.name in values2)) {
        throw new Error(`No value for placeholder "${p.value.name}" was provided`);
      }
      return p.encoder.mapToDriverValue(values2[p.value.name]);
    }
    return p;
  });
}
var IsDrizzleView = Symbol.for("drizzle:IsDrizzleView");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  [IsDrizzleView] = true;
  constructor({ name: name2, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
class ColumnAliasProxyHandler {
  constructor(table) {
    this.table = table;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value = target[prop];
    if (is(value, Column)) {
      return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value;
  }
}
function aliasedTable(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
}
function aliasedTableColumn(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
}
function mapColumnsInAliasedSQLToAlias(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
}
function mapColumnsInSQLToAlias(query, alias) {
  return sql.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger2 {
  static [entityKind] = "NoopLogger";
  logQuery() {}
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/utils.js
function mapResultRow(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result = columns.reduce((result2, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result2;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result2;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result[objectName] = null;
      }
    }
  }
  return result;
}
function orderSelectedFields(fields, pathPrefix) {
  return Object.entries(fields).reduce((result, [name, field]) => {
    if (typeof name !== "string") {
      return result;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result.push(...orderSelectedFields(field, newPath));
    }
    return result;
  }, []);
}
function haveSameKeys(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
}
function mapUpdateSet(table, values2) {
  const entries = Object.entries(values2).filter(([, value]) => value !== undefined).map(([key, value]) => {
    if (is(value, SQL) || is(value, Column)) {
      return [key, value];
    } else {
      return [key, new Param(value, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
}
function applyMixins(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || /* @__PURE__ */ Object.create(null));
    }
  }
}
function getTableColumns(table) {
  return table[Table.Symbol.Columns];
}
function getTableLikeName(table) {
  return is(table, Subquery) ? table._.alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
}
function getColumnNameAndConfig(a, b2) {
  return {
    name: typeof a === "string" && a.length > 0 ? a : "",
    config: typeof a === "object" ? a : b2
  };
}
function isConfig(data) {
  if (typeof data !== "object" || data === null)
    return false;
  if (data.constructor.name !== "Object")
    return false;
  if ("logger" in data) {
    const type = typeof data["logger"];
    if (type !== "boolean" && (type !== "object" || typeof data["logger"]["logQuery"] !== "function") && type !== "undefined")
      return false;
    return true;
  }
  if ("schema" in data) {
    const type = typeof data["schema"];
    if (type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("casing" in data) {
    const type = typeof data["casing"];
    if (type !== "string" && type !== "undefined")
      return false;
    return true;
  }
  if ("mode" in data) {
    if (data["mode"] !== "default" || data["mode"] !== "planetscale" || data["mode"] !== undefined)
      return false;
    return true;
  }
  if ("connection" in data) {
    const type = typeof data["connection"];
    if (type !== "string" && type !== "object" && type !== "undefined")
      return false;
    return true;
  }
  if ("client" in data) {
    const type = typeof data["client"];
    if (type !== "object" && type !== "function" && type !== "undefined")
      return false;
    return true;
  }
  if (Object.keys(data).length === 0)
    return true;
  return false;
}

// node_modules/drizzle-orm/pg-core/columns/int.common.js
class PgIntColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntColumnBaseBuilder";
  generatedAlwaysAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "always",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "always"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
  generatedByDefaultAsIdentity(sequence) {
    if (sequence) {
      const { name, ...options } = sequence;
      this.config.generatedIdentity = {
        type: "byDefault",
        sequenceName: name,
        sequenceOptions: options
      };
    } else {
      this.config.generatedIdentity = {
        type: "byDefault"
      };
    }
    this.config.hasDefault = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/columns/bigint.js
class PgBigInt53Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt53Builder";
  constructor(name) {
    super(name, "number", "PgBigInt53");
  }
  build(table) {
    return new PgBigInt53(table, this.config);
  }
}

class PgBigInt53 extends PgColumn {
  static [entityKind] = "PgBigInt53";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigInt64Builder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgBigInt64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigInt64");
  }
  build(table) {
    return new PgBigInt64(table, this.config);
  }
}

class PgBigInt64 extends PgColumn {
  static [entityKind] = "PgBigInt64";
  getSQLType() {
    return "bigint";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigint(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (config.mode === "number") {
    return new PgBigInt53Builder(name);
  }
  return new PgBigInt64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/bigserial.js
class PgBigSerial53Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial53Builder";
  constructor(name) {
    super(name, "number", "PgBigSerial53");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgBigSerial53(table, this.config);
  }
}

class PgBigSerial53 extends PgColumn {
  static [entityKind] = "PgBigSerial53";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    if (typeof value === "number") {
      return value;
    }
    return Number(value);
  }
}

class PgBigSerial64Builder extends PgColumnBuilder {
  static [entityKind] = "PgBigSerial64Builder";
  constructor(name) {
    super(name, "bigint", "PgBigSerial64");
    this.config.hasDefault = true;
  }
  build(table) {
    return new PgBigSerial64(table, this.config);
  }
}

class PgBigSerial64 extends PgColumn {
  static [entityKind] = "PgBigSerial64";
  getSQLType() {
    return "bigserial";
  }
  mapFromDriverValue(value) {
    return BigInt(value);
  }
}
function bigserial(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (config.mode === "number") {
    return new PgBigSerial53Builder(name);
  }
  return new PgBigSerial64Builder(name);
}

// node_modules/drizzle-orm/pg-core/columns/boolean.js
class PgBooleanBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBooleanBuilder";
  constructor(name) {
    super(name, "boolean", "PgBoolean");
  }
  build(table) {
    return new PgBoolean(table, this.config);
  }
}

class PgBoolean extends PgColumn {
  static [entityKind] = "PgBoolean";
  getSQLType() {
    return "boolean";
  }
}
function boolean(name) {
  return new PgBooleanBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/char.js
class PgCharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCharBuilder";
  constructor(name, config) {
    super(name, "string", "PgChar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgChar(table, this.config);
  }
}

class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
function char(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgCharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/cidr.js
class PgCidrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCidrBuilder";
  constructor(name) {
    super(name, "string", "PgCidr");
  }
  build(table) {
    return new PgCidr(table, this.config);
  }
}

class PgCidr extends PgColumn {
  static [entityKind] = "PgCidr";
  getSQLType() {
    return "cidr";
  }
}
function cidr(name) {
  return new PgCidrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/custom.js
class PgCustomColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgCustomColumnBuilder";
  constructor(name, fieldConfig, customTypeParams) {
    super(name, "custom", "PgCustomColumn");
    this.config.fieldConfig = fieldConfig;
    this.config.customTypeParams = customTypeParams;
  }
  build(table) {
    return new PgCustomColumn(table, this.config);
  }
}

class PgCustomColumn extends PgColumn {
  static [entityKind] = "PgCustomColumn";
  sqlName;
  mapTo;
  mapFrom;
  constructor(table, config) {
    super(table, config);
    this.sqlName = config.customTypeParams.dataType(config.fieldConfig);
    this.mapTo = config.customTypeParams.toDriver;
    this.mapFrom = config.customTypeParams.fromDriver;
  }
  getSQLType() {
    return this.sqlName;
  }
  mapFromDriverValue(value) {
    return typeof this.mapFrom === "function" ? this.mapFrom(value) : value;
  }
  mapToDriverValue(value) {
    return typeof this.mapTo === "function" ? this.mapTo(value) : value;
  }
}
function customType(customTypeParams) {
  return (a, b2) => {
    const { name, config } = getColumnNameAndConfig(a, b2);
    return new PgCustomColumnBuilder(name, config, customTypeParams);
  };
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDateBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateBuilder";
  constructor(name) {
    super(name, "date", "PgDate");
  }
  build(table) {
    return new PgDate(table, this.config);
  }
}

class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value) {
    return new Date(value);
  }
  mapToDriverValue(value) {
    return value.toISOString();
  }
}

class PgDateStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgDateStringBuilder";
  constructor(name) {
    super(name, "string", "PgDateString");
  }
  build(table) {
    return new PgDateString(table, this.config);
  }
}

class PgDateString extends PgColumn {
  static [entityKind] = "PgDateString";
  getSQLType() {
    return "date";
  }
}
function date(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (config?.mode === "date") {
    return new PgDateBuilder(name);
  }
  return new PgDateStringBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/double-precision.js
class PgDoublePrecisionBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDoublePrecisionBuilder";
  constructor(name) {
    super(name, "number", "PgDoublePrecision");
  }
  build(table) {
    return new PgDoublePrecision(table, this.config);
  }
}

class PgDoublePrecision extends PgColumn {
  static [entityKind] = "PgDoublePrecision";
  getSQLType() {
    return "double precision";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  }
}
function doublePrecision(name) {
  return new PgDoublePrecisionBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/inet.js
class PgInetBuilder extends PgColumnBuilder {
  static [entityKind] = "PgInetBuilder";
  constructor(name) {
    super(name, "string", "PgInet");
  }
  build(table) {
    return new PgInet(table, this.config);
  }
}

class PgInet extends PgColumn {
  static [entityKind] = "PgInet";
  getSQLType() {
    return "inet";
  }
}
function inet(name) {
  return new PgInetBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
class PgIntegerBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table) {
    return new PgInteger(table, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      return Number.parseInt(value);
    }
    return value;
  }
}
function integer(name) {
  return new PgIntegerBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/interval.js
class PgIntervalBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntervalBuilder";
  constructor(name, intervalConfig) {
    super(name, "string", "PgInterval");
    this.config.intervalConfig = intervalConfig;
  }
  build(table) {
    return new PgInterval(table, this.config);
  }
}

class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
function interval(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgIntervalBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJsonBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonBuilder";
  constructor(name) {
    super(name, "json", "PgJson");
  }
  build(table) {
    return new PgJson(table, this.config);
  }
}

class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function json(name) {
  return new PgJsonBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonbBuilder extends PgColumnBuilder {
  static [entityKind] = "PgJsonbBuilder";
  constructor(name) {
    super(name, "json", "PgJsonb");
  }
  build(table) {
    return new PgJsonb(table, this.config);
  }
}

class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    return value;
  }
}
function jsonb(name) {
  return new PgJsonbBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/line.js
class PgLineBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineBuilder";
  constructor(name) {
    super(name, "array", "PgLine");
  }
  build(table) {
    return new PgLineTuple(table, this.config);
  }
}

class PgLineTuple extends PgColumn {
  static [entityKind] = "PgLine";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b2, c] = value.slice(1, -1).split(",");
    return [Number.parseFloat(a), Number.parseFloat(b2), Number.parseFloat(c)];
  }
  mapToDriverValue(value) {
    return `{${value[0]},${value[1]},${value[2]}}`;
  }
}

class PgLineABCBuilder extends PgColumnBuilder {
  static [entityKind] = "PgLineABCBuilder";
  constructor(name) {
    super(name, "json", "PgLineABC");
  }
  build(table) {
    return new PgLineABC(table, this.config);
  }
}

class PgLineABC extends PgColumn {
  static [entityKind] = "PgLineABC";
  getSQLType() {
    return "line";
  }
  mapFromDriverValue(value) {
    const [a, b2, c] = value.slice(1, -1).split(",");
    return { a: Number.parseFloat(a), b: Number.parseFloat(b2), c: Number.parseFloat(c) };
  }
  mapToDriverValue(value) {
    return `{${value.a},${value.b},${value.c}}`;
  }
}
function line(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (!config?.mode || config.mode === "tuple") {
    return new PgLineBuilder(name);
  }
  return new PgLineABCBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/macaddr.js
class PgMacaddrBuilder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddrBuilder";
  constructor(name) {
    super(name, "string", "PgMacaddr");
  }
  build(table) {
    return new PgMacaddr(table, this.config);
  }
}

class PgMacaddr extends PgColumn {
  static [entityKind] = "PgMacaddr";
  getSQLType() {
    return "macaddr";
  }
}
function macaddr(name) {
  return new PgMacaddrBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/macaddr8.js
class PgMacaddr8Builder extends PgColumnBuilder {
  static [entityKind] = "PgMacaddr8Builder";
  constructor(name) {
    super(name, "string", "PgMacaddr8");
  }
  build(table) {
    return new PgMacaddr8(table, this.config);
  }
}

class PgMacaddr8 extends PgColumn {
  static [entityKind] = "PgMacaddr8";
  getSQLType() {
    return "macaddr8";
  }
}
function macaddr8(name) {
  return new PgMacaddr8Builder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumericBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBuilder";
  constructor(name, precision, scale) {
    super(name, "string", "PgNumeric");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumeric(table, this.config);
  }
}

class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "string")
      return value;
    return String(value);
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericNumberBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericNumberBuilder";
  constructor(name, precision, scale) {
    super(name, "number", "PgNumericNumber");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericNumber(table, this.config);
  }
}

class PgNumericNumber extends PgColumn {
  static [entityKind] = "PgNumericNumber";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue(value) {
    if (typeof value === "number")
      return value;
    return Number(value);
  }
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

class PgNumericBigIntBuilder extends PgColumnBuilder {
  static [entityKind] = "PgNumericBigIntBuilder";
  constructor(name, precision, scale) {
    super(name, "bigint", "PgNumericBigInt");
    this.config.precision = precision;
    this.config.scale = scale;
  }
  build(table) {
    return new PgNumericBigInt(table, this.config);
  }
}

class PgNumericBigInt extends PgColumn {
  static [entityKind] = "PgNumericBigInt";
  precision;
  scale;
  constructor(table, config) {
    super(table, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  mapFromDriverValue = BigInt;
  mapToDriverValue = String;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}
function numeric(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  const mode = config?.mode;
  return mode === "number" ? new PgNumericNumberBuilder(name, config?.precision, config?.scale) : mode === "bigint" ? new PgNumericBigIntBuilder(name, config?.precision, config?.scale) : new PgNumericBuilder(name, config?.precision, config?.scale);
}

// node_modules/drizzle-orm/pg-core/columns/point.js
class PgPointTupleBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointTupleBuilder";
  constructor(name) {
    super(name, "array", "PgPointTuple");
  }
  build(table) {
    return new PgPointTuple(table, this.config);
  }
}

class PgPointTuple extends PgColumn {
  static [entityKind] = "PgPointTuple";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return [Number.parseFloat(x2), Number.parseFloat(y)];
    }
    return [value.x, value.y];
  }
  mapToDriverValue(value) {
    return `(${value[0]},${value[1]})`;
  }
}

class PgPointObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgPointObjectBuilder";
  constructor(name) {
    super(name, "json", "PgPointObject");
  }
  build(table) {
    return new PgPointObject(table, this.config);
  }
}

class PgPointObject extends PgColumn {
  static [entityKind] = "PgPointObject";
  getSQLType() {
    return "point";
  }
  mapFromDriverValue(value) {
    if (typeof value === "string") {
      const [x2, y] = value.slice(1, -1).split(",");
      return { x: Number.parseFloat(x2), y: Number.parseFloat(y) };
    }
    return value;
  }
  mapToDriverValue(value) {
    return `(${value.x},${value.y})`;
  }
}
function point(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (!config?.mode || config.mode === "tuple") {
    return new PgPointTupleBuilder(name);
  }
  return new PgPointObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/utils.js
function hexToBytes(hex) {
  const bytes = [];
  for (let c = 0;c < hex.length; c += 2) {
    bytes.push(Number.parseInt(hex.slice(c, c + 2), 16));
  }
  return new Uint8Array(bytes);
}
function bytesToFloat64(bytes, offset) {
  const buffer2 = new ArrayBuffer(8);
  const view = new DataView(buffer2);
  for (let i2 = 0;i2 < 8; i2++) {
    view.setUint8(i2, bytes[offset + i2]);
  }
  return view.getFloat64(0, true);
}
function parseEWKB(hex) {
  const bytes = hexToBytes(hex);
  let offset = 0;
  const byteOrder = bytes[offset];
  offset += 1;
  const view = new DataView(bytes.buffer);
  const geomType = view.getUint32(offset, byteOrder === 1);
  offset += 4;
  let _srid;
  if (geomType & 536870912) {
    _srid = view.getUint32(offset, byteOrder === 1);
    offset += 4;
  }
  if ((geomType & 65535) === 1) {
    const x2 = bytesToFloat64(bytes, offset);
    offset += 8;
    const y = bytesToFloat64(bytes, offset);
    offset += 8;
    return [x2, y];
  }
  throw new Error("Unsupported geometry type");
}

// node_modules/drizzle-orm/pg-core/columns/postgis_extension/geometry.js
class PgGeometryBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryBuilder";
  constructor(name) {
    super(name, "array", "PgGeometry");
  }
  build(table) {
    return new PgGeometry(table, this.config);
  }
}

class PgGeometry extends PgColumn {
  static [entityKind] = "PgGeometry";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    return parseEWKB(value);
  }
  mapToDriverValue(value) {
    return `point(${value[0]} ${value[1]})`;
  }
}

class PgGeometryObjectBuilder extends PgColumnBuilder {
  static [entityKind] = "PgGeometryObjectBuilder";
  constructor(name) {
    super(name, "json", "PgGeometryObject");
  }
  build(table) {
    return new PgGeometryObject(table, this.config);
  }
}

class PgGeometryObject extends PgColumn {
  static [entityKind] = "PgGeometryObject";
  getSQLType() {
    return "geometry(point)";
  }
  mapFromDriverValue(value) {
    const parsed = parseEWKB(value);
    return { x: parsed[0], y: parsed[1] };
  }
  mapToDriverValue(value) {
    return `point(${value.x} ${value.y})`;
  }
}
function geometry(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (!config?.mode || config.mode === "tuple") {
    return new PgGeometryBuilder(name);
  }
  return new PgGeometryObjectBuilder(name);
}

// node_modules/drizzle-orm/pg-core/columns/real.js
class PgRealBuilder extends PgColumnBuilder {
  static [entityKind] = "PgRealBuilder";
  constructor(name, length) {
    super(name, "number", "PgReal");
    this.config.length = length;
  }
  build(table) {
    return new PgReal(table, this.config);
  }
}

class PgReal extends PgColumn {
  static [entityKind] = "PgReal";
  constructor(table, config) {
    super(table, config);
  }
  getSQLType() {
    return "real";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number.parseFloat(value);
    }
    return value;
  };
}
function real(name) {
  return new PgRealBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/serial.js
class PgSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSerial(table, this.config);
  }
}

class PgSerial extends PgColumn {
  static [entityKind] = "PgSerial";
  getSQLType() {
    return "serial";
  }
}
function serial(name) {
  return new PgSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallint.js
class PgSmallIntBuilder extends PgIntColumnBaseBuilder {
  static [entityKind] = "PgSmallIntBuilder";
  constructor(name) {
    super(name, "number", "PgSmallInt");
  }
  build(table) {
    return new PgSmallInt(table, this.config);
  }
}

class PgSmallInt extends PgColumn {
  static [entityKind] = "PgSmallInt";
  getSQLType() {
    return "smallint";
  }
  mapFromDriverValue = (value) => {
    if (typeof value === "string") {
      return Number(value);
    }
    return value;
  };
}
function smallint(name) {
  return new PgSmallIntBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/smallserial.js
class PgSmallSerialBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSmallSerialBuilder";
  constructor(name) {
    super(name, "number", "PgSmallSerial");
    this.config.hasDefault = true;
    this.config.notNull = true;
  }
  build(table) {
    return new PgSmallSerial(table, this.config);
  }
}

class PgSmallSerial extends PgColumn {
  static [entityKind] = "PgSmallSerial";
  getSQLType() {
    return "smallserial";
  }
}
function smallserial(name) {
  return new PgSmallSerialBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/text.js
class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgText(table, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
function text(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgTextBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTimeBuilder extends PgDateColumnBaseBuilder {
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTime");
    this.withTimezone = withTimezone;
    this.precision = precision;
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  static [entityKind] = "PgTimeBuilder";
  build(table) {
    return new PgTime(table, this.config);
  }
}

class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function time(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestamp(table, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value) => {
    return new Date(this.withTimezone ? value : value + "+0000");
  };
  mapToDriverValue = (value) => {
    return value.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table) {
    return new PgTimestampString(table, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table, config) {
    super(table, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}
function timestamp(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  if (config?.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUIDBuilder extends PgColumnBuilder {
  static [entityKind] = "PgUUIDBuilder";
  constructor(name) {
    super(name, "string", "PgUUID");
  }
  defaultRandom() {
    return this.default(sql`gen_random_uuid()`);
  }
  build(table) {
    return new PgUUID(table, this.config);
  }
}

class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
function uuid(name) {
  return new PgUUIDBuilder(name ?? "");
}

// node_modules/drizzle-orm/pg-core/columns/varchar.js
class PgVarcharBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVarcharBuilder";
  constructor(name, config) {
    super(name, "string", "PgVarchar");
    this.config.length = config.length;
    this.config.enumValues = config.enum;
  }
  build(table) {
    return new PgVarchar(table, this.config);
  }
}

class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
function varchar(a, b2 = {}) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgVarcharBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/bit.js
class PgBinaryVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgBinaryVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgBinaryVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgBinaryVector(table, this.config);
  }
}

class PgBinaryVector extends PgColumn {
  static [entityKind] = "PgBinaryVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `bit(${this.dimensions})`;
  }
}
function bit(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgBinaryVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/halfvec.js
class PgHalfVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgHalfVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgHalfVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgHalfVector(table, this.config);
  }
}

class PgHalfVector extends PgColumn {
  static [entityKind] = "PgHalfVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `halfvec(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function halfvec(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgHalfVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/sparsevec.js
class PgSparseVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgSparseVectorBuilder";
  constructor(name, config) {
    super(name, "string", "PgSparseVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgSparseVector(table, this.config);
  }
}

class PgSparseVector extends PgColumn {
  static [entityKind] = "PgSparseVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `sparsevec(${this.dimensions})`;
  }
}
function sparsevec(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgSparseVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/vector_extension/vector.js
class PgVectorBuilder extends PgColumnBuilder {
  static [entityKind] = "PgVectorBuilder";
  constructor(name, config) {
    super(name, "array", "PgVector");
    this.config.dimensions = config.dimensions;
  }
  build(table) {
    return new PgVector(table, this.config);
  }
}

class PgVector extends PgColumn {
  static [entityKind] = "PgVector";
  dimensions = this.config.dimensions;
  getSQLType() {
    return `vector(${this.dimensions})`;
  }
  mapToDriverValue(value) {
    return JSON.stringify(value);
  }
  mapFromDriverValue(value) {
    return value.slice(1, -1).split(",").map((v) => Number.parseFloat(v));
  }
}
function vector(a, b2) {
  const { name, config } = getColumnNameAndConfig(a, b2);
  return new PgVectorBuilder(name, config);
}

// node_modules/drizzle-orm/pg-core/columns/all.js
function getPgColumnBuilders() {
  return {
    bigint,
    bigserial,
    boolean,
    char,
    cidr,
    customType,
    date,
    doublePrecision,
    inet,
    integer,
    interval,
    json,
    jsonb,
    line,
    macaddr,
    macaddr8,
    numeric,
    point,
    geometry,
    real,
    serial,
    smallint,
    smallserial,
    text,
    time,
    timestamp,
    uuid,
    varchar,
    bit,
    halfvec,
    sparsevec,
    vector
  };
}

// node_modules/drizzle-orm/pg-core/table.js
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");
var EnableRLS = Symbol.for("drizzle:EnableRLS");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys,
    EnableRLS
  });
  [InlineForeignKeys] = [];
  [EnableRLS] = false;
  [Table.Symbol.ExtraConfigBuilder] = undefined;
  [Table.Symbol.ExtraConfigColumns] = {};
}
function pgTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
  const rawTable = new PgTable(name, schema, baseName);
  const parsedColumns = typeof columns === "function" ? columns(getPgColumnBuilders()) : columns;
  const builtColumns = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name2, column];
  }));
  const builtColumnsForExtraConfig = Object.fromEntries(Object.entries(parsedColumns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    colBuilder.setName(name2);
    const column = colBuilder.buildExtraConfigColumn(rawTable);
    return [name2, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  table[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;
  if (extraConfig) {
    table[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return Object.assign(table, {
    enableRLS: () => {
      table[PgTable.Symbol.EnableRLS] = true;
      return table;
    }
  });
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table) {
    return new PrimaryKey(table, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table, columns, name) {
    this.table = table;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
function bindIfParam(value, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value) && !is(value, Param) && !is(value, Placeholder) && !is(value, Column) && !is(value, Table) && !is(value, View)) {
    return new Param(value, column);
  }
  return value;
}
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
function and(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
}
function or(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
}
function not(condition) {
  return sql`not ${condition}`;
}
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};
function inArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`false`;
    }
    return sql`${column} in ${values2.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} in ${bindIfParam(values2, column)}`;
}
function notInArray(column, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      return sql`true`;
    }
    return sql`${column} not in ${values2.map((v) => bindIfParam(v, column))}`;
  }
  return sql`${column} not in ${bindIfParam(values2, column)}`;
}
function isNull(value) {
  return sql`${value} is null`;
}
function isNotNull(value) {
  return sql`${value} is not null`;
}
function exists(subquery) {
  return sql`exists ${subquery}`;
}
function notExists(subquery) {
  return sql`not exists ${subquery}`;
}
function between(column, min, max2) {
  return sql`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max2, column)}`;
}
function notBetween(column, min, max2) {
  return sql`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max2, column)}`;
}
function like(column, value) {
  return sql`${column} like ${value}`;
}
function notLike(column, value) {
  return sql`${column} not like ${value}`;
}
function ilike(column, value) {
  return sql`${column} ilike ${value}`;
}
function notIlike(column, value) {
  return sql`${column} not ilike ${value}`;
}

// node_modules/drizzle-orm/sql/expressions/select.js
function asc(column) {
  return sql`${column} asc`;
}
function desc(column) {
  return sql`${column} desc`;
}

// node_modules/drizzle-orm/relations.js
class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table, config) {
    this.table = table;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
function getOperators() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
}
function getOrderByOperators() {
  return {
    sql,
    asc,
    desc
  };
}
function extractTablesRelationalConfig(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && "default" in schema && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value] of Object.entries(schema)) {
    if (is(value, Table)) {
      const dbName = getTableUniqueName(value);
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value[Table.Symbol.Name],
        schema: value[Table.Symbol.Schema],
        columns: value[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value[Table.Symbol.ExtraConfigBuilder]?.(value[Table.Symbol.ExtraConfigColumns]);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value, Relations)) {
      const dbName = getTableUniqueName(value.table);
      const tableName = tableNamesMap[dbName];
      const relations2 = value.config(configHelpers(value.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
}
function createOne(sourceTable) {
  return function one(table, config) {
    return new One(sourceTable, table, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
}
function createMany(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
}
function normalizeRelation(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[getTableUniqueName(relation.referencedTable)];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[getTableUniqueName(sourceTable)];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
}
function createTableRelationsHelpers(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
}
function mapRelationalRow(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value) => value) {
  const result = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result[selectionItem.tsKey] = value === null ? null : decoder.mapFromDriverValue(value);
    }
  }
  return result;
}

// node_modules/drizzle-orm/sql/functions/aggregate.js
function max2(expression) {
  return sql`max(${expression})`.mapWith(is(expression, Column) ? expression : String);
}

// node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib2(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection2 = import_lib.default.Connection;
var types4 = import_lib.default.types;
var Query2 = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier2 = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result2 = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;
var esm_default = import_lib.default;

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery, prop) {
    if (prop === "_") {
      return {
        ...subquery["_"],
        selectedFields: new Proxy(subquery._.selectedFields, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery._.selectedFields : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value = columns[prop];
    if (is(value, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value.isSelectionField) {
        return value.sql;
      }
      const newValue = value.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value, Column)) {
      if (this.config.alias) {
        return new Proxy(value, new ColumnAliasProxyHandler(new Proxy(value.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value;
    }
    if (typeof value !== "object" || value === null) {
      return value;
    }
    return new Proxy(value, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/casing.js
function toSnakeCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.map((word) => word.toLowerCase()).join("_");
}
function toCamelCase(input) {
  const words = input.replace(/['\u2019]/g, "").match(/[\da-z]+|[A-Z]+(?![a-z])|[A-Z][\da-z]+/g) ?? [];
  return words.reduce((acc, word, i2) => {
    const formattedWord = i2 === 0 ? word.toLowerCase() : `${word[0].toUpperCase()}${word.slice(1)}`;
    return acc + formattedWord;
  }, "");
}
function noopCase(input) {
  return input;
}

class CasingCache {
  static [entityKind] = "CasingCache";
  cache = {};
  cachedTables = {};
  convert;
  constructor(casing) {
    this.convert = casing === "snake_case" ? toSnakeCase : casing === "camelCase" ? toCamelCase : noopCase;
  }
  getColumnCasing(column) {
    if (!column.keyAsName)
      return column.name;
    const schema = column.table[Table.Symbol.Schema] ?? "public";
    const tableName = column.table[Table.Symbol.OriginalName];
    const key = `${schema}.${tableName}.${column.name}`;
    if (!this.cache[key]) {
      this.cacheTable(column.table);
    }
    return this.cache[key];
  }
  cacheTable(table) {
    const schema = table[Table.Symbol.Schema] ?? "public";
    const tableName = table[Table.Symbol.OriginalName];
    const tableKey = `${schema}.${tableName}`;
    if (!this.cachedTables[tableKey]) {
      for (const column of Object.values(table[Table.Symbol.Columns])) {
        const columnKey = `${tableKey}.${column.name}`;
        this.cache[columnKey] = this.convert(column.name);
      }
      this.cachedTables[tableKey] = true;
    }
  }
  clearCache() {
    this.cache = {};
    this.cachedTables = {};
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  casing;
  constructor(config) {
    this.casing = new CasingCache(config?.casing);
  }
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i2, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w._.alias)} as (${w._.sql})`);
      if (i2 < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const tableColumns = table[Table.Symbol.Columns];
    const columnNames = Object.keys(tableColumns).filter((colName) => set[colName] !== undefined || tableColumns[colName]?.onUpdateFn !== undefined);
    const setSize = columnNames.length;
    return sql.join(columnNames.flatMap((colName, i2) => {
      const col = tableColumns[colName];
      const value = set[colName] ?? sql.param(col.onUpdateFn(), col);
      const res = sql`${sql.identifier(this.casing.getColumnCasing(col))} = ${value}`;
      if (i2 < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning, withList, from, joins }) {
    const withSql = this.buildWithCTE(withList);
    const tableName = table[PgTable.Symbol.Name];
    const tableSchema = table[PgTable.Symbol.Schema];
    const origTableName = table[PgTable.Symbol.OriginalName];
    const alias = tableName === origTableName ? undefined : tableName;
    const tableSql = sql`${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}`;
    const setSql = this.buildUpdateSet(table, set);
    const fromSql = from && sql.join([sql.raw(" from "), this.buildFromTable(from)]);
    const joinsSql = this.buildJoins(joins);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: !from })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${tableSql} set ${setSql}${fromSql}${joinsSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i2) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, PgColumn)) {
              return sql.identifier(this.casing.getColumnCasing(c));
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(this.casing.getColumnCasing(field)));
        } else {
          chunk.push(field);
        }
      }
      if (i2 < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildJoins(joins) {
    if (!joins || joins.length === 0) {
      return;
    }
    const joinsArray = [];
    for (const [index, joinMeta] of joins.entries()) {
      if (index === 0) {
        joinsArray.push(sql` `);
      }
      const table = joinMeta.table;
      const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
      const onSql = joinMeta.on ? sql` on ${joinMeta.on}` : undefined;
      if (is(table, PgTable)) {
        const tableName = table[PgTable.Symbol.Name];
        const tableSchema = table[PgTable.Symbol.Schema];
        const origTableName = table[PgTable.Symbol.OriginalName];
        const alias = tableName === origTableName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else if (is(table, View)) {
        const viewName = table[ViewBaseConfig].name;
        const viewSchema = table[ViewBaseConfig].schema;
        const origViewName = table[ViewBaseConfig].originalName;
        const alias = viewName === origViewName ? undefined : joinMeta.alias;
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql` ${sql.identifier(alias)}`}${onSql}`);
      } else {
        joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table}${onSql}`);
      }
      if (index < joins.length - 1) {
        joinsArray.push(sql` `);
      }
    }
    return sql.join(joinsArray);
  }
  buildFromTable(table) {
    if (is(table, Table) && table[Table.Symbol.IsAlias]) {
      let fullName = sql`${sql.identifier(table[Table.Symbol.OriginalName])}`;
      if (table[Table.Symbol.Schema]) {
        fullName = sql`${sql.identifier(table[Table.Symbol.Schema])}.${fullName}`;
      }
      return sql`${fullName} ${sql.identifier(table[Table.Symbol.Name])}`;
    }
    return table;
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table._.alias : is(table, PgViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = this.buildFromTable(table);
    const joinsSql = this.buildJoins(joins);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` nowait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i2 = 0;i2 < singleOrderBy.queryChunks.length; i2++) {
            const chunk = singleOrderBy.queryChunks[i2];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i2] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = typeof limit === "object" || typeof limit === "number" && limit >= 0 ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values: valuesOrSelect, onConflict, returning, withList, select: select2, overridingSystemValue_ }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns).filter(([_, col]) => !col.shouldDisableInsert());
    const insertOrder = colEntries.map(([, column]) => sql.identifier(this.casing.getColumnCasing(column)));
    if (select2) {
      const select22 = valuesOrSelect;
      if (is(select22, SQL)) {
        valuesSqlList.push(select22);
      } else {
        valuesSqlList.push(select22.getSQL());
      }
    } else {
      const values2 = valuesOrSelect;
      valuesSqlList.push(sql.raw("values "));
      for (const [valueIndex, value] of values2.entries()) {
        const valueList = [];
        for (const [fieldName, col] of colEntries) {
          const colValue = value[fieldName];
          if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
            if (col.defaultFn !== undefined) {
              const defaultFnResult = col.defaultFn();
              const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
              valueList.push(defaultValue);
            } else if (!col.default && col.onUpdateFn !== undefined) {
              const onUpdateFnResult = col.onUpdateFn();
              const newValue = is(onUpdateFnResult, SQL) ? onUpdateFnResult : sql.param(onUpdateFnResult, col);
              valueList.push(newValue);
            } else {
              valueList.push(sql`default`);
            }
          } else {
            valueList.push(colValue);
          }
        }
        valuesSqlList.push(valueList);
        if (valueIndex < values2.length - 1) {
          valuesSqlList.push(sql`, `);
        }
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    const overridingSql = overridingSystemValue_ === true ? sql`overriding system value ` : undefined;
    return sql`${withSql}insert into ${table} ${insertOrder} ${overridingSql}${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp) || is(encoder, PgTimestampString)) {
      return "timestamp";
    } else if (is(encoder, PgDate) || is(encoder, PgDateString)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql2, invokeSource) {
    return sql2.toQuery({
      casing: this.casing,
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping,
      invokeSource
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema,
    tableNamesMap,
    table,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value]) => ({
        dbKey: value.name,
        tsKey: key,
        field: aliasedTableColumn(value, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value] of Object.entries(config.columns)) {
          if (value === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value, tableAlias)
          });
        }
      }
      for (const { tsKey, value } of fieldsSelection) {
        selection.push({
          dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = getTableUniqueName(relation.referencedTable);
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i2) => eq(aliasedTableColumn(normalizedRelation.references[i2], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result = aliasedTable(table, tableAlias);
      }
      result = this.buildSelectQuery({
        table: is(result, PgTable) ? result : new Subquery(result, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    const src = source;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(src, Subquery)) {
      fields = Object.fromEntries(Object.keys(src._.selectedFields).map((key) => [key, src[key]]));
    } else if (is(src, PgViewBase)) {
      fields = src[ViewBaseConfig].selectedFields;
    } else if (is(src, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(src);
    }
    return new PgSelectBase({
      table: src,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    }).setToken(this.authToken);
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  cacheConfig = undefined;
  usedTables = /* @__PURE__ */ new Set;
  constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields,
      config: this.config
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
    for (const item of extractUsedTable(table))
      this.usedTables.add(item);
  }
  getUsedTables() {
    return [...this.usedTables];
  }
  createJoin(joinType, lateral) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      for (const item of extractUsedTable(table))
        this.usedTables.add(item);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table._.selectedFields : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName, lateral });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "cross":
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left", false);
  leftJoinLateral = this.createJoin("left", true);
  rightJoin = this.createJoin("right", false);
  innerJoin = this.createJoin("inner", false);
  innerJoinLateral = this.createJoin("inner", true);
  fullJoin = this.createJoin("full", false);
  crossJoin = this.createJoin("cross", false);
  crossJoinLateral = this.createJoin("cross", true);
  createSetOperator(type, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    const usedTables = [];
    usedTables.push(...extractUsedTable(this.config.table));
    if (this.config.joins) {
      for (const it of this.config.joins)
        usedTables.push(...extractUsedTable(it.table));
    }
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias, false, [...new Set(usedTables)]), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
  $withCache(config) {
    this.cacheConfig = config === undefined ? { config: {}, enable: true, autoInvalidate: true } : config === false ? { enable: false } : { enable: true, autoInvalidate: true, ...config };
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap, authToken, cacheConfig, usedTables } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const { fields } = config;
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(fields);
      const query = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name, true, undefined, {
        type: "select",
        tables: [...usedTables]
      }, cacheConfig);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query.setToken(authToken);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
function createSetOperator(type, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
}
var getPgSetOperators = () => ({
  union,
  unionAll,
  intersect,
  intersectAll,
  except,
  exceptAll
});
var union = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  dialectConfig;
  constructor(dialect) {
    this.dialect = is(dialect, PgDialect) ? dialect : undefined;
    this.dialectConfig = is(dialect, PgDialect) ? undefined : dialect;
  }
  $with = (alias, selection) => {
    const queryBuilder = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(queryBuilder);
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  with(...queries) {
    const self = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self.getDialect(),
        distinct: { on }
      });
    }
    return { select: select2, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect(this.dialectConfig);
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/utils.js
function extractUsedTable(table) {
  if (is(table, PgTable)) {
    return [table[Schema] ? `${table[Schema]}.${table[Table.Symbol.BaseName]}` : table[Table.Symbol.BaseName]];
  }
  if (is(table, Subquery)) {
    return table._.usedTables ?? [];
  }
  if (is(table, SQL)) {
    return table.usedTables ?? [];
  }
  return [];
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  cacheConfig;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "delete",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table, session, dialect, withList, overridingSystemValue_) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
    this.overridingSystemValue_ = overridingSystemValue_;
  }
  static [entityKind] = "PgInsertBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  overridingSystemValue() {
    this.overridingSystemValue_ = true;
    return this;
  }
  values(values2) {
    values2 = Array.isArray(values2) ? values2 : [values2];
    if (values2.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values2.map((entry) => {
      const result = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList, false, this.overridingSystemValue_).setToken(this.authToken);
  }
  select(selectQuery) {
    const select2 = typeof selectQuery === "function" ? selectQuery(new QueryBuilder) : selectQuery;
    if (!is(select2, SQL) && !haveSameKeys(this.table[Columns], select2._.selectedFields)) {
      throw new Error("Insert select error: selected fields are not the same or are in a different order compared to the table definition");
    }
    return new PgInsertBase(this.table, select2, this.session, this.dialect, this.withList, true);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table, values2, session, dialect, withList, select2, overridingSystemValue_) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table, values: values2, withList, select: select2, overridingSystemValue_ };
  }
  static [entityKind] = "PgInsert";
  config;
  cacheConfig;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)})${whereSql} do nothing`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    if (config.where && (config.targetWhere || config.setWhere)) {
      throw new Error('You cannot use both "where" and "targetWhere"/"setWhere" at the same time - "where" is deprecated, use "targetWhere" or "setWhere" instead.');
    }
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const targetWhereSql = config.targetWhere ? sql` where ${config.targetWhere}` : undefined;
    const setWhereSql = config.setWhere ? sql` where ${config.setWhere}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(this.dialect.casing.getColumnCasing(it))).join(",") : this.dialect.escapeName(this.dialect.casing.getColumnCasing(config.target));
    this.config.onConflict = sql`(${sql.raw(targetColumn)})${targetWhereSql} do update set ${setSql}${whereSql}${setWhereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
        type: "insert",
        tables: extractUsedTable(this.config.table)
      }, this.cacheConfig);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name, true);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues, this.authToken);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table, session, dialect, withList) {
    this.table = table;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  set(values2) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values2), this.session, this.dialect, this.withList).setToken(this.authToken);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table, set, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { set, table, withList, joins: [] };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  static [entityKind] = "PgUpdate";
  config;
  tableName;
  joinsNotNullableMap;
  cacheConfig;
  from(source) {
    const src = source;
    const tableName = getTableLikeName(src);
    if (typeof tableName === "string") {
      this.joinsNotNullableMap[tableName] = true;
    }
    this.config.from = src;
    return this;
  }
  getTableLikeFields(table) {
    if (is(table, PgTable)) {
      return table[Table.Symbol.Columns];
    } else if (is(table, Subquery)) {
      return table._.selectedFields;
    }
    return table[ViewBaseConfig].selectedFields;
  }
  createJoin(joinType) {
    return (table, on) => {
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (typeof on === "function") {
        const from = this.config.from && !is(this.config.from, SQL) ? this.getTableLikeFields(this.config.from) : undefined;
        on = on(new Proxy(this.config.table[Table.Symbol.Columns], new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })), from && new Proxy(from, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields) {
    if (!fields) {
      fields = Object.assign({}, this.config.table[Table.Symbol.Columns]);
      if (this.config.from) {
        const tableName = getTableLikeName(this.config.from);
        if (typeof tableName === "string" && this.config.from && !is(this.config.from, SQL)) {
          const fromFields = this.getTableLikeFields(this.config.from);
          fields[tableName] = fromFields;
        }
        for (const join of this.config.joins) {
          const tableName2 = getTableLikeName(join.table);
          if (typeof tableName2 === "string" && !is(join.table, SQL)) {
            const fromFields = this.getTableLikeFields(join.table);
            fields[tableName2] = fromFields;
          }
        }
      }
    }
    this.config.returningFields = fields;
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  _prepare(name) {
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name, true, undefined, {
      type: "insert",
      tables: extractUsedTable(this.config.table)
    }, this.cacheConfig);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  prepare(name) {
    return this._prepare(name);
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues, this.authToken);
  };
  getSelectedFields() {
    return this.config.returningFields ? new Proxy(this.config.returningFields, new SelectionProxyHandler({
      alias: getTableName(this.config.table),
      sqlAliasedBehavior: "alias",
      sqlBehavior: "error"
    })) : undefined;
  }
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/count.js
class PgCountBuilder extends SQL {
  constructor(params) {
    super(PgCountBuilder.buildEmbeddedCount(params.source, params.filters).queryChunks);
    this.params = params;
    this.mapWith(Number);
    this.session = params.session;
    this.sql = PgCountBuilder.buildCount(params.source, params.filters);
  }
  sql;
  token;
  static [entityKind] = "PgCountBuilder";
  [Symbol.toStringTag] = "PgCountBuilder";
  session;
  static buildEmbeddedCount(source, filters) {
    return sql`(select count(*) from ${source}${sql.raw(" where ").if(filters)}${filters})`;
  }
  static buildCount(source, filters) {
    return sql`select count(*) as count from ${source}${sql.raw(" where ").if(filters)}${filters};`;
  }
  setToken(token) {
    this.token = token;
    return this;
  }
  then(onfulfilled, onrejected) {
    return Promise.resolve(this.session.count(this.sql, this.token)).then(onfulfilled, onrejected);
  }
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value) => {
      onFinally?.();
      return value;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session) {
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, true, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  authToken;
  setToken(token) {
    this.authToken = token;
    return this;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(undefined, this.authToken);
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql2, query, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql2;
    this.query = query;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result) : result;
  }
  _prepare() {
    return this;
  }
  isResponseInArrayMode() {
    return false;
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? {
      schema: schema.schema,
      fullSchema: schema.fullSchema,
      tableNamesMap: schema.tableNamesMap,
      session
    } : {
      schema: undefined,
      fullSchema: {},
      tableNamesMap: {},
      session
    };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session);
      }
    }
    this.$cache = { invalidate: async (_params) => {} };
  }
  static [entityKind] = "PgDatabase";
  query;
  $with = (alias, selection) => {
    const self = this;
    const as = (qb) => {
      if (typeof qb === "function") {
        qb = qb(new QueryBuilder(self.dialect));
      }
      return new Proxy(new WithSubquery(qb.getSQL(), selection ?? ("getSelectedFields" in qb ? qb.getSelectedFields() ?? {} : {}), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
    };
    return { as };
  };
  $count(source, filters) {
    return new PgCountBuilder({ source, filters, session: this.session });
  }
  $cache;
  with(...queries) {
    const self = this;
    function select2(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table) {
      return new PgUpdateBuilder(table, self.session, self.dialect, queries);
    }
    function insert(table) {
      return new PgInsertBuilder(table, self.session, self.dialect, queries);
    }
    function delete_(table) {
      return new PgDeleteBase(table, self.session, self.dialect, queries);
    }
    return { select: select2, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  authToken;
  execute(query) {
    const sequel = typeof query === "string" ? sql.raw(query) : query.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sequel);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined, false);
    return new PgRaw(() => prepared.execute(undefined, this.authToken), sequel, builtQuery, (result) => prepared.mapResult(result, true));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/cache/core/cache.js
class Cache {
  static [entityKind] = "Cache";
}

class NoopCache extends Cache {
  strategy() {
    return "all";
  }
  static [entityKind] = "NoopCache";
  async get(_key) {
    return;
  }
  async put(_hashedQuery, _response, _tables, _config2) {}
  async onMutate(_params) {}
}
async function hashQuery(sql2, params) {
  const dataToHash = `${sql2}-${JSON.stringify(params)}`;
  const encoder = new TextEncoder;
  const data = encoder.encode(dataToHash);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = [...new Uint8Array(hashBuffer)];
  const hashHex = hashArray.map((b2) => b2.toString(16).padStart(2, "0")).join("");
  return hashHex;
}

// node_modules/drizzle-orm/errors/index.js
class DrizzleQueryError extends Error {
  constructor(query, params, cause) {
    super(`Failed query: ${query}
params: ${params}`);
    this.query = query;
    this.params = params;
    this.cause = cause;
    Error.captureStackTrace(this, DrizzleQueryError);
    if (cause)
      this.cause = cause;
  }
}

// node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query, cache2, queryMetadata, cacheConfig) {
    this.query = query;
    this.cache = cache2;
    this.queryMetadata = queryMetadata;
    this.cacheConfig = cacheConfig;
    if (cache2 && cache2.strategy() === "all" && cacheConfig === undefined) {
      this.cacheConfig = { enable: true, autoInvalidate: true };
    }
    if (!this.cacheConfig?.enable) {
      this.cacheConfig = undefined;
    }
  }
  authToken;
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  setToken(token) {
    this.authToken = token;
    return this;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
  async queryWithCache(queryString, params, query) {
    if (this.cache === undefined || is(this.cache, NoopCache) || this.queryMetadata === undefined) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.cacheConfig && !this.cacheConfig.enable) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if ((this.queryMetadata.type === "insert" || this.queryMetadata.type === "update" || this.queryMetadata.type === "delete") && this.queryMetadata.tables.length > 0) {
      try {
        const [res] = await Promise.all([
          query(),
          this.cache.onMutate({ tables: this.queryMetadata.tables })
        ]);
        return res;
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (!this.cacheConfig) {
      try {
        return await query();
      } catch (e) {
        throw new DrizzleQueryError(queryString, params, e);
      }
    }
    if (this.queryMetadata.type === "select") {
      const fromCache = await this.cache.get(this.cacheConfig.tag ?? await hashQuery(queryString, params), this.queryMetadata.tables, this.cacheConfig.tag !== undefined, this.cacheConfig.autoInvalidate);
      if (fromCache === undefined) {
        let result;
        try {
          result = await query();
        } catch (e) {
          throw new DrizzleQueryError(queryString, params, e);
        }
        await this.cache.put(this.cacheConfig.tag ?? await hashQuery(queryString, params), result, this.cacheConfig.autoInvalidate ? this.queryMetadata.tables : [], this.cacheConfig.tag !== undefined, this.cacheConfig.config);
        return result;
      }
      return fromCache;
    }
    try {
      return await query();
    } catch (e) {
      throw new DrizzleQueryError(queryString, params, e);
    }
  }
}

class PgSession {
  constructor(dialect) {
    this.dialect = dialect;
  }
  static [entityKind] = "PgSession";
  execute(query, token) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false);
      });
      return prepared.setToken(token).execute(undefined, token);
    });
  }
  all(query) {
    return this.prepareQuery(this.dialect.sqlToQuery(query), undefined, undefined, false).all();
  }
  async count(sql2, token) {
    const res = await this.execute(sql2, token);
    return Number(res[0]["count"]);
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect, session, schema, nestedIndex = 0) {
    super(dialect, session, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// node_modules/drizzle-orm/node-postgres/session.js
var { Pool: Pool2, types: types5 } = esm_default;

class NodePgPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger2, cache2, queryMetadata, cacheConfig, fields, name, _isResponseInArrayMode, customResultMapper) {
    super({ sql: queryString, params }, cache2, queryMetadata, cacheConfig);
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this._isResponseInArrayMode = _isResponseInArrayMode;
    this.customResultMapper = customResultMapper;
    this.rawQueryConfig = {
      name,
      text: queryString,
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types5.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types5.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types5.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types5.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types5.getTypeParser(typeId, format);
        }
      }
    };
    this.queryConfig = {
      name,
      text: queryString,
      rowMode: "array",
      types: {
        getTypeParser: (typeId, format) => {
          if (typeId === types5.builtins.TIMESTAMPTZ) {
            return (val) => val;
          }
          if (typeId === types5.builtins.TIMESTAMP) {
            return (val) => val;
          }
          if (typeId === types5.builtins.DATE) {
            return (val) => val;
          }
          if (typeId === types5.builtins.INTERVAL) {
            return (val) => val;
          }
          if (typeId === 1231) {
            return (val) => val;
          }
          if (typeId === 1115) {
            return (val) => val;
          }
          if (typeId === 1185) {
            return (val) => val;
          }
          if (typeId === 1187) {
            return (val) => val;
          }
          if (typeId === 1182) {
            return (val) => val;
          }
          return types5.getTypeParser(typeId, format);
        }
      }
    };
  }
  static [entityKind] = "NodePgPreparedQuery";
  rawQueryConfig;
  queryConfig;
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      const { fields, rawQueryConfig: rawQuery, client, queryConfig: query, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", async (span) => {
          span?.setAttributes({
            "drizzle.query.name": rawQuery.name,
            "drizzle.query.text": rawQuery.text,
            "drizzle.query.params": JSON.stringify(params)
          });
          return this.queryWithCache(rawQuery.text, params, async () => {
            return await client.query(rawQuery, params);
          });
        });
      }
      const result = await tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": query.name,
          "drizzle.query.text": query.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(query.text, params, async () => {
          return await client.query(query, params);
        });
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(result.rows) : result.rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", () => {
      const params = fillPlaceholders(this.params, placeholderValues);
      this.logger.logQuery(this.rawQueryConfig.text, params);
      return tracer.startActiveSpan("drizzle.driver.execute", (span) => {
        span?.setAttributes({
          "drizzle.query.name": this.rawQueryConfig.name,
          "drizzle.query.text": this.rawQueryConfig.text,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.queryWithCache(this.rawQueryConfig.text, params, async () => {
          return this.client.query(this.rawQueryConfig, params);
        }).then((result) => result.rows);
      });
    });
  }
  isResponseInArrayMode() {
    return this._isResponseInArrayMode;
  }
}

class NodePgSession extends PgSession {
  constructor(client, dialect, schema, options = {}) {
    super(dialect);
    this.client = client;
    this.schema = schema;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger2;
    this.cache = options.cache ?? new NoopCache;
  }
  static [entityKind] = "NodePgSession";
  logger;
  cache;
  prepareQuery(query, fields, name, isResponseInArrayMode, customResultMapper, queryMetadata, cacheConfig) {
    return new NodePgPreparedQuery(this.client, query.sql, query.params, this.logger, this.cache, queryMetadata, cacheConfig, fields, name, isResponseInArrayMode, customResultMapper);
  }
  async transaction(transaction, config) {
    const session = this.client instanceof Pool2 ? new NodePgSession(await this.client.connect(), this.dialect, this.schema, this.options) : this;
    const tx = new NodePgTransaction(this.dialect, session, this.schema);
    await tx.execute(sql`begin${config ? sql` ${tx.getTransactionConfigSQL(config)}` : undefined}`);
    try {
      const result = await transaction(tx);
      await tx.execute(sql`commit`);
      return result;
    } catch (error2) {
      await tx.execute(sql`rollback`);
      throw error2;
    } finally {
      if (this.client instanceof Pool2) {
        session.client.release();
      }
    }
  }
  async count(sql2) {
    const res = await this.execute(sql2);
    return Number(res["rows"][0]["count"]);
  }
}

class NodePgTransaction extends PgTransaction {
  static [entityKind] = "NodePgTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex + 1}`;
    const tx = new NodePgTransaction(this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await tx.execute(sql.raw(`savepoint ${savepointName}`));
    try {
      const result = await transaction(tx);
      await tx.execute(sql.raw(`release savepoint ${savepointName}`));
      return result;
    } catch (err2) {
      await tx.execute(sql.raw(`rollback to savepoint ${savepointName}`));
      throw err2;
    }
  }
}

// node_modules/drizzle-orm/node-postgres/driver.js
class NodePgDriver {
  constructor(client, dialect, options = {}) {
    this.client = client;
    this.dialect = dialect;
    this.options = options;
  }
  static [entityKind] = "NodePgDriver";
  createSession(schema) {
    return new NodePgSession(this.client, this.dialect, schema, {
      logger: this.options.logger,
      cache: this.options.cache
    });
  }
}

class NodePgDatabase extends PgDatabase {
  static [entityKind] = "NodePgDatabase";
}
function construct(client, config = {}) {
  const dialect = new PgDialect({ casing: config.casing });
  let logger2;
  if (config.logger === true) {
    logger2 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger2 = config.logger;
  }
  let schema;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const driver = new NodePgDriver(client, dialect, { logger: logger2, cache: config.cache });
  const session = driver.createSession(schema);
  const db = new NodePgDatabase(dialect, session, schema);
  db.$client = client;
  db.$cache = config.cache;
  if (db.$cache) {
    db.$cache["invalidate"] = config.cache?.onMutate;
  }
  return db;
}
function drizzle(...params) {
  if (typeof params[0] === "string") {
    const instance = new esm_default.Pool({
      connectionString: params[0]
    });
    return construct(instance, params[1]);
  }
  if (isConfig(params[0])) {
    const { connection: connection2, client, ...drizzleConfig } = params[0];
    if (client)
      return construct(client, drizzleConfig);
    const instance = typeof connection2 === "string" ? new esm_default.Pool({
      connectionString: connection2
    }) : new esm_default.Pool(connection2);
    return construct(instance, drizzleConfig);
  }
  return construct(params[0], params[1]);
}
((drizzle2) => {
  function mock(config) {
    return construct({}, config);
  }
  drizzle2.mock = mock;
})(drizzle || (drizzle = {}));

// src/db/schemas.ts
var exports_schemas = {};
__export(exports_schemas, {
  todos: () => todos,
  recipes: () => recipes,
  recipeInstructions: () => recipeInstructions,
  recipeInstructionFoodItemUnits: () => recipeInstructionFoodItemUnits,
  recipeIngredients: () => recipeIngredients,
  meals: () => meals,
  mealRecipes: () => mealRecipes,
  habits: () => habits,
  habitTriggers: () => habitTriggers,
  habitTriggerExecutions: () => habitTriggerExecutions,
  habitSubEntities: () => habitSubEntities,
  foodItems: () => foodItems,
  foodItemUnits: () => foodItemUnits
});
var recipes = pgTable("recipes", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  nameOfTheRecipe: text("name_of_the_recipe").notNull(),
  generalDescriptionOfTheRecipe: text("general_description_of_the_recipe"),
  whenIsItConsumed: text("when_is_it_consumed").array(),
  version: integer("version").notNull().default(1)
});
var recipeInstructions = pgTable("recipe_instructions", {
  id: uuid("id").primaryKey(),
  recipeId: uuid("recipe_id").references(() => recipes.id, {
    onDelete: "cascade"
  }),
  instruction: text("instruction").notNull(),
  instructionNumber: integer("instruction_number").notNull()
});
var recipeInstructionFoodItemUnits = pgTable("recipe_instructions_food_item_units", {
  id: uuid("id").primaryKey(),
  recipeInstructionId: uuid("recipe_instruction_id").references(() => recipeInstructions.id),
  foodItemUnitId: uuid("food_item_unit_id").notNull(),
  quantity: doublePrecision("quantity").notNull()
});
var recipeIngredients = pgTable("recipe_ingredients", {
  id: uuid("id").primaryKey(),
  recipeId: uuid("recipe_id").references(() => recipes.id, { onDelete: "cascade" }).notNull(),
  ingredientText: text("ingredient_text").notNull()
});
var meals = pgTable("meals", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  mealName: text("meal_name").notNull()
});
var mealRecipes = pgTable("meal_recipes", {
  id: uuid("id").primaryKey(),
  mealId: uuid("meal_id").notNull().references(() => meals.id, { onDelete: "cascade" }),
  recipeId: uuid("recipe_id").notNull(),
  orderInMeal: integer("order_in_meal").notNull().default(0)
});
var todos = pgTable("todos", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  title: text("title").notNull(),
  description: text("description"),
  completed: boolean("completed").notNull().default(false),
  scheduledFor: timestamp("scheduled_for"),
  dueDate: text("due_date"),
  preferredTime: text("preferred_time"),
  completedAt: timestamp("completed_at"),
  habitId: uuid("habit_id").references(() => habits.id),
  instanceId: uuid("instance_id"),
  domain: text("domain"),
  entityId: uuid("entity_id"),
  subEntityId: uuid("sub_entity_id"),
  relations: text("relations"),
  eventId: text("event_id")
});
var foodItems = pgTable("food_items", {
  id: uuid("id").primaryKey(),
  name: text("name").notNull(),
  categoryHierarchy: text("category_hierarchy").notNull().array(),
  userId: text("user_id").notNull()
});
var foodItemUnits = pgTable("food_item_units", {
  id: uuid("id").primaryKey(),
  foodItemId: uuid("food_item_id").references(() => foodItems.id).notNull(),
  unitOfMeasurement: text("unit_of_measurement").notNull(),
  unitDescription: text("unit_description"),
  calories: integer("calories").notNull(),
  proteinInGrams: integer("protein_in_grams"),
  carbohydratesInGrams: integer("carbohydrates_in_grams"),
  fatInGrams: integer("fat_in_grams"),
  fiberInGrams: integer("fiber_in_grams"),
  sugarInGrams: integer("sugar_in_grams"),
  sodiumInMilligrams: integer("sodium_in_milligrams"),
  source: text("source").notNull()
});
var habits = pgTable("habits", {
  id: uuid("id").primaryKey(),
  userId: text("user_id").notNull(),
  domain: text("domain").notNull(),
  entityId: uuid("entity_id").notNull(),
  recurrenceType: text("recurrence_type").notNull(),
  targetWeekday: text("target_weekday").notNull(),
  targetTime: text("target_time"),
  startDate: text("start_date").notNull(),
  isActive: boolean("is_active").notNull().default(true),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
var habitTriggers = pgTable("habit_triggers", {
  id: uuid("id").primaryKey(),
  habitId: uuid("habit_id").references(() => habits.id, { onDelete: "cascade" }).notNull(),
  triggerSubEntityId: uuid("trigger_sub_entity_id"),
  triggerWeekday: text("trigger_weekday").notNull()
});
var habitSubEntities = pgTable("habit_subentities", {
  id: uuid("id").primaryKey(),
  habitId: uuid("habit_id").references(() => habits.id, { onDelete: "cascade" }).notNull(),
  entityId: uuid("entity_id"),
  subEntityId: uuid("sub_entity_id"),
  scheduledWeekday: text("scheduled_weekday").notNull(),
  scheduledTime: text("scheduled_time")
});
var habitTriggerExecutions = pgTable("habit_trigger_executions", {
  userId: text("user_id").primaryKey(),
  triggerDate: text("trigger_date").notNull()
});

// src/db/index.ts
var pool;
var drizzleDb;
function initDb() {
  if (drizzleDb)
    return drizzleDb;
  const env = getEnv();
  pool ??= new Pool({
    connectionString: env.POSTGRES_CONNECTION_STRING
  });
  drizzleDb = drizzle(pool, { schema: exports_schemas });
  return drizzleDb;
}
var db = new Proxy({}, {
  get(_target, prop) {
    const instance = initDb();
    const value = instance[prop];
    return typeof value === "function" ? value.bind(instance) : value;
  }
});

// src/handlers/food-item/food-item.handler.ts
async function handleFoodItemCreated(event2) {
  const { payload } = event2;
  await db.insert(foodItems).values({
    id: payload.id,
    name: payload.name,
    categoryHierarchy: payload.categoryHierarchy,
    userId: payload.userId
  });
}
async function handleFoodItemDeleted(event2) {
  const { payload } = event2;
  await db.delete(foodItems).where(eq(foodItems.id, payload.foodItemId));
}

// src/handlers/food-item/food-item-units.handler.ts
async function handleFoodItemUnitsCreated(event2) {
  const { payload } = event2;
  await db.insert(foodItemUnits).values(payload.units.map((unit) => ({
    id: unit.id,
    foodItemId: payload.foodItemId,
    unitOfMeasurement: unit.unitOfMeasurement,
    unitDescription: unit.unitDescription,
    calories: unit.nutritionPerOfThisUnit.calories,
    proteinInGrams: unit.nutritionPerOfThisUnit.proteinInGrams,
    carbohydratesInGrams: unit.nutritionPerOfThisUnit.carbohydratesInGrams,
    fatInGrams: unit.nutritionPerOfThisUnit.fatInGrams,
    fiberInGrams: unit.nutritionPerOfThisUnit.fiberInGrams,
    sugarInGrams: unit.nutritionPerOfThisUnit.sugarInGrams,
    sodiumInMilligrams: unit.nutritionPerOfThisUnit.sodiumInMilligrams,
    source: unit.source
  })));
}
async function handleFoodItemUnitsDeleted(event2) {
  const { payload } = event2;
  const unitIds = payload.units.map((unit) => unit.id);
  await db.delete(foodItemUnits).where(and(inArray(foodItemUnits.id, unitIds), eq(foodItemUnits.foodItemId, payload.foodItemId)));
}

// src/handlers/habit/habit.handler.ts
var import_node_crypto2 = require("node:crypto");
async function handleHabitsCreated(event2) {
  const { payload } = event2;
  const habitId = import_node_crypto2.randomUUID();
  const habitRecord = {
    id: habitId,
    userId: payload.userId,
    domain: payload.domain,
    entityId: payload.entityId,
    recurrenceType: payload.recurrenceType,
    targetWeekday: payload.targetWeekday,
    targetTime: payload.targetTime || null,
    startDate: payload.startDate,
    isActive: true
  };
  const triggerSubEntity = findTriggerSubEntityForWeekRecurrenceType(payload.targetWeekday, payload.subEntities);
  const triggerRecord = {
    id: import_node_crypto2.randomUUID(),
    habitId,
    triggerSubEntityId: triggerSubEntity.subEntityId || null,
    triggerWeekday: triggerSubEntity.scheduledWeekday ?? payload.targetWeekday
  };
  const subEntityRecords = payload.subEntities.map((subEntity) => ({
    id: import_node_crypto2.randomUUID(),
    habitId,
    subEntityId: subEntity.subEntityId || null,
    scheduledWeekday: subEntity.scheduledWeekday ?? payload.targetWeekday,
    scheduledTime: subEntity.scheduledTime || null
  }));
  await db.transaction(async (tx) => {
    await tx.insert(habits).values(habitRecord);
    await tx.insert(habitTriggers).values(triggerRecord);
    await tx.insert(habitSubEntities).values(subEntityRecords);
  });
}
function findTriggerSubEntityForWeekRecurrenceType(targetWeekday, subEntities) {
  const weekdays = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  const targetDay = weekdays.indexOf(targetWeekday);
  let maxOffset = -1;
  let triggerSubEntity = subEntities[0];
  for (const subEntity of subEntities) {
    if (!subEntity.scheduledWeekday)
      continue;
    const subEntityDay = weekdays.indexOf(subEntity.scheduledWeekday);
    let offset = targetDay - subEntityDay;
    if (offset < 0)
      offset += 7;
    if (offset > maxOffset) {
      maxOffset = offset;
      triggerSubEntity = subEntity;
    }
  }
  return triggerSubEntity;
}

// src/handlers/meal/meal.handler.ts
async function handleMealCreated(event2) {
  const { payload } = event2;
  await db.insert(meals).values({
    id: payload.id,
    userId: payload.userId,
    mealName: payload.mealName
  });
}

// src/handlers/meal/meal-recipes.handler.ts
async function handleMealRecipeAttached(event2) {
  const { payload } = event2;
  const values2 = payload.recipes.map((recipe4) => ({
    id: crypto.randomUUID(),
    mealId: payload.mealId,
    recipeId: recipe4.recipeId,
    orderInMeal: recipe4.orderInMeal
  }));
  await db.insert(mealRecipes).values(values2);
}

// src/handlers/recipe/recipe.handler.ts
async function handleRecipeCreated(event2) {
  const { payload } = event2;
  await db.insert(recipes).values({
    id: payload.id,
    userId: payload.userId,
    nameOfTheRecipe: payload.nameOfTheRecipe,
    generalDescriptionOfTheRecipe: payload.generalDescriptionOfTheRecipe,
    whenIsItConsumed: payload.whenIsItConsumed
  });
}
async function handleRecipeDeleted(event2) {
  const { payload } = event2;
  await db.delete(recipes).where(eq(recipes.id, payload.recipeId));
}

// src/handlers/recipe/recipe-ingredients.handler.ts
async function handleRecipeIngredientsCreated(event2) {
  const { payload } = event2;
  for (const ingredient of payload.ingredients) {
    await db.insert(recipeIngredients).values({
      id: ingredient.id,
      recipeId: payload.recipeId,
      ingredientText: ingredient.ingredientText
    });
  }
}

// src/handlers/recipe/recipe-instructions.handler.ts
async function handleRecipeInstructionsCreated(event2) {
  const { payload } = event2;
  for (const step of payload.stepByStepInstructions) {
    await db.insert(recipeInstructions).values({
      id: step.id,
      recipeId: payload.recipeId,
      instruction: step.stepInstruction,
      instructionNumber: step.instructionNumber
    });
    if (step.foodItemUnitsUsedInStep) {
      for (const foodItemUnit of step.foodItemUnitsUsedInStep) {
        await db.insert(recipeInstructionFoodItemUnits).values({
          id: crypto.randomUUID(),
          recipeInstructionId: step.id,
          foodItemUnitId: foodItemUnit.foodItemUnitId,
          quantity: foodItemUnit.quantityOfFoodItemUnit
        });
      }
    }
  }
}

// src/handlers/todo/todo.completed.ts
async function handleTodoCompleted(event2) {
  const { payload } = event2;
  await db.delete(todos).where(eq(todos.id, payload.id));
}

// src/handlers/todo/todo.generated.ts
async function handleTodoGenerated(event2) {
  const { payload } = event2;
  await db.insert(todos).values({
    id: payload.id,
    userId: payload.userId,
    title: payload.description,
    description: payload.description,
    completed: payload.completed,
    scheduledFor: payload.scheduledFor ? (() => {
      const date2 = new Date(payload.scheduledFor);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid scheduledFor date: ${payload.scheduledFor}`);
      }
      return date2;
    })() : null,
    completedAt: payload.completedAt ? (() => {
      const date2 = new Date(payload.completedAt);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid completedAt date: ${payload.completedAt}`);
      }
      return date2;
    })() : null,
    relations: payload.relations ? JSON.stringify(payload.relations) : null
  });
}

// src/handlers/todo/todo.handler.ts
async function handleTodoCreated(event2) {
  const { payload } = event2;
  await db.insert(todos).values({
    id: payload.id,
    userId: payload.userId,
    title: payload.description,
    description: payload.description,
    completed: payload.completed,
    scheduledFor: payload.scheduledFor ? (() => {
      const date2 = new Date(payload.scheduledFor);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid scheduledFor date: ${payload.scheduledFor}`);
      }
      return date2;
    })() : null,
    completedAt: payload.completedAt ? (() => {
      const date2 = new Date(payload.completedAt);
      if (Number.isNaN(date2.getTime())) {
        throw new Error(`Invalid completedAt date: ${payload.completedAt}`);
      }
      return date2;
    })() : null,
    relations: payload.relations ? JSON.stringify(payload.relations) : null
  });
}

// src/utils/flowcore.ts
var cached;
function initFlowcore() {
  if (cached)
    return cached;
  const env = getEnv();
  const webhookApiKey = env.FLOWCORE_WEBHOOK_API_KEY;
  const postgresUrl = env.POSTGRES_CONNECTION_STRING;
  const pathways2 = new PathwaysBuilder({
    baseUrl: env.FLOWCORE_WEBHOOK_BASE_URL,
    tenant: env.FLOWCORE_TENANT,
    dataCore: env.FLOWCORE_DATA_CORE_NAME,
    apiKey: webhookApiKey
  }).withPathwayState(createPostgresPathwayState({
    connectionString: postgresUrl
  })).register({
    flowType: "food-item.v0",
    eventType: "food-item.created.v0",
    retryDelayMs: 1e4,
    schema: foodItemSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.deleted.v0",
    retryDelayMs: 1e4,
    schema: foodItemDeletedSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.units.created.v0",
    retryDelayMs: 1e4,
    schema: foodItemUnitSchema
  }).register({
    flowType: "food-item.v0",
    eventType: "food-item.units.deleted.v0",
    retryDelayMs: 1e4,
    schema: foodItemUnitDeletedSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe.created.v0",
    retryDelayMs: 1e4,
    schema: recipeSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe.deleted.v0",
    retryDelayMs: 1e4,
    schema: recipeDeletedSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe-instructions.created.v0",
    retryDelayMs: 1e4,
    schema: recipeInstructionsSchema
  }).register({
    flowType: "recipe.v0",
    eventType: "recipe-ingredients.created.v0",
    retryDelayMs: 1e4,
    schema: recipeIngredientsSchema
  }).register({
    flowType: "meal.v0",
    eventType: "meal.created.v0",
    retryDelayMs: 1e4,
    schema: mealSchema
  }).register({
    flowType: "meal.v0",
    eventType: "meal-recipe.attached.v0",
    retryDelayMs: 1e4,
    schema: mealRecipeAttachSchema
  }).register({
    flowType: "habit.v0",
    eventType: "complex-habit.created.v0",
    retryDelayMs: 1e4,
    schema: habitsCreatedSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.created.v0",
    retryDelayMs: 1e4,
    schema: todoSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.completed.v0",
    retryDelayMs: 1e4,
    schema: todoCompletedSchema
  }).register({
    flowType: "todo.v0",
    eventType: "todo.generated.v0",
    retryDelayMs: 1e4,
    schema: todoGeneratedSchema
  }).handle("food-item.v0/food-item.created.v0", handleFoodItemCreated).handle("food-item.v0/food-item.deleted.v0", handleFoodItemDeleted).handle("food-item.v0/food-item.units.created.v0", handleFoodItemUnitsCreated).handle("food-item.v0/food-item.units.deleted.v0", handleFoodItemUnitsDeleted).handle("recipe.v0/recipe.created.v0", handleRecipeCreated).handle("recipe.v0/recipe.deleted.v0", handleRecipeDeleted).handle("recipe.v0/recipe-instructions.created.v0", handleRecipeInstructionsCreated).handle("recipe.v0/recipe-ingredients.created.v0", handleRecipeIngredientsCreated).handle("meal.v0/meal.created.v0", handleMealCreated).handle("meal.v0/meal-recipe.attached.v0", handleMealRecipeAttached).handle("todo.v0/todo.created.v0", handleTodoCreated).handle("todo.v0/todo.generated.v0", handleTodoGenerated).handle("habit.v0/complex-habit.created.v0", handleHabitsCreated).handle("todo.v0/todo.completed.v0", handleTodoCompleted);
  const router2 = new PathwayRouter(pathways2, webhookApiKey);
  cached = { webhookApiKey, pathways: pathways2, router: router2 };
  return cached;
}
function getFlowcorePathways() {
  return initFlowcore().pathways;
}
function getPathwaysRouter() {
  return initFlowcore().router;
}
var FlowcorePathways = new Proxy({}, {
  get(_target, prop) {
    const instance = getFlowcorePathways();
    const value = instance[prop];
    return typeof value === "function" ? value.bind(instance) : value;
  }
});

// src/routes/api/transformer/index.ts
var transformer = new Hono2;
transformer.post("/", async (c) => {
  try {
    const event2 = await c.req.json();
    const secret = c.req.header("X-Secret");
    console.log("Received event", {
      flowType: event2.flowType,
      eventType: event2.eventType,
      eventId: event2.eventId,
      payload: event2.payload
    });
    if (secret !== zodEnv.FLOWCORE_WEBHOOK_API_KEY) {
      return c.json(ApiResponse.error("Secret key is incorrect or missing"), StatusCodes.UNAUTHORIZED);
    }
    await getPathwaysRouter().processEvent(event2, secret);
    return c.json({
      message: "Event processed "
    }, 200);
  } catch (error2) {
    console.error("Error processing event", { error: error2 });
    return c.json({
      error: "Failed to process event",
      message: error2.message
    }, 500);
  }
});
var transformer_default = transformer;

// src/routes/api/index.ts
var api = new Hono2;
api.get("/", (c) => {
  return c.text("Daily Scheduler API");
});
api.route("/transformer/", transformer_default);
api.route("/food-item", food_item_default);
api.route("/habit", habit_default);
api.route("/meal", meal_default);
api.route("/recipe", recipe_default);
api.route("/todo", todo_default);
var api_default = api;

// src/routes/api/food-item/food-item.create.ts
var createFoodItemRequestSchema = exports_external.object({
  foodItemName: exports_external.string().min(1, "Food item name min length is 1").max(100, "Food item name max length is 100"),
  categoryHierarchy: exports_external.array(exports_external.string()).optional()
});
var successResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemSchema
});
var errorResponseSchema = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createFoodItemResponses = {
  200: {
    description: "Food item created successfully",
    content: {
      "application/json": {
        schema: successResponseSchema
      }
    }
  },
  400: {
    description: "Bad Request",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  401: {
    description: "Unauthorized",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  409: {
    description: "Conflict - Food item with name already exists",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  },
  500: {
    description: "Internal Server Error",
    content: {
      "application/json": {
        schema: errorResponseSchema
      }
    }
  }
};
var createFoodItemRoute = createRoute({
  method: "post",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createFoodItemRequestSchema
        }
      }
    }
  },
  responses: createFoodItemResponses
});
function registerCreateFoodItem(app) {
  app.openapi(createFoodItemRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateFoodItemJsonBody = c.req.valid("json");
    const existingFoodItem = await db.select().from(foodItems).where(and(eq(foodItems.name, safeCreateFoodItemJsonBody.foodItemName), eq(foodItems.userId, safeUserId)));
    if (existingFoodItem.length > 0) {
      return c.json({
        success: false,
        message: "Food item with name already exists"
      }, 409);
    }
    const newFoodItem = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      name: safeCreateFoodItemJsonBody.foodItemName,
      categoryHierarchy: safeCreateFoodItemJsonBody.categoryHierarchy
    };
    const createFoodItemEvent = foodItemSchema.safeParse(newFoodItem);
    if (!createFoodItemEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item data",
        errors: createFoodItemEvent.error.errors
      }, 400);
    }
    const safeCreateFoodItemEvent = createFoodItemEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.created.v0", {
        data: safeCreateFoodItemEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create food item",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item created successfully",
      data: safeCreateFoodItemEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item.delete.ts
var deleteFoodItemRequestSchema = exports_external.object({
  foodItemId: exports_external.string().uuid()
});
var successResponseSchema2 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemDeletedSchema
});
var errorResponseSchema2 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var deleteFoodItemRoute = createRoute({
  method: "delete",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: deleteFoodItemRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item deleted successfully",
      content: {
        "application/json": {
          schema: successResponseSchema2
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    404: {
      description: "Not Found - Food item does not exist",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema2
        }
      }
    }
  }
});
function registerDeleteFoodItem(app) {
  app.openapi(deleteFoodItemRoute, async (c) => {
    const safeUserId = c.userId;
    const safeDeleteFoodItemRequestBody = c.req.valid("json");
    const foodItemFromDb = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.id, safeDeleteFoodItemRequestBody.foodItemId), eq(foodItems.userId, safeUserId))
    });
    if (!foodItemFromDb) {
      return c.json({
        success: false,
        message: "Food item not found"
      }, 404);
    }
    const foodItemDeleted = {
      foodItemId: foodItemFromDb.id
    };
    const foodItemDeletedEvent = foodItemDeletedSchema.safeParse(foodItemDeleted);
    if (!foodItemDeletedEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item deleted data",
        errors: foodItemDeletedEvent.error.errors
      }, 400);
    }
    const safeFoodItemDeletedEvent = foodItemDeletedEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.deleted.v0", {
        data: safeFoodItemDeletedEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to delete food item",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item deleted successfully",
      data: safeFoodItemDeletedEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item.list.ts
var foodItemWithUnitsSchema = exports_external.object({
  id: exports_external.string().uuid(),
  name: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable(),
  unitCount: exports_external.number(),
  hasUnits: exports_external.boolean()
});
var foodItemBasicSchema = exports_external.object({
  id: exports_external.string().uuid(),
  name: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable()
});
var listFoodItemsResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(foodItemWithUnitsSchema)
});
var searchFoodItemsResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(foodItemBasicSchema)
});
var listFoodItemsRoute = createRoute({
  method: "get",
  path: "/api/food-item",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Food items retrieved successfully",
      content: {
        "application/json": {
          schema: listFoodItemsResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var searchFoodItemsRoute = createRoute({
  method: "get",
  path: "/api/food-item/search",
  tags: ["Food Items"],
  security: [{ Bearer: [] }],
  request: {
    query: exports_external.object({
      q: exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Food items search results",
      content: {
        "application/json": {
          schema: searchFoodItemsResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListFoodItems(app) {
  app.openapi(listFoodItemsRoute, async (c) => {
    const safeUserId = c.userId;
    const userFoodItems = await db.select().from(foodItems).where(eq(foodItems.userId, safeUserId)).orderBy(foodItems.name);
    const foodItemsWithUnitCounts = await Promise.all(userFoodItems.map(async (item) => {
      const units = await db.select().from(foodItemUnits).where(eq(foodItemUnits.foodItemId, item.id));
      return {
        id: item.id,
        name: item.name,
        categoryHierarchy: item.categoryHierarchy,
        unitCount: units.length,
        hasUnits: units.length > 0
      };
    }));
    return c.json({
      success: true,
      message: "Food items retrieved successfully",
      data: foodItemsWithUnitCounts
    }, 200);
  });
  app.openapi(searchFoodItemsRoute, async (c) => {
    const safeUserId = c.userId;
    const query = c.req.query("q") || "";
    const dbQuery = db.select().from(foodItems).where(eq(foodItems.userId, safeUserId));
    if (query) {
      const searchResults = await dbQuery;
      const filtered = searchResults.filter((item) => item.name.toLowerCase().includes(query.toLowerCase()));
      return c.json({
        success: true,
        message: "Food items search results",
        data: filtered
      }, 200);
    }
    const results = await dbQuery.orderBy(foodItems.name);
    return c.json({
      success: true,
      message: "Food items retrieved successfully",
      data: results
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.create.ts
var createFoodItemUnitRequestSchema = foodItemUnitSchema.omit({
  foodItemId: true
}).extend({
  foodItemName: exports_external.string().min(1, "Food item name min length is 1"),
  units: exports_external.array(foodItemUnitSchema.shape.units.element.omit({
    id: true,
    source: true
  }))
});
var successResponseSchema3 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: foodItemUnitSchema
});
var errorResponseSchema3 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createFoodItemUnitsRoute = createRoute({
  method: "post",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: createFoodItemUnitRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item units created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema3
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema3
        }
      }
    }
  }
});
function registerCreateFoodItemUnits(app) {
  app.openapi(createFoodItemUnitsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateFoodItemUnitJsonBody = c.req.valid("json");
    const relatedFoodItem = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.name, safeCreateFoodItemUnitJsonBody.foodItemName), eq(foodItems.userId, safeUserId))
    });
    if (!relatedFoodItem) {
      return c.json({
        success: false,
        message: "Food item does not exist"
      }, 400);
    }
    const newFoodItemUnits = {
      foodItemId: relatedFoodItem.id,
      units: safeCreateFoodItemUnitJsonBody.units.map((unit) => ({
        id: crypto.randomUUID(),
        ...unit,
        source: "user_measured"
      }))
    };
    const createdFoodItemUnitEvent = foodItemUnitSchema.safeParse(newFoodItemUnits);
    if (!createdFoodItemUnitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item unit data",
        errors: createdFoodItemUnitEvent.error.errors
      }, 400);
    }
    const safeCreateFoodItemUnitEvent = createdFoodItemUnitEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.units.created.v0", {
        data: safeCreateFoodItemUnitEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create food item units",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item units created successfully",
      data: safeCreateFoodItemUnitEvent
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.delete.ts
var deleteFoodItemUnitRequestSchema = exports_external.object({
  unitIds: exports_external.array(exports_external.string().uuid())
});
var deleteFoodItemUnitsRoute = createRoute({
  method: "delete",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: deleteFoodItemUnitRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Food item units deleted successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.string()
          })
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string(),
            errors: exports_external.any().optional()
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string(),
            errors: exports_external.any().optional()
          })
        }
      }
    }
  }
});
function registerDeleteFoodItemUnits(app) {
  app.openapi(deleteFoodItemUnitsRoute, async (c) => {
    const safeDeleteFoodItemUnitRequestBody = c.req.valid("json");
    const foodItemUnitsFromDb = await db.query.foodItemUnits.findMany({
      where: inArray(foodItemUnits.id, safeDeleteFoodItemUnitRequestBody.unitIds)
    });
    if (foodItemUnitsFromDb.length !== safeDeleteFoodItemUnitRequestBody.unitIds.length) {
      return c.json({
        success: false,
        message: "One or more food item units not found"
      }, 404);
    }
    const uniqueFoodItemIds = new Set(foodItemUnitsFromDb.map((unit) => unit.foodItemId));
    if (uniqueFoodItemIds.size !== 1) {
      return c.json({
        success: false,
        message: "All units must belong to the same food item"
      }, 400);
    }
    const foodItemId = foodItemUnitsFromDb[0].foodItemId;
    const foodItemArr = foodItemUnitsFromDb.map((unit) => ({
      id: unit.id,
      unitOfMeasurement: unit.unitOfMeasurement,
      unitDescription: unit.unitDescription ?? undefined,
      nutritionPerOfThisUnit: {
        calories: unit.calories,
        proteinInGrams: unit.proteinInGrams,
        carbohydratesInGrams: unit.carbohydratesInGrams,
        fatInGrams: unit.fatInGrams,
        fiberInGrams: unit.fiberInGrams,
        sugarInGrams: unit.sugarInGrams,
        sodiumInMilligrams: unit.sodiumInMilligrams
      },
      source: unit.source
    }));
    const newDeleteFoodItemUnitEvent = foodItemUnitDeletedSchema.safeParse({
      foodItemId,
      units: foodItemArr
    });
    if (!newDeleteFoodItemUnitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid food item unit data",
        errors: newDeleteFoodItemUnitEvent.error.errors
      }, 400);
    }
    const safeDeleteFoodItemUnitEvent = newDeleteFoodItemUnitEvent.data;
    try {
      await FlowcorePathways.write("food-item.v0/food-item.units.deleted.v0", {
        data: safeDeleteFoodItemUnitEvent
      });
    } catch (error2) {
      console.error(error2);
      return c.json({
        success: false,
        message: "Failed to delete food item units",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Food item units deleted",
      data: "Food item units deleted successfully"
    }, 200);
  });
}

// src/routes/api/food-item/food-item-units.list.ts
var foodItemUnitDetailSchema = exports_external.object({
  id: exports_external.string().uuid(),
  foodItemId: exports_external.string().uuid(),
  foodItemName: exports_external.string(),
  unitOfMeasurement: exports_external.string(),
  unitDescription: exports_external.string().nullable(),
  calories: exports_external.number(),
  proteinInGrams: exports_external.number().nullable(),
  carbohydratesInGrams: exports_external.number().nullable(),
  fatInGrams: exports_external.number().nullable(),
  fiberInGrams: exports_external.number().nullable(),
  sugarInGrams: exports_external.number().nullable()
});
var allFoodItemUnitsSchema = exports_external.object({
  unitId: exports_external.string().uuid(),
  unitOfMeasurement: exports_external.string(),
  unitDescription: exports_external.string().nullable(),
  calories: exports_external.number(),
  proteinInGrams: exports_external.number().nullable(),
  carbohydratesInGrams: exports_external.number().nullable(),
  fatInGrams: exports_external.number().nullable(),
  fiberInGrams: exports_external.number().nullable(),
  sugarInGrams: exports_external.number().nullable(),
  foodItemId: exports_external.string().uuid(),
  foodItemName: exports_external.string(),
  categoryHierarchy: exports_external.array(exports_external.string()).nullable()
});
var listFoodItemUnitsByFoodItemIdRoute = createRoute({
  method: "get",
  path: "/api/food-item/:foodItemId/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      foodItemId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Food item units retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(foodItemUnitDetailSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var listAllFoodItemUnitsRoute = createRoute({
  method: "get",
  path: "/api/food-item/units",
  tags: ["Food Item Units"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "All food item units retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(allFoodItemUnitsSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListFoodItemUnits(app) {
  app.openapi(listFoodItemUnitsByFoodItemIdRoute, async (c) => {
    const safeUserId = c.userId;
    const foodItemId = c.req.param("foodItemId");
    const foodItemFromDb = await db.query.foodItems.findFirst({
      where: and(eq(foodItems.id, foodItemId), eq(foodItems.userId, safeUserId))
    });
    if (!foodItemFromDb) {
      return c.json({
        success: false,
        message: "Food item not found or access denied"
      }, 404);
    }
    const units = await db.select().from(foodItemUnits).where(eq(foodItemUnits.foodItemId, foodItemId)).orderBy(foodItemUnits.unitOfMeasurement);
    const unitsWithFoodItem = units.map((unit) => ({
      id: unit.id,
      foodItemId: unit.foodItemId,
      foodItemName: foodItemFromDb.name,
      unitOfMeasurement: unit.unitOfMeasurement,
      unitDescription: unit.unitDescription,
      calories: unit.calories,
      proteinInGrams: unit.proteinInGrams,
      carbohydratesInGrams: unit.carbohydratesInGrams,
      fatInGrams: unit.fatInGrams,
      fiberInGrams: unit.fiberInGrams,
      sugarInGrams: unit.sugarInGrams
    }));
    return c.json({
      success: true,
      message: "Food item units retrieved successfully",
      data: unitsWithFoodItem
    }, 200);
  });
  app.openapi(listAllFoodItemUnitsRoute, async (c) => {
    const safeUserId = c.userId;
    const unitsWithFoodItems = await db.select({
      unitId: foodItemUnits.id,
      unitOfMeasurement: foodItemUnits.unitOfMeasurement,
      unitDescription: foodItemUnits.unitDescription,
      calories: foodItemUnits.calories,
      proteinInGrams: foodItemUnits.proteinInGrams,
      carbohydratesInGrams: foodItemUnits.carbohydratesInGrams,
      fatInGrams: foodItemUnits.fatInGrams,
      fiberInGrams: foodItemUnits.fiberInGrams,
      sugarInGrams: foodItemUnits.sugarInGrams,
      foodItemId: foodItems.id,
      foodItemName: foodItems.name,
      categoryHierarchy: foodItems.categoryHierarchy
    }).from(foodItemUnits).innerJoin(foodItems, eq(foodItemUnits.foodItemId, foodItems.id)).where(eq(foodItems.userId, safeUserId)).orderBy(foodItems.name, foodItemUnits.unitOfMeasurement);
    return c.json({
      success: true,
      message: "All food item units retrieved successfully",
      data: unitsWithFoodItems
    }, 200);
  });
}

// src/routes/api/habit/habit.create.ts
var createComplexHabitRequestSchema = exports_external.object({
  domain: exports_external.literal("meal"),
  entityId: exports_external.string().uuid(),
  recurrenceType: exports_external.literal("weekly"),
  targetWeekday: Weekday,
  targetTime: HHMM.optional(),
  startDate: YMD,
  subEntities: exports_external.array(exports_external.object({
    subEntityId: exports_external.string().uuid().optional(),
    scheduledWeekday: Weekday,
    scheduledTime: HHMM.optional()
  })).min(1)
});
var successResponseSchema4 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    domain: exports_external.string(),
    configuredSubEntitiesCount: exports_external.number()
  })
});
var errorResponseSchema4 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createBatchHabitsRoute = createRoute({
  method: "post",
  path: "/api/habit/batch",
  tags: ["Habits"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createComplexHabitRequestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Batch habits created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema4
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    404: {
      description: "Not Found",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema4
        }
      }
    }
  }
});
function registerCreateHabit(app) {
  app.openapi(createBatchHabitsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeBatchHabitData = c.req.valid("json");
    if (safeBatchHabitData.domain !== "meal") {
      return c.json({
        success: false,
        message: "Unsupported domain for batch habits",
        errors: `Expected domain 'meal', got '${safeBatchHabitData.domain}'. Only meal domain is currently supported.`
      }, 400);
    }
    const mealFromDb = await db.query.meals.findFirst({
      where: eq(meals.id, safeBatchHabitData.entityId)
    });
    if (!mealFromDb || mealFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Invalid meal entity",
        errors: `Meal ${safeBatchHabitData.entityId} not found or access denied`
      }, 404);
    }
    const mealRecipesForEntity = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, safeBatchHabitData.entityId)).orderBy(mealRecipes.orderInMeal);
    if (mealRecipesForEntity.length === 0) {
      return c.json({
        success: false,
        message: "No recipes attached to meal",
        errors: `Meal ${safeBatchHabitData.entityId} has no recipes. Attach recipes using POST /api/meal/:id/recipes before creating a habit.`
      }, 400);
    }
    const allInstructions = [];
    for (const mealRecipe of mealRecipesForEntity) {
      const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
      allInstructions.push(...instructions);
    }
    if (allInstructions.length === 0) {
      return c.json({
        success: false,
        message: "No instructions found",
        errors: `None of the recipes attached to meal ${safeBatchHabitData.entityId} have instructions`
      }, 400);
    }
    const validInstructionIds = new Set(allInstructions.map((instr) => instr.id));
    const providedSubEntityIds = safeBatchHabitData.subEntities.map((se) => se.subEntityId).filter((id) => id !== undefined);
    for (const subEntityId of providedSubEntityIds) {
      if (!validInstructionIds.has(subEntityId)) {
        return c.json({
          success: false,
          message: "Invalid subEntityId",
          errors: `Instruction ${subEntityId} not found in meal's recipes`
        }, 400);
      }
    }
    const newHabit = {
      userId: safeUserId,
      ...safeBatchHabitData
    };
    console.log(safeUserId);
    const createHabitEvent = habitsCreatedSchema.safeParse(newHabit);
    if (!createHabitEvent.success) {
      return c.json({
        success: false,
        message: "Invalid habit data",
        errors: createHabitEvent.error.errors
      }, 400);
    }
    const safeCreateHabitEvent = createHabitEvent.data;
    try {
      await FlowcorePathways.write("habit.v0/complex-habit.created.v0", {
        data: safeCreateHabitEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create batch habits",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Batch habits created successfully",
      data: {
        domain: safeBatchHabitData.domain,
        configuredSubEntitiesCount: safeBatchHabitData.subEntities.length
      }
    }, 201);
  });
}

// src/routes/api/meal/meal.create.ts
var createMealRequestSchema = exports_external.object({
  mealName: exports_external.string().min(1, "Meal name min length is 1").max(100, "Meal name max length is 100")
});
var successResponseSchema5 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    meal: exports_external.object({
      id: exports_external.string().uuid(),
      mealName: exports_external.string()
    }),
    message: exports_external.string()
  })
});
var errorResponseSchema5 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createMealRoute = createRoute({
  method: "post",
  path: "/api/meal",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createMealRequestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Meal created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema5
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema5
        }
      }
    }
  }
});
function registerCreateMeal(app) {
  app.openapi(createMealRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateMealJsonBody = c.req.valid("json");
    const newMeal = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      mealName: safeCreateMealJsonBody.mealName
    };
    const createMealEvent = mealSchema.safeParse(newMeal);
    if (!createMealEvent.success) {
      return c.json({
        success: false,
        message: "Invalid meal data",
        errors: createMealEvent.error.errors
      }, 400);
    }
    const safeCreateMealEvent = createMealEvent.data;
    try {
      await FlowcorePathways.write("meal.v0/meal.created.v0", {
        data: safeCreateMealEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create meal",
        errors: error2
      }, 500);
    }
    const { userId: _, ...createMeal } = safeCreateMealEvent;
    return c.json({
      success: true,
      message: "Meal created successfully",
      data: {
        meal: createMeal,
        message: "Meal created. Use POST /api/meal/:id/recipes to attach recipes."
      }
    }, 201);
  });
}

// src/routes/api/meal/meal.get.ts
var fullMealSchema = exports_external.object({
  id: exports_external.string().uuid(),
  mealName: exports_external.string(),
  recipes: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    orderInMeal: exports_external.number()
  })),
  instructions: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    instruction: exports_external.string(),
    instructionNumber: exports_external.number()
  })),
  ingredients: exports_external.array(exports_external.object({
    recipeId: exports_external.string().uuid(),
    ingredientText: exports_external.string()
  }))
});
var getMealRoute = createRoute({
  method: "get",
  path: "/api/meal/{mealId}",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      mealId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Meal retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: fullMealSchema
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Meal not found or access denied",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerGetMeal(app) {
  app.openapi(getMealRoute, async (c) => {
    const safeUserId = c.userId;
    const mealId = c.req.param("mealId");
    const mealFromDb = await db.query.meals.findFirst({
      where: eq(meals.id, mealId)
    });
    if (!mealFromDb || mealFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Meal not found or access denied"
      }, 404);
    }
    const mealRecipesData = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId)).orderBy(mealRecipes.orderInMeal);
    const allIngredients = [];
    const allInstructions = [];
    for (const mealRecipe of mealRecipesData) {
      const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, mealRecipe.recipeId)).orderBy(recipeIngredients.ingredientText);
      for (const ingredient of ingredients) {
        allIngredients.push({
          recipeId: mealRecipe.recipeId,
          ingredientText: ingredient.ingredientText
        });
      }
      const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
      for (const inst of instructions) {
        allInstructions.push({
          recipeId: mealRecipe.recipeId,
          instruction: inst.instruction,
          instructionNumber: inst.instructionNumber
        });
      }
    }
    const fullMeal = {
      id: mealFromDb.id,
      mealName: mealFromDb.mealName,
      recipes: mealRecipesData.map((mr) => ({
        recipeId: mr.recipeId,
        orderInMeal: mr.orderInMeal
      })),
      instructions: allInstructions,
      ingredients: allIngredients
    };
    return c.json({
      success: true,
      message: "Meal retrieved successfully",
      data: fullMeal
    }, 200);
  });
}

// src/routes/api/meal/meal.list.ts
var mealSummarySchema = exports_external.object({
  id: exports_external.string().uuid(),
  mealName: exports_external.string(),
  recipeCount: exports_external.number()
});
var listMealsRoute = createRoute({
  method: "get",
  path: "/api/meal",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Meals retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(mealSummarySchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListMeals(app) {
  app.openapi(listMealsRoute, async (c) => {
    const safeUserId = c.userId;
    const userMeals = await db.select().from(meals).where(eq(meals.userId, safeUserId));
    const mealsData = await Promise.all(userMeals.map(async (meal3) => {
      const mealRecipesData = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, meal3.id)).orderBy(mealRecipes.orderInMeal);
      return {
        id: meal3.id,
        mealName: meal3.mealName,
        recipeCount: mealRecipesData.length
      };
    }));
    return c.json({
      success: true,
      message: "Meals retrieved successfully",
      data: mealsData
    }, 200);
  });
}

// src/routes/api/meal/meal-recipes.attach.ts
var requestSchema = exports_external.object({
  recipeIds: exports_external.array(exports_external.string().uuid()).min(1, "At least one recipe ID is required")
});
var successResponseSchema6 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    mealRecipe: mealRecipeAttachSchema
  })
});
var errorResponseSchema6 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var attachRecipesToMealRoute = createRoute({
  method: "post",
  path: "/api/meal/{mealId}/recipes",
  tags: ["Meals"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      mealId: exports_external.string().uuid()
    }),
    body: {
      content: {
        "application/json": {
          schema: requestSchema
        }
      }
    }
  },
  responses: {
    201: {
      description: "Recipes attached to meal successfully",
      content: {
        "application/json": {
          schema: successResponseSchema6
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    },
    404: {
      description: "Meal or recipes not found",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema6
        }
      }
    }
  }
});
function registerAttachMealRecipes(app) {
  app.openapi(attachRecipesToMealRoute, async (c) => {
    const safeUserId = c.userId;
    const mealId = c.req.param("mealId");
    const { recipeIds } = c.req.valid("json");
    const mealFromDb = await db.query.meals.findFirst({
      where: and(eq(meals.id, mealId), eq(meals.userId, safeUserId))
    });
    if (!mealFromDb) {
      return c.json({
        success: false,
        message: "Meal not found or access denied"
      }, 404);
    }
    const recipesFromDb = await db.query.recipes.findMany({
      where: and(inArray(recipes.id, recipeIds), eq(recipes.userId, safeUserId))
    });
    if (recipesFromDb.length !== recipeIds.length) {
      const missingRecipeIds = recipeIds.filter((id) => !recipesFromDb.some((r) => r.id === id));
      return c.json({
        success: false,
        message: "One or more recipes not found or access denied",
        errors: `Recipes ${missingRecipeIds.join(", ")} not found or access denied`
      }, 404);
    }
    const existingRecipes = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId));
    const maxOrder = existingRecipes.length > 0 ? Math.max(...existingRecipes.map((r) => r.orderInMeal)) : -1;
    const recipesToAttach = recipesFromDb.map((recipe4, index) => ({
      recipeId: recipe4.id,
      orderInMeal: maxOrder + 1 + index
    }));
    const newMealRecipe = {
      mealId,
      recipes: recipesToAttach
    };
    const attachEvent = mealRecipeAttachSchema.safeParse(newMealRecipe);
    if (!attachEvent.success) {
      return c.json({
        success: false,
        message: "Invalid meal recipe data",
        errors: attachEvent.error.errors
      }, 400);
    }
    try {
      await FlowcorePathways.write("meal.v0/meal-recipe.attached.v0", {
        data: attachEvent.data
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to attach recipes to meal",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: `${recipeIds.length} recipe${recipeIds.length > 1 ? "s" : ""} attached to meal successfully`,
      data: {
        mealRecipe: attachEvent.data
      }
    }, 201);
  });
}

// src/routes/api/recipe/recipe.create.ts
var createRecipeRequestSchema = exports_external.object({
  nameOfTheRecipe: exports_external.string().min(1, "Recipe name min length is 1").max(75, "Recipe name max length is 75"),
  generalDescriptionOfTheRecipe: exports_external.string().max(250).optional(),
  whenIsItConsumed: exports_external.array(exports_external.nativeEnum(MealTimingEnum)).optional()
});
var successResponseSchema7 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeSchema
});
var errorResponseSchema7 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeRoute = createRoute({
  method: "post",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema7
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    409: {
      description: "Conflict - Recipe with name already exists",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema7
        }
      }
    }
  }
});
function registerCreateRecipe(app) {
  app.openapi(createRecipeRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeJsonBody = c.req.valid("json");
    const existingRecipe = await db.select().from(recipes).where(and(eq(recipes.nameOfTheRecipe, safeCreateRecipeJsonBody.nameOfTheRecipe), eq(recipes.userId, safeUserId)));
    if (existingRecipe.length > 0) {
      return c.json({
        success: false,
        message: "Recipe with name already exists"
      }, 409);
    }
    const newRecipe = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      nameOfTheRecipe: safeCreateRecipeJsonBody.nameOfTheRecipe,
      generalDescriptionOfTheRecipe: safeCreateRecipeJsonBody.generalDescriptionOfTheRecipe,
      whenIsItConsumed: safeCreateRecipeJsonBody.whenIsItConsumed
    };
    const createRecipeEvent = recipeSchema.safeParse(newRecipe);
    if (!createRecipeEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe data",
        errors: createRecipeEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeEvent = createRecipeEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe.created.v0", {
        data: safeCreateRecipeEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe created successfully",
      data: safeCreateRecipeEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe.delete.ts
var deleteRecipeRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid()
});
var successResponseSchema8 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeDeletedSchema
});
var errorResponseSchema8 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var deleteRecipeRoute = createRoute({
  method: "delete",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: deleteRecipeRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe deleted successfully",
      content: {
        "application/json": {
          schema: successResponseSchema8
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    404: {
      description: "Recipe not found",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema8
        }
      }
    }
  }
});
function registerDeleteRecipe(app) {
  app.openapi(deleteRecipeRoute, async (c) => {
    const safeUserId = c.userId;
    const safeDeleteRecipeRequestBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: and(eq(recipes.id, safeDeleteRecipeRequestBody.recipeId), eq(recipes.userId, safeUserId))
    });
    if (!recipeFromDb) {
      return c.json({
        success: false,
        message: "Recipe not found"
      }, 404);
    }
    const recipeDeleted = {
      recipeId: recipeFromDb.id
    };
    const recipeDeletedEvent = recipeDeletedSchema.safeParse(recipeDeleted);
    if (!recipeDeletedEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe deleted data",
        errors: recipeDeletedEvent.error.errors
      }, 400);
    }
    const safeRecipeDeletedEvent = recipeDeletedEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe.deleted.v0", {
        data: safeRecipeDeletedEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to delete recipe",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe deleted successfully",
      data: safeRecipeDeletedEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe.list.ts
var recipeMetadataSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable(),
  version: exports_external.number(),
  stepCount: exports_external.number(),
  ingredientCount: exports_external.number(),
  hasSteps: exports_external.boolean(),
  hasIngredients: exports_external.boolean(),
  completeness: exports_external.enum(["complete", "incomplete"])
});
var fullRecipeSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable(),
  version: exports_external.number(),
  instructions: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    instruction: exports_external.string(),
    instructionNumber: exports_external.number(),
    foodItemUnits: exports_external.array(exports_external.object({
      quantity: exports_external.number(),
      calories: exports_external.number(),
      unitOfMeasurement: exports_external.string(),
      foodItemName: exports_external.string()
    }))
  })),
  ingredients: exports_external.array(exports_external.object({
    id: exports_external.string().uuid(),
    ingredientText: exports_external.string()
  })),
  metadata: exports_external.object({
    stepCount: exports_external.number(),
    ingredientCount: exports_external.number(),
    estimatedTotalTime: exports_external.number().nullable()
  })
});
var recipeBasicSchema = exports_external.object({
  id: exports_external.string().uuid(),
  nameOfTheRecipe: exports_external.string(),
  generalDescriptionOfTheRecipe: exports_external.string().nullable(),
  whenIsItConsumed: exports_external.array(exports_external.string()).nullable()
});
var listRecipesRoute = createRoute({
  method: "get",
  path: "/api/recipe",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  responses: {
    200: {
      description: "Recipes retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(recipeMetadataSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var getRecipeByIdRoute = createRoute({
  method: "get",
  path: "/api/recipe/{recipeId}",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    params: exports_external.object({
      recipeId: exports_external.string().uuid()
    })
  },
  responses: {
    200: {
      description: "Recipe retrieved successfully",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: fullRecipeSchema
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    },
    404: {
      description: "Recipe not found or access denied",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var searchRecipesRoute = createRoute({
  method: "get",
  path: "/api/recipe/search",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    query: exports_external.object({
      q: exports_external.string().optional(),
      timing: exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Recipe search results",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(true),
            message: exports_external.string(),
            data: exports_external.array(recipeBasicSchema)
          })
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListRecipes(app) {
  app.openapi(listRecipesRoute, async (c) => {
    const safeUserId = c.userId;
    const userRecipes = await db.select().from(recipes).where(eq(recipes.userId, safeUserId)).orderBy(recipes.nameOfTheRecipe);
    const recipesWithMetadata = await Promise.all(userRecipes.map(async (recipe4) => {
      const steps = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, recipe4.id));
      const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, recipe4.id));
      return {
        id: recipe4.id,
        nameOfTheRecipe: recipe4.nameOfTheRecipe,
        generalDescriptionOfTheRecipe: recipe4.generalDescriptionOfTheRecipe,
        whenIsItConsumed: recipe4.whenIsItConsumed,
        version: recipe4.version,
        stepCount: steps.length,
        ingredientCount: ingredients.length,
        hasSteps: steps.length > 0,
        hasIngredients: ingredients.length > 0,
        completeness: steps.length > 0 && ingredients.length > 0 ? "complete" : "incomplete"
      };
    }));
    return c.json({
      success: true,
      message: "Recipes retrieved successfully",
      data: recipesWithMetadata
    }, 200);
  });
  app.openapi(getRecipeByIdRoute, async (c) => {
    const safeUserId = c.userId;
    const recipeId = c.req.param("recipeId");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found or access denied"
      }, 404);
    }
    const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, recipeId)).orderBy(recipeInstructions.instructionNumber);
    const instructionFoodItemUnits = await db.select().from(recipeInstructionFoodItemUnits).where(inArray(recipeInstructionFoodItemUnits.recipeInstructionId, instructions.map((instruction) => instruction.id)));
    const foodItemUnitsFromDb = await db.select().from(foodItemUnits).where(inArray(foodItemUnits.id, instructionFoodItemUnits.map((instructionFoodItemUnit) => instructionFoodItemUnit.foodItemUnitId)));
    const foodItemsFromDb = await db.select().from(foodItems).where(inArray(foodItems.id, foodItemUnitsFromDb.map((foodItemUnit) => foodItemUnit.foodItemId)));
    const ingredients = await db.select().from(recipeIngredients).where(eq(recipeIngredients.recipeId, recipeId));
    const fullRecipe = {
      id: recipeFromDb.id,
      nameOfTheRecipe: recipeFromDb.nameOfTheRecipe,
      generalDescriptionOfTheRecipe: recipeFromDb.generalDescriptionOfTheRecipe,
      whenIsItConsumed: recipeFromDb.whenIsItConsumed,
      version: recipeFromDb.version,
      instructions: instructions.map((instruction) => {
        const instructionFoodUnits = instructionFoodItemUnits.filter((ifiu) => ifiu.recipeInstructionId === instruction.id).map((ifiu) => {
          const foodItemUnit = foodItemUnitsFromDb.find((fiu) => fiu.id === ifiu.foodItemUnitId);
          const foodItem2 = foodItemsFromDb.find((fi) => fi.id === foodItemUnit?.foodItemId);
          return {
            quantity: ifiu.quantity,
            calories: foodItemUnit?.calories || 0,
            unitOfMeasurement: foodItemUnit?.unitOfMeasurement || "",
            foodItemName: foodItem2?.name || ""
          };
        });
        return {
          id: instruction.id,
          instruction: instruction.instruction,
          instructionNumber: instruction.instructionNumber,
          foodItemUnits: instructionFoodUnits
        };
      }),
      ingredients: ingredients.map((ingredient) => ({
        id: ingredient.id,
        ingredientText: ingredient.ingredientText
      })),
      metadata: {
        stepCount: instructions.length,
        ingredientCount: ingredients.length,
        estimatedTotalTime: null
      }
    };
    return c.json({
      success: true,
      message: "Recipe retrieved successfully",
      data: fullRecipe
    }, 200);
  });
  app.openapi(searchRecipesRoute, async (c) => {
    const safeUserId = c.userId;
    const query = c.req.query("q") || "";
    const mealTiming = c.req.query("timing");
    let userRecipes = await db.select().from(recipes).where(eq(recipes.userId, safeUserId)).orderBy(recipes.nameOfTheRecipe);
    if (query) {
      userRecipes = userRecipes.filter((recipe4) => recipe4.nameOfTheRecipe.toLowerCase().includes(query.toLowerCase()) || (recipe4.generalDescriptionOfTheRecipe ? recipe4.generalDescriptionOfTheRecipe.toLowerCase().includes(query.toLowerCase()) : false));
    }
    if (mealTiming) {
      userRecipes = userRecipes.filter((recipe4) => recipe4.whenIsItConsumed ? recipe4.whenIsItConsumed.includes(mealTiming) : false);
    }
    return c.json({
      success: true,
      message: "Recipe search results",
      data: userRecipes
    }, 200);
  });
}

// src/routes/api/recipe/recipe-ingredients.create.ts
var createRecipeIngredientsRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  ingredients: exports_external.array(exports_external.object({
    ingredientText: exports_external.string().min(1).max(150)
  })).min(1).max(50)
});
var successResponseSchema9 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeIngredientsSchema
});
var errorResponseSchema9 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeIngredientsRoute = createRoute({
  method: "post",
  path: "/api/recipe/ingredients",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeIngredientsRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe ingredients created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema9
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    404: {
      description: "Recipe not found or access denied",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema9
        }
      }
    }
  }
});
function registerCreateRecipeIngredients(app) {
  app.openapi(createRecipeIngredientsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeIngredientsJsonBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, safeCreateRecipeIngredientsJsonBody.recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found or access denied"
      }, 404);
    }
    const newRecipeIngredients = {
      recipeId: safeCreateRecipeIngredientsJsonBody.recipeId,
      ingredients: safeCreateRecipeIngredientsJsonBody.ingredients.map((ingredient) => ({
        id: crypto.randomUUID(),
        ingredientText: ingredient.ingredientText
      }))
    };
    const createRecipeIngredientsEvent = recipeIngredientsSchema.safeParse(newRecipeIngredients);
    if (!createRecipeIngredientsEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe ingredients data",
        errors: createRecipeIngredientsEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeIngredientsEvent = createRecipeIngredientsEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe-ingredients.created.v0", {
        data: safeCreateRecipeIngredientsEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe ingredients",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe ingredients created successfully",
      data: safeCreateRecipeIngredientsEvent
    }, 200);
  });
}

// src/routes/api/recipe/recipe-instructions.create.ts
var createRecipeInstructionsRequestSchema = exports_external.object({
  recipeId: exports_external.string().uuid(),
  stepByStepInstructions: exports_external.array(exports_external.object({
    stepInstruction: exports_external.string().min(1).max(250),
    foodItemUnitsUsedInStep: exports_external.array(exports_external.object({
      foodItemUnitId: exports_external.string().uuid(),
      quantityOfFoodItemUnit: exports_external.number().positive().max(1e6).default(1)
    })).optional()
  })).min(1).max(30)
});
var successResponseSchema10 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: recipeInstructionsSchema
});
var errorResponseSchema10 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createRecipeInstructionsRoute = createRoute({
  method: "post",
  path: "/api/recipe/instructions",
  tags: ["Recipes"],
  security: [{ Bearer: [] }],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createRecipeInstructionsRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Recipe instructions created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema10
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    404: {
      description: "Recipe not found",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema10
        }
      }
    }
  }
});
function registerCreateRecipeInstructions(app) {
  app.openapi(createRecipeInstructionsRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateRecipeInstructionsJsonBody = c.req.valid("json");
    const recipeFromDb = await db.query.recipes.findFirst({
      where: eq(recipes.id, safeCreateRecipeInstructionsJsonBody.recipeId)
    });
    if (!recipeFromDb || recipeFromDb.userId !== safeUserId) {
      return c.json({
        success: false,
        message: "Recipe not found"
      }, 404);
    }
    const maxStepResult = await db.select({ maxStep: max2(recipeInstructions.instructionNumber) }).from(recipeInstructions).where(eq(recipeInstructions.recipeId, safeCreateRecipeInstructionsJsonBody.recipeId));
    const currentMaxStep = maxStepResult[0]?.maxStep ?? 0;
    const newRecipeInstructions = {
      recipeId: safeCreateRecipeInstructionsJsonBody.recipeId,
      stepByStepInstructions: safeCreateRecipeInstructionsJsonBody.stepByStepInstructions.map((step, index) => ({
        id: crypto.randomUUID(),
        instructionNumber: currentMaxStep + index + 1,
        stepInstruction: step.stepInstruction,
        foodItemUnitsUsedInStep: step.foodItemUnitsUsedInStep
      }))
    };
    const createRecipeInstructionsEvent = recipeInstructionsSchema.safeParse(newRecipeInstructions);
    if (!createRecipeInstructionsEvent.success) {
      return c.json({
        success: false,
        message: "Invalid recipe instructions data",
        errors: createRecipeInstructionsEvent.error.errors
      }, 400);
    }
    const safeCreateRecipeInstructionsEvent = createRecipeInstructionsEvent.data;
    try {
      await FlowcorePathways.write("recipe.v0/recipe-instructions.created.v0", {
        data: safeCreateRecipeInstructionsEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create recipe instructions",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Recipe instructions created successfully",
      data: safeCreateRecipeInstructionsEvent
    }, 200);
  });
}

// src/routes/api/todo/todo.complete.ts
var completeTodoRequestSchema = exports_external.object({
  id: exports_external.string().uuid()
});
var successResponseSchema11 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: todoCompletedSchema
});
var errorResponseSchema11 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var completeTodoRoute = createRoute({
  method: "post",
  path: "/api/todo/complete",
  tags: ["Todos"],
  security: [
    {
      Bearer: []
    }
  ],
  request: {
    body: {
      content: {
        "application/json": {
          schema: completeTodoRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Todo completed successfully",
      content: {
        "application/json": {
          schema: successResponseSchema11
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema11
        }
      }
    }
  }
});
function registerCompleteTodo(app) {
  app.openapi(completeTodoRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCompleteTodoJsonBody = c.req.valid("json");
    const completedTodo = {
      id: safeCompleteTodoJsonBody.id,
      userId: safeUserId
    };
    const completeTodoEvent = todoCompletedSchema.safeParse(completedTodo);
    if (!completeTodoEvent.success) {
      return c.json({
        success: false,
        message: "Invalid completed todo data",
        errors: completeTodoEvent.error.errors
      }, 400);
    }
    const safeCompleteTodoEvent = completeTodoEvent.data;
    try {
      await FlowcorePathways.write("todo.v0/todo.completed.v0", {
        data: safeCompleteTodoEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to complete todo",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Todo completed successfully",
      data: safeCompleteTodoEvent
    }, 200);
  });
}

// src/routes/api/todo/todo.create.ts
var createTodoRequestSchema = exports_external.object({
  description: exports_external.string().min(1, "Description is required").max(250, "Description must be less than 250 characters"),
  scheduledFor: exports_external.string().datetime().optional(),
  relations: exports_external.array(exports_external.object({
    mealInstruction: exports_external.object({
      mealStepId: exports_external.string().uuid(),
      mealId: exports_external.string().uuid(),
      recipeId: exports_external.string().uuid(),
      instructionNumber: exports_external.number().int().positive()
    })
  })).min(1, "if relations is NOT undefined, you must have at least one relation").max(5, "you can only have up to 5 relations").optional()
});
var successResponseSchema12 = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: todoSchema
});
var errorResponseSchema12 = exports_external.object({
  success: exports_external.literal(false),
  message: exports_external.string(),
  errors: exports_external.any().optional()
});
var createTodoRoute = createRoute({
  method: "post",
  path: "/api/todo",
  tags: ["Todos"],
  security: [
    {
      Bearer: []
    }
  ],
  request: {
    body: {
      content: {
        "application/json": {
          schema: createTodoRequestSchema
        }
      }
    }
  },
  responses: {
    200: {
      description: "Todo created successfully",
      content: {
        "application/json": {
          schema: successResponseSchema12
        }
      }
    },
    400: {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    },
    500: {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: errorResponseSchema12
        }
      }
    }
  }
});
function registerCreateTodo(app) {
  app.openapi(createTodoRoute, async (c) => {
    const safeUserId = c.userId;
    const safeCreateTodoJsonBody = c.req.valid("json");
    const newTodo = {
      id: crypto.randomUUID(),
      userId: safeUserId,
      description: safeCreateTodoJsonBody.description,
      completed: false,
      scheduledFor: safeCreateTodoJsonBody.scheduledFor,
      completedAt: undefined,
      relations: safeCreateTodoJsonBody.relations
    };
    const createTodoEvent = todoSchema.safeParse(newTodo);
    if (!createTodoEvent.success) {
      return c.json({
        success: false,
        message: "Invalid todo data",
        errors: createTodoEvent.error.errors
      }, 400);
    }
    const safeCreateTodoEvent = createTodoEvent.data;
    try {
      await FlowcorePathways.write("todo.v0/todo.created.v0", {
        data: safeCreateTodoEvent
      });
    } catch (error2) {
      return c.json({
        success: false,
        message: "Failed to create todo",
        errors: error2
      }, 500);
    }
    return c.json({
      success: true,
      message: "Todo created successfully",
      data: safeCreateTodoEvent
    }, 200);
  });
}

// src/services/habit-generation.ts
var import_node_crypto3 = __toESM(require("node:crypto"));
var import_date_fns = __toESM(require_date_fns(), 1);

// src/services/domain-resolvers/meal-resolver.ts
class MealTitleResolver {
  async getMainEventTitle(mealId) {
    const meal3 = await db.query.meals.findFirst({
      where: eq(meals.id, mealId)
    });
    if (!meal3) {
      console.warn(`Meal not found for ID: ${mealId}`);
      return "Unknown Meal";
    }
    return `Eat: ${meal3.mealName}`;
  }
  async getSubEntityTitle(instructionId) {
    const instruction = await db.query.recipeInstructions.findFirst({
      where: eq(recipeInstructions.id, instructionId)
    });
    if (!instruction) {
      console.warn(`Recipe instruction not found for ID: ${instructionId}`);
      return "Unknown Instruction";
    }
    return instruction.instruction;
  }
}

// src/services/domain-resolvers/index.ts
var RESOLVERS = {
  meal: new MealTitleResolver
};
function getTitleResolver(domain) {
  const resolver = RESOLVERS[domain];
  if (!resolver) {
    throw new Error(`No title resolver found for domain: ${domain}. Available domains: ${Object.keys(RESOLVERS).join(", ")}`);
  }
  return resolver;
}

// src/services/habit-generation.ts
function subtractMinutesFromTime(time2, minutes) {
  const [hours, mins] = time2.split(":").map(Number);
  const totalMinutes = hours * 60 + mins - minutes;
  const adjustedMinutes = totalMinutes < 0 ? 0 : totalMinutes;
  const newHours = Math.floor(adjustedMinutes / 60);
  const newMins = adjustedMinutes % 60;
  return `${String(newHours).padStart(2, "0")}:${String(newMins).padStart(2, "0")}`;
}
async function fetchCurrentMealInstructions(mealId) {
  const mealRecipesForEntity = await db.select().from(mealRecipes).where(eq(mealRecipes.mealId, mealId)).orderBy(mealRecipes.orderInMeal);
  const allInstructions = [];
  for (const mealRecipe of mealRecipesForEntity) {
    const instructions = await db.select().from(recipeInstructions).where(eq(recipeInstructions.recipeId, mealRecipe.recipeId)).orderBy(recipeInstructions.instructionNumber);
    allInstructions.push(...instructions);
  }
  return allInstructions;
}
function calculateScheduledFor(dueDate, preferredTime) {
  const timeToUse = preferredTime || "09:00";
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dueDate)) {
    throw new Error(`Invalid dueDate format: ${dueDate}. Expected YYYY-MM-DD`);
  }
  if (!/^\d{2}:\d{2}$/.test(timeToUse)) {
    throw new Error(`Invalid time format: ${timeToUse}. Expected HH:MM`);
  }
  const dateTimeString = `${dueDate}T${timeToUse}:00.000Z`;
  const utcDate = import_date_fns.parseISO(dateTimeString);
  if (Number.isNaN(utcDate.getTime())) {
    throw new Error(`Invalid date created from: ${dateTimeString}`);
  }
  return utcDate;
}
function getWeekdayFromDate(dateStr) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
    throw new Error(`Invalid date format: ${dateStr}. Expected YYYY-MM-DD`);
  }
  const dateTimeString = `${dateStr}T12:00:00.000Z`;
  const date2 = import_date_fns.parseISO(dateTimeString);
  if (Number.isNaN(date2.getTime())) {
    throw new Error(`Invalid date created from: ${dateTimeString}`);
  }
  const weekdays = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  return weekdays[date2.getDay()];
}
async function selectTriggersForDate(userId, targetDate) {
  const weekday = getWeekdayFromDate(targetDate);
  const triggers = await db.query.habitTriggers.findMany({
    where: eq(habitTriggers.triggerWeekday, weekday)
  });
  const habitIds = Array.from(new Set(triggers.map((t) => t.habitId)));
  if (habitIds.length === 0) {
    return [];
  }
  const habitsForToday = await db.query.habits.findMany({
    where: and(inArray(habits.id, habitIds), eq(habits.userId, userId), eq(habits.isActive, true), eq(habits.recurrenceType, "weekly"))
  });
  const habitMap = new Map(habitsForToday.map((h) => [h.id, h]));
  const validHabitIds = habitsForToday.map((h) => h.id);
  const allSubEntities = await db.query.habitSubEntities.findMany({
    where: inArray(habitSubEntities.habitId, validHabitIds),
    orderBy: habitSubEntities.scheduledWeekday
  });
  const subEntitiesByHabitId = new Map;
  for (const subEntity of allSubEntities) {
    const existing = subEntitiesByHabitId.get(subEntity.habitId) || [];
    existing.push(subEntity);
    subEntitiesByHabitId.set(subEntity.habitId, existing);
  }
  const triggersWithSubEntities = [];
  for (const trigger of triggers) {
    const habit2 = habitMap.get(trigger.habitId);
    if (!habit2)
      continue;
    const subEntities = subEntitiesByHabitId.get(habit2.id) || [];
    triggersWithSubEntities.push({
      trigger,
      habit: habit2,
      subEntities
    });
  }
  return triggersWithSubEntities;
}
async function generateHabitInstance(habit2, subEntities, triggerDate) {
  const instanceId = import_node_crypto3.default.randomUUID();
  const todoEvents = [];
  const resolver = getTitleResolver(habit2.domain);
  for (const subEntity of subEntities) {
    if (!subEntity.subEntityId)
      continue;
    const scheduledDate = calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, subEntity.scheduledWeekday);
    const scheduledTime = subEntity.scheduledTime || "09:00";
    const scheduledFor = calculateScheduledFor(scheduledDate, scheduledTime);
    const title = subEntity.subEntityId ? await resolver.getSubEntityTitle(subEntity.subEntityId) : "Unknown Task";
    const todoEvent = {
      id: import_node_crypto3.default.randomUUID(),
      userId: habit2.userId,
      description: title,
      completed: false,
      scheduledFor: scheduledFor.toISOString(),
      completedAt: undefined,
      relations: undefined
    };
    todoEvents.push(todoEvent);
  }
  if (habit2.domain === "meal") {
    const currentInstructions = await fetchCurrentMealInstructions(habit2.entityId);
    const configuredInstructionIds = new Set(subEntities.map((se) => se.subEntityId).filter((id) => id !== null));
    const unconfiguredInstructions = currentInstructions.filter((instr) => !configuredInstructionIds.has(instr.id));
    for (const instruction of unconfiguredInstructions) {
      const scheduledDate = calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, habit2.targetWeekday);
      const scheduledTime = habit2.targetTime ? subtractMinutesFromTime(habit2.targetTime, 30) : "09:00";
      const scheduledFor = calculateScheduledFor(scheduledDate, scheduledTime);
      const title = await resolver.getSubEntityTitle(instruction.id);
      const todoEvent = {
        id: import_node_crypto3.default.randomUUID(),
        userId: habit2.userId,
        description: title,
        completed: false,
        scheduledFor: scheduledFor.toISOString(),
        completedAt: undefined,
        relations: undefined
      };
      todoEvents.push(todoEvent);
    }
  }
  const mainEventDate = calculateScheduledDateForSubEntity(triggerDate, habit2.targetWeekday, habit2.targetWeekday);
  const mainEventTime = habit2.targetTime || "09:00";
  const mainEventScheduledFor = calculateScheduledFor(mainEventDate, mainEventTime);
  const mainEventTitle = await resolver.getMainEventTitle(habit2.entityId);
  const mainEventTodo = {
    id: import_node_crypto3.default.randomUUID(),
    userId: habit2.userId,
    description: mainEventTitle,
    completed: false,
    scheduledFor: mainEventScheduledFor.toISOString(),
    completedAt: undefined,
    relations: undefined
  };
  todoEvents.push(mainEventTodo);
  await FlowcorePathways.write("todo.v0/todo.generated.v0", {
    batch: true,
    data: todoEvents
  });
  return { instanceId, todosGenerated: todoEvents.length };
}
function calculateScheduledDateForSubEntity(triggerDate, _targetWeekday, subEntityWeekday) {
  if (!/^\d{4}-\d{2}-\d{2}$/.test(triggerDate)) {
    throw new Error(`Invalid triggerDate format: ${triggerDate}. Expected YYYY-MM-DD`);
  }
  const weekdays = [
    "sunday",
    "monday",
    "tuesday",
    "wednesday",
    "thursday",
    "friday",
    "saturday"
  ];
  const subEntityDay = weekdays.indexOf(subEntityWeekday);
  if (subEntityDay === -1) {
    throw new Error(`Invalid subEntityWeekday: ${subEntityWeekday}`);
  }
  const triggerDay = getWeekdayFromDate(triggerDate);
  const triggerDayIndex = weekdays.indexOf(triggerDay);
  if (triggerDayIndex === -1) {
    throw new Error(`Invalid triggerDay: ${triggerDay}`);
  }
  let offset = subEntityDay - triggerDayIndex;
  if (offset < 0)
    offset += 7;
  const triggerDateObj = import_date_fns.parseISO(`${triggerDate}T12:00:00.000Z`);
  if (Number.isNaN(triggerDateObj.getTime())) {
    throw new Error(`Invalid trigger date created from: ${triggerDate}T12:00:00.000Z`);
  }
  const scheduledDateObj = new Date(triggerDateObj);
  scheduledDateObj.setDate(scheduledDateObj.getDate() + offset);
  if (Number.isNaN(scheduledDateObj.getTime())) {
    throw new Error(`Invalid scheduled date calculated from triggerDate: ${triggerDate}, offset: ${offset}`);
  }
  return scheduledDateObj.toISOString().split("T")[0];
}
async function generateMissingHabitTodos(userId, targetDate) {
  try {
    if (!/^\d{4}-\d{2}-\d{2}$/.test(targetDate)) {
      throw new Error(`Invalid targetDate format: ${targetDate}. Expected YYYY-MM-DD`);
    }
    const hasExecutedToday = await db.query.habitTriggerExecutions.findFirst({
      where: and(eq(habitTriggerExecutions.userId, userId), eq(habitTriggerExecutions.triggerDate, targetDate))
    });
    if (hasExecutedToday) {
      console.log(`Habit generation already completed for ${targetDate}`);
      return {
        success: 0,
        skipped: 0,
        failed: 0,
        errors: []
      };
    }
    await db.insert(habitTriggerExecutions).values({
      userId,
      triggerDate: targetDate
    }).onConflictDoUpdate({
      target: habitTriggerExecutions.userId,
      set: {
        triggerDate: targetDate
      }
    });
    console.log(`Starting weekly habit todo generation for user ${userId} on ${targetDate}`);
    const triggersToFire = await selectTriggersForDate(userId, targetDate);
    console.log(`Found ${triggersToFire.length} habit triggers for ${targetDate}`);
    const results = {
      success: 0,
      skipped: 0,
      failed: 0,
      errors: []
    };
    for (const { habit: habit2, subEntities } of triggersToFire) {
      try {
        const { instanceId, todosGenerated } = await generateHabitInstance(habit2, subEntities, targetDate);
        results.success++;
        console.log(`Generated habit instance for ${habit2.entityId}: ${todosGenerated} todos created (instance: ${instanceId})`);
      } catch (error2) {
        const errorMessage = error2 instanceof Error ? error2.message : String(error2);
        console.error(`Failed to generate habit instance for ${habit2.entityId}:`, error2);
        results.failed++;
        results.errors.push({
          habitId: habit2.id,
          error: errorMessage
        });
      }
    }
    console.log(`Weekly habit generation completed: ${results.success} successful, ${results.skipped} skipped, ${results.failed} failed`);
    return results;
  } catch (error2) {
    console.error(`Critical error in generateMissingHabitTodos:`, error2);
    throw error2;
  }
}

// src/utils/timezone.ts
function getDayBoundsInTimezone(timezone, date2 = new Date) {
  if (Number.isNaN(date2.getTime())) {
    throw new Error(`Invalid input date provided: ${date2}`);
  }
  try {
    const year = date2.getFullYear();
    const month = date2.getMonth();
    const day = date2.getDate();
    const startOfDayLocal = new Date(year, month, day, 0, 0, 0, 0);
    const endOfDayLocal = new Date(year, month, day, 23, 59, 59, 999);
    if (Number.isNaN(startOfDayLocal.getTime()) || Number.isNaN(endOfDayLocal.getTime())) {
      throw new Error(`Invalid local dates created from year=${year}, month=${month}, day=${day}`);
    }
    const startOfDayUTC = convertLocalTimeToUTC(startOfDayLocal, timezone);
    const endOfDayUTC = convertLocalTimeToUTC(endOfDayLocal, timezone);
    return {
      startOfDay: startOfDayUTC,
      endOfDay: endOfDayUTC
    };
  } catch (error2) {
    console.error(`Error in getDayBoundsInTimezone: ${error2}`);
    console.error(`Input: timezone=${timezone}, date=${date2}`);
    throw error2;
  }
}
function convertLocalTimeToUTC(localDate, timezone) {
  if (Number.isNaN(localDate.getTime())) {
    throw new Error(`Invalid localDate provided: ${localDate}`);
  }
  try {
    const localString = localDate.toISOString().slice(0, 19);
    const timeInTargetTz = new Date(`${localString}Z`);
    if (Number.isNaN(timeInTargetTz.getTime())) {
      throw new Error(`Invalid intermediate date created: ${localString}Z`);
    }
    const utcTime = timeInTargetTz.getTime();
    const timezoneString = timeInTargetTz.toLocaleString("sv-SE", {
      timeZone: timezone
    });
    const timezoneTime = new Date(timezoneString).getTime();
    if (Number.isNaN(timezoneTime)) {
      throw new Error(`Invalid timezone conversion: ${timezoneString} for timezone ${timezone}`);
    }
    const offset = utcTime - timezoneTime;
    const result = new Date(localDate.getTime() + offset);
    if (Number.isNaN(result.getTime())) {
      throw new Error(`Invalid result date calculated with offset ${offset}`);
    }
    return result;
  } catch (error2) {
    console.error(`Error in convertLocalTimeToUTC: ${error2}`);
    console.error(`Input: localDate=${localDate}, timezone=${timezone}`);
    throw error2;
  }
}
function getCurrentDateInTimezone(timezone) {
  const now = new Date;
  if (Number.isNaN(now.getTime())) {
    throw new Error(`Invalid current date: ${now}`);
  }
  try {
    const dateString = now.toLocaleDateString("en-CA", {
      timeZone: timezone
    });
    if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
      throw new Error(`Invalid date format returned: ${dateString}. Expected YYYY-MM-DD`);
    }
    return dateString;
  } catch (error2) {
    console.error(`Error in getCurrentDateInTimezone: ${error2}`);
    console.error(`Input: timezone=${timezone}`);
    throw error2;
  }
}

// src/routes/api/todo/todo.list.ts
var todayTodoItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  description: exports_external.string().nullable(),
  scheduledFor: exports_external.string().datetime().optional(),
  completed: exports_external.boolean(),
  context: exports_external.union([
    exports_external.object({
      type: exports_external.literal("meal"),
      mealName: exports_external.string(),
      instructionNumber: exports_external.number(),
      estimatedDuration: exports_external.number().nullable()
    }),
    exports_external.object({
      type: exports_external.literal("standalone")
    })
  ]),
  canStartNow: exports_external.boolean(),
  isOverdue: exports_external.boolean(),
  urgency: exports_external.enum(["overdue", "now", "upcoming", "later"])
});
var todayTodosResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.object({
    todos: exports_external.array(todayTodoItemSchema),
    counts: exports_external.object({
      total: exports_external.number(),
      completed: exports_external.number(),
      remaining: exports_external.number(),
      overdue: exports_external.number()
    })
  })
});
var allTodosItemSchema = exports_external.object({
  id: exports_external.string().uuid(),
  description: exports_external.string().nullable(),
  completed: exports_external.boolean(),
  scheduledFor: exports_external.string().datetime().optional(),
  completedAt: exports_external.string().datetime().optional(),
  relations: exports_external.any().nullable()
});
var allTodosResponseSchema = exports_external.object({
  success: exports_external.literal(true),
  message: exports_external.string(),
  data: exports_external.array(allTodosItemSchema)
});
var getTodayTodosRoute = createRoute({
  method: "get",
  path: "/api/todo/today",
  tags: ["Todos"],
  security: [{ Bearer: [] }],
  request: {
    headers: exports_external.object({
      "x-timezone": exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "Today's todos retrieved successfully",
      content: {
        "application/json": {
          schema: todayTodosResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
var getAllTodosRoute = createRoute({
  method: "get",
  path: "/api/todo",
  tags: ["Todos"],
  security: [{ Bearer: [] }],
  request: {
    headers: exports_external.object({
      "x-timezone": exports_external.string().optional()
    })
  },
  responses: {
    200: {
      description: "All todos retrieved successfully",
      content: {
        "application/json": {
          schema: allTodosResponseSchema
        }
      }
    },
    401: {
      description: "Unauthorized",
      content: {
        "application/json": {
          schema: exports_external.object({
            success: exports_external.literal(false),
            message: exports_external.string()
          })
        }
      }
    }
  }
});
function registerListTodos(app) {
  app.openapi(getTodayTodosRoute, async (c) => {
    const safeUserId = c.userId;
    const userTimezone = c.req.header("X-Timezone") || "UTC";
    const todayDate = getCurrentDateInTimezone(userTimezone);
    generateMissingHabitTodos(safeUserId, todayDate);
    const { startOfDay: startOfDayUTC, endOfDay: endOfDayUTC } = getDayBoundsInTimezone(userTimezone);
    const now = new Date;
    const todaysTodos = await db.select().from(todos).where(and(eq(todos.userId, safeUserId), gte(todos.scheduledFor, startOfDayUTC), lte(todos.scheduledFor, endOfDayUTC))).orderBy(todos.scheduledFor);
    const transformedTodos = todaysTodos.map((todo4) => {
      const relations = todo4.relations ? JSON.parse(todo4.relations) : null;
      const mealRelation = relations?.[0]?.mealInstruction;
      const scheduledTime = todo4.scheduledFor ? new Date(todo4.scheduledFor) : null;
      const isOverdue = scheduledTime ? scheduledTime < now : false;
      const canStartNow = !scheduledTime || scheduledTime <= now;
      let urgency = "later";
      if (isOverdue)
        urgency = "overdue";
      else if (canStartNow)
        urgency = "now";
      else if (scheduledTime && scheduledTime.getTime() - now.getTime() <= 60 * 60 * 1000)
        urgency = "upcoming";
      return {
        id: todo4.id,
        description: todo4.description,
        scheduledFor: todo4.scheduledFor?.toISOString(),
        completed: todo4.completed,
        context: mealRelation ? {
          type: "meal",
          mealName: `Step ${mealRelation.instructionNumber}`,
          instructionNumber: Number(mealRelation.instructionNumber),
          estimatedDuration: null
        } : {
          type: "standalone"
        },
        canStartNow,
        isOverdue,
        urgency
      };
    });
    const counts = {
      total: transformedTodos.length,
      completed: transformedTodos.filter((t) => t.completed).length,
      remaining: transformedTodos.filter((t) => !t.completed).length,
      overdue: transformedTodos.filter((t) => t.urgency === "overdue").length
    };
    return c.json({
      success: true,
      message: "Today's todos retrieved successfully",
      data: {
        todos: transformedTodos,
        counts
      }
    }, 200);
  });
  app.openapi(getAllTodosRoute, async (c) => {
    const safeUserId = c.userId;
    const userTimezone = c.req.header("X-Timezone") || "UTC";
    const todayDate = getCurrentDateInTimezone(userTimezone);
    try {
      await generateMissingHabitTodos(safeUserId, todayDate);
    } catch (error2) {
      console.error("Failed to generate habit todos:", error2);
    }
    const allTodos = await db.select().from(todos).where(eq(todos.userId, safeUserId)).orderBy(todos.scheduledFor);
    const transformedTodos = allTodos.map((todo4) => ({
      id: todo4.id,
      description: todo4.description,
      completed: todo4.completed,
      scheduledFor: todo4.scheduledFor?.toISOString(),
      completedAt: todo4.completedAt?.toISOString(),
      relations: todo4.relations ? JSON.parse(todo4.relations) : null
    }));
    return c.json({
      success: true,
      message: "Todos retrieved successfully",
      data: transformedTodos
    }, 200);
  });
}

// src/index.ts
var app = new OpenAPIHono;
app.onError((err2, c) => {
  console.error("Unhandled error", err2);
  return c.json({
    error: "INTERNAL_SERVER_ERROR",
    message: err2 instanceof Error ? err2.message : String(err2)
  }, 500);
});
app.use("/*", cors({
  origin: [
    "https://flowday.io",
    "https://www.flowday.io",
    "http://localhost:3000",
    "http://localhost:3001"
  ],
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  maxAge: 86400,
  credentials: true
}));
app.get("/health", (c) => {
  return c.json({ ok: true }, 200);
});
app.get("/api/health", (c) => {
  return c.json({ ok: true }, 200);
});
app.openAPIRegistry.registerComponent("securitySchemes", "Bearer", {
  type: "http",
  scheme: "bearer",
  bearerFormat: "JWT"
});
app.use("/api/todo/*", requireAuth());
app.use("/api/food-item/*", requireAuth());
app.use("/api/habit/*", requireAuth());
app.use("/api/recipe/*", requireAuth());
app.use("/api/meal/*", requireAuth());
registerCreateTodo(app);
registerCompleteTodo(app);
registerListTodos(app);
registerCreateFoodItem(app);
registerListFoodItems(app);
registerDeleteFoodItem(app);
registerCreateFoodItemUnits(app);
registerListFoodItemUnits(app);
registerDeleteFoodItemUnits(app);
registerCreateHabit(app);
registerCreateRecipe(app);
registerDeleteRecipe(app);
registerListRecipes(app);
registerCreateRecipeIngredients(app);
registerCreateRecipeInstructions(app);
registerCreateMeal(app);
registerListMeals(app);
registerGetMeal(app);
registerAttachMealRecipes(app);
app.route("/api", api_default);
app.doc31("/api/openapi.json", {
  openapi: "3.1.0",
  info: {
    title: "Daily Scheduler API",
    version: "1.0.0",
    description: "API for managing todos, habits, meals, recipes, and food items"
  },
  servers: [
    {
      url: "http://localhost:3030",
      description: "Local development server"
    },
    {
      url: "https://api.flowday.io",
      description: "Production server"
    }
  ]
});
var scalarHandler;
var scalarHandlerInit;
async function getScalarHandler() {
  if (scalarHandler)
    return scalarHandler;
  scalarHandlerInit ??= Promise.resolve().then(() => (init_dist2(), exports_dist)).then(({ Scalar: Scalar2 }) => {
    scalarHandler = Scalar2({
      url: "/api/openapi.json",
      theme: "purple"
    });
    return scalarHandler;
  });
  return scalarHandlerInit;
}
app.get("/api/swagger", async (c, next) => {
  const handler = await getScalarHandler();
  return handler(c, next);
});
var src_default2 = {
  port: 3030,
  fetch: app.fetch
};
